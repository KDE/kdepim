#ifndef __email_idl__
#define __email_idl__

#include <openparts.idl>
#include <texteditor.idl> // remember the texteditor interface proposal? ;-)

module KEmail
{

  //forward references
  interface MailBox;
  interface Folder;
  interface Message;

  typedef sequence<MailBox> MailBoxList;
  typedef sequence<Folder> FolderList;
  typedef sequence<Message> MessageList;

  enum MessageStatus { Unknown, New, Unread, Read, Old, Deleted, Replied, 
                       Forwarded, Queued, Sent };
		  
  //TODO: filter interfaces?

  interface MailBox
  {
    /*
     * (note: does not return sub-folder. access these via Folder::subFolderList()
     */
    FolderList rootFolderList();
    
    void addRootFolder( in Folder folder );
    
    Folder findFolder( in string name );

    void sendMessage( in Message msg );
        
    /*
     * Folder implementation might depend on the mailbox (account) type, that's
     * why folder creation is done here
     */
    Folder createEmptyFolder();
  };
  
  struct MessageInfo
  {
    long index;
    MessageStatus status;
    //add more short message info stuff
  };
  
  typedef sequence<MessageInfo> MessageInfoList;
  
  interface Folder
  {
    string name();
    
    /*
     * returns nil of root folder
     */
    Folder parent();
    
    MailBox mailBox();
    
    FolderList subFolderList();
    void addSubFolder( in Folder folder );
    
    long messageCount();
    MessageList messageList();
    MessageInfoList messageInfoList();

    Message messageAt( in long index );
    
    void addMessage( in Message msg );
    void removeMessage( in long index );
    
  };

  
  /*
   * Huh, can we afford it to create an extra object per message?
   * Perhaps this can be tweaked by using CORBA objects only for communication 
   * through this interface and instead use internally plain extra classes to 
   * avoid overhead in the OA . OTOH this means asking for a lot of duplicated
   * code, or? hm....
   * I vote for extra object, although it might become a hazardous situation ;)
   * if we have 1000+ messages or so...
   */
  interface Message : KOM::Component
  {
    void setStatus( in MessageStatus status );
    MessageStatus status();

    void setSubject( in wstring subject );
    wstring subject();
    
    void setFrom( in wstring from );
    wstring from();
    
    void setTo( in wstring to );
    wstring to();
    
    void setReplyTo( in wstring replyTo );
    wstring replyTo();
    
    void setCC( in wstring CC );
    wstring cc();
    
    void setBCC( in wstring BCC );
    wstring bcc();
    
    void setHeaderField( in wstring name, in wstring value );
    wstring headerField( in wstring name );
    
    void setDateStr( in wstring date );
    wstring dateStr(); //use "string" instead??
    
    void setModified( in boolean b );
    boolean modified();
    
    /*
     * Hey, isn't this nice?
     * This way we can use every text editor available for
     *  a) providing the document (body)
     *  b) editing in a composer window. The composer window
     *     the simply does this (or similar) :
     *     TextEditor::Document_var doc = the_message->bodyDocument();
     *     TextEditor::View_var view = doc->createView(); //TODO: catch exceptions
     *     -> attach the view (as being a Part) into a OPFrame :-)
     *  c) viewing is either done by reading the document data via the
     *     TextEditor::Document interface and putting it into your
     *     favourite mail view widget or by using a document view
     *
     * ---------------------------------------------------------------
     *
     * Note: This replaces any existing body document
     * TODO: add something like setReadOnly( in boolean b ) to 
     *       the TextEditor::View interface!
     */
    void setBodyDocument( in TextEditor::Document body );
    TextEditor::Document bodyDocument();
    
    /*
     * initialize the object from an unparsed message.
     * the message body then gets filled into the document, which is cleared
     * before
     */
    void fromString( in TextEditor::Document doc, in string unparsedMessage);

    void setCTE( in string cte );
    string cte();
    
    /*
     * TODO: 1) handle attachments ......
     *       2) better handling for CTE, also in regard to body encoding
     */

    // ARGL, problem with all the methods below: how to create a new body document
    // object from an existing one?
              
    /*
     * copy message
     */
    Message copy();
    
    /*
     * create a new message that is a reply to this message, filling all
     * required header fields with the proper values. The returned message
     * is not stored in any folder. Marks this message as replied.
     * (copied from kmail/kmmessage.h :-)))
     */
    Message reply();
    
    /*
     * Create a new message that is a forward to this message, filling all
     * required header blahblahbla...you might guess ;-)
     */
    Message forward();
     
    /*
     * return the entire message as string
     */
    wstring asString();
    /*
     * return the header as string
     */
    wstring headerAsString();
     
    /*
     * Moves message if replacing folder
     */
    void setFolder( in Folder folder );
     
    /*
     * return nil of not assigned to any folder
     */
    Folder folder();

    /*
     * signals:
     *
     * signal void modified(); --> emitted when the message to modified
     *                         (might be useful to update a reader/composer window)
     */
         
    //add more here?
  }; 

  interface Composer: OpenParts::MainWindow
  {
     void setMessage( in Message msg );
     Message message();
     
     /*
      * signals:
      *
      * signal void send() --> emitted when the user finished composing,
      *                        pressed the send-button. after return from
      *                        the signal call the object/window is destroyed
      */
  };
  
  interface MessageReader: OpenParts::Part //use as part child only!!!!
  {
    void setMessage( in Message msg );
    Message message();
    
    /*
     * signals:
     * 
     * signal void openURL( in string url ); -> emitted when clicking on an url
     */
  };
  
  interface MainWindow: OpenParts::MainWindow
  {
    MessageReader messageReader();
  };
    
  interface MailApp: OpenParts::Application
  {
    TextEditor::Document createBodyDocument();

    /*
     * (note: Message does _not_ contain a body document)
     */    
    Message createEmptyMessage();
    
    Composer createComposer();
    MessageReader createMessageReader();
    
    //==> create MainWindow via OpenParts::Application::createWindow();
    //createPart() and createDoc() is not supported/implemented
    
    MailBoxList mailBoxList();
  };
  
};

#endif
