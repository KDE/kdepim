/*
    Copyright (C) 2008,2009    Dmitry Ivanov <vonami@gmail.com>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "nepomuktagjobimpls.h"
#include "nepomuktag_p.h"
#include "krss/tagidsattribute.h"
#include "krss/feed.h"
#include "krss/feedcollection.h"

#include <nepomuk/tag.h>
#include <akonadi/collection.h>
#include <akonadi/itemfetchjob.h>
#include <akonadi/itemfetchscope.h>
#include <akonadi/itemmodifyjob.h>
#include <akonadi/collectionfetchjob.h>
#include <akonadi/collectionmodifyjob.h>
#include <KRandom>
#include <KLocale>
#include <KDebug>

using namespace KRss;
using Akonadi::Collection;
using Akonadi::CollectionFetchJob;
using Akonadi::CollectionModifyJob;
using Akonadi::ItemFetchJob;

// TODO: if the feed/item has been modified and has no tags anymore
// delete the associated Nepomuk resource


Tag KRss::fromNepomukTag( const Nepomuk::Tag& ntag ) {
    Tag tag( ntag.resourceUri() );
    tag.setLabel( ntag.label() );
    tag.setDescription( ntag.description() );
    if ( !ntag.symbols().isEmpty() )
        tag.setIcon( ntag.symbols().first() );
    return tag;
}

NepomukTagCreateJob::NepomukTagCreateJob( QObject* parent )
    : TagCreateJob( parent )
{
}

void NepomukTagCreateJob::setTag( const Tag& tag )
{
    m_tag = tag;
}

Tag NepomukTagCreateJob::tag() const
{
    return m_tag;
}

QString NepomukTagCreateJob::errorString() const
{
    QString result;
    switch ( error() ) {
        case KJob::NoError:
            result = i18n( "No error." );
            break;
        case NepomukTagCreateJob::CouldNotCreateTag:
            result = i18n( "Couldn't create tag.\n%1", errorText() );
            break;
        default:
            result = i18n( "Unknown result code." );
            break;
    }
    return result;
}

void NepomukTagCreateJob::start()
{
    QMetaObject::invokeMethod( this, "doStart", Qt::QueuedConnection );
}

void NepomukTagCreateJob::doStart()
{
    if ( !m_tag.isNull() ) {
        setError( CouldNotCreateTag );
        setErrorText( i18n( "This tag already has a valid URI." ) );
        kWarning() << errorString();
        emitResult();
        return;
    }

    // FIXME: if I don't pass the tag's label in the ctor
    // the tag's resource uri gets autogenerated (like "nepomuk:/jgerk05nmht" )
    // but the tag won't show up afterwards in Nepomuk::Tag::allTags()
    // bug in Nepomuk?
    Nepomuk::Tag ntag( m_tag.label() );
    ntag.setLabel( m_tag.label() );
    ntag.setDescription( m_tag.description() );
    QStringList symbols = ntag.symbols();
    if ( !symbols.contains( m_tag.icon() ) ) {
        symbols.prepend( m_tag.icon() );
        ntag.setSymbols( symbols );
    }

    // check wthether the tag is actually created
    if ( !ntag.exists() ) {
        setError( CouldNotCreateTag );
        setErrorText( i18n( "Couldn't allocate a new Nepomuk tag" ) );
        emitResult();
        return;
    }

    kDebug() << "Created tag:" << ntag.resourceUri();
    Tag createdTag( ntag.resourceUri() );
    createdTag.setLabel( m_tag.label() );
    createdTag.setDescription( m_tag.description() );
    createdTag.setIcon( m_tag.icon() );
    m_tag = createdTag;
    emitResult();
}

NepomukTagModifyJob::NepomukTagModifyJob( QObject* parent )
    : TagModifyJob( parent )
{
}

void NepomukTagModifyJob::setTag( const Tag& tag )
{
    m_tag = tag;
}

Tag NepomukTagModifyJob::tag() const
{
    return m_tag;
}

QString NepomukTagModifyJob::errorString() const
{
    QString result;
    switch ( error() ) {
        case KJob::NoError:
            result = i18n( "No error." );
            break;
        case NepomukTagModifyJob::CouldNotModifyTag:
            result = i18n( "Couldn't modify tag.\n%1", errorText() );
            break;
        default:
            result = i18n( "Unknown result code." );
            break;
    }
    return result;
}

void NepomukTagModifyJob::start()
{
    QMetaObject::invokeMethod( this, "doStart", Qt::QueuedConnection );
}

void NepomukTagModifyJob::doStart()
{
    if ( m_tag.isNull() ) {
        setError( CouldNotModifyTag );
        setErrorText( i18n( "Cannot modify null tag." ) );
        kWarning() << errorString();
        emitResult();
        return;
    }

    Nepomuk::Tag ntag( m_tag.id() );
    if ( !ntag.exists() ) {
        setError( CouldNotModifyTag );
        setErrorText( i18n( "Tag doesn't exist." ) );
        kWarning() << errorString();
        emitResult();
        return;
    }

    ntag.setLabel( m_tag.label() );
    ntag.setDescription( m_tag.description() );
    QStringList symbols = ntag.symbols();
    if ( !symbols.contains( m_tag.icon() ) ) {
        symbols.prepend( m_tag.icon() );
        ntag.setSymbols( symbols );
    }

    emitResult();
}

NepomukTagDeleteJob::NepomukTagDeleteJob( QObject* parent )
    : TagDeleteJob( parent ), m_pendingCollectionModifyJobs( 0 ),
      m_pendingItemFetchJobs( 0 ), m_pendingItemModifyJobs( 0 )
{
}

void NepomukTagDeleteJob::setTag( const Tag& tag )
{
    m_tag = tag;
}

TagId NepomukTagDeleteJob::tag() const
{
    return m_tag.id();
}

QString NepomukTagDeleteJob::errorString() const
{
    QString result;
    switch ( error() ) {
        case KJob::NoError:
            result = i18n( "No error." );
            break;
        case NepomukTagDeleteJob::CouldNotDeleteTag:
            result = i18n( "Couldn't delete tag.\n%1", errorText() );
            break;
        case NepomukTagDeleteJob::CouldNotLoadFeeds:
            result = i18n( "Couldn't load feeds.\n%1", errorText() );
            break;
        case NepomukTagDeleteJob::CouldNotModifyFeeds:
            result = i18n( "Couldn't remove the tag from feeds.\n%1", errorText() );
            break;
        case NepomukTagDeleteJob::CouldNotLoadItems:
            result = i18n( "Couldn't load items.\n%1", errorText() );
            break;
        case NepomukTagDeleteJob::CouldNotModifyItems:
            result = i18n( "Couldn't remove the tag from items.\n%1", errorText() );
            break;
        case NepomukTagDeleteJob::CouldNotDeleteNepomukTag:
            result = i18n( "Couldn't delete Nepomuk tag with uri %1.", errorText() );
            break;
        default:
            result = i18n( "Unknown result code." );
            break;
    }
    return result;
}

void NepomukTagDeleteJob::start()
{
    QMetaObject::invokeMethod( this, "doStart", Qt::QueuedConnection );
}

void NepomukTagDeleteJob::doStart()
{
    if ( m_tag.isNull() ) {
        setError( CouldNotDeleteTag );
        setErrorText( i18n( "Cannot delete null tag." ) );
        kWarning() << errorString();
        emitResult();
        return;
    }

    Nepomuk::Tag ntag( m_tag.id() );
    if ( !ntag.exists() ) {
        setError( CouldNotDeleteTag );
        setErrorText( i18n( "Tag doesn't exist." ) );
        kWarning() << errorString();
        emitResult();
        return;
    }

    QList<Akonadi::Collection> collectionsToFetch;
    QList<Akonadi::Item> itemsToFetch;

    const QList<Nepomuk::Resource> resources = ntag.tagOf();
    Q_FOREACH( const Nepomuk::Resource& resource, resources ) {
        const KUrl url = resource.resourceUri();
        kDebug() << m_tag.id() << "is a tag of resource:" << url;
        if ( url.protocol() != QLatin1String( "akonadi" ) )
            continue;

        Collection col = Collection::fromUrl( url );
        if ( col.isValid() ) {
            kDebug() << "Collection to fetch:" << col.id();
            collectionsToFetch.append( col );
            continue;
        }

        Akonadi::Item item = Akonadi::Item::fromUrl( url );
        if ( item.isValid() ) {
            kDebug() << "Item to fetch:" << item.id();
            itemsToFetch.append( item );
            continue;
        }
    }

    // no tagged feeds and items
    if ( collectionsToFetch.isEmpty() && itemsToFetch.isEmpty() ) {
        kDebug() << "No tagged feeds and items";
        deleteNepomukTag();
        return;
    }

    // fetch collections
    if ( !collectionsToFetch.isEmpty() ) {
        CollectionFetchJob *fjob = new CollectionFetchJob( collectionsToFetch, this );
        connect( fjob, SIGNAL( result( KJob* ) ), this, SLOT( slotCollectionsFetched( KJob* ) ) );
        fjob->start();
    }

    // fetch items
    Q_FOREACH( const Akonadi::Item& item, itemsToFetch ) {
        ++m_pendingItemFetchJobs;
        Akonadi::ItemFetchJob *fjob = new Akonadi::ItemFetchJob( item, this );
        fjob->fetchScope().fetchFullPayload( false );
        fjob->fetchScope().fetchAllAttributes( false );
        fjob->fetchScope().fetchAttribute<TagIdsAttribute>( true );
        connect( fjob, SIGNAL( result( KJob* ) ), this, SLOT( slotItemFetched( KJob* ) ) );
        fjob->start();
    }
}

void NepomukTagDeleteJob::slotCollectionsFetched( KJob *job )
{
    if ( job->error() ) {
        setError( CouldNotLoadFeeds );
        setErrorText( job->errorString() );
        kWarning() << job->errorString();
        emitResult();
        return;
    }

    const CollectionFetchJob *fjob = qobject_cast<const CollectionFetchJob*>( job );
    Q_ASSERT( fjob );

    QList<Collection> cols = fjob->collections();
    Q_FOREACH( FeedCollection col, cols ) {
        if ( !col.tags().contains( m_tag.id() ) ) {
            kWarning() << "Collection" << col.id() << "got out of sync with Nepomuk";
            kWarning() << "It doesn't have tag" << m_tag.id();
            continue;
        }

        col.removeTag( m_tag.id() );
        ++m_pendingCollectionModifyJobs;
        CollectionModifyJob *mjob = new CollectionModifyJob( col );
        connect( mjob, SIGNAL( result( KJob* ) ), this, SLOT( slotCollectionModified( KJob* ) ) );
        mjob->start();
    }

    if ( m_pendingCollectionModifyJobs == 0 && m_pendingItemFetchJobs == 0 &&
         m_pendingItemModifyJobs == 0 ) {
        kDebug() << "Done with collection and items, removing the tag";
        deleteNepomukTag();
    }
}

void NepomukTagDeleteJob::slotCollectionModified( KJob *job )
{
    --m_pendingCollectionModifyJobs;
    if ( job->error() ) {
        setError( CouldNotModifyFeeds );
        setErrorText( job->errorString() );
        kWarning() << job->errorString();
        emitResult();
        return;
    }

    if ( m_pendingCollectionModifyJobs == 0 && m_pendingItemFetchJobs == 0 &&
         m_pendingItemModifyJobs == 0 ) {
        kDebug() << "Done with collection and items, removing the tag";
        deleteNepomukTag();
    }
}

void NepomukTagDeleteJob::slotItemFetched( KJob *job )
{
    --m_pendingItemFetchJobs;
    if ( job->error() ) {
        setError( CouldNotLoadItems );
        setErrorText( job->errorString() );
        kWarning() << job->errorString();
        emitResult();
        return;
    }

    const ItemFetchJob* const fjob = qobject_cast<const ItemFetchJob*>( job );
    Q_ASSERT( fjob );

    Akonadi::Item item = fjob->items().first();
    TagIdsAttribute *attr = item.attribute<TagIdsAttribute>();
    if ( !attr || !attr->tagIds().contains( m_tag.id() ) ) {
        kWarning() << "Item" << item.id() << "got out of sync with Nepomuk";
        kWarning() << "It doesn't have tag" << m_tag.id();
    }
    else {
        item.attribute<TagIdsAttribute>()->removeTagId( m_tag.id() );
        ++m_pendingItemModifyJobs;
        Akonadi::ItemModifyJob *mjob = new Akonadi::ItemModifyJob( item );
        connect( mjob, SIGNAL( result( KJob* ) ), this, SLOT( slotItemModified( KJob* ) ) );
        mjob->start();
    }

    if ( m_pendingCollectionModifyJobs == 0 && m_pendingItemFetchJobs == 0 &&
         m_pendingItemModifyJobs == 0 ) {
        kDebug() << "Done with collection and items, removing the tag";
        deleteNepomukTag();
    }
}

void NepomukTagDeleteJob::slotItemModified( KJob *job )
{
    --m_pendingItemModifyJobs;
    if ( job->error() ) {
        setError( CouldNotModifyItems );
        setErrorText( job->errorString() );
        kWarning() << job->errorString();
        emitResult();
        return;
    }

    if ( m_pendingCollectionModifyJobs == 0 && m_pendingItemFetchJobs == 0 &&
         m_pendingItemModifyJobs == 0 ) {
        kDebug() << "Done with collection and items, removing the tag";
        deleteNepomukTag();
    }
}

void NepomukTagDeleteJob::deleteNepomukTag()
{
    Nepomuk::Tag ntag( m_tag.id() );
    ntag.remove();

    if ( Nepomuk::Tag( m_tag.id() ).exists() ) {
        setError( CouldNotDeleteNepomukTag );
        setErrorText( m_tag.id().prettyUrl() );
        kWarning() << errorString();
        emitResult();
        return;
    }

    emitResult();
}

NepomukTagCreateReferencesJob::NepomukTagCreateReferencesJob( QObject *parent )
    : TagCreateReferencesJob( parent ), m_referrerType( NoReferrer )
{
}

void NepomukTagCreateReferencesJob::setReferrer( const Feed *feed )
{
    m_feed = feed;
    m_referrerType = FeedReferrer;
}

void NepomukTagCreateReferencesJob::setReferrer( const Item& item )
{
    m_item = item;
    m_referrerType = ItemReferrer;
}

QString NepomukTagCreateReferencesJob::errorString() const
{
    QString result;
    switch ( error() ) {
        case KJob::NoError:
            result = i18n( "No error." );
            break;
        case NepomukTagCreateReferencesJob::CouldNotCreateReferences:
            result = i18n( "Couldn't create references.\n%1", errorText() );
            break;
        case NepomukTagCreateReferencesJob::ReferrerNotSet:
            result = i18n( "Referrer not set." );
            break;
        case NepomukTagCreateReferencesJob::ResourceAlreadyExists:
            result = i18n( "Resource with uri %1 already exists", errorText() );
            break;
        case NepomukTagCreateReferencesJob::TagNotFound:
            result = i18n( "Tag with uri %1 not found", errorText() );
            break;
        case NepomukTagCreateReferencesJob::CouldNotAllocateNepomukResource:
            result = i18n( "Couldn't allocate a new Nepomuk resource." );
            break;
        default:
            result = i18n( "Unknown result code." );
            break;
    }
    return result;
}

void NepomukTagCreateReferencesJob::start()
{
    QMetaObject::invokeMethod( this, "doStart", Qt::QueuedConnection );
}

void NepomukTagCreateReferencesJob::doStart()
{
    if ( m_referrerType == NoReferrer) {
        setError( ReferrerNotSet );
        kWarning() << errorString();
        emitResult();
        return;
    }

    // don't allocate a Nepomuk::resource for the feed if it has no tags
    if ( m_referrerType == FeedReferrer && m_feed->tags().isEmpty() ) {
        emitResult();
        return;
    }

    // don't allocate a Nepomuk::resource for the item if it has no tags
    if ( m_referrerType == ItemReferrer && m_item.tags().isEmpty() ) {
        emitResult();
        return;
    }

    const QList<TagId> tagIds = ( m_referrerType == FeedReferrer ? m_feed->tags() : m_item.tags() );
    QList<Nepomuk::Tag> nepomukTags;
    Q_FOREACH( const TagId& id, tagIds ) {
        Nepomuk::Tag ntag( id );
        if ( !ntag.exists() ) {
            setError( TagNotFound );
            setErrorText( id.prettyUrl() );
            kWarning() << errorString();
            emitResult();
            return;
        }
        nepomukTags.append( ntag );
    }

    // we translate feed/item ids to KUrls using Akonadi::Item/Collection::url()
    const KUrl resourceUrl = ( m_referrerType == FeedReferrer ? Akonadi::Collection( m_feed->id() ).url() :
                                                          Akonadi::Item( m_item.id() ).url() );
    Nepomuk::Resource resource( resourceUrl );
    if ( resource.exists() ) {
        setError( ResourceAlreadyExists );
        setErrorText( resourceUrl.prettyUrl() );
        kWarning() << errorString();
        emitResult();
        return;
    }

    if ( m_referrerType == FeedReferrer ) {
        resource.setLabel( m_feed->title() );
        resource.setDescription( m_feed->description() );
        resource.setTags( nepomukTags );
    } else {
        resource.setLabel( m_item.title() );
        resource.setDescription( m_item.description() );
        resource.setTags( nepomukTags );
    }

    Nepomuk::Resource allocatedResource( resourceUrl );
    if ( !allocatedResource.exists() ) {
        setError( CouldNotAllocateNepomukResource );
        kWarning() << errorString();
        emitResult();
        return;
    } else {
        kDebug() << "The resource uri of the allocated Nepomuk resource:" << resource.uri();
        kDebug() << "The label of the allocated Nepomuk resource:" << resource.label();
        kDebug() << "The resource's tags:";
        const QList<Nepomuk::Tag> ntags = resource.tags();
        Q_FOREACH( const Nepomuk::Tag& ntag, ntags ) {
            kDebug() << "The uri of the tag:" << ntag.resourceUri();
            kDebug() << "The label of the tag:" << ntag.label();
        }
    }

    emitResult();
}

NepomukTagModifyReferencesJob::NepomukTagModifyReferencesJob( QObject *parent )
    : TagModifyReferencesJob( parent ), m_referrerType( NoReferrer )
{
}

void NepomukTagModifyReferencesJob::setReferrer( const Feed *feed )
{
    m_feed = feed;
    m_referrerType = FeedReferrer;
}

void NepomukTagModifyReferencesJob::setReferrer( const Item& item )
{
    m_item = item;
    m_referrerType = ItemReferrer;
}

void NepomukTagModifyReferencesJob::setAddedTags( const QList<TagId>& tags )
{
    m_addedTags = tags;
}

void NepomukTagModifyReferencesJob::setRemovedTags( const QList<TagId>& tags )
{
    m_removedTags = tags;
}

QString NepomukTagModifyReferencesJob::errorString() const
{
    QString result;
    switch ( error() ) {
        case KJob::NoError:
            result = i18n( "No error." );
            break;
        case NepomukTagModifyReferencesJob::CouldNotModifyReferences:
            result = i18n( "Couldn't modify references.\n%1", errorText() );
            break;
        case NepomukTagModifyReferencesJob::ReferrerNotSet:
            result = i18n( "Referrer not set." );
            break;
        case NepomukTagModifyReferencesJob::ResourceNotFound:
            result = i18n( "Resource with uri %1 not found", errorText() );
            break;
        case NepomukTagModifyReferencesJob::TagNotFound:
            result = i18n( "Tag with uri %1 not found", errorText() );
            break;
        case NepomukTagModifyReferencesJob::CouldNotAllocateNepomukResource:
            result = i18n( "Couldn't allocate a new Nepomuk resource." );
            break;
        default:
            result = i18n( "Unknown result code." );
            break;
    }
    return result;
}

void NepomukTagModifyReferencesJob::doStart()
{
    QMetaObject::invokeMethod( this, "doStart", Qt::QueuedConnection );
}

void NepomukTagModifyReferencesJob::start()
{
    if ( m_referrerType == NoReferrer ) {
        setError( ReferrerNotSet );
        kWarning() << errorString();
        emitResult();
        return;
    }

    // we translate feed/item ids to KUrls using Akonadi::Item/Collection::url()
    const KUrl resourceUrl = ( m_referrerType == FeedReferrer ? Akonadi::Collection( m_feed->id() ).url() :
                                                          Akonadi::Item( m_item.id() ).url() );
    Nepomuk::Resource resource( resourceUrl );
    QList<Nepomuk::Tag> nepomukTagsToSet = resource.tags();
    Q_FOREACH( const TagId& id, m_addedTags ) {
        Nepomuk::Tag ntag( id );
        if ( !ntag.exists() ) {
            setError( TagNotFound );
            setErrorText( id.prettyUrl() );
            kWarning() << errorString();
            emitResult();
            return;
        }
        nepomukTagsToSet.append( ntag );
    }

    Q_FOREACH( const TagId& id, m_removedTags ) {
        Nepomuk::Tag ntag( id );
        if ( !ntag.exists() ) {
            setError( TagNotFound );
            setErrorText( id.prettyUrl() );
            kWarning() << errorString();
            emitResult();
            return;
        }
        nepomukTagsToSet.removeOne( ntag );
    }

    if ( m_referrerType == FeedReferrer ) {
        resource.setLabel( m_feed->title() );
        resource.setDescription( m_feed->description() );
        resource.setTags( nepomukTagsToSet );
    } else {
        resource.setLabel( m_item.title() );
        resource.setDescription( m_item.description() );
        resource.setTags( nepomukTagsToSet );
    }

    Nepomuk::Resource allocatedResource( resourceUrl );
    if ( !allocatedResource.exists() ) {
        setError( CouldNotAllocateNepomukResource );
        kWarning() << errorString();
        emitResult();
        return;
    } else {
        kDebug() << "The resource uri of the allocated Nepomuk resource:" << resource.uri();
        kDebug() << "The label of the allocated Nepomuk resource:" << resource.label();
        kDebug() << "The resource's tags:";
        const QList<Nepomuk::Tag> ntags = resource.tags();
        Q_FOREACH( const Nepomuk::Tag& ntag, ntags ) {
            kDebug() << "The uri of the tag:" << ntag.resourceUri();
            kDebug() << "The label of the tag:" << ntag.label();
        }
    }

    emitResult();
}

NepomukTagDeleteReferencesJob::NepomukTagDeleteReferencesJob( QObject *parent )
    : TagDeleteReferencesJob( parent ), m_referrerType( NoReferrer )
{
}

void NepomukTagDeleteReferencesJob::setReferrer( const Feed *feed )
{
    m_feed = feed;
    m_referrerType = FeedReferrer;
}

void NepomukTagDeleteReferencesJob::setReferrer( const Item& item )
{
    m_item = item;
    m_referrerType = ItemReferrer;
}

QString NepomukTagDeleteReferencesJob::errorString() const
{
    QString result;
    switch ( error() ) {
        case KJob::NoError:
            result = i18n( "No error." );
            break;
        case NepomukTagDeleteReferencesJob::CouldNotDeleteReferences:
            result = i18n( "Couldn't delete references.\n%1", errorText() );
            break;
        case NepomukTagDeleteReferencesJob::ReferrerNotSet:
            result = i18n( "Referrer not set." );
            break;
        case NepomukTagDeleteReferencesJob::ResourceNotFound:
            result = i18n( "Resource with uri %1 not found", errorText() );
            break;
        case NepomukTagDeleteReferencesJob::CouldNotDeleteNepomukResource:
            result = i18n( "Couldn't delete Nepomuk resource with uri %1.", errorText() );
            break;
        default:
            result = i18n( "Unknown result code." );
            break;
    }
    return result;
}

void NepomukTagDeleteReferencesJob::start()
{
    QMetaObject::invokeMethod( this, "doStart", Qt::QueuedConnection );
}

void NepomukTagDeleteReferencesJob::doStart()
{
    if ( m_referrerType == NoReferrer ) {
        setError( ReferrerNotSet );
        kWarning() << errorString();
        emitResult();
        return;
    }

    // we translate feed/item ids to KUrls using Akonadi::Item/Collection::url()
    const KUrl resourceUrl = ( m_referrerType == FeedReferrer ? Akonadi::Collection( m_feed->id() ).url() :
                                                          Akonadi::Item( m_item.id() ).url() );
    Nepomuk::Resource resource( resourceUrl );
    if ( !resource.exists() ) {
        setError( ResourceNotFound );
        setErrorText( resourceUrl.prettyUrl() );
        kWarning() << errorString();
        emitResult();
        return;
    }

    resource.remove();

    Nepomuk::Resource deletedResource( resourceUrl );
    if ( deletedResource.exists() ) {
        setError( CouldNotDeleteNepomukResource );
        setErrorText( resourceUrl.prettyUrl() );
        kWarning() << errorString();
        emitResult();
        return;
    }

    emitResult();
}

#include "nepomuktagjobimpls.moc"
