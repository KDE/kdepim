Things that need fixing:

* Sending mail via seems a little flaky and there's no way to tell the user what's going on.

* Using an external editor: This seems broken. Someone suggested instead of doing the weird thing with mapping KProcess * -> filename and then filename -> mtime, I just wrap everything into a class, like EmpathExternalEditorProcess. This should be a much cleaner implementation.

* The tokeniser (RToken) is bugged. I have something like an out-by-one problem, and it manifests itself when there's quoted text ( "...." ). It doesn't seem to happen with comments ( (....) ), but maybe that's just luck.

* EmpathComposeWidget uses the fancy Netscape-alike thing where when you add
  headers, more widgets are created. What needs to happen is that when the user
  uses header names that aren't in the order of the base list, next time they
  get what they did before:
  
  e.g. user enters the to body, presses enter, changes Cc: to Reply-To: We then
  remember that they wanted Reply-To: next and next time when they press enter
  after To:, they get Reply-To:
  
  Is this a good idea or should they just be able to edit what headers come up and
  in which order via a config dialog ?

Things that need redesigning:

* Maildir indexing. This uses its own class for an index record. It needs to use EmpathMessageDescription, as the classes are virtually identical, save for one data member. Also, it needs to read the index as little as possible.

* Talking to network can cause blocking. This is completely unacceptable. I WILL
  NOT release Empath with a user interface that stalls, whatever the reason.
  I have carefully designed the message retrieval system so that everything doesn't
  stop when you're receiving. Let's carry on like that.
  
  Options:

	+ QThread
	+ External process
	+ Completely non-blocking I/O and host lookup.
  
	- QThread
	  Probably not supported on all KDE platforms but perhaps the 'nicest' design.
	  Trolls haven't written it yet though :(
	
	- External process
	  Communication would be via KProcess style signals/slots. Should work nicely.
	  We can also spawn more than one process (up to a maximum) to perform separate
	  deliveries. This would, of course, work with QThread too.
	  
	- Completely non-blocking I/O and host lookup.
	  Supposedly a CPU hog, but I don't think people worry about that too much
	  these days.


