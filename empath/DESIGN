Last update: Sat May  8 16:07:40 BST 1999

The design of Empath may be a little confusing at first. Please take the time
to read this document. It should help make things a little clearer. You should
hopefully end up with the impression that the design is actually quite simple !

Empath has three main parts:

rmm/ The message parsing library
lib/ The kernel
ui/  The user interface

=========================== RMM - Rik's Mail Messages ========================

The message parsing library is designed to have a class hierarchy which looks
exactly the same as that specified by RFC 822. You'll notice that in a couple
of places, the code is a little strange. For example,  RFC 822 specifies that
an Address may be either a Mailbox, OR a Group. This doesn't work well with
an OO design, so an RAddress is a little smart - it know whether it's a
Mailbox or a Group.

Apart from things like that, rmm is actually quite simple. Its design is based
upon that of mimelib, so if you've seen that you'll recognise the parse() and
assemble() methods in each class.

You may create any part in rmm by using either a string, or by using specific
parameters. This means that you can create an RHeader by passing either
the header name (e.g. 'To:') and the header body as strings, or you can simply
pass the whole header (e.g. 'To: foo@bar') and then call parse().

The parse() method takes the string representation and creates the necessary
component parts. It only needs to be called when you actually need access to
these parts, i.e. when you need the parsed representation so you can find
out something. If you have an RDateTime which you constructed with a string,
then you'll have to call parse() before you can call year(), or you'll get
the wrong answer.

The assemble() method does the opposite of parse(). It takes the broken
down representation and recreates the internal string representation. So if
you have created an RDateTime using a number (unix time) and want to use
the RDateTime as a header, you'll have to call assemble() to get the string
representation.

The major difference between rmm and mimelib is that rmm uses Qt's collections
extensively. This probably incurs a speed hit, and for this reason, and to
avoid code duplication, I may use libkmsg instead sometime in the future.
However, for the moment, there's little need to switch. If/when the switch
happens, it won't affect much code, as you actually use the library very little.
Most of the time you just create an RMessage, and occasionally parse it.

Another reason for hanging on for a bit is that I understand Qt's collections
and they make for understandable code.

========================== empath/lib - the kernel ===========================

The kernel does most of the hard work. It is designed to be very open, in the
sense that the parts are not tied together tightly with interdependencies.

------- URLs

The system works with URLs. For the moment, these are of my own making, and
look like:
empath://<mailbox name>/[folder name>/][<subfolder name>/][...][<message id>]

So an URL which references a message with id 'arse' in mailbox 'vogue mahone',
folder 'metal', subfolder 'sweet' and subsubfolder 'ream' would look like this:

empath://vogue mahone/metal/sweet/ream/arse

Note that spaces are allowed in the URL for the moment.

This idea might move somewhere into KDE's libs, depending on whether it looks
like a good standard.

You can see from the above that there's no reference to the type of the mailbox.

Empath, following KDE's network transparency paradigm, doesn't expose the
network within its code. The only place you'll find networking code (and hence
knowledge that a network exists) is in subclasses of EmpathMailbox. Actually,
you'll find that the dialogs to configure mailboxes have to know about hostnames
etc, but that doesn't count :)

-------

From anywhere in Empath, you can reference a mailbox, a folder, or a message.

This is done using the Empath object, of which there is only one.

The macro 'empath' references the Empath object from anywhere within the system.
Just include 'Empath.h' to get the macro defined.

So, to get a pointer to a mailbox called 'arse', do this:
EmpathMailbox * m(empath->mailbox("arse"));

Remember to check the pointer isn't 0.

Similarly, to get a message (from the location in the URL example above), do
this:

RMessage * m(empath->message(url));

where url is an EmpathURL which is as above.

Note: EmpathURL is similar to the components of rmm, except that the parsing
and assembling is transparent. The class knows when it needs to parse, and
when to assemble, so you can just use it as you wish.

-------

Similar to the above, you can also compose a new message, or send a message,
simply by calling one of Empath's methods.

empath->s_compose() brings up a new composer.
empath->s_reply(EmpathURL) replies to the message referenced by the URL.

Note that the s_ prefix to these is simply there to show these are slots,
so you can connect to them if you find this more useful.

empath->send(RMessage) sends the given message
(Actually, you need to do empath->mailSender().send(RMessage) for now.
 This will change so that the example is correct.)

-------

You should by now be able to see that you don't have much work to do.
If you want the data of a message, you simply ask for it.
If you want to send a new message, you just ask.
Empath handles the rest as intelligently as it can.

------- Filters

All automatic operations are done by filters.

Please forget what you believe about filters. In Empath, a filter is not just
for matching a message and moving it to a folder.

Empath's filters basically do all the work. When an EmpathMailbox notices
that a new message is available, it doesn't do anything with it. It tells
Empath that the message has arrived, and Empath lets the filter mechanism know.

The filter mechanism is basically a list of EmpathFilter.

Each EmpathFilter consists of a source URL, 1..n EmpathMatcher(s), and
an EmpathFilterEventHandler.

So, the mailbox says that an event has occurred (new message).

The filter mechanism goes through each filter in turn, and tells it that
the new message has arrived. It gives the filter an URL.

The filter compares the mailbox and folder parts of this URL with its own
'source URL'. If they match, it knows that it should try to match this message.

Basically the source URL just specifies the folder that the filter operates on.

So, if the filter is set to look at messages from this mailbox/folder, it tells
its matching mechanism to try to match the message.

A matcher may request information about the message referenced by the URL.
Of course, it does this via calls to empath->message(), to get the message
data. Note that Empath caches all messages, so multiple calls to
empath->message() shouldn't result in multiple network transactions.

If any of the matchers match the message, then the filter continues by
running the EmpathFilterEventHandler.

Th handler may perform any action it likes. Currently these options have
been set up, but it's trivial to add more.

Move to folder, Copy to folder, Delete, Ignore, Forward.

The handler may then request that no further filters run.

Move to folder does this:
RMessage * m(empath->message(messageURL));
// check for 0 here !
EmpathFolder * f(empath->folder(destinationURL));
// check for 0 again
if (f->writeMessage(m));
	empath->remove(messageURL);

See how it works ? Get the message data, write it to the destination folder.
If the write worked, remove the original message.

Note that EmpathFolder::writeMessage() actually does this:

EmpathMailbox * m = empath->mailbox(url_);
return (m != 0 && m->writeMessage(url_, message));

That's it !

You should notice that the folder doesn't know how to write a message, as a
folder doesn't actually exist as a real-world entity - it's only for the user.

Writing separate classes for the folders of each mailbox would be mad !

Also, you can see here that the folder doesn't have a pointer to its parent
mailbox. Instead, it simply knows its own URL. In this way, the system isn't
full of pointers. They're gained when they're needed, and then only.

Hopefully you like this design. If you have any comments, please let me know.

Rik Hemsley <rik@kde.org>


