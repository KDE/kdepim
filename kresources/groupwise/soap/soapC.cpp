/* soapC.cpp
   Generated by gSOAP 2.6.2 from /build/kde/cvs/pim/kdepim/kresources/groupwise/soap/groupwise.h
   Copyright (C) 2001-2004 Genivia, Inc. All Rights Reserved.
   This software is released under the gSOAP public license and GPL.
   See README.txt for further details.
*/
#include "soapH.h"

SOAP_BEGIN_NAMESPACE(soap)

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.6.2 2004-10-07 12:56:01 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version != 1 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_ns1__GMTOffset:
		return soap_in_ns1__GMTOffset(soap, NULL, NULL, "ns1:GMTOffset");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_ns1__Month:
		return soap_in_ns1__Month(soap, NULL, NULL, "ns1:Month");
	case SOAP_TYPE_ns1__Minute:
		return soap_in_ns1__Minute(soap, NULL, NULL, "ns1:Minute");
	case SOAP_TYPE_ns1__Hour:
		return soap_in_ns1__Hour(soap, NULL, NULL, "ns1:Hour");
	case SOAP_TYPE_ns1__Day:
		return soap_in_ns1__Day(soap, NULL, NULL, "ns1:Day");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_in_unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__WeekDay:
		return soap_in_ns1__WeekDay(soap, NULL, NULL, "ns1:WeekDay");
	case SOAP_TYPE_ns1__StatusTrackingOptions:
		return soap_in_ns1__StatusTrackingOptions(soap, NULL, NULL, "ns1:StatusTrackingOptions");
	case SOAP_TYPE_ns1__RecipientType:
		return soap_in_ns1__RecipientType(soap, NULL, NULL, "ns1:RecipientType");
	case SOAP_TYPE_ns1__PostalAddressType:
		return soap_in_ns1__PostalAddressType(soap, NULL, NULL, "ns1:PostalAddressType");
	case SOAP_TYPE_ns1__OccurrenceType:
		return soap_in_ns1__OccurrenceType(soap, NULL, NULL, "ns1:OccurrenceType");
	case SOAP_TYPE_ns1__ItemSource:
		return soap_in_ns1__ItemSource(soap, NULL, NULL, "ns1:ItemSource");
	case SOAP_TYPE_ns1__ItemOptionsPriority:
		return soap_in_ns1__ItemOptionsPriority(soap, NULL, NULL, "ns1:ItemOptionsPriority");
	case SOAP_TYPE_ns1__ItemClass:
		return soap_in_ns1__ItemClass(soap, NULL, NULL, "ns1:ItemClass");
	case SOAP_TYPE_ns1__FolderType:
		return soap_in_ns1__FolderType(soap, NULL, NULL, "ns1:FolderType");
	case SOAP_TYPE_ns1__FolderACLStatus:
		return soap_in_ns1__FolderACLStatus(soap, NULL, NULL, "ns1:FolderACLStatus");
	case SOAP_TYPE_ns1__FilterOp:
		return soap_in_ns1__FilterOp(soap, NULL, NULL, "ns1:FilterOp");
	case SOAP_TYPE_ns1__DistributionType:
		return soap_in_ns1__DistributionType(soap, NULL, NULL, "ns1:DistributionType");
	case SOAP_TYPE_ns1__CursorSeek:
		return soap_in_ns1__CursorSeek(soap, NULL, NULL, "ns1:CursorSeek");
	case SOAP_TYPE_ns1__ContactType:
		return soap_in_ns1__ContactType(soap, NULL, NULL, "ns1:ContactType");
	case SOAP_TYPE_ns1__CategoryType:
		return soap_in_ns1__CategoryType(soap, NULL, NULL, "ns1:CategoryType");
	case SOAP_TYPE_ns1__AcceptLevel:
		return soap_in_ns1__AcceptLevel(soap, NULL, NULL, "ns1:AcceptLevel");
	case SOAP_TYPE_ns1__UUID:
		return soap_in_ns1__UUID(soap, NULL, NULL, "ns1:UUID");
	case SOAP_TYPE_ns1__uid:
		return soap_in_ns1__uid(soap, NULL, NULL, "ns1:uid");
	case SOAP_TYPE_ns1__View:
		return soap_in_ns1__View(soap, NULL, NULL, "ns1:View");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__ns1__startFreeBusySessionResponse:
		return soap_in__ns1__startFreeBusySessionResponse(soap, NULL, NULL, "ns1:startFreeBusySessionResponse");
	case SOAP_TYPE__ns1__startFreeBusySessionRequest:
		return soap_in__ns1__startFreeBusySessionRequest(soap, NULL, NULL, "ns1:startFreeBusySessionRequest");
	case SOAP_TYPE__ns1__sendItemResponse:
		return soap_in__ns1__sendItemResponse(soap, NULL, NULL, "ns1:sendItemResponse");
	case SOAP_TYPE__ns1__sendItemRequest:
		return soap_in__ns1__sendItemRequest(soap, NULL, NULL, "ns1:sendItemRequest");
	case SOAP_TYPE__ns1__retractResponse:
		return soap_in__ns1__retractResponse(soap, NULL, NULL, "ns1:retractResponse");
	case SOAP_TYPE__ns1__retractRequest:
		return soap_in__ns1__retractRequest(soap, NULL, NULL, "ns1:retractRequest");
	case SOAP_TYPE__ns1__removeProxyAccessResponse:
		return soap_in__ns1__removeProxyAccessResponse(soap, NULL, NULL, "ns1:removeProxyAccessResponse");
	case SOAP_TYPE__ns1__removeProxyAccessRequest:
		return soap_in__ns1__removeProxyAccessRequest(soap, NULL, NULL, "ns1:removeProxyAccessRequest");
	case SOAP_TYPE__ns1__removeMembersResponse:
		return soap_in__ns1__removeMembersResponse(soap, NULL, NULL, "ns1:removeMembersResponse");
	case SOAP_TYPE__ns1__removeMembersRequest:
		return soap_in__ns1__removeMembersRequest(soap, NULL, NULL, "ns1:removeMembersRequest");
	case SOAP_TYPE__ns1__removeItemsResponse:
		return soap_in__ns1__removeItemsResponse(soap, NULL, NULL, "ns1:removeItemsResponse");
	case SOAP_TYPE__ns1__removeItemsRequest:
		return soap_in__ns1__removeItemsRequest(soap, NULL, NULL, "ns1:removeItemsRequest");
	case SOAP_TYPE__ns1__removeItemResponse:
		return soap_in__ns1__removeItemResponse(soap, NULL, NULL, "ns1:removeItemResponse");
	case SOAP_TYPE__ns1__removeItemRequest:
		return soap_in__ns1__removeItemRequest(soap, NULL, NULL, "ns1:removeItemRequest");
	case SOAP_TYPE__ns1__readCursorResponse:
		return soap_in__ns1__readCursorResponse(soap, NULL, NULL, "ns1:readCursorResponse");
	case SOAP_TYPE__ns1__readCursorRequest:
		return soap_in__ns1__readCursorRequest(soap, NULL, NULL, "ns1:readCursorRequest");
	case SOAP_TYPE__ns1__purgeItemResponse:
		return soap_in__ns1__purgeItemResponse(soap, NULL, NULL, "ns1:purgeItemResponse");
	case SOAP_TYPE__ns1__purgeItemRequest:
		return soap_in__ns1__purgeItemRequest(soap, NULL, NULL, "ns1:purgeItemRequest");
	case SOAP_TYPE__ns1__purgeDeletedItemsResponse:
		return soap_in__ns1__purgeDeletedItemsResponse(soap, NULL, NULL, "ns1:purgeDeletedItemsResponse");
	case SOAP_TYPE__ns1__purgeDeletedItemsRequest:
		return soap_in__ns1__purgeDeletedItemsRequest(soap, NULL, NULL, "ns1:purgeDeletedItemsRequest");
	case SOAP_TYPE__ns1__positionCursorResponse:
		return soap_in__ns1__positionCursorResponse(soap, NULL, NULL, "ns1:positionCursorResponse");
	case SOAP_TYPE__ns1__positionCursorRequest:
		return soap_in__ns1__positionCursorRequest(soap, NULL, NULL, "ns1:positionCursorRequest");
	case SOAP_TYPE__ns1__modifySettingsResponse:
		return soap_in__ns1__modifySettingsResponse(soap, NULL, NULL, "ns1:modifySettingsResponse");
	case SOAP_TYPE__ns1__modifySettingsRequest:
		return soap_in__ns1__modifySettingsRequest(soap, NULL, NULL, "ns1:modifySettingsRequest");
	case SOAP_TYPE__ns1__modifyProxyAccessResponse:
		return soap_in__ns1__modifyProxyAccessResponse(soap, NULL, NULL, "ns1:modifyProxyAccessResponse");
	case SOAP_TYPE__ns1__modifyProxyAccessRequest:
		return soap_in__ns1__modifyProxyAccessRequest(soap, NULL, NULL, "ns1:modifyProxyAccessRequest");
	case SOAP_TYPE__ns1__modifyItemResponse:
		return soap_in__ns1__modifyItemResponse(soap, NULL, NULL, "ns1:modifyItemResponse");
	case SOAP_TYPE__ns1__modifyItemRequest:
		return soap_in__ns1__modifyItemRequest(soap, NULL, NULL, "ns1:modifyItemRequest");
	case SOAP_TYPE__ns1__markUnReadResponse:
		return soap_in__ns1__markUnReadResponse(soap, NULL, NULL, "ns1:markUnReadResponse");
	case SOAP_TYPE__ns1__markUnReadRequest:
		return soap_in__ns1__markUnReadRequest(soap, NULL, NULL, "ns1:markUnReadRequest");
	case SOAP_TYPE__ns1__markReadResponse:
		return soap_in__ns1__markReadResponse(soap, NULL, NULL, "ns1:markReadResponse");
	case SOAP_TYPE__ns1__markReadRequest:
		return soap_in__ns1__markReadRequest(soap, NULL, NULL, "ns1:markReadRequest");
	case SOAP_TYPE__ns1__logoutResponse:
		return soap_in__ns1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE__ns1__loginResponse:
		return soap_in__ns1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE__ns1__loginRequest:
		return soap_in__ns1__loginRequest(soap, NULL, NULL, "ns1:loginRequest");
	case SOAP_TYPE__ns1__getTimezoneListResponse:
		return soap_in__ns1__getTimezoneListResponse(soap, NULL, NULL, "ns1:getTimezoneListResponse");
	case SOAP_TYPE__ns1__getSettingsResponse:
		return soap_in__ns1__getSettingsResponse(soap, NULL, NULL, "ns1:getSettingsResponse");
	case SOAP_TYPE__ns1__getSettingsRequest:
		return soap_in__ns1__getSettingsRequest(soap, NULL, NULL, "ns1:getSettingsRequest");
	case SOAP_TYPE__ns1__getProxyListResponse:
		return soap_in__ns1__getProxyListResponse(soap, NULL, NULL, "ns1:getProxyListResponse");
	case SOAP_TYPE__ns1__getProxyAccessListResponse:
		return soap_in__ns1__getProxyAccessListResponse(soap, NULL, NULL, "ns1:getProxyAccessListResponse");
	case SOAP_TYPE__ns1__getItemsResponse:
		return soap_in__ns1__getItemsResponse(soap, NULL, NULL, "ns1:getItemsResponse");
	case SOAP_TYPE__ns1__getItemsRequest:
		return soap_in__ns1__getItemsRequest(soap, NULL, NULL, "ns1:getItemsRequest");
	case SOAP_TYPE__ns1__getItemResponse:
		return soap_in__ns1__getItemResponse(soap, NULL, NULL, "ns1:getItemResponse");
	case SOAP_TYPE__ns1__getItemRequest:
		return soap_in__ns1__getItemRequest(soap, NULL, NULL, "ns1:getItemRequest");
	case SOAP_TYPE__ns1__getFreeBusyResponse:
		return soap_in__ns1__getFreeBusyResponse(soap, NULL, NULL, "ns1:getFreeBusyResponse");
	case SOAP_TYPE__ns1__getFreeBusyRequest:
		return soap_in__ns1__getFreeBusyRequest(soap, NULL, NULL, "ns1:getFreeBusyRequest");
	case SOAP_TYPE__ns1__getFolderListResponse:
		return soap_in__ns1__getFolderListResponse(soap, NULL, NULL, "ns1:getFolderListResponse");
	case SOAP_TYPE__ns1__getFolderListRequest:
		return soap_in__ns1__getFolderListRequest(soap, NULL, NULL, "ns1:getFolderListRequest");
	case SOAP_TYPE__ns1__getDeltaResponse:
		return soap_in__ns1__getDeltaResponse(soap, NULL, NULL, "ns1:getDeltaResponse");
	case SOAP_TYPE__ns1__getDeltaRequest:
		return soap_in__ns1__getDeltaRequest(soap, NULL, NULL, "ns1:getDeltaRequest");
	case SOAP_TYPE__ns1__getCustomListResponse:
		return soap_in__ns1__getCustomListResponse(soap, NULL, NULL, "ns1:getCustomListResponse");
	case SOAP_TYPE__ns1__getCategoryListResponse:
		return soap_in__ns1__getCategoryListResponse(soap, NULL, NULL, "ns1:getCategoryListResponse");
	case SOAP_TYPE__ns1__getAttachmentResponse:
		return soap_in__ns1__getAttachmentResponse(soap, NULL, NULL, "ns1:getAttachmentResponse");
	case SOAP_TYPE__ns1__getAttachmentRequest:
		return soap_in__ns1__getAttachmentRequest(soap, NULL, NULL, "ns1:getAttachmentRequest");
	case SOAP_TYPE__ns1__getAddressBookListResponse:
		return soap_in__ns1__getAddressBookListResponse(soap, NULL, NULL, "ns1:getAddressBookListResponse");
	case SOAP_TYPE__ns1__destroyCursorResponse:
		return soap_in__ns1__destroyCursorResponse(soap, NULL, NULL, "ns1:destroyCursorResponse");
	case SOAP_TYPE__ns1__destroyCursorRequest:
		return soap_in__ns1__destroyCursorRequest(soap, NULL, NULL, "ns1:destroyCursorRequest");
	case SOAP_TYPE__ns1__delegateResponse:
		return soap_in__ns1__delegateResponse(soap, NULL, NULL, "ns1:delegateResponse");
	case SOAP_TYPE__ns1__delegateRequest:
		return soap_in__ns1__delegateRequest(soap, NULL, NULL, "ns1:delegateRequest");
	case SOAP_TYPE__ns1__declineResponse:
		return soap_in__ns1__declineResponse(soap, NULL, NULL, "ns1:declineResponse");
	case SOAP_TYPE__ns1__declineRequest:
		return soap_in__ns1__declineRequest(soap, NULL, NULL, "ns1:declineRequest");
	case SOAP_TYPE__ns1__createProxyAccessResponse:
		return soap_in__ns1__createProxyAccessResponse(soap, NULL, NULL, "ns1:createProxyAccessResponse");
	case SOAP_TYPE__ns1__createProxyAccessRequest:
		return soap_in__ns1__createProxyAccessRequest(soap, NULL, NULL, "ns1:createProxyAccessRequest");
	case SOAP_TYPE__ns1__createItemResponse:
		return soap_in__ns1__createItemResponse(soap, NULL, NULL, "ns1:createItemResponse");
	case SOAP_TYPE__ns1__createItemRequest:
		return soap_in__ns1__createItemRequest(soap, NULL, NULL, "ns1:createItemRequest");
	case SOAP_TYPE__ns1__createCursorResponse:
		return soap_in__ns1__createCursorResponse(soap, NULL, NULL, "ns1:createCursorResponse");
	case SOAP_TYPE__ns1__createCursorRequest:
		return soap_in__ns1__createCursorRequest(soap, NULL, NULL, "ns1:createCursorRequest");
	case SOAP_TYPE__ns1__completeResponse:
		return soap_in__ns1__completeResponse(soap, NULL, NULL, "ns1:completeResponse");
	case SOAP_TYPE__ns1__completeRequest:
		return soap_in__ns1__completeRequest(soap, NULL, NULL, "ns1:completeRequest");
	case SOAP_TYPE__ns1__closeFreeBusySessionResponse:
		return soap_in__ns1__closeFreeBusySessionResponse(soap, NULL, NULL, "ns1:closeFreeBusySessionResponse");
	case SOAP_TYPE__ns1__closeFreeBusySessionRequest:
		return soap_in__ns1__closeFreeBusySessionRequest(soap, NULL, NULL, "ns1:closeFreeBusySessionRequest");
	case SOAP_TYPE__ns1__addMembersResponse:
		return soap_in__ns1__addMembersResponse(soap, NULL, NULL, "ns1:addMembersResponse");
	case SOAP_TYPE__ns1__addMembersRequest:
		return soap_in__ns1__addMembersRequest(soap, NULL, NULL, "ns1:addMembersRequest");
	case SOAP_TYPE__ns1__addItemsResponse:
		return soap_in__ns1__addItemsResponse(soap, NULL, NULL, "ns1:addItemsResponse");
	case SOAP_TYPE__ns1__addItemsRequest:
		return soap_in__ns1__addItemsRequest(soap, NULL, NULL, "ns1:addItemsRequest");
	case SOAP_TYPE__ns1__addItemResponse:
		return soap_in__ns1__addItemResponse(soap, NULL, NULL, "ns1:addItemResponse");
	case SOAP_TYPE__ns1__addItemRequest:
		return soap_in__ns1__addItemRequest(soap, NULL, NULL, "ns1:addItemRequest");
	case SOAP_TYPE__ns1__acceptResponse:
		return soap_in__ns1__acceptResponse(soap, NULL, NULL, "ns1:acceptResponse");
	case SOAP_TYPE__ns1__acceptRequest:
		return soap_in__ns1__acceptRequest(soap, NULL, NULL, "ns1:acceptRequest");
	case SOAP_TYPE_ns1__UserInfo:
		return soap_in_ns1__UserInfo(soap, NULL, NULL, "ns1:UserInfo");
	case SOAP_TYPE_ns1__TrustedApplication:
		return soap_in_ns1__TrustedApplication(soap, NULL, NULL, "ns1:TrustedApplication");
	case SOAP_TYPE_ns1__TimezoneList:
		return soap_in_ns1__TimezoneList(soap, NULL, NULL, "ns1:TimezoneList");
	case SOAP_TYPE_ns1__TimezoneComponent:
		return soap_in_ns1__TimezoneComponent(soap, NULL, NULL, "ns1:TimezoneComponent");
	case SOAP_TYPE_ns1__Timezone:
		return soap_in_ns1__Timezone(soap, NULL, NULL, "ns1:Timezone");
	case SOAP_TYPE_ns1__Task:
		return soap_in_ns1__Task(soap, NULL, NULL, "ns1:Task");
	case SOAP_TYPE_ns1__SystemFolder:
		return soap_in_ns1__SystemFolder(soap, NULL, NULL, "ns1:SystemFolder");
	case SOAP_TYPE_ns1__StatusTracking:
		return soap_in_ns1__StatusTracking(soap, NULL, NULL, "ns1:StatusTracking");
	case SOAP_TYPE_ns1__Status:
		return soap_in_ns1__Status(soap, NULL, NULL, "ns1:Status");
	case SOAP_TYPE_ns1__SharedFolderNotification:
		return soap_in_ns1__SharedFolderNotification(soap, NULL, NULL, "ns1:SharedFolderNotification");
	case SOAP_TYPE_ns1__SharedFolder:
		return soap_in_ns1__SharedFolder(soap, NULL, NULL, "ns1:SharedFolder");
	case SOAP_TYPE_ns1__SettingsList:
		return soap_in_ns1__SettingsList(soap, NULL, NULL, "ns1:SettingsList");
	case SOAP_TYPE_ns1__SettingsGroup:
		return soap_in_ns1__SettingsGroup(soap, NULL, NULL, "ns1:SettingsGroup");
	case SOAP_TYPE_ns1__Settings:
		return soap_in_ns1__Settings(soap, NULL, NULL, "ns1:Settings");
	case SOAP_TYPE_ns1__SendOptions:
		return soap_in_ns1__SendOptions(soap, NULL, NULL, "ns1:SendOptions");
	case SOAP_TYPE_ns1__SendOptionsRequestReply:
		return soap_in_ns1__SendOptionsRequestReply(soap, NULL, NULL, "ns1:SendOptionsRequestReply");
	case SOAP_TYPE_ns1__Rights:
		return soap_in_ns1__Rights(soap, NULL, NULL, "ns1:Rights");
	case SOAP_TYPE_ns1__ReturnNotificationOptions:
		return soap_in_ns1__ReturnNotificationOptions(soap, NULL, NULL, "ns1:ReturnNotificationOptions");
	case SOAP_TYPE_ns1__ReturnNotification:
		return soap_in_ns1__ReturnNotification(soap, NULL, NULL, "ns1:ReturnNotification");
	case SOAP_TYPE_ns1__Resource:
		return soap_in_ns1__Resource(soap, NULL, NULL, "ns1:Resource");
	case SOAP_TYPE_ns1__RecurrenceDateType:
		return soap_in_ns1__RecurrenceDateType(soap, NULL, NULL, "ns1:RecurrenceDateType");
	case SOAP_TYPE_ns1__RecipientStatus:
		return soap_in_ns1__RecipientStatus(soap, NULL, NULL, "ns1:RecipientStatus");
	case SOAP_TYPE_ns1__RecipientList:
		return soap_in_ns1__RecipientList(soap, NULL, NULL, "ns1:RecipientList");
	case SOAP_TYPE_ns1__Recipient:
		return soap_in_ns1__Recipient(soap, NULL, NULL, "ns1:Recipient");
	case SOAP_TYPE_ns1__QueryTarget:
		return soap_in_ns1__QueryTarget(soap, NULL, NULL, "ns1:QueryTarget");
	case SOAP_TYPE_ns1__QueryFolder:
		return soap_in_ns1__QueryFolder(soap, NULL, NULL, "ns1:QueryFolder");
	case SOAP_TYPE_ns1__Query:
		return soap_in_ns1__Query(soap, NULL, NULL, "ns1:Query");
	case SOAP_TYPE_ns1__ProxyList:
		return soap_in_ns1__ProxyList(soap, NULL, NULL, "ns1:ProxyList");
	case SOAP_TYPE_ns1__Proxy:
		return soap_in_ns1__Proxy(soap, NULL, NULL, "ns1:Proxy");
	case SOAP_TYPE_ns1__ProblemList:
		return soap_in_ns1__ProblemList(soap, NULL, NULL, "ns1:ProblemList");
	case SOAP_TYPE_ns1__ProblemEntry:
		return soap_in_ns1__ProblemEntry(soap, NULL, NULL, "ns1:ProblemEntry");
	case SOAP_TYPE_ns1__PostalAddressList:
		return soap_in_ns1__PostalAddressList(soap, NULL, NULL, "ns1:PostalAddressList");
	case SOAP_TYPE_ns1__PostalAddress:
		return soap_in_ns1__PostalAddress(soap, NULL, NULL, "ns1:PostalAddress");
	case SOAP_TYPE_ns1__PlainText:
		return soap_in_ns1__PlainText(soap, NULL, NULL, "ns1:PlainText");
	case SOAP_TYPE_ns1__PhoneMessage:
		return soap_in_ns1__PhoneMessage(soap, NULL, NULL, "ns1:PhoneMessage");
	case SOAP_TYPE_ns1__PhoneFlags:
		return soap_in_ns1__PhoneFlags(soap, NULL, NULL, "ns1:PhoneFlags");
	case SOAP_TYPE_ns1__PersonalInfo:
		return soap_in_ns1__PersonalInfo(soap, NULL, NULL, "ns1:PersonalInfo");
	case SOAP_TYPE_ns1__Organization:
		return soap_in_ns1__Organization(soap, NULL, NULL, "ns1:Organization");
	case SOAP_TYPE_ns1__OfficeInfo:
		return soap_in_ns1__OfficeInfo(soap, NULL, NULL, "ns1:OfficeInfo");
	case SOAP_TYPE_ns1__Note:
		return soap_in_ns1__Note(soap, NULL, NULL, "ns1:Note");
	case SOAP_TYPE_ns1__NameAndEmail:
		return soap_in_ns1__NameAndEmail(soap, NULL, NULL, "ns1:NameAndEmail");
	case SOAP_TYPE_ns1__MessagePart:
		return soap_in_ns1__MessagePart(soap, NULL, NULL, "ns1:MessagePart");
	case SOAP_TYPE_ns1__MessageBody:
		return soap_in_ns1__MessageBody(soap, NULL, NULL, "ns1:MessageBody");
	case SOAP_TYPE_ns1__Mail:
		return soap_in_ns1__Mail(soap, NULL, NULL, "ns1:Mail");
	case SOAP_TYPE_ns1__ItemStatus:
		return soap_in_ns1__ItemStatus(soap, NULL, NULL, "ns1:ItemStatus");
	case SOAP_TYPE_ns1__Items:
		return soap_in_ns1__Items(soap, NULL, NULL, "ns1:Items");
	case SOAP_TYPE_ns1__ItemRefList:
		return soap_in_ns1__ItemRefList(soap, NULL, NULL, "ns1:ItemRefList");
	case SOAP_TYPE_ns1__ItemRef:
		return soap_in_ns1__ItemRef(soap, NULL, NULL, "ns1:ItemRef");
	case SOAP_TYPE_ns1__ItemOptions:
		return soap_in_ns1__ItemOptions(soap, NULL, NULL, "ns1:ItemOptions");
	case SOAP_TYPE_ns1__ItemList:
		return soap_in_ns1__ItemList(soap, NULL, NULL, "ns1:ItemList");
	case SOAP_TYPE_ns1__ItemChanges:
		return soap_in_ns1__ItemChanges(soap, NULL, NULL, "ns1:ItemChanges");
	case SOAP_TYPE_ns1__Item:
		return soap_in_ns1__Item(soap, NULL, NULL, "ns1:Item");
	case SOAP_TYPE_ns1__ImAddressList:
		return soap_in_ns1__ImAddressList(soap, NULL, NULL, "ns1:ImAddressList");
	case SOAP_TYPE_ns1__ImAddress:
		return soap_in_ns1__ImAddress(soap, NULL, NULL, "ns1:ImAddress");
	case SOAP_TYPE_ns1__GroupMemberList:
		return soap_in_ns1__GroupMemberList(soap, NULL, NULL, "ns1:GroupMemberList");
	case SOAP_TYPE_ns1__GroupMember:
		return soap_in_ns1__GroupMember(soap, NULL, NULL, "ns1:GroupMember");
	case SOAP_TYPE_ns1__Group:
		return soap_in_ns1__Group(soap, NULL, NULL, "ns1:Group");
	case SOAP_TYPE_ns1__FullName:
		return soap_in_ns1__FullName(soap, NULL, NULL, "ns1:FullName");
	case SOAP_TYPE_ns1__From:
		return soap_in_ns1__From(soap, NULL, NULL, "ns1:From");
	case SOAP_TYPE_ns1__FreeBusyUser:
		return soap_in_ns1__FreeBusyUser(soap, NULL, NULL, "ns1:FreeBusyUser");
	case SOAP_TYPE_ns1__FreeBusyStats:
		return soap_in_ns1__FreeBusyStats(soap, NULL, NULL, "ns1:FreeBusyStats");
	case SOAP_TYPE_ns1__FreeBusyInfoList:
		return soap_in_ns1__FreeBusyInfoList(soap, NULL, NULL, "ns1:FreeBusyInfoList");
	case SOAP_TYPE_ns1__FreeBusyUserList:
		return soap_in_ns1__FreeBusyUserList(soap, NULL, NULL, "ns1:FreeBusyUserList");
	case SOAP_TYPE_ns1__FreeBusyInfo:
		return soap_in_ns1__FreeBusyInfo(soap, NULL, NULL, "ns1:FreeBusyInfo");
	case SOAP_TYPE_ns1__FreeBusyBlock:
		return soap_in_ns1__FreeBusyBlock(soap, NULL, NULL, "ns1:FreeBusyBlock");
	case SOAP_TYPE_ns1__FreeBusyBlockList:
		return soap_in_ns1__FreeBusyBlockList(soap, NULL, NULL, "ns1:FreeBusyBlockList");
	case SOAP_TYPE_ns1__FolderList:
		return soap_in_ns1__FolderList(soap, NULL, NULL, "ns1:FolderList");
	case SOAP_TYPE_ns1__FolderACLEntry:
		return soap_in_ns1__FolderACLEntry(soap, NULL, NULL, "ns1:FolderACLEntry");
	case SOAP_TYPE_ns1__FolderACL:
		return soap_in_ns1__FolderACL(soap, NULL, NULL, "ns1:FolderACL");
	case SOAP_TYPE_ns1__Folder:
		return soap_in_ns1__Folder(soap, NULL, NULL, "ns1:Folder");
	case SOAP_TYPE_ns1__FilterGroup:
		return soap_in_ns1__FilterGroup(soap, NULL, NULL, "ns1:FilterGroup");
	case SOAP_TYPE_ns1__FilterEntry:
		return soap_in_ns1__FilterEntry(soap, NULL, NULL, "ns1:FilterEntry");
	case SOAP_TYPE_ns1__FilterElement:
		return soap_in_ns1__FilterElement(soap, NULL, NULL, "ns1:FilterElement");
	case SOAP_TYPE_ns1__Filter:
		return soap_in_ns1__Filter(soap, NULL, NULL, "ns1:Filter");
	case SOAP_TYPE_ns1__EmailAddressList:
		return soap_in_ns1__EmailAddressList(soap, NULL, NULL, "ns1:EmailAddressList");
	case SOAP_TYPE_ns1__DocumentRef:
		return soap_in_ns1__DocumentRef(soap, NULL, NULL, "ns1:DocumentRef");
	case SOAP_TYPE_ns1__Distribution:
		return soap_in_ns1__Distribution(soap, NULL, NULL, "ns1:Distribution");
	case SOAP_TYPE_ns1__DeltaList:
		return soap_in_ns1__DeltaList(soap, NULL, NULL, "ns1:DeltaList");
	case SOAP_TYPE_ns1__DelegateeStatus:
		return soap_in_ns1__DelegateeStatus(soap, NULL, NULL, "ns1:DelegateeStatus");
	case SOAP_TYPE_ns1__DelegatedStatus:
		return soap_in_ns1__DelegatedStatus(soap, NULL, NULL, "ns1:DelegatedStatus");
	case SOAP_TYPE_ns1__DayOfWeek:
		return soap_in_ns1__DayOfWeek(soap, NULL, NULL, "ns1:DayOfWeek");
	case SOAP_TYPE_ns1__CustomList:
		return soap_in_ns1__CustomList(soap, NULL, NULL, "ns1:CustomList");
	case SOAP_TYPE_ns1__Custom:
		return soap_in_ns1__Custom(soap, NULL, NULL, "ns1:Custom");
	case SOAP_TYPE_ns1__ContactFolder:
		return soap_in_ns1__ContactFolder(soap, NULL, NULL, "ns1:ContactFolder");
	case SOAP_TYPE_ns1__ContainerRef:
		return soap_in_ns1__ContainerRef(soap, NULL, NULL, "ns1:ContainerRef");
	case SOAP_TYPE_ns1__ContainerItem:
		return soap_in_ns1__ContainerItem(soap, NULL, NULL, "ns1:ContainerItem");
	case SOAP_TYPE_ns1__Contact:
		return soap_in_ns1__Contact(soap, NULL, NULL, "ns1:Contact");
	case SOAP_TYPE_ns1__CommentStatus:
		return soap_in_ns1__CommentStatus(soap, NULL, NULL, "ns1:CommentStatus");
	case SOAP_TYPE_ns1__CategoryRefList:
		return soap_in_ns1__CategoryRefList(soap, NULL, NULL, "ns1:CategoryRefList");
	case SOAP_TYPE_ns1__CategoryList:
		return soap_in_ns1__CategoryList(soap, NULL, NULL, "ns1:CategoryList");
	case SOAP_TYPE_ns1__Category:
		return soap_in_ns1__Category(soap, NULL, NULL, "ns1:Category");
	case SOAP_TYPE_ns1__CalendarItem:
		return soap_in_ns1__CalendarItem(soap, NULL, NULL, "ns1:CalendarItem");
	case SOAP_TYPE_ns1__BoxEntry:
		return soap_in_ns1__BoxEntry(soap, NULL, NULL, "ns1:BoxEntry");
	case SOAP_TYPE_ns1__Authentication:
		return soap_in_ns1__Authentication(soap, NULL, NULL, "ns1:Authentication");
	case SOAP_TYPE_ns1__AttachmentItemInfo:
		return soap_in_ns1__AttachmentItemInfo(soap, NULL, NULL, "ns1:AttachmentItemInfo");
	case SOAP_TYPE_ns1__AttachmentInfo:
		return soap_in_ns1__AttachmentInfo(soap, NULL, NULL, "ns1:AttachmentInfo");
	case SOAP_TYPE_ns1__AttachmentID:
		return soap_in_ns1__AttachmentID(soap, NULL, NULL, "ns1:AttachmentID");
	case SOAP_TYPE_ns1__Appointment:
		return soap_in_ns1__Appointment(soap, NULL, NULL, "ns1:Appointment");
	case SOAP_TYPE_ns1__Alarm:
		return soap_in_ns1__Alarm(soap, NULL, NULL, "ns1:Alarm");
	case SOAP_TYPE_ns1__AddressBookList:
		return soap_in_ns1__AddressBookList(soap, NULL, NULL, "ns1:AddressBookList");
	case SOAP_TYPE_ns1__AddressBookItem:
		return soap_in_ns1__AddressBookItem(soap, NULL, NULL, "ns1:AddressBookItem");
	case SOAP_TYPE_ns1__AddressBook:
		return soap_in_ns1__AddressBook(soap, NULL, NULL, "ns1:AddressBook");
	case SOAP_TYPE_ns1__AccessRightList:
		return soap_in_ns1__AccessRightList(soap, NULL, NULL, "ns1:AccessRightList");
	case SOAP_TYPE_ns1__AccessRightEntry:
		return soap_in_ns1__AccessRightEntry(soap, NULL, NULL, "ns1:AccessRightEntry");
	case SOAP_TYPE_ns1__AccessRightChanges:
		return soap_in_ns1__AccessRightChanges(soap, NULL, NULL, "ns1:AccessRightChanges");
	case SOAP_TYPE_ns1__AccessRight:
		return soap_in_ns1__AccessRight(soap, NULL, NULL, "ns1:AccessRight");
	case SOAP_TYPE_ns1__AccessMiscRight:
		return soap_in_ns1__AccessMiscRight(soap, NULL, NULL, "ns1:AccessMiscRight");
	case SOAP_TYPE_ns1__AccessControlList:
		return soap_in_ns1__AccessControlList(soap, NULL, NULL, "ns1:AccessControlList");
	case SOAP_TYPE_ns1__AccessControlListEntry:
		return soap_in_ns1__AccessControlListEntry(soap, NULL, NULL, "ns1:AccessControlListEntry");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__createItemResponse:
		return soap_in_PointerTo_ns1__createItemResponse(soap, NULL, NULL, "ns1:createItemResponse");
	case SOAP_TYPE_PointerTo_ns1__createItemRequest:
		return soap_in_PointerTo_ns1__createItemRequest(soap, NULL, NULL, "ns1:createItemRequest");
	case SOAP_TYPE_PointerTo_ns1__getDeltaResponse:
		return soap_in_PointerTo_ns1__getDeltaResponse(soap, NULL, NULL, "ns1:getDeltaResponse");
	case SOAP_TYPE_PointerTo_ns1__getDeltaRequest:
		return soap_in_PointerTo_ns1__getDeltaRequest(soap, NULL, NULL, "ns1:getDeltaRequest");
	case SOAP_TYPE_PointerTo_ns1__getFolderListResponse:
		return soap_in_PointerTo_ns1__getFolderListResponse(soap, NULL, NULL, "ns1:getFolderListResponse");
	case SOAP_TYPE_PointerTo_ns1__getFolderListRequest:
		return soap_in_PointerTo_ns1__getFolderListRequest(soap, NULL, NULL, "ns1:getFolderListRequest");
	case SOAP_TYPE_PointerTo_ns1__getItemsResponse:
		return soap_in_PointerTo_ns1__getItemsResponse(soap, NULL, NULL, "ns1:getItemsResponse");
	case SOAP_TYPE_PointerTo_ns1__getItemsRequest:
		return soap_in_PointerTo_ns1__getItemsRequest(soap, NULL, NULL, "ns1:getItemsRequest");
	case SOAP_TYPE_PointerTo_ns1__getItemResponse:
		return soap_in_PointerTo_ns1__getItemResponse(soap, NULL, NULL, "ns1:getItemResponse");
	case SOAP_TYPE_PointerTo_ns1__getItemRequest:
		return soap_in_PointerTo_ns1__getItemRequest(soap, NULL, NULL, "ns1:getItemRequest");
	case SOAP_TYPE_PointerTo_ns1__getAddressBookListResponse:
		return soap_in_PointerTo_ns1__getAddressBookListResponse(soap, NULL, NULL, "ns1:getAddressBookListResponse");
	case SOAP_TYPE_PointerTo_ns1__getCategoryListResponse:
		return soap_in_PointerTo_ns1__getCategoryListResponse(soap, NULL, NULL, "ns1:getCategoryListResponse");
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		return soap_in_PointerTo_ns1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_PointerTo_ns1__loginRequest:
		return soap_in_PointerTo_ns1__loginRequest(soap, NULL, NULL, "ns1:loginRequest");
	case SOAP_TYPE_PointerTo_ns1__sendItemResponse:
		return soap_in_PointerTo_ns1__sendItemResponse(soap, NULL, NULL, "ns1:sendItemResponse");
	case SOAP_TYPE_PointerTo_ns1__sendItemRequest:
		return soap_in_PointerTo_ns1__sendItemRequest(soap, NULL, NULL, "ns1:sendItemRequest");
	case SOAP_TYPE_PointerTo_ns1__getFreeBusyResponse:
		return soap_in_PointerTo_ns1__getFreeBusyResponse(soap, NULL, NULL, "ns1:getFreeBusyResponse");
	case SOAP_TYPE_PointerTo_ns1__getFreeBusyRequest:
		return soap_in_PointerTo_ns1__getFreeBusyRequest(soap, NULL, NULL, "ns1:getFreeBusyRequest");
	case SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionResponse:
		return soap_in_PointerTo_ns1__closeFreeBusySessionResponse(soap, NULL, NULL, "ns1:closeFreeBusySessionResponse");
	case SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionRequest:
		return soap_in_PointerTo_ns1__closeFreeBusySessionRequest(soap, NULL, NULL, "ns1:closeFreeBusySessionRequest");
	case SOAP_TYPE_PointerTo_ns1__startFreeBusySessionResponse:
		return soap_in_PointerTo_ns1__startFreeBusySessionResponse(soap, NULL, NULL, "ns1:startFreeBusySessionResponse");
	case SOAP_TYPE_PointerTo_ns1__startFreeBusySessionRequest:
		return soap_in_PointerTo_ns1__startFreeBusySessionRequest(soap, NULL, NULL, "ns1:startFreeBusySessionRequest");
	case SOAP_TYPE_PointerTo_ns1__removeItemResponse:
		return soap_in_PointerTo_ns1__removeItemResponse(soap, NULL, NULL, "ns1:removeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__removeItemRequest:
		return soap_in_PointerTo_ns1__removeItemRequest(soap, NULL, NULL, "ns1:removeItemRequest");
	case SOAP_TYPE_PointerTo_ns1__purgeItemResponse:
		return soap_in_PointerTo_ns1__purgeItemResponse(soap, NULL, NULL, "ns1:purgeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__purgeItemRequest:
		return soap_in_PointerTo_ns1__purgeItemRequest(soap, NULL, NULL, "ns1:purgeItemRequest");
	case SOAP_TYPE_PointerTo_ns1__modifyItemResponse:
		return soap_in_PointerTo_ns1__modifyItemResponse(soap, NULL, NULL, "ns1:modifyItemResponse");
	case SOAP_TYPE_PointerTo_ns1__modifyItemRequest:
		return soap_in_PointerTo_ns1__modifyItemRequest(soap, NULL, NULL, "ns1:modifyItemRequest");
	case SOAP_TYPE_PointerTons1__Alarm:
		return soap_in_PointerTons1__Alarm(soap, NULL, NULL, "ns1:Alarm");
	case SOAP_TYPE_PointerTons1__PhoneFlags:
		return soap_in_PointerTons1__PhoneFlags(soap, NULL, NULL, "ns1:PhoneFlags");
	case SOAP_TYPE_PointerTons1__AccessControlList:
		return soap_in_PointerTons1__AccessControlList(soap, NULL, NULL, "ns1:AccessControlList");
	case SOAP_TYPE_PointerTons1__RecurrenceDateType:
		return soap_in_PointerTons1__RecurrenceDateType(soap, NULL, NULL, "ns1:RecurrenceDateType");
	case SOAP_TYPE_PointerTons1__ItemOptions:
		return soap_in_PointerTons1__ItemOptions(soap, NULL, NULL, "ns1:ItemOptions");
	case SOAP_TYPE_PointerTons1__AttachmentInfo:
		return soap_in_PointerTons1__AttachmentInfo(soap, NULL, NULL, "ns1:AttachmentInfo");
	case SOAP_TYPE_PointerTons1__MessageBody:
		return soap_in_PointerTons1__MessageBody(soap, NULL, NULL, "ns1:MessageBody");
	case SOAP_TYPE_PointerTons1__PersonalInfo:
		return soap_in_PointerTons1__PersonalInfo(soap, NULL, NULL, "ns1:PersonalInfo");
	case SOAP_TYPE_PointerTons1__OfficeInfo:
		return soap_in_PointerTons1__OfficeInfo(soap, NULL, NULL, "ns1:OfficeInfo");
	case SOAP_TYPE_PointerTons1__PostalAddressList:
		return soap_in_PointerTons1__PostalAddressList(soap, NULL, NULL, "ns1:PostalAddressList");
	case SOAP_TYPE_PointerTons1__ImAddressList:
		return soap_in_PointerTons1__ImAddressList(soap, NULL, NULL, "ns1:ImAddressList");
	case SOAP_TYPE_PointerTons1__EmailAddressList:
		return soap_in_PointerTons1__EmailAddressList(soap, NULL, NULL, "ns1:EmailAddressList");
	case SOAP_TYPE_PointerTons1__FullName:
		return soap_in_PointerTons1__FullName(soap, NULL, NULL, "ns1:FullName");
	case SOAP_TYPE_PointerTons1__UUID:
		return soap_in_PointerTons1__UUID(soap, NULL, NULL, "ns1:UUID");
	case SOAP_TYPE_PointerTons1__FolderACL:
		return soap_in_PointerTons1__FolderACL(soap, NULL, NULL, "ns1:FolderACL");
	case SOAP_TYPE_PointerTons1__Query:
		return soap_in_PointerTons1__Query(soap, NULL, NULL, "ns1:Query");
	case SOAP_TYPE_PointerTons1__FreeBusyBlockList:
		return soap_in_PointerTons1__FreeBusyBlockList(soap, NULL, NULL, "ns1:FreeBusyBlockList");
	case SOAP_TYPE_PointerTons1__ItemClass:
		return soap_in_PointerTons1__ItemClass(soap, NULL, NULL, "ns1:ItemClass");
	case SOAP_TYPE_PointerTons1__ItemSource:
		return soap_in_PointerTons1__ItemSource(soap, NULL, NULL, "ns1:ItemSource");
	case SOAP_TYPE_PointerTons1__ItemStatus:
		return soap_in_PointerTons1__ItemStatus(soap, NULL, NULL, "ns1:ItemStatus");
	case SOAP_TYPE_PointerTons1__RecipientStatus:
		return soap_in_PointerTons1__RecipientStatus(soap, NULL, NULL, "ns1:RecipientStatus");
	case SOAP_TYPE_PointerTons1__SharedFolderNotification:
		return soap_in_PointerTons1__SharedFolderNotification(soap, NULL, NULL, "ns1:SharedFolderNotification");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons1__CategoryRefList:
		return soap_in_PointerTons1__CategoryRefList(soap, NULL, NULL, "ns1:CategoryRefList");
	case SOAP_TYPE_PointerTons1__ContainerRef:
		return soap_in_PointerTons1__ContainerRef(soap, NULL, NULL, "ns1:ContainerRef");
	case SOAP_TYPE_PointerTounsignedLong:
		return soap_in_PointerTounsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTons1__CategoryType:
		return soap_in_PointerTons1__CategoryType(soap, NULL, NULL, "ns1:CategoryType");
	case SOAP_TYPE_PointerTons1__AccessMiscRight:
		return soap_in_PointerTons1__AccessMiscRight(soap, NULL, NULL, "ns1:AccessMiscRight");
	case SOAP_TYPE_PointerTons1__AccessRight:
		return soap_in_PointerTons1__AccessRight(soap, NULL, NULL, "ns1:AccessRight");
	case SOAP_TYPE_PointerTons1__Rights:
		return soap_in_PointerTons1__Rights(soap, NULL, NULL, "ns1:Rights");
	case SOAP_TYPE_PointerTons1__FreeBusyUserList:
		return soap_in_PointerTons1__FreeBusyUserList(soap, NULL, NULL, "ns1:FreeBusyUserList");
	case SOAP_TYPE_PointerTons1__ItemList:
		return soap_in_PointerTons1__ItemList(soap, NULL, NULL, "ns1:ItemList");
	case SOAP_TYPE_PointerTons1__SettingsList:
		return soap_in_PointerTons1__SettingsList(soap, NULL, NULL, "ns1:SettingsList");
	case SOAP_TYPE_PointerTons1__AccessRightChanges:
		return soap_in_PointerTons1__AccessRightChanges(soap, NULL, NULL, "ns1:AccessRightChanges");
	case SOAP_TYPE_PointerTons1__UserInfo:
		return soap_in_PointerTons1__UserInfo(soap, NULL, NULL, "ns1:UserInfo");
	case SOAP_TYPE_PointerTons1__Authentication:
		return soap_in_PointerTons1__Authentication(soap, NULL, NULL, "ns1:Authentication");
	case SOAP_TYPE_PointerTons1__TimezoneList:
		return soap_in_PointerTons1__TimezoneList(soap, NULL, NULL, "ns1:TimezoneList");
	case SOAP_TYPE_PointerTons1__Settings:
		return soap_in_PointerTons1__Settings(soap, NULL, NULL, "ns1:Settings");
	case SOAP_TYPE_PointerTons1__ProxyList:
		return soap_in_PointerTons1__ProxyList(soap, NULL, NULL, "ns1:ProxyList");
	case SOAP_TYPE_PointerTons1__AccessRightList:
		return soap_in_PointerTons1__AccessRightList(soap, NULL, NULL, "ns1:AccessRightList");
	case SOAP_TYPE_PointerTons1__View:
		return soap_in_PointerTons1__View(soap, NULL, NULL, "ns1:View");
	case SOAP_TYPE_PointerTons1__FreeBusyInfoList:
		return soap_in_PointerTons1__FreeBusyInfoList(soap, NULL, NULL, "ns1:FreeBusyInfoList");
	case SOAP_TYPE_PointerTons1__FreeBusyStats:
		return soap_in_PointerTons1__FreeBusyStats(soap, NULL, NULL, "ns1:FreeBusyStats");
	case SOAP_TYPE_PointerTons1__FolderList:
		return soap_in_PointerTons1__FolderList(soap, NULL, NULL, "ns1:FolderList");
	case SOAP_TYPE_PointerTons1__DeltaList:
		return soap_in_PointerTons1__DeltaList(soap, NULL, NULL, "ns1:DeltaList");
	case SOAP_TYPE_PointerTons1__CustomList:
		return soap_in_PointerTons1__CustomList(soap, NULL, NULL, "ns1:CustomList");
	case SOAP_TYPE_PointerTons1__CategoryList:
		return soap_in_PointerTons1__CategoryList(soap, NULL, NULL, "ns1:CategoryList");
	case SOAP_TYPE_PointerTons1__AddressBookList:
		return soap_in_PointerTons1__AddressBookList(soap, NULL, NULL, "ns1:AddressBookList");
	case SOAP_TYPE_PointerTons1__Distribution:
		return soap_in_PointerTons1__Distribution(soap, NULL, NULL, "ns1:Distribution");
	case SOAP_TYPE_PointerTons1__GroupMemberList:
		return soap_in_PointerTons1__GroupMemberList(soap, NULL, NULL, "ns1:GroupMemberList");
	case SOAP_TYPE_PointerTons1__Status:
		return soap_in_PointerTons1__Status(soap, NULL, NULL, "ns1:Status");
	case SOAP_TYPE_PointerTons1__ItemRefList:
		return soap_in_PointerTons1__ItemRefList(soap, NULL, NULL, "ns1:ItemRefList");
	case SOAP_TYPE_PointerTons1__Timezone:
		return soap_in_PointerTons1__Timezone(soap, NULL, NULL, "ns1:Timezone");
	case SOAP_TYPE_PointerTons1__DayOfWeek:
		return soap_in_PointerTons1__DayOfWeek(soap, NULL, NULL, "ns1:DayOfWeek");
	case SOAP_TYPE_PointerTons1__Day:
		return soap_in_PointerTons1__Day(soap, NULL, NULL, "ns1:Day");
	case SOAP_TYPE_PointerTons1__Minute:
		return soap_in_PointerTons1__Minute(soap, NULL, NULL, "ns1:Minute");
	case SOAP_TYPE_PointerTons1__Hour:
		return soap_in_PointerTons1__Hour(soap, NULL, NULL, "ns1:Hour");
	case SOAP_TYPE_PointerTons1__Month:
		return soap_in_PointerTons1__Month(soap, NULL, NULL, "ns1:Month");
	case SOAP_TYPE_PointerTons1__TimezoneComponent:
		return soap_in_PointerTons1__TimezoneComponent(soap, NULL, NULL, "ns1:TimezoneComponent");
	case SOAP_TYPE_PointerTons1__ProblemList:
		return soap_in_PointerTons1__ProblemList(soap, NULL, NULL, "ns1:ProblemList");
	case SOAP_TYPE_PointerTons1__SettingsGroup:
		return soap_in_PointerTons1__SettingsGroup(soap, NULL, NULL, "ns1:SettingsGroup");
	case SOAP_TYPE_PointerTons1__ReturnNotification:
		return soap_in_PointerTons1__ReturnNotification(soap, NULL, NULL, "ns1:ReturnNotification");
	case SOAP_TYPE_PointerTons1__StatusTracking:
		return soap_in_PointerTons1__StatusTracking(soap, NULL, NULL, "ns1:StatusTracking");
	case SOAP_TYPE_PointerTons1__SendOptionsRequestReply:
		return soap_in_PointerTons1__SendOptionsRequestReply(soap, NULL, NULL, "ns1:SendOptionsRequestReply");
	case SOAP_TYPE_PointerTons1__ReturnNotificationOptions:
		return soap_in_PointerTons1__ReturnNotificationOptions(soap, NULL, NULL, "ns1:ReturnNotificationOptions");
	case SOAP_TYPE_PointerTons1__DelegateeStatus:
		return soap_in_PointerTons1__DelegateeStatus(soap, NULL, NULL, "ns1:DelegateeStatus");
	case SOAP_TYPE_PointerTons1__DelegatedStatus:
		return soap_in_PointerTons1__DelegatedStatus(soap, NULL, NULL, "ns1:DelegatedStatus");
	case SOAP_TYPE_PointerTons1__CommentStatus:
		return soap_in_PointerTons1__CommentStatus(soap, NULL, NULL, "ns1:CommentStatus");
	case SOAP_TYPE_PointerTons1__Recipient:
		return soap_in_PointerTons1__Recipient(soap, NULL, NULL, "ns1:Recipient");
	case SOAP_TYPE_PointerTons1__uid:
		return soap_in_PointerTons1__uid(soap, NULL, NULL, "ns1:uid");
	case SOAP_TYPE_PointerTons1__Filter:
		return soap_in_PointerTons1__Filter(soap, NULL, NULL, "ns1:Filter");
	case SOAP_TYPE_PointerTons1__QueryTarget:
		return soap_in_PointerTons1__QueryTarget(soap, NULL, NULL, "ns1:QueryTarget");
	case SOAP_TYPE_PointerTons1__NameAndEmail:
		return soap_in_PointerTons1__NameAndEmail(soap, NULL, NULL, "ns1:NameAndEmail");
	case SOAP_TYPE_PointerTons1__ProblemEntry:
		return soap_in_PointerTons1__ProblemEntry(soap, NULL, NULL, "ns1:ProblemEntry");
	case SOAP_TYPE_PointerTons1__PostalAddress:
		return soap_in_PointerTons1__PostalAddress(soap, NULL, NULL, "ns1:PostalAddress");
	case SOAP_TYPE_PointerTons1__ItemRef:
		return soap_in_PointerTons1__ItemRef(soap, NULL, NULL, "ns1:ItemRef");
	case SOAP_TYPE_PointerTons1__MessagePart:
		return soap_in_PointerTons1__MessagePart(soap, NULL, NULL, "ns1:MessagePart");
	case SOAP_TYPE_PointerTons1__Item:
		return soap_in_PointerTons1__Item(soap, NULL, NULL, "ns1:Item");
	case SOAP_TYPE_PointerTons1__ItemChanges:
		return soap_in_PointerTons1__ItemChanges(soap, NULL, NULL, "ns1:ItemChanges");
	case SOAP_TYPE_PointerTons1__ImAddress:
		return soap_in_PointerTons1__ImAddress(soap, NULL, NULL, "ns1:ImAddress");
	case SOAP_TYPE_PointerTons1__GroupMember:
		return soap_in_PointerTons1__GroupMember(soap, NULL, NULL, "ns1:GroupMember");
	case SOAP_TYPE_PointerTons1__FreeBusyInfo:
		return soap_in_PointerTons1__FreeBusyInfo(soap, NULL, NULL, "ns1:FreeBusyInfo");
	case SOAP_TYPE_PointerTons1__FreeBusyUser:
		return soap_in_PointerTons1__FreeBusyUser(soap, NULL, NULL, "ns1:FreeBusyUser");
	case SOAP_TYPE_PointerTons1__FreeBusyBlock:
		return soap_in_PointerTons1__FreeBusyBlock(soap, NULL, NULL, "ns1:FreeBusyBlock");
	case SOAP_TYPE_PointerTons1__Folder:
		return soap_in_PointerTons1__Folder(soap, NULL, NULL, "ns1:Folder");
	case SOAP_TYPE_PointerTons1__FolderACLEntry:
		return soap_in_PointerTons1__FolderACLEntry(soap, NULL, NULL, "ns1:FolderACLEntry");
	case SOAP_TYPE_PointerTons1__FilterElement:
		return soap_in_PointerTons1__FilterElement(soap, NULL, NULL, "ns1:FilterElement");
	case SOAP_TYPE_PointerTons1__SendOptions:
		return soap_in_PointerTons1__SendOptions(soap, NULL, NULL, "ns1:SendOptions");
	case SOAP_TYPE_PointerTons1__RecipientList:
		return soap_in_PointerTons1__RecipientList(soap, NULL, NULL, "ns1:RecipientList");
	case SOAP_TYPE_PointerTons1__From:
		return soap_in_PointerTons1__From(soap, NULL, NULL, "ns1:From");
	case SOAP_TYPE_PointerTons1__Items:
		return soap_in_PointerTons1__Items(soap, NULL, NULL, "ns1:Items");
	case SOAP_TYPE_PointerTons1__Custom:
		return soap_in_PointerTons1__Custom(soap, NULL, NULL, "ns1:Custom");
	case SOAP_TYPE_PointerTons1__Category:
		return soap_in_PointerTons1__Category(soap, NULL, NULL, "ns1:Category");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__AttachmentID:
		return soap_in_PointerTons1__AttachmentID(soap, NULL, NULL, "ns1:AttachmentID");
	case SOAP_TYPE_PointerTons1__AttachmentItemInfo:
		return soap_in_PointerTons1__AttachmentItemInfo(soap, NULL, NULL, "ns1:AttachmentItemInfo");
	case SOAP_TYPE_PointerTons1__AddressBook:
		return soap_in_PointerTons1__AddressBook(soap, NULL, NULL, "ns1:AddressBook");
	case SOAP_TYPE_PointerTons1__AccessRightEntry:
		return soap_in_PointerTons1__AccessRightEntry(soap, NULL, NULL, "ns1:AccessRightEntry");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__AccessControlListEntry:
		return soap_in_PointerTons1__AccessControlListEntry(soap, NULL, NULL, "ns1:AccessControlListEntry");
	case SOAP_TYPE_xsd__language:
	{	char **s;
		s = soap_in_xsd__language(soap, NULL, NULL, "xsd:language");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__decimal:
	{	char **s;
		s = soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__date:
	{	char **s;
		s = soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__bool:
	{	char **s;
		s = soap_in_xsd__bool(soap, NULL, NULL, "xsd:bool");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GMTOffset"))
		{	*type = SOAP_TYPE_ns1__GMTOffset;
			return soap_in_ns1__GMTOffset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Month"))
		{	*type = SOAP_TYPE_ns1__Month;
			return soap_in_ns1__Month(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Minute"))
		{	*type = SOAP_TYPE_ns1__Minute;
			return soap_in_ns1__Minute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Hour"))
		{	*type = SOAP_TYPE_ns1__Hour;
			return soap_in_ns1__Hour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Day"))
		{	*type = SOAP_TYPE_ns1__Day;
			return soap_in_ns1__Day(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLong;
			return soap_in_unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WeekDay"))
		{	*type = SOAP_TYPE_ns1__WeekDay;
			return soap_in_ns1__WeekDay(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StatusTrackingOptions"))
		{	*type = SOAP_TYPE_ns1__StatusTrackingOptions;
			return soap_in_ns1__StatusTrackingOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipientType"))
		{	*type = SOAP_TYPE_ns1__RecipientType;
			return soap_in_ns1__RecipientType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PostalAddressType"))
		{	*type = SOAP_TYPE_ns1__PostalAddressType;
			return soap_in_ns1__PostalAddressType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OccurrenceType"))
		{	*type = SOAP_TYPE_ns1__OccurrenceType;
			return soap_in_ns1__OccurrenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemSource"))
		{	*type = SOAP_TYPE_ns1__ItemSource;
			return soap_in_ns1__ItemSource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemOptionsPriority"))
		{	*type = SOAP_TYPE_ns1__ItemOptionsPriority;
			return soap_in_ns1__ItemOptionsPriority(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemClass"))
		{	*type = SOAP_TYPE_ns1__ItemClass;
			return soap_in_ns1__ItemClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FolderType"))
		{	*type = SOAP_TYPE_ns1__FolderType;
			return soap_in_ns1__FolderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FolderACLStatus"))
		{	*type = SOAP_TYPE_ns1__FolderACLStatus;
			return soap_in_ns1__FolderACLStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FilterOp"))
		{	*type = SOAP_TYPE_ns1__FilterOp;
			return soap_in_ns1__FilterOp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DistributionType"))
		{	*type = SOAP_TYPE_ns1__DistributionType;
			return soap_in_ns1__DistributionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CursorSeek"))
		{	*type = SOAP_TYPE_ns1__CursorSeek;
			return soap_in_ns1__CursorSeek(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ContactType"))
		{	*type = SOAP_TYPE_ns1__ContactType;
			return soap_in_ns1__ContactType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CategoryType"))
		{	*type = SOAP_TYPE_ns1__CategoryType;
			return soap_in_ns1__CategoryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AcceptLevel"))
		{	*type = SOAP_TYPE_ns1__AcceptLevel;
			return soap_in_ns1__AcceptLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UUID"))
		{	*type = SOAP_TYPE_ns1__UUID;
			return soap_in_ns1__UUID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:uid"))
		{	*type = SOAP_TYPE_ns1__uid;
			return soap_in_ns1__uid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:View"))
		{	*type = SOAP_TYPE_ns1__View;
			return soap_in_ns1__View(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:startFreeBusySessionResponse"))
		{	*type = SOAP_TYPE__ns1__startFreeBusySessionResponse;
			return soap_in__ns1__startFreeBusySessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:startFreeBusySessionRequest"))
		{	*type = SOAP_TYPE__ns1__startFreeBusySessionRequest;
			return soap_in__ns1__startFreeBusySessionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendItemResponse"))
		{	*type = SOAP_TYPE__ns1__sendItemResponse;
			return soap_in__ns1__sendItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendItemRequest"))
		{	*type = SOAP_TYPE__ns1__sendItemRequest;
			return soap_in__ns1__sendItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:retractResponse"))
		{	*type = SOAP_TYPE__ns1__retractResponse;
			return soap_in__ns1__retractResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:retractRequest"))
		{	*type = SOAP_TYPE__ns1__retractRequest;
			return soap_in__ns1__retractRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeProxyAccessResponse"))
		{	*type = SOAP_TYPE__ns1__removeProxyAccessResponse;
			return soap_in__ns1__removeProxyAccessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeProxyAccessRequest"))
		{	*type = SOAP_TYPE__ns1__removeProxyAccessRequest;
			return soap_in__ns1__removeProxyAccessRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeMembersResponse"))
		{	*type = SOAP_TYPE__ns1__removeMembersResponse;
			return soap_in__ns1__removeMembersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeMembersRequest"))
		{	*type = SOAP_TYPE__ns1__removeMembersRequest;
			return soap_in__ns1__removeMembersRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeItemsResponse"))
		{	*type = SOAP_TYPE__ns1__removeItemsResponse;
			return soap_in__ns1__removeItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeItemsRequest"))
		{	*type = SOAP_TYPE__ns1__removeItemsRequest;
			return soap_in__ns1__removeItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeItemResponse"))
		{	*type = SOAP_TYPE__ns1__removeItemResponse;
			return soap_in__ns1__removeItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeItemRequest"))
		{	*type = SOAP_TYPE__ns1__removeItemRequest;
			return soap_in__ns1__removeItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:readCursorResponse"))
		{	*type = SOAP_TYPE__ns1__readCursorResponse;
			return soap_in__ns1__readCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:readCursorRequest"))
		{	*type = SOAP_TYPE__ns1__readCursorRequest;
			return soap_in__ns1__readCursorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:purgeItemResponse"))
		{	*type = SOAP_TYPE__ns1__purgeItemResponse;
			return soap_in__ns1__purgeItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:purgeItemRequest"))
		{	*type = SOAP_TYPE__ns1__purgeItemRequest;
			return soap_in__ns1__purgeItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:purgeDeletedItemsResponse"))
		{	*type = SOAP_TYPE__ns1__purgeDeletedItemsResponse;
			return soap_in__ns1__purgeDeletedItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:purgeDeletedItemsRequest"))
		{	*type = SOAP_TYPE__ns1__purgeDeletedItemsRequest;
			return soap_in__ns1__purgeDeletedItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:positionCursorResponse"))
		{	*type = SOAP_TYPE__ns1__positionCursorResponse;
			return soap_in__ns1__positionCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:positionCursorRequest"))
		{	*type = SOAP_TYPE__ns1__positionCursorRequest;
			return soap_in__ns1__positionCursorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifySettingsResponse"))
		{	*type = SOAP_TYPE__ns1__modifySettingsResponse;
			return soap_in__ns1__modifySettingsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifySettingsRequest"))
		{	*type = SOAP_TYPE__ns1__modifySettingsRequest;
			return soap_in__ns1__modifySettingsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyProxyAccessResponse"))
		{	*type = SOAP_TYPE__ns1__modifyProxyAccessResponse;
			return soap_in__ns1__modifyProxyAccessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyProxyAccessRequest"))
		{	*type = SOAP_TYPE__ns1__modifyProxyAccessRequest;
			return soap_in__ns1__modifyProxyAccessRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyItemResponse"))
		{	*type = SOAP_TYPE__ns1__modifyItemResponse;
			return soap_in__ns1__modifyItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:modifyItemRequest"))
		{	*type = SOAP_TYPE__ns1__modifyItemRequest;
			return soap_in__ns1__modifyItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:markUnReadResponse"))
		{	*type = SOAP_TYPE__ns1__markUnReadResponse;
			return soap_in__ns1__markUnReadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:markUnReadRequest"))
		{	*type = SOAP_TYPE__ns1__markUnReadRequest;
			return soap_in__ns1__markUnReadRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:markReadResponse"))
		{	*type = SOAP_TYPE__ns1__markReadResponse;
			return soap_in__ns1__markReadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:markReadRequest"))
		{	*type = SOAP_TYPE__ns1__markReadRequest;
			return soap_in__ns1__markReadRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logoutResponse"))
		{	*type = SOAP_TYPE__ns1__logoutResponse;
			return soap_in__ns1__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginResponse"))
		{	*type = SOAP_TYPE__ns1__loginResponse;
			return soap_in__ns1__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginRequest"))
		{	*type = SOAP_TYPE__ns1__loginRequest;
			return soap_in__ns1__loginRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTimezoneListResponse"))
		{	*type = SOAP_TYPE__ns1__getTimezoneListResponse;
			return soap_in__ns1__getTimezoneListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSettingsResponse"))
		{	*type = SOAP_TYPE__ns1__getSettingsResponse;
			return soap_in__ns1__getSettingsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSettingsRequest"))
		{	*type = SOAP_TYPE__ns1__getSettingsRequest;
			return soap_in__ns1__getSettingsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProxyListResponse"))
		{	*type = SOAP_TYPE__ns1__getProxyListResponse;
			return soap_in__ns1__getProxyListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProxyAccessListResponse"))
		{	*type = SOAP_TYPE__ns1__getProxyAccessListResponse;
			return soap_in__ns1__getProxyAccessListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getItemsResponse"))
		{	*type = SOAP_TYPE__ns1__getItemsResponse;
			return soap_in__ns1__getItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getItemsRequest"))
		{	*type = SOAP_TYPE__ns1__getItemsRequest;
			return soap_in__ns1__getItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getItemResponse"))
		{	*type = SOAP_TYPE__ns1__getItemResponse;
			return soap_in__ns1__getItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getItemRequest"))
		{	*type = SOAP_TYPE__ns1__getItemRequest;
			return soap_in__ns1__getItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFreeBusyResponse"))
		{	*type = SOAP_TYPE__ns1__getFreeBusyResponse;
			return soap_in__ns1__getFreeBusyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFreeBusyRequest"))
		{	*type = SOAP_TYPE__ns1__getFreeBusyRequest;
			return soap_in__ns1__getFreeBusyRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderListResponse"))
		{	*type = SOAP_TYPE__ns1__getFolderListResponse;
			return soap_in__ns1__getFolderListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderListRequest"))
		{	*type = SOAP_TYPE__ns1__getFolderListRequest;
			return soap_in__ns1__getFolderListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeltaResponse"))
		{	*type = SOAP_TYPE__ns1__getDeltaResponse;
			return soap_in__ns1__getDeltaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeltaRequest"))
		{	*type = SOAP_TYPE__ns1__getDeltaRequest;
			return soap_in__ns1__getDeltaRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCustomListResponse"))
		{	*type = SOAP_TYPE__ns1__getCustomListResponse;
			return soap_in__ns1__getCustomListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCategoryListResponse"))
		{	*type = SOAP_TYPE__ns1__getCategoryListResponse;
			return soap_in__ns1__getCategoryListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAttachmentResponse"))
		{	*type = SOAP_TYPE__ns1__getAttachmentResponse;
			return soap_in__ns1__getAttachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAttachmentRequest"))
		{	*type = SOAP_TYPE__ns1__getAttachmentRequest;
			return soap_in__ns1__getAttachmentRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAddressBookListResponse"))
		{	*type = SOAP_TYPE__ns1__getAddressBookListResponse;
			return soap_in__ns1__getAddressBookListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:destroyCursorResponse"))
		{	*type = SOAP_TYPE__ns1__destroyCursorResponse;
			return soap_in__ns1__destroyCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:destroyCursorRequest"))
		{	*type = SOAP_TYPE__ns1__destroyCursorRequest;
			return soap_in__ns1__destroyCursorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:delegateResponse"))
		{	*type = SOAP_TYPE__ns1__delegateResponse;
			return soap_in__ns1__delegateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:delegateRequest"))
		{	*type = SOAP_TYPE__ns1__delegateRequest;
			return soap_in__ns1__delegateRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:declineResponse"))
		{	*type = SOAP_TYPE__ns1__declineResponse;
			return soap_in__ns1__declineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:declineRequest"))
		{	*type = SOAP_TYPE__ns1__declineRequest;
			return soap_in__ns1__declineRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createProxyAccessResponse"))
		{	*type = SOAP_TYPE__ns1__createProxyAccessResponse;
			return soap_in__ns1__createProxyAccessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createProxyAccessRequest"))
		{	*type = SOAP_TYPE__ns1__createProxyAccessRequest;
			return soap_in__ns1__createProxyAccessRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createItemResponse"))
		{	*type = SOAP_TYPE__ns1__createItemResponse;
			return soap_in__ns1__createItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createItemRequest"))
		{	*type = SOAP_TYPE__ns1__createItemRequest;
			return soap_in__ns1__createItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createCursorResponse"))
		{	*type = SOAP_TYPE__ns1__createCursorResponse;
			return soap_in__ns1__createCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createCursorRequest"))
		{	*type = SOAP_TYPE__ns1__createCursorRequest;
			return soap_in__ns1__createCursorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:completeResponse"))
		{	*type = SOAP_TYPE__ns1__completeResponse;
			return soap_in__ns1__completeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:completeRequest"))
		{	*type = SOAP_TYPE__ns1__completeRequest;
			return soap_in__ns1__completeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:closeFreeBusySessionResponse"))
		{	*type = SOAP_TYPE__ns1__closeFreeBusySessionResponse;
			return soap_in__ns1__closeFreeBusySessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:closeFreeBusySessionRequest"))
		{	*type = SOAP_TYPE__ns1__closeFreeBusySessionRequest;
			return soap_in__ns1__closeFreeBusySessionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addMembersResponse"))
		{	*type = SOAP_TYPE__ns1__addMembersResponse;
			return soap_in__ns1__addMembersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addMembersRequest"))
		{	*type = SOAP_TYPE__ns1__addMembersRequest;
			return soap_in__ns1__addMembersRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addItemsResponse"))
		{	*type = SOAP_TYPE__ns1__addItemsResponse;
			return soap_in__ns1__addItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addItemsRequest"))
		{	*type = SOAP_TYPE__ns1__addItemsRequest;
			return soap_in__ns1__addItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addItemResponse"))
		{	*type = SOAP_TYPE__ns1__addItemResponse;
			return soap_in__ns1__addItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addItemRequest"))
		{	*type = SOAP_TYPE__ns1__addItemRequest;
			return soap_in__ns1__addItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:acceptResponse"))
		{	*type = SOAP_TYPE__ns1__acceptResponse;
			return soap_in__ns1__acceptResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:acceptRequest"))
		{	*type = SOAP_TYPE__ns1__acceptRequest;
			return soap_in__ns1__acceptRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UserInfo"))
		{	*type = SOAP_TYPE_ns1__UserInfo;
			return soap_in_ns1__UserInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TrustedApplication"))
		{	*type = SOAP_TYPE_ns1__TrustedApplication;
			return soap_in_ns1__TrustedApplication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TimezoneList"))
		{	*type = SOAP_TYPE_ns1__TimezoneList;
			return soap_in_ns1__TimezoneList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TimezoneComponent"))
		{	*type = SOAP_TYPE_ns1__TimezoneComponent;
			return soap_in_ns1__TimezoneComponent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Timezone"))
		{	*type = SOAP_TYPE_ns1__Timezone;
			return soap_in_ns1__Timezone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Task"))
		{	*type = SOAP_TYPE_ns1__Task;
			return soap_in_ns1__Task(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SystemFolder"))
		{	*type = SOAP_TYPE_ns1__SystemFolder;
			return soap_in_ns1__SystemFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StatusTracking"))
		{	*type = SOAP_TYPE_ns1__StatusTracking;
			return soap_in_ns1__StatusTracking(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Status"))
		{	*type = SOAP_TYPE_ns1__Status;
			return soap_in_ns1__Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SharedFolderNotification"))
		{	*type = SOAP_TYPE_ns1__SharedFolderNotification;
			return soap_in_ns1__SharedFolderNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SharedFolder"))
		{	*type = SOAP_TYPE_ns1__SharedFolder;
			return soap_in_ns1__SharedFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SettingsList"))
		{	*type = SOAP_TYPE_ns1__SettingsList;
			return soap_in_ns1__SettingsList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SettingsGroup"))
		{	*type = SOAP_TYPE_ns1__SettingsGroup;
			return soap_in_ns1__SettingsGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Settings"))
		{	*type = SOAP_TYPE_ns1__Settings;
			return soap_in_ns1__Settings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SendOptions"))
		{	*type = SOAP_TYPE_ns1__SendOptions;
			return soap_in_ns1__SendOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SendOptionsRequestReply"))
		{	*type = SOAP_TYPE_ns1__SendOptionsRequestReply;
			return soap_in_ns1__SendOptionsRequestReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Rights"))
		{	*type = SOAP_TYPE_ns1__Rights;
			return soap_in_ns1__Rights(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReturnNotificationOptions"))
		{	*type = SOAP_TYPE_ns1__ReturnNotificationOptions;
			return soap_in_ns1__ReturnNotificationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReturnNotification"))
		{	*type = SOAP_TYPE_ns1__ReturnNotification;
			return soap_in_ns1__ReturnNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Resource"))
		{	*type = SOAP_TYPE_ns1__Resource;
			return soap_in_ns1__Resource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecurrenceDateType"))
		{	*type = SOAP_TYPE_ns1__RecurrenceDateType;
			return soap_in_ns1__RecurrenceDateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipientStatus"))
		{	*type = SOAP_TYPE_ns1__RecipientStatus;
			return soap_in_ns1__RecipientStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RecipientList"))
		{	*type = SOAP_TYPE_ns1__RecipientList;
			return soap_in_ns1__RecipientList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Recipient"))
		{	*type = SOAP_TYPE_ns1__Recipient;
			return soap_in_ns1__Recipient(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryTarget"))
		{	*type = SOAP_TYPE_ns1__QueryTarget;
			return soap_in_ns1__QueryTarget(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryFolder"))
		{	*type = SOAP_TYPE_ns1__QueryFolder;
			return soap_in_ns1__QueryFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Query"))
		{	*type = SOAP_TYPE_ns1__Query;
			return soap_in_ns1__Query(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProxyList"))
		{	*type = SOAP_TYPE_ns1__ProxyList;
			return soap_in_ns1__ProxyList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Proxy"))
		{	*type = SOAP_TYPE_ns1__Proxy;
			return soap_in_ns1__Proxy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProblemList"))
		{	*type = SOAP_TYPE_ns1__ProblemList;
			return soap_in_ns1__ProblemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProblemEntry"))
		{	*type = SOAP_TYPE_ns1__ProblemEntry;
			return soap_in_ns1__ProblemEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PostalAddressList"))
		{	*type = SOAP_TYPE_ns1__PostalAddressList;
			return soap_in_ns1__PostalAddressList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PostalAddress"))
		{	*type = SOAP_TYPE_ns1__PostalAddress;
			return soap_in_ns1__PostalAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PlainText"))
		{	*type = SOAP_TYPE_ns1__PlainText;
			return soap_in_ns1__PlainText(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PhoneMessage"))
		{	*type = SOAP_TYPE_ns1__PhoneMessage;
			return soap_in_ns1__PhoneMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PhoneFlags"))
		{	*type = SOAP_TYPE_ns1__PhoneFlags;
			return soap_in_ns1__PhoneFlags(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PersonalInfo"))
		{	*type = SOAP_TYPE_ns1__PersonalInfo;
			return soap_in_ns1__PersonalInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Organization"))
		{	*type = SOAP_TYPE_ns1__Organization;
			return soap_in_ns1__Organization(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OfficeInfo"))
		{	*type = SOAP_TYPE_ns1__OfficeInfo;
			return soap_in_ns1__OfficeInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Note"))
		{	*type = SOAP_TYPE_ns1__Note;
			return soap_in_ns1__Note(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NameAndEmail"))
		{	*type = SOAP_TYPE_ns1__NameAndEmail;
			return soap_in_ns1__NameAndEmail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MessagePart"))
		{	*type = SOAP_TYPE_ns1__MessagePart;
			return soap_in_ns1__MessagePart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MessageBody"))
		{	*type = SOAP_TYPE_ns1__MessageBody;
			return soap_in_ns1__MessageBody(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Mail"))
		{	*type = SOAP_TYPE_ns1__Mail;
			return soap_in_ns1__Mail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemStatus"))
		{	*type = SOAP_TYPE_ns1__ItemStatus;
			return soap_in_ns1__ItemStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Items"))
		{	*type = SOAP_TYPE_ns1__Items;
			return soap_in_ns1__Items(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemRefList"))
		{	*type = SOAP_TYPE_ns1__ItemRefList;
			return soap_in_ns1__ItemRefList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemRef"))
		{	*type = SOAP_TYPE_ns1__ItemRef;
			return soap_in_ns1__ItemRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemOptions"))
		{	*type = SOAP_TYPE_ns1__ItemOptions;
			return soap_in_ns1__ItemOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemList"))
		{	*type = SOAP_TYPE_ns1__ItemList;
			return soap_in_ns1__ItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemChanges"))
		{	*type = SOAP_TYPE_ns1__ItemChanges;
			return soap_in_ns1__ItemChanges(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Item"))
		{	*type = SOAP_TYPE_ns1__Item;
			return soap_in_ns1__Item(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ImAddressList"))
		{	*type = SOAP_TYPE_ns1__ImAddressList;
			return soap_in_ns1__ImAddressList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ImAddress"))
		{	*type = SOAP_TYPE_ns1__ImAddress;
			return soap_in_ns1__ImAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GroupMemberList"))
		{	*type = SOAP_TYPE_ns1__GroupMemberList;
			return soap_in_ns1__GroupMemberList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GroupMember"))
		{	*type = SOAP_TYPE_ns1__GroupMember;
			return soap_in_ns1__GroupMember(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Group"))
		{	*type = SOAP_TYPE_ns1__Group;
			return soap_in_ns1__Group(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FullName"))
		{	*type = SOAP_TYPE_ns1__FullName;
			return soap_in_ns1__FullName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:From"))
		{	*type = SOAP_TYPE_ns1__From;
			return soap_in_ns1__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FreeBusyUser"))
		{	*type = SOAP_TYPE_ns1__FreeBusyUser;
			return soap_in_ns1__FreeBusyUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FreeBusyStats"))
		{	*type = SOAP_TYPE_ns1__FreeBusyStats;
			return soap_in_ns1__FreeBusyStats(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FreeBusyInfoList"))
		{	*type = SOAP_TYPE_ns1__FreeBusyInfoList;
			return soap_in_ns1__FreeBusyInfoList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FreeBusyUserList"))
		{	*type = SOAP_TYPE_ns1__FreeBusyUserList;
			return soap_in_ns1__FreeBusyUserList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FreeBusyInfo"))
		{	*type = SOAP_TYPE_ns1__FreeBusyInfo;
			return soap_in_ns1__FreeBusyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FreeBusyBlock"))
		{	*type = SOAP_TYPE_ns1__FreeBusyBlock;
			return soap_in_ns1__FreeBusyBlock(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FreeBusyBlockList"))
		{	*type = SOAP_TYPE_ns1__FreeBusyBlockList;
			return soap_in_ns1__FreeBusyBlockList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FolderList"))
		{	*type = SOAP_TYPE_ns1__FolderList;
			return soap_in_ns1__FolderList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FolderACLEntry"))
		{	*type = SOAP_TYPE_ns1__FolderACLEntry;
			return soap_in_ns1__FolderACLEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FolderACL"))
		{	*type = SOAP_TYPE_ns1__FolderACL;
			return soap_in_ns1__FolderACL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Folder"))
		{	*type = SOAP_TYPE_ns1__Folder;
			return soap_in_ns1__Folder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FilterGroup"))
		{	*type = SOAP_TYPE_ns1__FilterGroup;
			return soap_in_ns1__FilterGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FilterEntry"))
		{	*type = SOAP_TYPE_ns1__FilterEntry;
			return soap_in_ns1__FilterEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FilterElement"))
		{	*type = SOAP_TYPE_ns1__FilterElement;
			return soap_in_ns1__FilterElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Filter"))
		{	*type = SOAP_TYPE_ns1__Filter;
			return soap_in_ns1__Filter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EmailAddressList"))
		{	*type = SOAP_TYPE_ns1__EmailAddressList;
			return soap_in_ns1__EmailAddressList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DocumentRef"))
		{	*type = SOAP_TYPE_ns1__DocumentRef;
			return soap_in_ns1__DocumentRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Distribution"))
		{	*type = SOAP_TYPE_ns1__Distribution;
			return soap_in_ns1__Distribution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeltaList"))
		{	*type = SOAP_TYPE_ns1__DeltaList;
			return soap_in_ns1__DeltaList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DelegateeStatus"))
		{	*type = SOAP_TYPE_ns1__DelegateeStatus;
			return soap_in_ns1__DelegateeStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DelegatedStatus"))
		{	*type = SOAP_TYPE_ns1__DelegatedStatus;
			return soap_in_ns1__DelegatedStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DayOfWeek"))
		{	*type = SOAP_TYPE_ns1__DayOfWeek;
			return soap_in_ns1__DayOfWeek(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CustomList"))
		{	*type = SOAP_TYPE_ns1__CustomList;
			return soap_in_ns1__CustomList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Custom"))
		{	*type = SOAP_TYPE_ns1__Custom;
			return soap_in_ns1__Custom(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ContactFolder"))
		{	*type = SOAP_TYPE_ns1__ContactFolder;
			return soap_in_ns1__ContactFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ContainerRef"))
		{	*type = SOAP_TYPE_ns1__ContainerRef;
			return soap_in_ns1__ContainerRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ContainerItem"))
		{	*type = SOAP_TYPE_ns1__ContainerItem;
			return soap_in_ns1__ContainerItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Contact"))
		{	*type = SOAP_TYPE_ns1__Contact;
			return soap_in_ns1__Contact(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CommentStatus"))
		{	*type = SOAP_TYPE_ns1__CommentStatus;
			return soap_in_ns1__CommentStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CategoryRefList"))
		{	*type = SOAP_TYPE_ns1__CategoryRefList;
			return soap_in_ns1__CategoryRefList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CategoryList"))
		{	*type = SOAP_TYPE_ns1__CategoryList;
			return soap_in_ns1__CategoryList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Category"))
		{	*type = SOAP_TYPE_ns1__Category;
			return soap_in_ns1__Category(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CalendarItem"))
		{	*type = SOAP_TYPE_ns1__CalendarItem;
			return soap_in_ns1__CalendarItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BoxEntry"))
		{	*type = SOAP_TYPE_ns1__BoxEntry;
			return soap_in_ns1__BoxEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Authentication"))
		{	*type = SOAP_TYPE_ns1__Authentication;
			return soap_in_ns1__Authentication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AttachmentItemInfo"))
		{	*type = SOAP_TYPE_ns1__AttachmentItemInfo;
			return soap_in_ns1__AttachmentItemInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AttachmentInfo"))
		{	*type = SOAP_TYPE_ns1__AttachmentInfo;
			return soap_in_ns1__AttachmentInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AttachmentID"))
		{	*type = SOAP_TYPE_ns1__AttachmentID;
			return soap_in_ns1__AttachmentID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Appointment"))
		{	*type = SOAP_TYPE_ns1__Appointment;
			return soap_in_ns1__Appointment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Alarm"))
		{	*type = SOAP_TYPE_ns1__Alarm;
			return soap_in_ns1__Alarm(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddressBookList"))
		{	*type = SOAP_TYPE_ns1__AddressBookList;
			return soap_in_ns1__AddressBookList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddressBookItem"))
		{	*type = SOAP_TYPE_ns1__AddressBookItem;
			return soap_in_ns1__AddressBookItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddressBook"))
		{	*type = SOAP_TYPE_ns1__AddressBook;
			return soap_in_ns1__AddressBook(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccessRightList"))
		{	*type = SOAP_TYPE_ns1__AccessRightList;
			return soap_in_ns1__AccessRightList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccessRightEntry"))
		{	*type = SOAP_TYPE_ns1__AccessRightEntry;
			return soap_in_ns1__AccessRightEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccessRightChanges"))
		{	*type = SOAP_TYPE_ns1__AccessRightChanges;
			return soap_in_ns1__AccessRightChanges(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccessRight"))
		{	*type = SOAP_TYPE_ns1__AccessRight;
			return soap_in_ns1__AccessRight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccessMiscRight"))
		{	*type = SOAP_TYPE_ns1__AccessMiscRight;
			return soap_in_ns1__AccessMiscRight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccessControlList"))
		{	*type = SOAP_TYPE_ns1__AccessControlList;
			return soap_in_ns1__AccessControlList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccessControlListEntry"))
		{	*type = SOAP_TYPE_ns1__AccessControlListEntry;
			return soap_in_ns1__AccessControlListEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:language"))
		{	char **s;
			*type = SOAP_TYPE_xsd__language;
			s = soap_in_xsd__language(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	char **s;
			*type = SOAP_TYPE_xsd__decimal;
			s = soap_in_xsd__decimal(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	char **s;
			*type = SOAP_TYPE_xsd__date;
			s = soap_in_xsd__date(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:bool"))
		{	char **s;
			*type = SOAP_TYPE_xsd__bool;
			s = soap_in_xsd__bool(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{	if (soap->mode & SOAP_XML_STRICT)
		return SOAP_TAG_MISMATCH;
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if ((soap->mode & SOAP_IO_LENGTH) ? pp->mark1 == 2 : pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ns1__GMTOffset:
		return soap_out_ns1__GMTOffset(soap, tag, id, (const int *)ptr, "ns1:GMTOffset");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_ns1__Month:
		return soap_out_ns1__Month(soap, tag, id, (const unsigned char *)ptr, "ns1:Month");
	case SOAP_TYPE_ns1__Minute:
		return soap_out_ns1__Minute(soap, tag, id, (const unsigned char *)ptr, "ns1:Minute");
	case SOAP_TYPE_ns1__Hour:
		return soap_out_ns1__Hour(soap, tag, id, (const unsigned char *)ptr, "ns1:Hour");
	case SOAP_TYPE_ns1__Day:
		return soap_out_ns1__Day(soap, tag, id, (const unsigned char *)ptr, "ns1:Day");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_out_unsignedLong(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__WeekDay:
		return soap_out_ns1__WeekDay(soap, tag, id, (const enum ns1__WeekDay *)ptr, "ns1:WeekDay");
	case SOAP_TYPE_ns1__StatusTrackingOptions:
		return soap_out_ns1__StatusTrackingOptions(soap, tag, id, (const enum ns1__StatusTrackingOptions *)ptr, "ns1:StatusTrackingOptions");
	case SOAP_TYPE_ns1__RecipientType:
		return soap_out_ns1__RecipientType(soap, tag, id, (const enum ns1__RecipientType *)ptr, "ns1:RecipientType");
	case SOAP_TYPE_ns1__PostalAddressType:
		return soap_out_ns1__PostalAddressType(soap, tag, id, (const enum ns1__PostalAddressType *)ptr, "ns1:PostalAddressType");
	case SOAP_TYPE_ns1__OccurrenceType:
		return soap_out_ns1__OccurrenceType(soap, tag, id, (const enum ns1__OccurrenceType *)ptr, "ns1:OccurrenceType");
	case SOAP_TYPE_ns1__ItemSource:
		return soap_out_ns1__ItemSource(soap, tag, id, (const enum ns1__ItemSource *)ptr, "ns1:ItemSource");
	case SOAP_TYPE_ns1__ItemOptionsPriority:
		return soap_out_ns1__ItemOptionsPriority(soap, tag, id, (const enum ns1__ItemOptionsPriority *)ptr, "ns1:ItemOptionsPriority");
	case SOAP_TYPE_ns1__ItemClass:
		return soap_out_ns1__ItemClass(soap, tag, id, (const enum ns1__ItemClass *)ptr, "ns1:ItemClass");
	case SOAP_TYPE_ns1__FolderType:
		return soap_out_ns1__FolderType(soap, tag, id, (const enum ns1__FolderType *)ptr, "ns1:FolderType");
	case SOAP_TYPE_ns1__FolderACLStatus:
		return soap_out_ns1__FolderACLStatus(soap, tag, id, (const enum ns1__FolderACLStatus *)ptr, "ns1:FolderACLStatus");
	case SOAP_TYPE_ns1__FilterOp:
		return soap_out_ns1__FilterOp(soap, tag, id, (const enum ns1__FilterOp *)ptr, "ns1:FilterOp");
	case SOAP_TYPE_ns1__DistributionType:
		return soap_out_ns1__DistributionType(soap, tag, id, (const enum ns1__DistributionType *)ptr, "ns1:DistributionType");
	case SOAP_TYPE_ns1__CursorSeek:
		return soap_out_ns1__CursorSeek(soap, tag, id, (const enum ns1__CursorSeek *)ptr, "ns1:CursorSeek");
	case SOAP_TYPE_ns1__ContactType:
		return soap_out_ns1__ContactType(soap, tag, id, (const enum ns1__ContactType *)ptr, "ns1:ContactType");
	case SOAP_TYPE_ns1__CategoryType:
		return soap_out_ns1__CategoryType(soap, tag, id, (const enum ns1__CategoryType *)ptr, "ns1:CategoryType");
	case SOAP_TYPE_ns1__AcceptLevel:
		return soap_out_ns1__AcceptLevel(soap, tag, id, (const enum ns1__AcceptLevel *)ptr, "ns1:AcceptLevel");
	case SOAP_TYPE_ns1__UUID:
		return soap_out_ns1__UUID(soap, tag, id, (const std::string *)ptr, "ns1:UUID");
	case SOAP_TYPE_ns1__uid:
		return soap_out_ns1__uid(soap, tag, id, (const std::string *)ptr, "ns1:uid");
	case SOAP_TYPE_ns1__View:
		return soap_out_ns1__View(soap, tag, id, (const std::string *)ptr, "ns1:View");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__ns1__startFreeBusySessionResponse:
		return ((_ns1__startFreeBusySessionResponse *)ptr)->soap_out(soap, "ns1:startFreeBusySessionResponse", id, NULL);
	case SOAP_TYPE__ns1__startFreeBusySessionRequest:
		return ((_ns1__startFreeBusySessionRequest *)ptr)->soap_out(soap, "ns1:startFreeBusySessionRequest", id, NULL);
	case SOAP_TYPE__ns1__sendItemResponse:
		return ((_ns1__sendItemResponse *)ptr)->soap_out(soap, "ns1:sendItemResponse", id, NULL);
	case SOAP_TYPE__ns1__sendItemRequest:
		return ((_ns1__sendItemRequest *)ptr)->soap_out(soap, "ns1:sendItemRequest", id, NULL);
	case SOAP_TYPE__ns1__retractResponse:
		return ((_ns1__retractResponse *)ptr)->soap_out(soap, "ns1:retractResponse", id, NULL);
	case SOAP_TYPE__ns1__retractRequest:
		return ((_ns1__retractRequest *)ptr)->soap_out(soap, "ns1:retractRequest", id, NULL);
	case SOAP_TYPE__ns1__removeProxyAccessResponse:
		return ((_ns1__removeProxyAccessResponse *)ptr)->soap_out(soap, "ns1:removeProxyAccessResponse", id, NULL);
	case SOAP_TYPE__ns1__removeProxyAccessRequest:
		return ((_ns1__removeProxyAccessRequest *)ptr)->soap_out(soap, "ns1:removeProxyAccessRequest", id, NULL);
	case SOAP_TYPE__ns1__removeMembersResponse:
		return ((_ns1__removeMembersResponse *)ptr)->soap_out(soap, "ns1:removeMembersResponse", id, NULL);
	case SOAP_TYPE__ns1__removeMembersRequest:
		return ((_ns1__removeMembersRequest *)ptr)->soap_out(soap, "ns1:removeMembersRequest", id, NULL);
	case SOAP_TYPE__ns1__removeItemsResponse:
		return ((_ns1__removeItemsResponse *)ptr)->soap_out(soap, "ns1:removeItemsResponse", id, NULL);
	case SOAP_TYPE__ns1__removeItemsRequest:
		return ((_ns1__removeItemsRequest *)ptr)->soap_out(soap, "ns1:removeItemsRequest", id, NULL);
	case SOAP_TYPE__ns1__removeItemResponse:
		return ((_ns1__removeItemResponse *)ptr)->soap_out(soap, "ns1:removeItemResponse", id, NULL);
	case SOAP_TYPE__ns1__removeItemRequest:
		return ((_ns1__removeItemRequest *)ptr)->soap_out(soap, "ns1:removeItemRequest", id, NULL);
	case SOAP_TYPE__ns1__readCursorResponse:
		return ((_ns1__readCursorResponse *)ptr)->soap_out(soap, "ns1:readCursorResponse", id, NULL);
	case SOAP_TYPE__ns1__readCursorRequest:
		return ((_ns1__readCursorRequest *)ptr)->soap_out(soap, "ns1:readCursorRequest", id, NULL);
	case SOAP_TYPE__ns1__purgeItemResponse:
		return ((_ns1__purgeItemResponse *)ptr)->soap_out(soap, "ns1:purgeItemResponse", id, NULL);
	case SOAP_TYPE__ns1__purgeItemRequest:
		return ((_ns1__purgeItemRequest *)ptr)->soap_out(soap, "ns1:purgeItemRequest", id, NULL);
	case SOAP_TYPE__ns1__purgeDeletedItemsResponse:
		return ((_ns1__purgeDeletedItemsResponse *)ptr)->soap_out(soap, "ns1:purgeDeletedItemsResponse", id, NULL);
	case SOAP_TYPE__ns1__purgeDeletedItemsRequest:
		return ((_ns1__purgeDeletedItemsRequest *)ptr)->soap_out(soap, "ns1:purgeDeletedItemsRequest", id, NULL);
	case SOAP_TYPE__ns1__positionCursorResponse:
		return ((_ns1__positionCursorResponse *)ptr)->soap_out(soap, "ns1:positionCursorResponse", id, NULL);
	case SOAP_TYPE__ns1__positionCursorRequest:
		return ((_ns1__positionCursorRequest *)ptr)->soap_out(soap, "ns1:positionCursorRequest", id, NULL);
	case SOAP_TYPE__ns1__modifySettingsResponse:
		return ((_ns1__modifySettingsResponse *)ptr)->soap_out(soap, "ns1:modifySettingsResponse", id, NULL);
	case SOAP_TYPE__ns1__modifySettingsRequest:
		return ((_ns1__modifySettingsRequest *)ptr)->soap_out(soap, "ns1:modifySettingsRequest", id, NULL);
	case SOAP_TYPE__ns1__modifyProxyAccessResponse:
		return ((_ns1__modifyProxyAccessResponse *)ptr)->soap_out(soap, "ns1:modifyProxyAccessResponse", id, NULL);
	case SOAP_TYPE__ns1__modifyProxyAccessRequest:
		return ((_ns1__modifyProxyAccessRequest *)ptr)->soap_out(soap, "ns1:modifyProxyAccessRequest", id, NULL);
	case SOAP_TYPE__ns1__modifyItemResponse:
		return ((_ns1__modifyItemResponse *)ptr)->soap_out(soap, "ns1:modifyItemResponse", id, NULL);
	case SOAP_TYPE__ns1__modifyItemRequest:
		return ((_ns1__modifyItemRequest *)ptr)->soap_out(soap, "ns1:modifyItemRequest", id, NULL);
	case SOAP_TYPE__ns1__markUnReadResponse:
		return ((_ns1__markUnReadResponse *)ptr)->soap_out(soap, "ns1:markUnReadResponse", id, NULL);
	case SOAP_TYPE__ns1__markUnReadRequest:
		return ((_ns1__markUnReadRequest *)ptr)->soap_out(soap, "ns1:markUnReadRequest", id, NULL);
	case SOAP_TYPE__ns1__markReadResponse:
		return ((_ns1__markReadResponse *)ptr)->soap_out(soap, "ns1:markReadResponse", id, NULL);
	case SOAP_TYPE__ns1__markReadRequest:
		return ((_ns1__markReadRequest *)ptr)->soap_out(soap, "ns1:markReadRequest", id, NULL);
	case SOAP_TYPE__ns1__logoutResponse:
		return ((_ns1__logoutResponse *)ptr)->soap_out(soap, "ns1:logoutResponse", id, NULL);
	case SOAP_TYPE__ns1__loginResponse:
		return ((_ns1__loginResponse *)ptr)->soap_out(soap, "ns1:loginResponse", id, NULL);
	case SOAP_TYPE__ns1__loginRequest:
		return ((_ns1__loginRequest *)ptr)->soap_out(soap, "ns1:loginRequest", id, NULL);
	case SOAP_TYPE__ns1__getTimezoneListResponse:
		return ((_ns1__getTimezoneListResponse *)ptr)->soap_out(soap, "ns1:getTimezoneListResponse", id, NULL);
	case SOAP_TYPE__ns1__getSettingsResponse:
		return ((_ns1__getSettingsResponse *)ptr)->soap_out(soap, "ns1:getSettingsResponse", id, NULL);
	case SOAP_TYPE__ns1__getSettingsRequest:
		return ((_ns1__getSettingsRequest *)ptr)->soap_out(soap, "ns1:getSettingsRequest", id, NULL);
	case SOAP_TYPE__ns1__getProxyListResponse:
		return ((_ns1__getProxyListResponse *)ptr)->soap_out(soap, "ns1:getProxyListResponse", id, NULL);
	case SOAP_TYPE__ns1__getProxyAccessListResponse:
		return ((_ns1__getProxyAccessListResponse *)ptr)->soap_out(soap, "ns1:getProxyAccessListResponse", id, NULL);
	case SOAP_TYPE__ns1__getItemsResponse:
		return ((_ns1__getItemsResponse *)ptr)->soap_out(soap, "ns1:getItemsResponse", id, NULL);
	case SOAP_TYPE__ns1__getItemsRequest:
		return ((_ns1__getItemsRequest *)ptr)->soap_out(soap, "ns1:getItemsRequest", id, NULL);
	case SOAP_TYPE__ns1__getItemResponse:
		return ((_ns1__getItemResponse *)ptr)->soap_out(soap, "ns1:getItemResponse", id, NULL);
	case SOAP_TYPE__ns1__getItemRequest:
		return ((_ns1__getItemRequest *)ptr)->soap_out(soap, "ns1:getItemRequest", id, NULL);
	case SOAP_TYPE__ns1__getFreeBusyResponse:
		return ((_ns1__getFreeBusyResponse *)ptr)->soap_out(soap, "ns1:getFreeBusyResponse", id, NULL);
	case SOAP_TYPE__ns1__getFreeBusyRequest:
		return ((_ns1__getFreeBusyRequest *)ptr)->soap_out(soap, "ns1:getFreeBusyRequest", id, NULL);
	case SOAP_TYPE__ns1__getFolderListResponse:
		return ((_ns1__getFolderListResponse *)ptr)->soap_out(soap, "ns1:getFolderListResponse", id, NULL);
	case SOAP_TYPE__ns1__getFolderListRequest:
		return ((_ns1__getFolderListRequest *)ptr)->soap_out(soap, "ns1:getFolderListRequest", id, NULL);
	case SOAP_TYPE__ns1__getDeltaResponse:
		return ((_ns1__getDeltaResponse *)ptr)->soap_out(soap, "ns1:getDeltaResponse", id, NULL);
	case SOAP_TYPE__ns1__getDeltaRequest:
		return ((_ns1__getDeltaRequest *)ptr)->soap_out(soap, "ns1:getDeltaRequest", id, NULL);
	case SOAP_TYPE__ns1__getCustomListResponse:
		return ((_ns1__getCustomListResponse *)ptr)->soap_out(soap, "ns1:getCustomListResponse", id, NULL);
	case SOAP_TYPE__ns1__getCategoryListResponse:
		return ((_ns1__getCategoryListResponse *)ptr)->soap_out(soap, "ns1:getCategoryListResponse", id, NULL);
	case SOAP_TYPE__ns1__getAttachmentResponse:
		return ((_ns1__getAttachmentResponse *)ptr)->soap_out(soap, "ns1:getAttachmentResponse", id, NULL);
	case SOAP_TYPE__ns1__getAttachmentRequest:
		return ((_ns1__getAttachmentRequest *)ptr)->soap_out(soap, "ns1:getAttachmentRequest", id, NULL);
	case SOAP_TYPE__ns1__getAddressBookListResponse:
		return ((_ns1__getAddressBookListResponse *)ptr)->soap_out(soap, "ns1:getAddressBookListResponse", id, NULL);
	case SOAP_TYPE__ns1__destroyCursorResponse:
		return ((_ns1__destroyCursorResponse *)ptr)->soap_out(soap, "ns1:destroyCursorResponse", id, NULL);
	case SOAP_TYPE__ns1__destroyCursorRequest:
		return ((_ns1__destroyCursorRequest *)ptr)->soap_out(soap, "ns1:destroyCursorRequest", id, NULL);
	case SOAP_TYPE__ns1__delegateResponse:
		return ((_ns1__delegateResponse *)ptr)->soap_out(soap, "ns1:delegateResponse", id, NULL);
	case SOAP_TYPE__ns1__delegateRequest:
		return ((_ns1__delegateRequest *)ptr)->soap_out(soap, "ns1:delegateRequest", id, NULL);
	case SOAP_TYPE__ns1__declineResponse:
		return ((_ns1__declineResponse *)ptr)->soap_out(soap, "ns1:declineResponse", id, NULL);
	case SOAP_TYPE__ns1__declineRequest:
		return ((_ns1__declineRequest *)ptr)->soap_out(soap, "ns1:declineRequest", id, NULL);
	case SOAP_TYPE__ns1__createProxyAccessResponse:
		return ((_ns1__createProxyAccessResponse *)ptr)->soap_out(soap, "ns1:createProxyAccessResponse", id, NULL);
	case SOAP_TYPE__ns1__createProxyAccessRequest:
		return ((_ns1__createProxyAccessRequest *)ptr)->soap_out(soap, "ns1:createProxyAccessRequest", id, NULL);
	case SOAP_TYPE__ns1__createItemResponse:
		return ((_ns1__createItemResponse *)ptr)->soap_out(soap, "ns1:createItemResponse", id, NULL);
	case SOAP_TYPE__ns1__createItemRequest:
		return ((_ns1__createItemRequest *)ptr)->soap_out(soap, "ns1:createItemRequest", id, NULL);
	case SOAP_TYPE__ns1__createCursorResponse:
		return ((_ns1__createCursorResponse *)ptr)->soap_out(soap, "ns1:createCursorResponse", id, NULL);
	case SOAP_TYPE__ns1__createCursorRequest:
		return ((_ns1__createCursorRequest *)ptr)->soap_out(soap, "ns1:createCursorRequest", id, NULL);
	case SOAP_TYPE__ns1__completeResponse:
		return ((_ns1__completeResponse *)ptr)->soap_out(soap, "ns1:completeResponse", id, NULL);
	case SOAP_TYPE__ns1__completeRequest:
		return ((_ns1__completeRequest *)ptr)->soap_out(soap, "ns1:completeRequest", id, NULL);
	case SOAP_TYPE__ns1__closeFreeBusySessionResponse:
		return ((_ns1__closeFreeBusySessionResponse *)ptr)->soap_out(soap, "ns1:closeFreeBusySessionResponse", id, NULL);
	case SOAP_TYPE__ns1__closeFreeBusySessionRequest:
		return ((_ns1__closeFreeBusySessionRequest *)ptr)->soap_out(soap, "ns1:closeFreeBusySessionRequest", id, NULL);
	case SOAP_TYPE__ns1__addMembersResponse:
		return ((_ns1__addMembersResponse *)ptr)->soap_out(soap, "ns1:addMembersResponse", id, NULL);
	case SOAP_TYPE__ns1__addMembersRequest:
		return ((_ns1__addMembersRequest *)ptr)->soap_out(soap, "ns1:addMembersRequest", id, NULL);
	case SOAP_TYPE__ns1__addItemsResponse:
		return ((_ns1__addItemsResponse *)ptr)->soap_out(soap, "ns1:addItemsResponse", id, NULL);
	case SOAP_TYPE__ns1__addItemsRequest:
		return ((_ns1__addItemsRequest *)ptr)->soap_out(soap, "ns1:addItemsRequest", id, NULL);
	case SOAP_TYPE__ns1__addItemResponse:
		return ((_ns1__addItemResponse *)ptr)->soap_out(soap, "ns1:addItemResponse", id, NULL);
	case SOAP_TYPE__ns1__addItemRequest:
		return ((_ns1__addItemRequest *)ptr)->soap_out(soap, "ns1:addItemRequest", id, NULL);
	case SOAP_TYPE__ns1__acceptResponse:
		return ((_ns1__acceptResponse *)ptr)->soap_out(soap, "ns1:acceptResponse", id, NULL);
	case SOAP_TYPE__ns1__acceptRequest:
		return ((_ns1__acceptRequest *)ptr)->soap_out(soap, "ns1:acceptRequest", id, NULL);
	case SOAP_TYPE_ns1__UserInfo:
		return ((ns1__UserInfo *)ptr)->soap_out(soap, tag, id, "ns1:UserInfo");
	case SOAP_TYPE_ns1__TrustedApplication:
		return ((ns1__TrustedApplication *)ptr)->soap_out(soap, tag, id, "ns1:TrustedApplication");
	case SOAP_TYPE_ns1__TimezoneList:
		return ((ns1__TimezoneList *)ptr)->soap_out(soap, tag, id, "ns1:TimezoneList");
	case SOAP_TYPE_ns1__TimezoneComponent:
		return ((ns1__TimezoneComponent *)ptr)->soap_out(soap, tag, id, "ns1:TimezoneComponent");
	case SOAP_TYPE_ns1__Timezone:
		return ((ns1__Timezone *)ptr)->soap_out(soap, tag, id, "ns1:Timezone");
	case SOAP_TYPE_ns1__Task:
		return ((ns1__Task *)ptr)->soap_out(soap, tag, id, "ns1:Task");
	case SOAP_TYPE_ns1__SystemFolder:
		return ((ns1__SystemFolder *)ptr)->soap_out(soap, tag, id, "ns1:SystemFolder");
	case SOAP_TYPE_ns1__StatusTracking:
		return ((ns1__StatusTracking *)ptr)->soap_out(soap, tag, id, "ns1:StatusTracking");
	case SOAP_TYPE_ns1__Status:
		return ((ns1__Status *)ptr)->soap_out(soap, tag, id, "ns1:Status");
	case SOAP_TYPE_ns1__SharedFolderNotification:
		return ((ns1__SharedFolderNotification *)ptr)->soap_out(soap, tag, id, "ns1:SharedFolderNotification");
	case SOAP_TYPE_ns1__SharedFolder:
		return ((ns1__SharedFolder *)ptr)->soap_out(soap, tag, id, "ns1:SharedFolder");
	case SOAP_TYPE_ns1__SettingsList:
		return ((ns1__SettingsList *)ptr)->soap_out(soap, tag, id, "ns1:SettingsList");
	case SOAP_TYPE_ns1__SettingsGroup:
		return ((ns1__SettingsGroup *)ptr)->soap_out(soap, tag, id, "ns1:SettingsGroup");
	case SOAP_TYPE_ns1__Settings:
		return ((ns1__Settings *)ptr)->soap_out(soap, tag, id, "ns1:Settings");
	case SOAP_TYPE_ns1__SendOptions:
		return ((ns1__SendOptions *)ptr)->soap_out(soap, tag, id, "ns1:SendOptions");
	case SOAP_TYPE_ns1__SendOptionsRequestReply:
		return ((ns1__SendOptionsRequestReply *)ptr)->soap_out(soap, tag, id, "ns1:SendOptionsRequestReply");
	case SOAP_TYPE_ns1__Rights:
		return ((ns1__Rights *)ptr)->soap_out(soap, tag, id, "ns1:Rights");
	case SOAP_TYPE_ns1__ReturnNotificationOptions:
		return ((ns1__ReturnNotificationOptions *)ptr)->soap_out(soap, tag, id, "ns1:ReturnNotificationOptions");
	case SOAP_TYPE_ns1__ReturnNotification:
		return ((ns1__ReturnNotification *)ptr)->soap_out(soap, tag, id, "ns1:ReturnNotification");
	case SOAP_TYPE_ns1__Resource:
		return ((ns1__Resource *)ptr)->soap_out(soap, tag, id, "ns1:Resource");
	case SOAP_TYPE_ns1__RecurrenceDateType:
		return ((ns1__RecurrenceDateType *)ptr)->soap_out(soap, tag, id, "ns1:RecurrenceDateType");
	case SOAP_TYPE_ns1__RecipientStatus:
		return ((ns1__RecipientStatus *)ptr)->soap_out(soap, tag, id, "ns1:RecipientStatus");
	case SOAP_TYPE_ns1__RecipientList:
		return ((ns1__RecipientList *)ptr)->soap_out(soap, tag, id, "ns1:RecipientList");
	case SOAP_TYPE_ns1__Recipient:
		return ((ns1__Recipient *)ptr)->soap_out(soap, tag, id, "ns1:Recipient");
	case SOAP_TYPE_ns1__QueryTarget:
		return ((ns1__QueryTarget *)ptr)->soap_out(soap, tag, id, "ns1:QueryTarget");
	case SOAP_TYPE_ns1__QueryFolder:
		return ((ns1__QueryFolder *)ptr)->soap_out(soap, tag, id, "ns1:QueryFolder");
	case SOAP_TYPE_ns1__Query:
		return ((ns1__Query *)ptr)->soap_out(soap, tag, id, "ns1:Query");
	case SOAP_TYPE_ns1__ProxyList:
		return ((ns1__ProxyList *)ptr)->soap_out(soap, tag, id, "ns1:ProxyList");
	case SOAP_TYPE_ns1__Proxy:
		return ((ns1__Proxy *)ptr)->soap_out(soap, tag, id, "ns1:Proxy");
	case SOAP_TYPE_ns1__ProblemList:
		return ((ns1__ProblemList *)ptr)->soap_out(soap, tag, id, "ns1:ProblemList");
	case SOAP_TYPE_ns1__ProblemEntry:
		return ((ns1__ProblemEntry *)ptr)->soap_out(soap, tag, id, "ns1:ProblemEntry");
	case SOAP_TYPE_ns1__PostalAddressList:
		return ((ns1__PostalAddressList *)ptr)->soap_out(soap, tag, id, "ns1:PostalAddressList");
	case SOAP_TYPE_ns1__PostalAddress:
		return ((ns1__PostalAddress *)ptr)->soap_out(soap, tag, id, "ns1:PostalAddress");
	case SOAP_TYPE_ns1__PlainText:
		return ((ns1__PlainText *)ptr)->soap_out(soap, tag, id, "ns1:PlainText");
	case SOAP_TYPE_ns1__PhoneMessage:
		return ((ns1__PhoneMessage *)ptr)->soap_out(soap, tag, id, "ns1:PhoneMessage");
	case SOAP_TYPE_ns1__PhoneFlags:
		return ((ns1__PhoneFlags *)ptr)->soap_out(soap, tag, id, "ns1:PhoneFlags");
	case SOAP_TYPE_ns1__PersonalInfo:
		return ((ns1__PersonalInfo *)ptr)->soap_out(soap, tag, id, "ns1:PersonalInfo");
	case SOAP_TYPE_ns1__Organization:
		return ((ns1__Organization *)ptr)->soap_out(soap, tag, id, "ns1:Organization");
	case SOAP_TYPE_ns1__OfficeInfo:
		return ((ns1__OfficeInfo *)ptr)->soap_out(soap, tag, id, "ns1:OfficeInfo");
	case SOAP_TYPE_ns1__Note:
		return ((ns1__Note *)ptr)->soap_out(soap, tag, id, "ns1:Note");
	case SOAP_TYPE_ns1__NameAndEmail:
		return ((ns1__NameAndEmail *)ptr)->soap_out(soap, tag, id, "ns1:NameAndEmail");
	case SOAP_TYPE_ns1__MessagePart:
		return ((ns1__MessagePart *)ptr)->soap_out(soap, tag, id, "ns1:MessagePart");
	case SOAP_TYPE_ns1__MessageBody:
		return ((ns1__MessageBody *)ptr)->soap_out(soap, tag, id, "ns1:MessageBody");
	case SOAP_TYPE_ns1__Mail:
		return ((ns1__Mail *)ptr)->soap_out(soap, tag, id, "ns1:Mail");
	case SOAP_TYPE_ns1__ItemStatus:
		return ((ns1__ItemStatus *)ptr)->soap_out(soap, tag, id, "ns1:ItemStatus");
	case SOAP_TYPE_ns1__Items:
		return ((ns1__Items *)ptr)->soap_out(soap, tag, id, "ns1:Items");
	case SOAP_TYPE_ns1__ItemRefList:
		return ((ns1__ItemRefList *)ptr)->soap_out(soap, tag, id, "ns1:ItemRefList");
	case SOAP_TYPE_ns1__ItemRef:
		return ((ns1__ItemRef *)ptr)->soap_out(soap, tag, id, "ns1:ItemRef");
	case SOAP_TYPE_ns1__ItemOptions:
		return ((ns1__ItemOptions *)ptr)->soap_out(soap, tag, id, "ns1:ItemOptions");
	case SOAP_TYPE_ns1__ItemList:
		return ((ns1__ItemList *)ptr)->soap_out(soap, tag, id, "ns1:ItemList");
	case SOAP_TYPE_ns1__ItemChanges:
		return ((ns1__ItemChanges *)ptr)->soap_out(soap, tag, id, "ns1:ItemChanges");
	case SOAP_TYPE_ns1__Item:
		return ((ns1__Item *)ptr)->soap_out(soap, tag, id, "ns1:Item");
	case SOAP_TYPE_ns1__ImAddressList:
		return ((ns1__ImAddressList *)ptr)->soap_out(soap, tag, id, "ns1:ImAddressList");
	case SOAP_TYPE_ns1__ImAddress:
		return ((ns1__ImAddress *)ptr)->soap_out(soap, tag, id, "ns1:ImAddress");
	case SOAP_TYPE_ns1__GroupMemberList:
		return ((ns1__GroupMemberList *)ptr)->soap_out(soap, tag, id, "ns1:GroupMemberList");
	case SOAP_TYPE_ns1__GroupMember:
		return ((ns1__GroupMember *)ptr)->soap_out(soap, tag, id, "ns1:GroupMember");
	case SOAP_TYPE_ns1__Group:
		return ((ns1__Group *)ptr)->soap_out(soap, tag, id, "ns1:Group");
	case SOAP_TYPE_ns1__FullName:
		return ((ns1__FullName *)ptr)->soap_out(soap, tag, id, "ns1:FullName");
	case SOAP_TYPE_ns1__From:
		return ((ns1__From *)ptr)->soap_out(soap, tag, id, "ns1:From");
	case SOAP_TYPE_ns1__FreeBusyUser:
		return ((ns1__FreeBusyUser *)ptr)->soap_out(soap, tag, id, "ns1:FreeBusyUser");
	case SOAP_TYPE_ns1__FreeBusyStats:
		return ((ns1__FreeBusyStats *)ptr)->soap_out(soap, tag, id, "ns1:FreeBusyStats");
	case SOAP_TYPE_ns1__FreeBusyInfoList:
		return ((ns1__FreeBusyInfoList *)ptr)->soap_out(soap, tag, id, "ns1:FreeBusyInfoList");
	case SOAP_TYPE_ns1__FreeBusyUserList:
		return ((ns1__FreeBusyUserList *)ptr)->soap_out(soap, tag, id, "ns1:FreeBusyUserList");
	case SOAP_TYPE_ns1__FreeBusyInfo:
		return ((ns1__FreeBusyInfo *)ptr)->soap_out(soap, tag, id, "ns1:FreeBusyInfo");
	case SOAP_TYPE_ns1__FreeBusyBlock:
		return ((ns1__FreeBusyBlock *)ptr)->soap_out(soap, tag, id, "ns1:FreeBusyBlock");
	case SOAP_TYPE_ns1__FreeBusyBlockList:
		return ((ns1__FreeBusyBlockList *)ptr)->soap_out(soap, tag, id, "ns1:FreeBusyBlockList");
	case SOAP_TYPE_ns1__FolderList:
		return ((ns1__FolderList *)ptr)->soap_out(soap, tag, id, "ns1:FolderList");
	case SOAP_TYPE_ns1__FolderACLEntry:
		return ((ns1__FolderACLEntry *)ptr)->soap_out(soap, tag, id, "ns1:FolderACLEntry");
	case SOAP_TYPE_ns1__FolderACL:
		return ((ns1__FolderACL *)ptr)->soap_out(soap, tag, id, "ns1:FolderACL");
	case SOAP_TYPE_ns1__Folder:
		return ((ns1__Folder *)ptr)->soap_out(soap, tag, id, "ns1:Folder");
	case SOAP_TYPE_ns1__FilterGroup:
		return ((ns1__FilterGroup *)ptr)->soap_out(soap, tag, id, "ns1:FilterGroup");
	case SOAP_TYPE_ns1__FilterEntry:
		return ((ns1__FilterEntry *)ptr)->soap_out(soap, tag, id, "ns1:FilterEntry");
	case SOAP_TYPE_ns1__FilterElement:
		return ((ns1__FilterElement *)ptr)->soap_out(soap, tag, id, "ns1:FilterElement");
	case SOAP_TYPE_ns1__Filter:
		return ((ns1__Filter *)ptr)->soap_out(soap, tag, id, "ns1:Filter");
	case SOAP_TYPE_ns1__EmailAddressList:
		return ((ns1__EmailAddressList *)ptr)->soap_out(soap, tag, id, "ns1:EmailAddressList");
	case SOAP_TYPE_ns1__DocumentRef:
		return ((ns1__DocumentRef *)ptr)->soap_out(soap, tag, id, "ns1:DocumentRef");
	case SOAP_TYPE_ns1__Distribution:
		return ((ns1__Distribution *)ptr)->soap_out(soap, tag, id, "ns1:Distribution");
	case SOAP_TYPE_ns1__DeltaList:
		return ((ns1__DeltaList *)ptr)->soap_out(soap, tag, id, "ns1:DeltaList");
	case SOAP_TYPE_ns1__DelegateeStatus:
		return ((ns1__DelegateeStatus *)ptr)->soap_out(soap, tag, id, "ns1:DelegateeStatus");
	case SOAP_TYPE_ns1__DelegatedStatus:
		return ((ns1__DelegatedStatus *)ptr)->soap_out(soap, tag, id, "ns1:DelegatedStatus");
	case SOAP_TYPE_ns1__DayOfWeek:
		return ((ns1__DayOfWeek *)ptr)->soap_out(soap, tag, id, "ns1:DayOfWeek");
	case SOAP_TYPE_ns1__CustomList:
		return ((ns1__CustomList *)ptr)->soap_out(soap, tag, id, "ns1:CustomList");
	case SOAP_TYPE_ns1__Custom:
		return ((ns1__Custom *)ptr)->soap_out(soap, tag, id, "ns1:Custom");
	case SOAP_TYPE_ns1__ContactFolder:
		return ((ns1__ContactFolder *)ptr)->soap_out(soap, tag, id, "ns1:ContactFolder");
	case SOAP_TYPE_ns1__ContainerRef:
		return ((ns1__ContainerRef *)ptr)->soap_out(soap, tag, id, "ns1:ContainerRef");
	case SOAP_TYPE_ns1__ContainerItem:
		return ((ns1__ContainerItem *)ptr)->soap_out(soap, tag, id, "ns1:ContainerItem");
	case SOAP_TYPE_ns1__Contact:
		return ((ns1__Contact *)ptr)->soap_out(soap, tag, id, "ns1:Contact");
	case SOAP_TYPE_ns1__CommentStatus:
		return ((ns1__CommentStatus *)ptr)->soap_out(soap, tag, id, "ns1:CommentStatus");
	case SOAP_TYPE_ns1__CategoryRefList:
		return ((ns1__CategoryRefList *)ptr)->soap_out(soap, tag, id, "ns1:CategoryRefList");
	case SOAP_TYPE_ns1__CategoryList:
		return ((ns1__CategoryList *)ptr)->soap_out(soap, tag, id, "ns1:CategoryList");
	case SOAP_TYPE_ns1__Category:
		return ((ns1__Category *)ptr)->soap_out(soap, tag, id, "ns1:Category");
	case SOAP_TYPE_ns1__CalendarItem:
		return ((ns1__CalendarItem *)ptr)->soap_out(soap, tag, id, "ns1:CalendarItem");
	case SOAP_TYPE_ns1__BoxEntry:
		return ((ns1__BoxEntry *)ptr)->soap_out(soap, tag, id, "ns1:BoxEntry");
	case SOAP_TYPE_ns1__Authentication:
		return ((ns1__Authentication *)ptr)->soap_out(soap, tag, id, "ns1:Authentication");
	case SOAP_TYPE_ns1__AttachmentItemInfo:
		return ((ns1__AttachmentItemInfo *)ptr)->soap_out(soap, tag, id, "ns1:AttachmentItemInfo");
	case SOAP_TYPE_ns1__AttachmentInfo:
		return ((ns1__AttachmentInfo *)ptr)->soap_out(soap, tag, id, "ns1:AttachmentInfo");
	case SOAP_TYPE_ns1__AttachmentID:
		return ((ns1__AttachmentID *)ptr)->soap_out(soap, tag, id, "ns1:AttachmentID");
	case SOAP_TYPE_ns1__Appointment:
		return ((ns1__Appointment *)ptr)->soap_out(soap, tag, id, "ns1:Appointment");
	case SOAP_TYPE_ns1__Alarm:
		return ((ns1__Alarm *)ptr)->soap_out(soap, tag, id, "ns1:Alarm");
	case SOAP_TYPE_ns1__AddressBookList:
		return ((ns1__AddressBookList *)ptr)->soap_out(soap, tag, id, "ns1:AddressBookList");
	case SOAP_TYPE_ns1__AddressBookItem:
		return ((ns1__AddressBookItem *)ptr)->soap_out(soap, tag, id, "ns1:AddressBookItem");
	case SOAP_TYPE_ns1__AddressBook:
		return ((ns1__AddressBook *)ptr)->soap_out(soap, tag, id, "ns1:AddressBook");
	case SOAP_TYPE_ns1__AccessRightList:
		return ((ns1__AccessRightList *)ptr)->soap_out(soap, tag, id, "ns1:AccessRightList");
	case SOAP_TYPE_ns1__AccessRightEntry:
		return ((ns1__AccessRightEntry *)ptr)->soap_out(soap, tag, id, "ns1:AccessRightEntry");
	case SOAP_TYPE_ns1__AccessRightChanges:
		return ((ns1__AccessRightChanges *)ptr)->soap_out(soap, tag, id, "ns1:AccessRightChanges");
	case SOAP_TYPE_ns1__AccessRight:
		return ((ns1__AccessRight *)ptr)->soap_out(soap, tag, id, "ns1:AccessRight");
	case SOAP_TYPE_ns1__AccessMiscRight:
		return ((ns1__AccessMiscRight *)ptr)->soap_out(soap, tag, id, "ns1:AccessMiscRight");
	case SOAP_TYPE_ns1__AccessControlList:
		return ((ns1__AccessControlList *)ptr)->soap_out(soap, tag, id, "ns1:AccessControlList");
	case SOAP_TYPE_ns1__AccessControlListEntry:
		return ((ns1__AccessControlListEntry *)ptr)->soap_out(soap, tag, id, "ns1:AccessControlListEntry");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__createItemResponse:
		return soap_out_PointerTo_ns1__createItemResponse(soap, tag, id, (_ns1__createItemResponse *const*)ptr, "ns1:createItemResponse");
	case SOAP_TYPE_PointerTo_ns1__createItemRequest:
		return soap_out_PointerTo_ns1__createItemRequest(soap, tag, id, (_ns1__createItemRequest *const*)ptr, "ns1:createItemRequest");
	case SOAP_TYPE_PointerTo_ns1__getDeltaResponse:
		return soap_out_PointerTo_ns1__getDeltaResponse(soap, tag, id, (_ns1__getDeltaResponse *const*)ptr, "ns1:getDeltaResponse");
	case SOAP_TYPE_PointerTo_ns1__getDeltaRequest:
		return soap_out_PointerTo_ns1__getDeltaRequest(soap, tag, id, (_ns1__getDeltaRequest *const*)ptr, "ns1:getDeltaRequest");
	case SOAP_TYPE_PointerTo_ns1__getFolderListResponse:
		return soap_out_PointerTo_ns1__getFolderListResponse(soap, tag, id, (_ns1__getFolderListResponse *const*)ptr, "ns1:getFolderListResponse");
	case SOAP_TYPE_PointerTo_ns1__getFolderListRequest:
		return soap_out_PointerTo_ns1__getFolderListRequest(soap, tag, id, (_ns1__getFolderListRequest *const*)ptr, "ns1:getFolderListRequest");
	case SOAP_TYPE_PointerTo_ns1__getItemsResponse:
		return soap_out_PointerTo_ns1__getItemsResponse(soap, tag, id, (_ns1__getItemsResponse *const*)ptr, "ns1:getItemsResponse");
	case SOAP_TYPE_PointerTo_ns1__getItemsRequest:
		return soap_out_PointerTo_ns1__getItemsRequest(soap, tag, id, (_ns1__getItemsRequest *const*)ptr, "ns1:getItemsRequest");
	case SOAP_TYPE_PointerTo_ns1__getItemResponse:
		return soap_out_PointerTo_ns1__getItemResponse(soap, tag, id, (_ns1__getItemResponse *const*)ptr, "ns1:getItemResponse");
	case SOAP_TYPE_PointerTo_ns1__getItemRequest:
		return soap_out_PointerTo_ns1__getItemRequest(soap, tag, id, (_ns1__getItemRequest *const*)ptr, "ns1:getItemRequest");
	case SOAP_TYPE_PointerTo_ns1__getAddressBookListResponse:
		return soap_out_PointerTo_ns1__getAddressBookListResponse(soap, tag, id, (_ns1__getAddressBookListResponse *const*)ptr, "ns1:getAddressBookListResponse");
	case SOAP_TYPE_PointerTo_ns1__getCategoryListResponse:
		return soap_out_PointerTo_ns1__getCategoryListResponse(soap, tag, id, (_ns1__getCategoryListResponse *const*)ptr, "ns1:getCategoryListResponse");
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		return soap_out_PointerTo_ns1__loginResponse(soap, tag, id, (_ns1__loginResponse *const*)ptr, "ns1:loginResponse");
	case SOAP_TYPE_PointerTo_ns1__loginRequest:
		return soap_out_PointerTo_ns1__loginRequest(soap, tag, id, (_ns1__loginRequest *const*)ptr, "ns1:loginRequest");
	case SOAP_TYPE_PointerTo_ns1__sendItemResponse:
		return soap_out_PointerTo_ns1__sendItemResponse(soap, tag, id, (_ns1__sendItemResponse *const*)ptr, "ns1:sendItemResponse");
	case SOAP_TYPE_PointerTo_ns1__sendItemRequest:
		return soap_out_PointerTo_ns1__sendItemRequest(soap, tag, id, (_ns1__sendItemRequest *const*)ptr, "ns1:sendItemRequest");
	case SOAP_TYPE_PointerTo_ns1__getFreeBusyResponse:
		return soap_out_PointerTo_ns1__getFreeBusyResponse(soap, tag, id, (_ns1__getFreeBusyResponse *const*)ptr, "ns1:getFreeBusyResponse");
	case SOAP_TYPE_PointerTo_ns1__getFreeBusyRequest:
		return soap_out_PointerTo_ns1__getFreeBusyRequest(soap, tag, id, (_ns1__getFreeBusyRequest *const*)ptr, "ns1:getFreeBusyRequest");
	case SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionResponse:
		return soap_out_PointerTo_ns1__closeFreeBusySessionResponse(soap, tag, id, (_ns1__closeFreeBusySessionResponse *const*)ptr, "ns1:closeFreeBusySessionResponse");
	case SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionRequest:
		return soap_out_PointerTo_ns1__closeFreeBusySessionRequest(soap, tag, id, (_ns1__closeFreeBusySessionRequest *const*)ptr, "ns1:closeFreeBusySessionRequest");
	case SOAP_TYPE_PointerTo_ns1__startFreeBusySessionResponse:
		return soap_out_PointerTo_ns1__startFreeBusySessionResponse(soap, tag, id, (_ns1__startFreeBusySessionResponse *const*)ptr, "ns1:startFreeBusySessionResponse");
	case SOAP_TYPE_PointerTo_ns1__startFreeBusySessionRequest:
		return soap_out_PointerTo_ns1__startFreeBusySessionRequest(soap, tag, id, (_ns1__startFreeBusySessionRequest *const*)ptr, "ns1:startFreeBusySessionRequest");
	case SOAP_TYPE_PointerTo_ns1__removeItemResponse:
		return soap_out_PointerTo_ns1__removeItemResponse(soap, tag, id, (_ns1__removeItemResponse *const*)ptr, "ns1:removeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__removeItemRequest:
		return soap_out_PointerTo_ns1__removeItemRequest(soap, tag, id, (_ns1__removeItemRequest *const*)ptr, "ns1:removeItemRequest");
	case SOAP_TYPE_PointerTo_ns1__purgeItemResponse:
		return soap_out_PointerTo_ns1__purgeItemResponse(soap, tag, id, (_ns1__purgeItemResponse *const*)ptr, "ns1:purgeItemResponse");
	case SOAP_TYPE_PointerTo_ns1__purgeItemRequest:
		return soap_out_PointerTo_ns1__purgeItemRequest(soap, tag, id, (_ns1__purgeItemRequest *const*)ptr, "ns1:purgeItemRequest");
	case SOAP_TYPE_PointerTo_ns1__modifyItemResponse:
		return soap_out_PointerTo_ns1__modifyItemResponse(soap, tag, id, (_ns1__modifyItemResponse *const*)ptr, "ns1:modifyItemResponse");
	case SOAP_TYPE_PointerTo_ns1__modifyItemRequest:
		return soap_out_PointerTo_ns1__modifyItemRequest(soap, tag, id, (_ns1__modifyItemRequest *const*)ptr, "ns1:modifyItemRequest");
	case SOAP_TYPE_PointerTons1__Alarm:
		return soap_out_PointerTons1__Alarm(soap, tag, id, (ns1__Alarm *const*)ptr, "ns1:Alarm");
	case SOAP_TYPE_PointerTons1__PhoneFlags:
		return soap_out_PointerTons1__PhoneFlags(soap, tag, id, (ns1__PhoneFlags *const*)ptr, "ns1:PhoneFlags");
	case SOAP_TYPE_PointerTons1__AccessControlList:
		return soap_out_PointerTons1__AccessControlList(soap, tag, id, (ns1__AccessControlList *const*)ptr, "ns1:AccessControlList");
	case SOAP_TYPE_PointerTons1__RecurrenceDateType:
		return soap_out_PointerTons1__RecurrenceDateType(soap, tag, id, (ns1__RecurrenceDateType *const*)ptr, "ns1:RecurrenceDateType");
	case SOAP_TYPE_PointerTons1__ItemOptions:
		return soap_out_PointerTons1__ItemOptions(soap, tag, id, (ns1__ItemOptions *const*)ptr, "ns1:ItemOptions");
	case SOAP_TYPE_PointerTons1__AttachmentInfo:
		return soap_out_PointerTons1__AttachmentInfo(soap, tag, id, (ns1__AttachmentInfo *const*)ptr, "ns1:AttachmentInfo");
	case SOAP_TYPE_PointerTons1__MessageBody:
		return soap_out_PointerTons1__MessageBody(soap, tag, id, (ns1__MessageBody *const*)ptr, "ns1:MessageBody");
	case SOAP_TYPE_PointerTons1__PersonalInfo:
		return soap_out_PointerTons1__PersonalInfo(soap, tag, id, (ns1__PersonalInfo *const*)ptr, "ns1:PersonalInfo");
	case SOAP_TYPE_PointerTons1__OfficeInfo:
		return soap_out_PointerTons1__OfficeInfo(soap, tag, id, (ns1__OfficeInfo *const*)ptr, "ns1:OfficeInfo");
	case SOAP_TYPE_PointerTons1__PostalAddressList:
		return soap_out_PointerTons1__PostalAddressList(soap, tag, id, (ns1__PostalAddressList *const*)ptr, "ns1:PostalAddressList");
	case SOAP_TYPE_PointerTons1__ImAddressList:
		return soap_out_PointerTons1__ImAddressList(soap, tag, id, (ns1__ImAddressList *const*)ptr, "ns1:ImAddressList");
	case SOAP_TYPE_PointerTons1__EmailAddressList:
		return soap_out_PointerTons1__EmailAddressList(soap, tag, id, (ns1__EmailAddressList *const*)ptr, "ns1:EmailAddressList");
	case SOAP_TYPE_PointerTons1__FullName:
		return soap_out_PointerTons1__FullName(soap, tag, id, (ns1__FullName *const*)ptr, "ns1:FullName");
	case SOAP_TYPE_PointerTons1__UUID:
		return soap_out_PointerTons1__UUID(soap, tag, id, (std::string *const*)ptr, "ns1:UUID");
	case SOAP_TYPE_PointerTons1__FolderACL:
		return soap_out_PointerTons1__FolderACL(soap, tag, id, (ns1__FolderACL *const*)ptr, "ns1:FolderACL");
	case SOAP_TYPE_PointerTons1__Query:
		return soap_out_PointerTons1__Query(soap, tag, id, (ns1__Query *const*)ptr, "ns1:Query");
	case SOAP_TYPE_PointerTons1__FreeBusyBlockList:
		return soap_out_PointerTons1__FreeBusyBlockList(soap, tag, id, (ns1__FreeBusyBlockList *const*)ptr, "ns1:FreeBusyBlockList");
	case SOAP_TYPE_PointerTons1__ItemClass:
		return soap_out_PointerTons1__ItemClass(soap, tag, id, (enum ns1__ItemClass *const*)ptr, "ns1:ItemClass");
	case SOAP_TYPE_PointerTons1__ItemSource:
		return soap_out_PointerTons1__ItemSource(soap, tag, id, (enum ns1__ItemSource *const*)ptr, "ns1:ItemSource");
	case SOAP_TYPE_PointerTons1__ItemStatus:
		return soap_out_PointerTons1__ItemStatus(soap, tag, id, (ns1__ItemStatus *const*)ptr, "ns1:ItemStatus");
	case SOAP_TYPE_PointerTons1__RecipientStatus:
		return soap_out_PointerTons1__RecipientStatus(soap, tag, id, (ns1__RecipientStatus *const*)ptr, "ns1:RecipientStatus");
	case SOAP_TYPE_PointerTons1__SharedFolderNotification:
		return soap_out_PointerTons1__SharedFolderNotification(soap, tag, id, (ns1__SharedFolderNotification *const*)ptr, "ns1:SharedFolderNotification");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons1__CategoryRefList:
		return soap_out_PointerTons1__CategoryRefList(soap, tag, id, (ns1__CategoryRefList *const*)ptr, "ns1:CategoryRefList");
	case SOAP_TYPE_PointerTons1__ContainerRef:
		return soap_out_PointerTons1__ContainerRef(soap, tag, id, (ns1__ContainerRef *const*)ptr, "ns1:ContainerRef");
	case SOAP_TYPE_PointerTounsignedLong:
		return soap_out_PointerTounsignedLong(soap, tag, id, (unsigned long *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTons1__CategoryType:
		return soap_out_PointerTons1__CategoryType(soap, tag, id, (enum ns1__CategoryType *const*)ptr, "ns1:CategoryType");
	case SOAP_TYPE_PointerTons1__AccessMiscRight:
		return soap_out_PointerTons1__AccessMiscRight(soap, tag, id, (ns1__AccessMiscRight *const*)ptr, "ns1:AccessMiscRight");
	case SOAP_TYPE_PointerTons1__AccessRight:
		return soap_out_PointerTons1__AccessRight(soap, tag, id, (ns1__AccessRight *const*)ptr, "ns1:AccessRight");
	case SOAP_TYPE_PointerTons1__Rights:
		return soap_out_PointerTons1__Rights(soap, tag, id, (ns1__Rights *const*)ptr, "ns1:Rights");
	case SOAP_TYPE_PointerTons1__FreeBusyUserList:
		return soap_out_PointerTons1__FreeBusyUserList(soap, tag, id, (ns1__FreeBusyUserList *const*)ptr, "ns1:FreeBusyUserList");
	case SOAP_TYPE_PointerTons1__ItemList:
		return soap_out_PointerTons1__ItemList(soap, tag, id, (ns1__ItemList *const*)ptr, "ns1:ItemList");
	case SOAP_TYPE_PointerTons1__SettingsList:
		return soap_out_PointerTons1__SettingsList(soap, tag, id, (ns1__SettingsList *const*)ptr, "ns1:SettingsList");
	case SOAP_TYPE_PointerTons1__AccessRightChanges:
		return soap_out_PointerTons1__AccessRightChanges(soap, tag, id, (ns1__AccessRightChanges *const*)ptr, "ns1:AccessRightChanges");
	case SOAP_TYPE_PointerTons1__UserInfo:
		return soap_out_PointerTons1__UserInfo(soap, tag, id, (ns1__UserInfo *const*)ptr, "ns1:UserInfo");
	case SOAP_TYPE_PointerTons1__Authentication:
		return soap_out_PointerTons1__Authentication(soap, tag, id, (ns1__Authentication *const*)ptr, "ns1:Authentication");
	case SOAP_TYPE_PointerTons1__TimezoneList:
		return soap_out_PointerTons1__TimezoneList(soap, tag, id, (ns1__TimezoneList *const*)ptr, "ns1:TimezoneList");
	case SOAP_TYPE_PointerTons1__Settings:
		return soap_out_PointerTons1__Settings(soap, tag, id, (ns1__Settings *const*)ptr, "ns1:Settings");
	case SOAP_TYPE_PointerTons1__ProxyList:
		return soap_out_PointerTons1__ProxyList(soap, tag, id, (ns1__ProxyList *const*)ptr, "ns1:ProxyList");
	case SOAP_TYPE_PointerTons1__AccessRightList:
		return soap_out_PointerTons1__AccessRightList(soap, tag, id, (ns1__AccessRightList *const*)ptr, "ns1:AccessRightList");
	case SOAP_TYPE_PointerTons1__View:
		return soap_out_PointerTons1__View(soap, tag, id, (std::string *const*)ptr, "ns1:View");
	case SOAP_TYPE_PointerTons1__FreeBusyInfoList:
		return soap_out_PointerTons1__FreeBusyInfoList(soap, tag, id, (ns1__FreeBusyInfoList *const*)ptr, "ns1:FreeBusyInfoList");
	case SOAP_TYPE_PointerTons1__FreeBusyStats:
		return soap_out_PointerTons1__FreeBusyStats(soap, tag, id, (ns1__FreeBusyStats *const*)ptr, "ns1:FreeBusyStats");
	case SOAP_TYPE_PointerTons1__FolderList:
		return soap_out_PointerTons1__FolderList(soap, tag, id, (ns1__FolderList *const*)ptr, "ns1:FolderList");
	case SOAP_TYPE_PointerTons1__DeltaList:
		return soap_out_PointerTons1__DeltaList(soap, tag, id, (ns1__DeltaList *const*)ptr, "ns1:DeltaList");
	case SOAP_TYPE_PointerTons1__CustomList:
		return soap_out_PointerTons1__CustomList(soap, tag, id, (ns1__CustomList *const*)ptr, "ns1:CustomList");
	case SOAP_TYPE_PointerTons1__CategoryList:
		return soap_out_PointerTons1__CategoryList(soap, tag, id, (ns1__CategoryList *const*)ptr, "ns1:CategoryList");
	case SOAP_TYPE_PointerTons1__AddressBookList:
		return soap_out_PointerTons1__AddressBookList(soap, tag, id, (ns1__AddressBookList *const*)ptr, "ns1:AddressBookList");
	case SOAP_TYPE_PointerTons1__Distribution:
		return soap_out_PointerTons1__Distribution(soap, tag, id, (ns1__Distribution *const*)ptr, "ns1:Distribution");
	case SOAP_TYPE_PointerTons1__GroupMemberList:
		return soap_out_PointerTons1__GroupMemberList(soap, tag, id, (ns1__GroupMemberList *const*)ptr, "ns1:GroupMemberList");
	case SOAP_TYPE_PointerTons1__Status:
		return soap_out_PointerTons1__Status(soap, tag, id, (ns1__Status *const*)ptr, "ns1:Status");
	case SOAP_TYPE_PointerTons1__ItemRefList:
		return soap_out_PointerTons1__ItemRefList(soap, tag, id, (ns1__ItemRefList *const*)ptr, "ns1:ItemRefList");
	case SOAP_TYPE_PointerTons1__Timezone:
		return soap_out_PointerTons1__Timezone(soap, tag, id, (ns1__Timezone *const*)ptr, "ns1:Timezone");
	case SOAP_TYPE_PointerTons1__DayOfWeek:
		return soap_out_PointerTons1__DayOfWeek(soap, tag, id, (ns1__DayOfWeek *const*)ptr, "ns1:DayOfWeek");
	case SOAP_TYPE_PointerTons1__Day:
		return soap_out_PointerTons1__Day(soap, tag, id, (unsigned char *const*)ptr, "ns1:Day");
	case SOAP_TYPE_PointerTons1__Minute:
		return soap_out_PointerTons1__Minute(soap, tag, id, (unsigned char *const*)ptr, "ns1:Minute");
	case SOAP_TYPE_PointerTons1__Hour:
		return soap_out_PointerTons1__Hour(soap, tag, id, (unsigned char *const*)ptr, "ns1:Hour");
	case SOAP_TYPE_PointerTons1__Month:
		return soap_out_PointerTons1__Month(soap, tag, id, (unsigned char *const*)ptr, "ns1:Month");
	case SOAP_TYPE_PointerTons1__TimezoneComponent:
		return soap_out_PointerTons1__TimezoneComponent(soap, tag, id, (ns1__TimezoneComponent *const*)ptr, "ns1:TimezoneComponent");
	case SOAP_TYPE_PointerTons1__ProblemList:
		return soap_out_PointerTons1__ProblemList(soap, tag, id, (ns1__ProblemList *const*)ptr, "ns1:ProblemList");
	case SOAP_TYPE_PointerTons1__SettingsGroup:
		return soap_out_PointerTons1__SettingsGroup(soap, tag, id, (ns1__SettingsGroup *const*)ptr, "ns1:SettingsGroup");
	case SOAP_TYPE_PointerTons1__ReturnNotification:
		return soap_out_PointerTons1__ReturnNotification(soap, tag, id, (ns1__ReturnNotification *const*)ptr, "ns1:ReturnNotification");
	case SOAP_TYPE_PointerTons1__StatusTracking:
		return soap_out_PointerTons1__StatusTracking(soap, tag, id, (ns1__StatusTracking *const*)ptr, "ns1:StatusTracking");
	case SOAP_TYPE_PointerTons1__SendOptionsRequestReply:
		return soap_out_PointerTons1__SendOptionsRequestReply(soap, tag, id, (ns1__SendOptionsRequestReply *const*)ptr, "ns1:SendOptionsRequestReply");
	case SOAP_TYPE_PointerTons1__ReturnNotificationOptions:
		return soap_out_PointerTons1__ReturnNotificationOptions(soap, tag, id, (ns1__ReturnNotificationOptions *const*)ptr, "ns1:ReturnNotificationOptions");
	case SOAP_TYPE_PointerTons1__DelegateeStatus:
		return soap_out_PointerTons1__DelegateeStatus(soap, tag, id, (ns1__DelegateeStatus *const*)ptr, "ns1:DelegateeStatus");
	case SOAP_TYPE_PointerTons1__DelegatedStatus:
		return soap_out_PointerTons1__DelegatedStatus(soap, tag, id, (ns1__DelegatedStatus *const*)ptr, "ns1:DelegatedStatus");
	case SOAP_TYPE_PointerTons1__CommentStatus:
		return soap_out_PointerTons1__CommentStatus(soap, tag, id, (ns1__CommentStatus *const*)ptr, "ns1:CommentStatus");
	case SOAP_TYPE_PointerTons1__Recipient:
		return soap_out_PointerTons1__Recipient(soap, tag, id, (ns1__Recipient *const*)ptr, "ns1:Recipient");
	case SOAP_TYPE_PointerTons1__uid:
		return soap_out_PointerTons1__uid(soap, tag, id, (std::string *const*)ptr, "ns1:uid");
	case SOAP_TYPE_PointerTons1__Filter:
		return soap_out_PointerTons1__Filter(soap, tag, id, (ns1__Filter *const*)ptr, "ns1:Filter");
	case SOAP_TYPE_PointerTons1__QueryTarget:
		return soap_out_PointerTons1__QueryTarget(soap, tag, id, (ns1__QueryTarget *const*)ptr, "ns1:QueryTarget");
	case SOAP_TYPE_PointerTons1__NameAndEmail:
		return soap_out_PointerTons1__NameAndEmail(soap, tag, id, (ns1__NameAndEmail *const*)ptr, "ns1:NameAndEmail");
	case SOAP_TYPE_PointerTons1__ProblemEntry:
		return soap_out_PointerTons1__ProblemEntry(soap, tag, id, (ns1__ProblemEntry *const*)ptr, "ns1:ProblemEntry");
	case SOAP_TYPE_PointerTons1__PostalAddress:
		return soap_out_PointerTons1__PostalAddress(soap, tag, id, (ns1__PostalAddress *const*)ptr, "ns1:PostalAddress");
	case SOAP_TYPE_PointerTons1__ItemRef:
		return soap_out_PointerTons1__ItemRef(soap, tag, id, (ns1__ItemRef *const*)ptr, "ns1:ItemRef");
	case SOAP_TYPE_PointerTons1__MessagePart:
		return soap_out_PointerTons1__MessagePart(soap, tag, id, (ns1__MessagePart *const*)ptr, "ns1:MessagePart");
	case SOAP_TYPE_PointerTons1__Item:
		return soap_out_PointerTons1__Item(soap, tag, id, (ns1__Item *const*)ptr, "ns1:Item");
	case SOAP_TYPE_PointerTons1__ItemChanges:
		return soap_out_PointerTons1__ItemChanges(soap, tag, id, (ns1__ItemChanges *const*)ptr, "ns1:ItemChanges");
	case SOAP_TYPE_PointerTons1__ImAddress:
		return soap_out_PointerTons1__ImAddress(soap, tag, id, (ns1__ImAddress *const*)ptr, "ns1:ImAddress");
	case SOAP_TYPE_PointerTons1__GroupMember:
		return soap_out_PointerTons1__GroupMember(soap, tag, id, (ns1__GroupMember *const*)ptr, "ns1:GroupMember");
	case SOAP_TYPE_PointerTons1__FreeBusyInfo:
		return soap_out_PointerTons1__FreeBusyInfo(soap, tag, id, (ns1__FreeBusyInfo *const*)ptr, "ns1:FreeBusyInfo");
	case SOAP_TYPE_PointerTons1__FreeBusyUser:
		return soap_out_PointerTons1__FreeBusyUser(soap, tag, id, (ns1__FreeBusyUser *const*)ptr, "ns1:FreeBusyUser");
	case SOAP_TYPE_PointerTons1__FreeBusyBlock:
		return soap_out_PointerTons1__FreeBusyBlock(soap, tag, id, (ns1__FreeBusyBlock *const*)ptr, "ns1:FreeBusyBlock");
	case SOAP_TYPE_PointerTons1__Folder:
		return soap_out_PointerTons1__Folder(soap, tag, id, (ns1__Folder *const*)ptr, "ns1:Folder");
	case SOAP_TYPE_PointerTons1__FolderACLEntry:
		return soap_out_PointerTons1__FolderACLEntry(soap, tag, id, (ns1__FolderACLEntry *const*)ptr, "ns1:FolderACLEntry");
	case SOAP_TYPE_PointerTons1__FilterElement:
		return soap_out_PointerTons1__FilterElement(soap, tag, id, (ns1__FilterElement *const*)ptr, "ns1:FilterElement");
	case SOAP_TYPE_PointerTons1__SendOptions:
		return soap_out_PointerTons1__SendOptions(soap, tag, id, (ns1__SendOptions *const*)ptr, "ns1:SendOptions");
	case SOAP_TYPE_PointerTons1__RecipientList:
		return soap_out_PointerTons1__RecipientList(soap, tag, id, (ns1__RecipientList *const*)ptr, "ns1:RecipientList");
	case SOAP_TYPE_PointerTons1__From:
		return soap_out_PointerTons1__From(soap, tag, id, (ns1__From *const*)ptr, "ns1:From");
	case SOAP_TYPE_PointerTons1__Items:
		return soap_out_PointerTons1__Items(soap, tag, id, (ns1__Items *const*)ptr, "ns1:Items");
	case SOAP_TYPE_PointerTons1__Custom:
		return soap_out_PointerTons1__Custom(soap, tag, id, (ns1__Custom *const*)ptr, "ns1:Custom");
	case SOAP_TYPE_PointerTons1__Category:
		return soap_out_PointerTons1__Category(soap, tag, id, (ns1__Category *const*)ptr, "ns1:Category");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__AttachmentID:
		return soap_out_PointerTons1__AttachmentID(soap, tag, id, (ns1__AttachmentID *const*)ptr, "ns1:AttachmentID");
	case SOAP_TYPE_PointerTons1__AttachmentItemInfo:
		return soap_out_PointerTons1__AttachmentItemInfo(soap, tag, id, (ns1__AttachmentItemInfo *const*)ptr, "ns1:AttachmentItemInfo");
	case SOAP_TYPE_PointerTons1__AddressBook:
		return soap_out_PointerTons1__AddressBook(soap, tag, id, (ns1__AddressBook *const*)ptr, "ns1:AddressBook");
	case SOAP_TYPE_PointerTons1__AccessRightEntry:
		return soap_out_PointerTons1__AccessRightEntry(soap, tag, id, (ns1__AccessRightEntry *const*)ptr, "ns1:AccessRightEntry");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__AccessControlListEntry:
		return soap_out_PointerTons1__AccessControlListEntry(soap, tag, id, (ns1__AccessControlListEntry *const*)ptr, "ns1:AccessControlListEntry");
	case SOAP_TYPE_xsd__language:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:language");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:date");
	case SOAP_TYPE_xsd__bool:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:bool");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:anyURI");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	switch (type)
	{
	case SOAP_TYPE_ns1__UUID:
		soap_mark_ns1__UUID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__uid:
		soap_mark_ns1__uid(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__View:
		soap_mark_ns1__View(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_mark_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns1__startFreeBusySessionResponse:
		((_ns1__startFreeBusySessionResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__startFreeBusySessionRequest:
		((_ns1__startFreeBusySessionRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__sendItemResponse:
		((_ns1__sendItemResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__sendItemRequest:
		((_ns1__sendItemRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__retractResponse:
		((_ns1__retractResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__retractRequest:
		((_ns1__retractRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__removeProxyAccessResponse:
		((_ns1__removeProxyAccessResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__removeProxyAccessRequest:
		((_ns1__removeProxyAccessRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__removeMembersResponse:
		((_ns1__removeMembersResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__removeMembersRequest:
		((_ns1__removeMembersRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__removeItemsResponse:
		((_ns1__removeItemsResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__removeItemsRequest:
		((_ns1__removeItemsRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__removeItemResponse:
		((_ns1__removeItemResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__removeItemRequest:
		((_ns1__removeItemRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__readCursorResponse:
		((_ns1__readCursorResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__readCursorRequest:
		((_ns1__readCursorRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__purgeItemResponse:
		((_ns1__purgeItemResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__purgeItemRequest:
		((_ns1__purgeItemRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__purgeDeletedItemsResponse:
		((_ns1__purgeDeletedItemsResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__purgeDeletedItemsRequest:
		((_ns1__purgeDeletedItemsRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__positionCursorResponse:
		((_ns1__positionCursorResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__positionCursorRequest:
		((_ns1__positionCursorRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__modifySettingsResponse:
		((_ns1__modifySettingsResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__modifySettingsRequest:
		((_ns1__modifySettingsRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__modifyProxyAccessResponse:
		((_ns1__modifyProxyAccessResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__modifyProxyAccessRequest:
		((_ns1__modifyProxyAccessRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__modifyItemResponse:
		((_ns1__modifyItemResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__modifyItemRequest:
		((_ns1__modifyItemRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__markUnReadResponse:
		((_ns1__markUnReadResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__markUnReadRequest:
		((_ns1__markUnReadRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__markReadResponse:
		((_ns1__markReadResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__markReadRequest:
		((_ns1__markReadRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__logoutResponse:
		((_ns1__logoutResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__loginResponse:
		((_ns1__loginResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__loginRequest:
		((_ns1__loginRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getTimezoneListResponse:
		((_ns1__getTimezoneListResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getSettingsResponse:
		((_ns1__getSettingsResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getSettingsRequest:
		((_ns1__getSettingsRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getProxyListResponse:
		((_ns1__getProxyListResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getProxyAccessListResponse:
		((_ns1__getProxyAccessListResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getItemsResponse:
		((_ns1__getItemsResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getItemsRequest:
		((_ns1__getItemsRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getItemResponse:
		((_ns1__getItemResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getItemRequest:
		((_ns1__getItemRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getFreeBusyResponse:
		((_ns1__getFreeBusyResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getFreeBusyRequest:
		((_ns1__getFreeBusyRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getFolderListResponse:
		((_ns1__getFolderListResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getFolderListRequest:
		((_ns1__getFolderListRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getDeltaResponse:
		((_ns1__getDeltaResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getDeltaRequest:
		((_ns1__getDeltaRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getCustomListResponse:
		((_ns1__getCustomListResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getCategoryListResponse:
		((_ns1__getCategoryListResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getAttachmentResponse:
		((_ns1__getAttachmentResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getAttachmentRequest:
		((_ns1__getAttachmentRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__getAddressBookListResponse:
		((_ns1__getAddressBookListResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__destroyCursorResponse:
		((_ns1__destroyCursorResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__destroyCursorRequest:
		((_ns1__destroyCursorRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__delegateResponse:
		((_ns1__delegateResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__delegateRequest:
		((_ns1__delegateRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__declineResponse:
		((_ns1__declineResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__declineRequest:
		((_ns1__declineRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__createProxyAccessResponse:
		((_ns1__createProxyAccessResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__createProxyAccessRequest:
		((_ns1__createProxyAccessRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__createItemResponse:
		((_ns1__createItemResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__createItemRequest:
		((_ns1__createItemRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__createCursorResponse:
		((_ns1__createCursorResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__createCursorRequest:
		((_ns1__createCursorRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__completeResponse:
		((_ns1__completeResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__completeRequest:
		((_ns1__completeRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__closeFreeBusySessionResponse:
		((_ns1__closeFreeBusySessionResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__closeFreeBusySessionRequest:
		((_ns1__closeFreeBusySessionRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__addMembersResponse:
		((_ns1__addMembersResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__addMembersRequest:
		((_ns1__addMembersRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__addItemsResponse:
		((_ns1__addItemsResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__addItemsRequest:
		((_ns1__addItemsRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__addItemResponse:
		((_ns1__addItemResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__addItemRequest:
		((_ns1__addItemRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__acceptResponse:
		((_ns1__acceptResponse *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE__ns1__acceptRequest:
		((_ns1__acceptRequest *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__UserInfo:
		((ns1__UserInfo *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__TrustedApplication:
		((ns1__TrustedApplication *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__TimezoneList:
		((ns1__TimezoneList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__TimezoneComponent:
		((ns1__TimezoneComponent *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Timezone:
		((ns1__Timezone *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Task:
		((ns1__Task *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__SystemFolder:
		((ns1__SystemFolder *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__StatusTracking:
		((ns1__StatusTracking *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Status:
		((ns1__Status *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__SharedFolderNotification:
		((ns1__SharedFolderNotification *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__SharedFolder:
		((ns1__SharedFolder *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__SettingsList:
		((ns1__SettingsList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__SettingsGroup:
		((ns1__SettingsGroup *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Settings:
		((ns1__Settings *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__SendOptions:
		((ns1__SendOptions *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__SendOptionsRequestReply:
		((ns1__SendOptionsRequestReply *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Rights:
		((ns1__Rights *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ReturnNotificationOptions:
		((ns1__ReturnNotificationOptions *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ReturnNotification:
		((ns1__ReturnNotification *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Resource:
		((ns1__Resource *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__RecurrenceDateType:
		((ns1__RecurrenceDateType *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__RecipientStatus:
		((ns1__RecipientStatus *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__RecipientList:
		((ns1__RecipientList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Recipient:
		((ns1__Recipient *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__QueryTarget:
		((ns1__QueryTarget *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__QueryFolder:
		((ns1__QueryFolder *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Query:
		((ns1__Query *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ProxyList:
		((ns1__ProxyList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Proxy:
		((ns1__Proxy *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ProblemList:
		((ns1__ProblemList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ProblemEntry:
		((ns1__ProblemEntry *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__PostalAddressList:
		((ns1__PostalAddressList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__PostalAddress:
		((ns1__PostalAddress *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__PlainText:
		((ns1__PlainText *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__PhoneMessage:
		((ns1__PhoneMessage *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__PhoneFlags:
		((ns1__PhoneFlags *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__PersonalInfo:
		((ns1__PersonalInfo *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Organization:
		((ns1__Organization *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__OfficeInfo:
		((ns1__OfficeInfo *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Note:
		((ns1__Note *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__NameAndEmail:
		((ns1__NameAndEmail *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__MessagePart:
		((ns1__MessagePart *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__MessageBody:
		((ns1__MessageBody *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Mail:
		((ns1__Mail *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ItemStatus:
		((ns1__ItemStatus *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Items:
		((ns1__Items *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ItemRefList:
		((ns1__ItemRefList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ItemRef:
		((ns1__ItemRef *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ItemOptions:
		((ns1__ItemOptions *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ItemList:
		((ns1__ItemList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ItemChanges:
		((ns1__ItemChanges *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Item:
		((ns1__Item *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ImAddressList:
		((ns1__ImAddressList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ImAddress:
		((ns1__ImAddress *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__GroupMemberList:
		((ns1__GroupMemberList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__GroupMember:
		((ns1__GroupMember *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Group:
		((ns1__Group *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FullName:
		((ns1__FullName *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__From:
		((ns1__From *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FreeBusyUser:
		((ns1__FreeBusyUser *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FreeBusyStats:
		((ns1__FreeBusyStats *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FreeBusyInfoList:
		((ns1__FreeBusyInfoList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FreeBusyUserList:
		((ns1__FreeBusyUserList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FreeBusyInfo:
		((ns1__FreeBusyInfo *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FreeBusyBlock:
		((ns1__FreeBusyBlock *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FreeBusyBlockList:
		((ns1__FreeBusyBlockList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FolderList:
		((ns1__FolderList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FolderACLEntry:
		((ns1__FolderACLEntry *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FolderACL:
		((ns1__FolderACL *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Folder:
		((ns1__Folder *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FilterGroup:
		((ns1__FilterGroup *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FilterEntry:
		((ns1__FilterEntry *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__FilterElement:
		((ns1__FilterElement *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Filter:
		((ns1__Filter *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__EmailAddressList:
		((ns1__EmailAddressList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__DocumentRef:
		((ns1__DocumentRef *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Distribution:
		((ns1__Distribution *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__DeltaList:
		((ns1__DeltaList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__DelegateeStatus:
		((ns1__DelegateeStatus *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__DelegatedStatus:
		((ns1__DelegatedStatus *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__DayOfWeek:
		((ns1__DayOfWeek *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__CustomList:
		((ns1__CustomList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Custom:
		((ns1__Custom *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ContactFolder:
		((ns1__ContactFolder *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ContainerRef:
		((ns1__ContainerRef *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__ContainerItem:
		((ns1__ContainerItem *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Contact:
		((ns1__Contact *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__CommentStatus:
		((ns1__CommentStatus *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__CategoryRefList:
		((ns1__CategoryRefList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__CategoryList:
		((ns1__CategoryList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Category:
		((ns1__Category *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__CalendarItem:
		((ns1__CalendarItem *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__BoxEntry:
		((ns1__BoxEntry *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Authentication:
		((ns1__Authentication *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AttachmentItemInfo:
		((ns1__AttachmentItemInfo *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AttachmentInfo:
		((ns1__AttachmentInfo *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AttachmentID:
		((ns1__AttachmentID *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Appointment:
		((ns1__Appointment *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__Alarm:
		((ns1__Alarm *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AddressBookList:
		((ns1__AddressBookList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AddressBookItem:
		((ns1__AddressBookItem *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AddressBook:
		((ns1__AddressBook *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AccessRightList:
		((ns1__AccessRightList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AccessRightEntry:
		((ns1__AccessRightEntry *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AccessRightChanges:
		((ns1__AccessRightChanges *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AccessRight:
		((ns1__AccessRight *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AccessMiscRight:
		((ns1__AccessMiscRight *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AccessControlList:
		((ns1__AccessControlList *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_ns1__AccessControlListEntry:
		((ns1__AccessControlListEntry *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_mark(soap);
		break;
	case SOAP_TYPE___ns9__createItemRequest:
		soap_mark___ns9__createItemRequest(soap, (const struct __ns9__createItemRequest *)ptr);
		break;
	case SOAP_TYPE___ns8__getDeltaRequest:
		soap_mark___ns8__getDeltaRequest(soap, (const struct __ns8__getDeltaRequest *)ptr);
		break;
	case SOAP_TYPE___ns7__getFolderListRequest:
		soap_mark___ns7__getFolderListRequest(soap, (const struct __ns7__getFolderListRequest *)ptr);
		break;
	case SOAP_TYPE___ns6__getItemsRequest:
		soap_mark___ns6__getItemsRequest(soap, (const struct __ns6__getItemsRequest *)ptr);
		break;
	case SOAP_TYPE___ns5__getItemRequest:
		soap_mark___ns5__getItemRequest(soap, (const struct __ns5__getItemRequest *)ptr);
		break;
	case SOAP_TYPE___ns4__getAddressBookListRequest:
		soap_mark___ns4__getAddressBookListRequest(soap, (const struct __ns4__getAddressBookListRequest *)ptr);
		break;
	case SOAP_TYPE___ns3__getCategoryListRequest:
		soap_mark___ns3__getCategoryListRequest(soap, (const struct __ns3__getCategoryListRequest *)ptr);
		break;
	case SOAP_TYPE___ns2__loginRequest:
		soap_mark___ns2__loginRequest(soap, (const struct __ns2__loginRequest *)ptr);
		break;
	case SOAP_TYPE___ns16__sendItemRequest:
		soap_mark___ns16__sendItemRequest(soap, (const struct __ns16__sendItemRequest *)ptr);
		break;
	case SOAP_TYPE___ns15__getFreeBusyRequest:
		soap_mark___ns15__getFreeBusyRequest(soap, (const struct __ns15__getFreeBusyRequest *)ptr);
		break;
	case SOAP_TYPE___ns14__closeFreeBusySessionRequest:
		soap_mark___ns14__closeFreeBusySessionRequest(soap, (const struct __ns14__closeFreeBusySessionRequest *)ptr);
		break;
	case SOAP_TYPE___ns13__startFreeBusySessionRequest:
		soap_mark___ns13__startFreeBusySessionRequest(soap, (const struct __ns13__startFreeBusySessionRequest *)ptr);
		break;
	case SOAP_TYPE___ns12__removeItemRequest:
		soap_mark___ns12__removeItemRequest(soap, (const struct __ns12__removeItemRequest *)ptr);
		break;
	case SOAP_TYPE___ns11__purgeItemRequest:
		soap_mark___ns11__purgeItemRequest(soap, (const struct __ns11__purgeItemRequest *)ptr);
		break;
	case SOAP_TYPE___ns10__modifyItemRequest:
		soap_mark___ns10__modifyItemRequest(soap, (const struct __ns10__modifyItemRequest *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createItemResponse:
		soap_mark_PointerTo_ns1__createItemResponse(soap, (_ns1__createItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createItemRequest:
		soap_mark_PointerTo_ns1__createItemRequest(soap, (_ns1__createItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDeltaResponse:
		soap_mark_PointerTo_ns1__getDeltaResponse(soap, (_ns1__getDeltaResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDeltaRequest:
		soap_mark_PointerTo_ns1__getDeltaRequest(soap, (_ns1__getDeltaRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getFolderListResponse:
		soap_mark_PointerTo_ns1__getFolderListResponse(soap, (_ns1__getFolderListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getFolderListRequest:
		soap_mark_PointerTo_ns1__getFolderListRequest(soap, (_ns1__getFolderListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getItemsResponse:
		soap_mark_PointerTo_ns1__getItemsResponse(soap, (_ns1__getItemsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getItemsRequest:
		soap_mark_PointerTo_ns1__getItemsRequest(soap, (_ns1__getItemsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getItemResponse:
		soap_mark_PointerTo_ns1__getItemResponse(soap, (_ns1__getItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getItemRequest:
		soap_mark_PointerTo_ns1__getItemRequest(soap, (_ns1__getItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAddressBookListResponse:
		soap_mark_PointerTo_ns1__getAddressBookListResponse(soap, (_ns1__getAddressBookListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCategoryListResponse:
		soap_mark_PointerTo_ns1__getCategoryListResponse(soap, (_ns1__getCategoryListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		soap_mark_PointerTo_ns1__loginResponse(soap, (_ns1__loginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__loginRequest:
		soap_mark_PointerTo_ns1__loginRequest(soap, (_ns1__loginRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__sendItemResponse:
		soap_mark_PointerTo_ns1__sendItemResponse(soap, (_ns1__sendItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__sendItemRequest:
		soap_mark_PointerTo_ns1__sendItemRequest(soap, (_ns1__sendItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getFreeBusyResponse:
		soap_mark_PointerTo_ns1__getFreeBusyResponse(soap, (_ns1__getFreeBusyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getFreeBusyRequest:
		soap_mark_PointerTo_ns1__getFreeBusyRequest(soap, (_ns1__getFreeBusyRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionResponse:
		soap_mark_PointerTo_ns1__closeFreeBusySessionResponse(soap, (_ns1__closeFreeBusySessionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionRequest:
		soap_mark_PointerTo_ns1__closeFreeBusySessionRequest(soap, (_ns1__closeFreeBusySessionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__startFreeBusySessionResponse:
		soap_mark_PointerTo_ns1__startFreeBusySessionResponse(soap, (_ns1__startFreeBusySessionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__startFreeBusySessionRequest:
		soap_mark_PointerTo_ns1__startFreeBusySessionRequest(soap, (_ns1__startFreeBusySessionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeItemResponse:
		soap_mark_PointerTo_ns1__removeItemResponse(soap, (_ns1__removeItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeItemRequest:
		soap_mark_PointerTo_ns1__removeItemRequest(soap, (_ns1__removeItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__purgeItemResponse:
		soap_mark_PointerTo_ns1__purgeItemResponse(soap, (_ns1__purgeItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__purgeItemRequest:
		soap_mark_PointerTo_ns1__purgeItemRequest(soap, (_ns1__purgeItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__modifyItemResponse:
		soap_mark_PointerTo_ns1__modifyItemResponse(soap, (_ns1__modifyItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__modifyItemRequest:
		soap_mark_PointerTo_ns1__modifyItemRequest(soap, (_ns1__modifyItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Alarm:
		soap_mark_PointerTons1__Alarm(soap, (ns1__Alarm *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PhoneFlags:
		soap_mark_PointerTons1__PhoneFlags(soap, (ns1__PhoneFlags *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccessControlList:
		soap_mark_PointerTons1__AccessControlList(soap, (ns1__AccessControlList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RecurrenceDateType:
		soap_mark_PointerTons1__RecurrenceDateType(soap, (ns1__RecurrenceDateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemOptions:
		soap_mark_PointerTons1__ItemOptions(soap, (ns1__ItemOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AttachmentInfo:
		soap_mark_PointerTons1__AttachmentInfo(soap, (ns1__AttachmentInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MessageBody:
		soap_mark_PointerTons1__MessageBody(soap, (ns1__MessageBody *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PersonalInfo:
		soap_mark_PointerTons1__PersonalInfo(soap, (ns1__PersonalInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OfficeInfo:
		soap_mark_PointerTons1__OfficeInfo(soap, (ns1__OfficeInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PostalAddressList:
		soap_mark_PointerTons1__PostalAddressList(soap, (ns1__PostalAddressList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ImAddressList:
		soap_mark_PointerTons1__ImAddressList(soap, (ns1__ImAddressList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EmailAddressList:
		soap_mark_PointerTons1__EmailAddressList(soap, (ns1__EmailAddressList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FullName:
		soap_mark_PointerTons1__FullName(soap, (ns1__FullName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UUID:
		soap_mark_PointerTons1__UUID(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FolderACL:
		soap_mark_PointerTons1__FolderACL(soap, (ns1__FolderACL *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Query:
		soap_mark_PointerTons1__Query(soap, (ns1__Query *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FreeBusyBlockList:
		soap_mark_PointerTons1__FreeBusyBlockList(soap, (ns1__FreeBusyBlockList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemClass:
		soap_mark_PointerTons1__ItemClass(soap, (enum ns1__ItemClass *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemSource:
		soap_mark_PointerTons1__ItemSource(soap, (enum ns1__ItemSource *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemStatus:
		soap_mark_PointerTons1__ItemStatus(soap, (ns1__ItemStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RecipientStatus:
		soap_mark_PointerTons1__RecipientStatus(soap, (ns1__RecipientStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SharedFolderNotification:
		soap_mark_PointerTons1__SharedFolderNotification(soap, (ns1__SharedFolderNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_mark_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CategoryRefList:
		soap_mark_PointerTons1__CategoryRefList(soap, (ns1__CategoryRefList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ContainerRef:
		soap_mark_PointerTons1__ContainerRef(soap, (ns1__ContainerRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedLong:
		soap_mark_PointerTounsignedLong(soap, (unsigned long *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CategoryType:
		soap_mark_PointerTons1__CategoryType(soap, (enum ns1__CategoryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccessMiscRight:
		soap_mark_PointerTons1__AccessMiscRight(soap, (ns1__AccessMiscRight *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccessRight:
		soap_mark_PointerTons1__AccessRight(soap, (ns1__AccessRight *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Rights:
		soap_mark_PointerTons1__Rights(soap, (ns1__Rights *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FreeBusyUserList:
		soap_mark_PointerTons1__FreeBusyUserList(soap, (ns1__FreeBusyUserList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemList:
		soap_mark_PointerTons1__ItemList(soap, (ns1__ItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SettingsList:
		soap_mark_PointerTons1__SettingsList(soap, (ns1__SettingsList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccessRightChanges:
		soap_mark_PointerTons1__AccessRightChanges(soap, (ns1__AccessRightChanges *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UserInfo:
		soap_mark_PointerTons1__UserInfo(soap, (ns1__UserInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Authentication:
		soap_mark_PointerTons1__Authentication(soap, (ns1__Authentication *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TimezoneList:
		soap_mark_PointerTons1__TimezoneList(soap, (ns1__TimezoneList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Settings:
		soap_mark_PointerTons1__Settings(soap, (ns1__Settings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProxyList:
		soap_mark_PointerTons1__ProxyList(soap, (ns1__ProxyList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccessRightList:
		soap_mark_PointerTons1__AccessRightList(soap, (ns1__AccessRightList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__View:
		soap_mark_PointerTons1__View(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FreeBusyInfoList:
		soap_mark_PointerTons1__FreeBusyInfoList(soap, (ns1__FreeBusyInfoList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FreeBusyStats:
		soap_mark_PointerTons1__FreeBusyStats(soap, (ns1__FreeBusyStats *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FolderList:
		soap_mark_PointerTons1__FolderList(soap, (ns1__FolderList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DeltaList:
		soap_mark_PointerTons1__DeltaList(soap, (ns1__DeltaList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CustomList:
		soap_mark_PointerTons1__CustomList(soap, (ns1__CustomList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CategoryList:
		soap_mark_PointerTons1__CategoryList(soap, (ns1__CategoryList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AddressBookList:
		soap_mark_PointerTons1__AddressBookList(soap, (ns1__AddressBookList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Distribution:
		soap_mark_PointerTons1__Distribution(soap, (ns1__Distribution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GroupMemberList:
		soap_mark_PointerTons1__GroupMemberList(soap, (ns1__GroupMemberList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Status:
		soap_mark_PointerTons1__Status(soap, (ns1__Status *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemRefList:
		soap_mark_PointerTons1__ItemRefList(soap, (ns1__ItemRefList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Timezone:
		soap_mark_PointerTons1__Timezone(soap, (ns1__Timezone *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DayOfWeek:
		soap_mark_PointerTons1__DayOfWeek(soap, (ns1__DayOfWeek *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Day:
		soap_mark_PointerTons1__Day(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Minute:
		soap_mark_PointerTons1__Minute(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Hour:
		soap_mark_PointerTons1__Hour(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Month:
		soap_mark_PointerTons1__Month(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TimezoneComponent:
		soap_mark_PointerTons1__TimezoneComponent(soap, (ns1__TimezoneComponent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProblemList:
		soap_mark_PointerTons1__ProblemList(soap, (ns1__ProblemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SettingsGroup:
		soap_mark_PointerTons1__SettingsGroup(soap, (ns1__SettingsGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReturnNotification:
		soap_mark_PointerTons1__ReturnNotification(soap, (ns1__ReturnNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StatusTracking:
		soap_mark_PointerTons1__StatusTracking(soap, (ns1__StatusTracking *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SendOptionsRequestReply:
		soap_mark_PointerTons1__SendOptionsRequestReply(soap, (ns1__SendOptionsRequestReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReturnNotificationOptions:
		soap_mark_PointerTons1__ReturnNotificationOptions(soap, (ns1__ReturnNotificationOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DelegateeStatus:
		soap_mark_PointerTons1__DelegateeStatus(soap, (ns1__DelegateeStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DelegatedStatus:
		soap_mark_PointerTons1__DelegatedStatus(soap, (ns1__DelegatedStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CommentStatus:
		soap_mark_PointerTons1__CommentStatus(soap, (ns1__CommentStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Recipient:
		soap_mark_PointerTons1__Recipient(soap, (ns1__Recipient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__uid:
		soap_mark_PointerTons1__uid(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Filter:
		soap_mark_PointerTons1__Filter(soap, (ns1__Filter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__QueryTarget:
		soap_mark_PointerTons1__QueryTarget(soap, (ns1__QueryTarget *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NameAndEmail:
		soap_mark_PointerTons1__NameAndEmail(soap, (ns1__NameAndEmail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProblemEntry:
		soap_mark_PointerTons1__ProblemEntry(soap, (ns1__ProblemEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PostalAddress:
		soap_mark_PointerTons1__PostalAddress(soap, (ns1__PostalAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemRef:
		soap_mark_PointerTons1__ItemRef(soap, (ns1__ItemRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MessagePart:
		soap_mark_PointerTons1__MessagePart(soap, (ns1__MessagePart *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Item:
		soap_mark_PointerTons1__Item(soap, (ns1__Item *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemChanges:
		soap_mark_PointerTons1__ItemChanges(soap, (ns1__ItemChanges *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ImAddress:
		soap_mark_PointerTons1__ImAddress(soap, (ns1__ImAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GroupMember:
		soap_mark_PointerTons1__GroupMember(soap, (ns1__GroupMember *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FreeBusyInfo:
		soap_mark_PointerTons1__FreeBusyInfo(soap, (ns1__FreeBusyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FreeBusyUser:
		soap_mark_PointerTons1__FreeBusyUser(soap, (ns1__FreeBusyUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FreeBusyBlock:
		soap_mark_PointerTons1__FreeBusyBlock(soap, (ns1__FreeBusyBlock *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Folder:
		soap_mark_PointerTons1__Folder(soap, (ns1__Folder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FolderACLEntry:
		soap_mark_PointerTons1__FolderACLEntry(soap, (ns1__FolderACLEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FilterElement:
		soap_mark_PointerTons1__FilterElement(soap, (ns1__FilterElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SendOptions:
		soap_mark_PointerTons1__SendOptions(soap, (ns1__SendOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RecipientList:
		soap_mark_PointerTons1__RecipientList(soap, (ns1__RecipientList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__From:
		soap_mark_PointerTons1__From(soap, (ns1__From *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Items:
		soap_mark_PointerTons1__Items(soap, (ns1__Items *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Custom:
		soap_mark_PointerTons1__Custom(soap, (ns1__Custom *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Category:
		soap_mark_PointerTons1__Category(soap, (ns1__Category *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_mark_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_mark_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AttachmentID:
		soap_mark_PointerTons1__AttachmentID(soap, (ns1__AttachmentID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AttachmentItemInfo:
		soap_mark_PointerTons1__AttachmentItemInfo(soap, (ns1__AttachmentItemInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AddressBook:
		soap_mark_PointerTons1__AddressBook(soap, (ns1__AddressBook *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccessRightEntry:
		soap_mark_PointerTons1__AccessRightEntry(soap, (ns1__AccessRightEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_mark_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccessControlListEntry:
		soap_mark_PointerTons1__AccessControlListEntry(soap, (ns1__AccessControlListEntry *const*)ptr);
		break;
	case SOAP_TYPE_xsd__language:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_xsd__bool:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_mark_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_mark_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_mark_string(soap, (char**)&ptr);
		break;
	}
}

#ifndef WITH_LEANER
SOAP_FMAC3 int SOAP_FMAC4 soap_getattachments(struct soap *soap)
{
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	while (soap->dime_flags & SOAP_DIME_CF)
	{	if (soap_getdimehdr(soap))
			return soap->error;
		if (soap_move(soap, soap->dime_size))
			return soap->error = SOAP_EOF;
	}
	if (soap_move(soap, ((soap->dime_size+3)&(~3))-soap_tell(soap)))
		return soap->error = SOAP_EOF;
	for (;;)
	{	if (soap_getdime(soap) || !soap->dime_id)
			break;
		switch (soap_lookup_type(soap, soap->dime_id))
		{
		case SOAP_TYPE_xsd__base64Binary:
		{	xsd__base64Binary * a;
			a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), NULL, NULL);
			if (a)
			{	a->__ptr = (unsigned char*)soap->dime_ptr;
				a->__size = soap->dime_size;
			}
			break;
		}
		case SOAP_TYPE_xsd__language:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__language, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsd__decimal:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__decimal, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsd__date:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__date, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsd__bool:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__bool, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsd__anyURI:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__anyURI, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE__QName:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE__QName, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		default:
			soap->error = SOAP_DIME_ERROR;
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_EOD)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putattachments(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if (pp->mark2 == 3)
				switch (pp->type)
				{
				}
		
	return SOAP_OK;
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccessControlList:
		return (void*)soap_instantiate_ns1__AccessControlList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccessMiscRight:
		return (void*)soap_instantiate_ns1__AccessMiscRight(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccessRight:
		return (void*)soap_instantiate_ns1__AccessRight(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccessRightChanges:
		return (void*)soap_instantiate_ns1__AccessRightChanges(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccessRightList:
		return (void*)soap_instantiate_ns1__AccessRightList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AddressBookList:
		return (void*)soap_instantiate_ns1__AddressBookList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AttachmentInfo:
		return (void*)soap_instantiate_ns1__AttachmentInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AttachmentItemInfo:
		return (void*)soap_instantiate_ns1__AttachmentItemInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Authentication:
		return (void*)soap_instantiate_ns1__Authentication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CategoryList:
		return (void*)soap_instantiate_ns1__CategoryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CategoryRefList:
		return (void*)soap_instantiate_ns1__CategoryRefList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Custom:
		return (void*)soap_instantiate_ns1__Custom(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CustomList:
		return (void*)soap_instantiate_ns1__CustomList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeltaList:
		return (void*)soap_instantiate_ns1__DeltaList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Distribution:
		return (void*)soap_instantiate_ns1__Distribution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EmailAddressList:
		return (void*)soap_instantiate_ns1__EmailAddressList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Filter:
		return (void*)soap_instantiate_ns1__Filter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FilterElement:
		return (void*)soap_instantiate_ns1__FilterElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FolderACL:
		return (void*)soap_instantiate_ns1__FolderACL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FolderList:
		return (void*)soap_instantiate_ns1__FolderList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FreeBusyBlockList:
		return (void*)soap_instantiate_ns1__FreeBusyBlockList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FreeBusyBlock:
		return (void*)soap_instantiate_ns1__FreeBusyBlock(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FreeBusyUserList:
		return (void*)soap_instantiate_ns1__FreeBusyUserList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FreeBusyInfoList:
		return (void*)soap_instantiate_ns1__FreeBusyInfoList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FreeBusyStats:
		return (void*)soap_instantiate_ns1__FreeBusyStats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FullName:
		return (void*)soap_instantiate_ns1__FullName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GroupMember:
		return (void*)soap_instantiate_ns1__GroupMember(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GroupMemberList:
		return (void*)soap_instantiate_ns1__GroupMemberList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ImAddress:
		return (void*)soap_instantiate_ns1__ImAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ImAddressList:
		return (void*)soap_instantiate_ns1__ImAddressList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Item:
		return (void*)soap_instantiate_ns1__Item(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ItemChanges:
		return (void*)soap_instantiate_ns1__ItemChanges(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ItemOptions:
		return (void*)soap_instantiate_ns1__ItemOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ItemRefList:
		return (void*)soap_instantiate_ns1__ItemRefList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Items:
		return (void*)soap_instantiate_ns1__Items(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ItemStatus:
		return (void*)soap_instantiate_ns1__ItemStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MessageBody:
		return (void*)soap_instantiate_ns1__MessageBody(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NameAndEmail:
		return (void*)soap_instantiate_ns1__NameAndEmail(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OfficeInfo:
		return (void*)soap_instantiate_ns1__OfficeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PersonalInfo:
		return (void*)soap_instantiate_ns1__PersonalInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PhoneFlags:
		return (void*)soap_instantiate_ns1__PhoneFlags(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PostalAddress:
		return (void*)soap_instantiate_ns1__PostalAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PostalAddressList:
		return (void*)soap_instantiate_ns1__PostalAddressList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ProblemEntry:
		return (void*)soap_instantiate_ns1__ProblemEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ProblemList:
		return (void*)soap_instantiate_ns1__ProblemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ProxyList:
		return (void*)soap_instantiate_ns1__ProxyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Query:
		return (void*)soap_instantiate_ns1__Query(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QueryTarget:
		return (void*)soap_instantiate_ns1__QueryTarget(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RecipientList:
		return (void*)soap_instantiate_ns1__RecipientList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RecipientStatus:
		return (void*)soap_instantiate_ns1__RecipientStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RecurrenceDateType:
		return (void*)soap_instantiate_ns1__RecurrenceDateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReturnNotification:
		return (void*)soap_instantiate_ns1__ReturnNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReturnNotificationOptions:
		return (void*)soap_instantiate_ns1__ReturnNotificationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Rights:
		return (void*)soap_instantiate_ns1__Rights(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SendOptionsRequestReply:
		return (void*)soap_instantiate_ns1__SendOptionsRequestReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SendOptions:
		return (void*)soap_instantiate_ns1__SendOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Settings:
		return (void*)soap_instantiate_ns1__Settings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SettingsGroup:
		return (void*)soap_instantiate_ns1__SettingsGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SettingsList:
		return (void*)soap_instantiate_ns1__SettingsList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SharedFolderNotification:
		return (void*)soap_instantiate_ns1__SharedFolderNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Status:
		return (void*)soap_instantiate_ns1__Status(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Timezone:
		return (void*)soap_instantiate_ns1__Timezone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TimezoneComponent:
		return (void*)soap_instantiate_ns1__TimezoneComponent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TimezoneList:
		return (void*)soap_instantiate_ns1__TimezoneList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UserInfo:
		return (void*)soap_instantiate_ns1__UserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__acceptRequest:
		return (void*)soap_instantiate__ns1__acceptRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__acceptResponse:
		return (void*)soap_instantiate__ns1__acceptResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addItemRequest:
		return (void*)soap_instantiate__ns1__addItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addItemResponse:
		return (void*)soap_instantiate__ns1__addItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addItemsRequest:
		return (void*)soap_instantiate__ns1__addItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addItemsResponse:
		return (void*)soap_instantiate__ns1__addItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addMembersRequest:
		return (void*)soap_instantiate__ns1__addMembersRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addMembersResponse:
		return (void*)soap_instantiate__ns1__addMembersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__closeFreeBusySessionRequest:
		return (void*)soap_instantiate__ns1__closeFreeBusySessionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__closeFreeBusySessionResponse:
		return (void*)soap_instantiate__ns1__closeFreeBusySessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__completeRequest:
		return (void*)soap_instantiate__ns1__completeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__completeResponse:
		return (void*)soap_instantiate__ns1__completeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__createCursorRequest:
		return (void*)soap_instantiate__ns1__createCursorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__createCursorResponse:
		return (void*)soap_instantiate__ns1__createCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__createItemRequest:
		return (void*)soap_instantiate__ns1__createItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__createItemResponse:
		return (void*)soap_instantiate__ns1__createItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__createProxyAccessRequest:
		return (void*)soap_instantiate__ns1__createProxyAccessRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__createProxyAccessResponse:
		return (void*)soap_instantiate__ns1__createProxyAccessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__declineRequest:
		return (void*)soap_instantiate__ns1__declineRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__declineResponse:
		return (void*)soap_instantiate__ns1__declineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__delegateRequest:
		return (void*)soap_instantiate__ns1__delegateRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__delegateResponse:
		return (void*)soap_instantiate__ns1__delegateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__destroyCursorRequest:
		return (void*)soap_instantiate__ns1__destroyCursorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__destroyCursorResponse:
		return (void*)soap_instantiate__ns1__destroyCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAddressBookListResponse:
		return (void*)soap_instantiate__ns1__getAddressBookListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAttachmentRequest:
		return (void*)soap_instantiate__ns1__getAttachmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAttachmentResponse:
		return (void*)soap_instantiate__ns1__getAttachmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getCategoryListResponse:
		return (void*)soap_instantiate__ns1__getCategoryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getCustomListResponse:
		return (void*)soap_instantiate__ns1__getCustomListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getDeltaRequest:
		return (void*)soap_instantiate__ns1__getDeltaRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getDeltaResponse:
		return (void*)soap_instantiate__ns1__getDeltaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getFolderListRequest:
		return (void*)soap_instantiate__ns1__getFolderListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getFolderListResponse:
		return (void*)soap_instantiate__ns1__getFolderListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getFreeBusyRequest:
		return (void*)soap_instantiate__ns1__getFreeBusyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getFreeBusyResponse:
		return (void*)soap_instantiate__ns1__getFreeBusyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getItemRequest:
		return (void*)soap_instantiate__ns1__getItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getItemResponse:
		return (void*)soap_instantiate__ns1__getItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getItemsRequest:
		return (void*)soap_instantiate__ns1__getItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getItemsResponse:
		return (void*)soap_instantiate__ns1__getItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getProxyAccessListResponse:
		return (void*)soap_instantiate__ns1__getProxyAccessListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getProxyListResponse:
		return (void*)soap_instantiate__ns1__getProxyListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSettingsRequest:
		return (void*)soap_instantiate__ns1__getSettingsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSettingsResponse:
		return (void*)soap_instantiate__ns1__getSettingsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTimezoneListResponse:
		return (void*)soap_instantiate__ns1__getTimezoneListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__loginRequest:
		return (void*)soap_instantiate__ns1__loginRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__loginResponse:
		return (void*)soap_instantiate__ns1__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__logoutResponse:
		return (void*)soap_instantiate__ns1__logoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__markReadRequest:
		return (void*)soap_instantiate__ns1__markReadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__markReadResponse:
		return (void*)soap_instantiate__ns1__markReadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__markUnReadRequest:
		return (void*)soap_instantiate__ns1__markUnReadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__markUnReadResponse:
		return (void*)soap_instantiate__ns1__markUnReadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__modifyItemRequest:
		return (void*)soap_instantiate__ns1__modifyItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__modifyItemResponse:
		return (void*)soap_instantiate__ns1__modifyItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__modifyProxyAccessRequest:
		return (void*)soap_instantiate__ns1__modifyProxyAccessRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__modifyProxyAccessResponse:
		return (void*)soap_instantiate__ns1__modifyProxyAccessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__modifySettingsRequest:
		return (void*)soap_instantiate__ns1__modifySettingsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__modifySettingsResponse:
		return (void*)soap_instantiate__ns1__modifySettingsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__positionCursorRequest:
		return (void*)soap_instantiate__ns1__positionCursorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__positionCursorResponse:
		return (void*)soap_instantiate__ns1__positionCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__purgeDeletedItemsRequest:
		return (void*)soap_instantiate__ns1__purgeDeletedItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__purgeDeletedItemsResponse:
		return (void*)soap_instantiate__ns1__purgeDeletedItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__purgeItemRequest:
		return (void*)soap_instantiate__ns1__purgeItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__purgeItemResponse:
		return (void*)soap_instantiate__ns1__purgeItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__readCursorRequest:
		return (void*)soap_instantiate__ns1__readCursorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__readCursorResponse:
		return (void*)soap_instantiate__ns1__readCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeItemRequest:
		return (void*)soap_instantiate__ns1__removeItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeItemResponse:
		return (void*)soap_instantiate__ns1__removeItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeItemsRequest:
		return (void*)soap_instantiate__ns1__removeItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeItemsResponse:
		return (void*)soap_instantiate__ns1__removeItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeMembersRequest:
		return (void*)soap_instantiate__ns1__removeMembersRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeMembersResponse:
		return (void*)soap_instantiate__ns1__removeMembersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeProxyAccessRequest:
		return (void*)soap_instantiate__ns1__removeProxyAccessRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeProxyAccessResponse:
		return (void*)soap_instantiate__ns1__removeProxyAccessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__retractRequest:
		return (void*)soap_instantiate__ns1__retractRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__retractResponse:
		return (void*)soap_instantiate__ns1__retractResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__sendItemRequest:
		return (void*)soap_instantiate__ns1__sendItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__sendItemResponse:
		return (void*)soap_instantiate__ns1__sendItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__startFreeBusySessionRequest:
		return (void*)soap_instantiate__ns1__startFreeBusySessionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__startFreeBusySessionResponse:
		return (void*)soap_instantiate__ns1__startFreeBusySessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccessControlListEntry:
		return (void*)soap_instantiate_ns1__AccessControlListEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccessRightEntry:
		return (void*)soap_instantiate_ns1__AccessRightEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AddressBook:
		return (void*)soap_instantiate_ns1__AddressBook(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Alarm:
		return (void*)soap_instantiate_ns1__Alarm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Category:
		return (void*)soap_instantiate_ns1__Category(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CommentStatus:
		return (void*)soap_instantiate_ns1__CommentStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ContainerItem:
		return (void*)soap_instantiate_ns1__ContainerItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ContainerRef:
		return (void*)soap_instantiate_ns1__ContainerRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DelegatedStatus:
		return (void*)soap_instantiate_ns1__DelegatedStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DelegateeStatus:
		return (void*)soap_instantiate_ns1__DelegateeStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FilterEntry:
		return (void*)soap_instantiate_ns1__FilterEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FilterGroup:
		return (void*)soap_instantiate_ns1__FilterGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Folder:
		return (void*)soap_instantiate_ns1__Folder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FreeBusyUser:
		return (void*)soap_instantiate_ns1__FreeBusyUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__From:
		return (void*)soap_instantiate_ns1__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ItemList:
		return (void*)soap_instantiate_ns1__ItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ItemRef:
		return (void*)soap_instantiate_ns1__ItemRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MessagePart:
		return (void*)soap_instantiate_ns1__MessagePart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PlainText:
		return (void*)soap_instantiate_ns1__PlainText(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Proxy:
		return (void*)soap_instantiate_ns1__Proxy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Recipient:
		return (void*)soap_instantiate_ns1__Recipient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TrustedApplication:
		return (void*)soap_instantiate_ns1__TrustedApplication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AddressBookItem:
		return (void*)soap_instantiate_ns1__AddressBookItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AttachmentID:
		return (void*)soap_instantiate_ns1__AttachmentID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BoxEntry:
		return (void*)soap_instantiate_ns1__BoxEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DayOfWeek:
		return (void*)soap_instantiate_ns1__DayOfWeek(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FolderACLEntry:
		return (void*)soap_instantiate_ns1__FolderACLEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FreeBusyInfo:
		return (void*)soap_instantiate_ns1__FreeBusyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QueryFolder:
		return (void*)soap_instantiate_ns1__QueryFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SharedFolder:
		return (void*)soap_instantiate_ns1__SharedFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StatusTracking:
		return (void*)soap_instantiate_ns1__StatusTracking(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SystemFolder:
		return (void*)soap_instantiate_ns1__SystemFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Contact:
		return (void*)soap_instantiate_ns1__Contact(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ContactFolder:
		return (void*)soap_instantiate_ns1__ContactFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Group:
		return (void*)soap_instantiate_ns1__Group(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Mail:
		return (void*)soap_instantiate_ns1__Mail(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Organization:
		return (void*)soap_instantiate_ns1__Organization(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Resource:
		return (void*)soap_instantiate_ns1__Resource(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CalendarItem:
		return (void*)soap_instantiate_ns1__CalendarItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DocumentRef:
		return (void*)soap_instantiate_ns1__DocumentRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PhoneMessage:
		return (void*)soap_instantiate_ns1__PhoneMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Appointment:
		return (void*)soap_instantiate_ns1__Appointment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Note:
		return (void*)soap_instantiate_ns1__Note(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Task:
		return (void*)soap_instantiate_ns1__Task(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__getCategoryListRequest:
		return (void*)soap_instantiate___ns3__getCategoryListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getAddressBookListRequest:
		return (void*)soap_instantiate___ns4__getAddressBookListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__View:
		return (void*)soap_instantiate_ns1__View(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__uid:
		return (void*)soap_instantiate_ns1__uid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UUID:
		return (void*)soap_instantiate_ns1__UUID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FilterElement:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__FilterElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ContainerRef:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ContainerRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Timezone:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Timezone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SettingsGroup:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SettingsGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__date:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Recipient:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Recipient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__NameAndEmail:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__NameAndEmail(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProblemEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ProblemEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PostalAddress:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__PostalAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MessagePart:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__MessagePart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Item:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Item(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ImAddress:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ImAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupMember:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__GroupMember(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyUser:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyBlock:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Folder:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Folder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FolderACLEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__FolderACLEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Custom:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Custom(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__uid:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__uid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Category:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Category(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttachmentItemInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AddressBook:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__AddressBook(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessRightEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__AccessRightEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessControlListEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			delete (xsd__base64Binary*)p->ptr;
		else
			delete[] (xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AccessControlList:
		if (p->size < 0)
			delete (ns1__AccessControlList*)p->ptr;
		else
			delete[] (ns1__AccessControlList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AccessMiscRight:
		if (p->size < 0)
			delete (ns1__AccessMiscRight*)p->ptr;
		else
			delete[] (ns1__AccessMiscRight*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AccessRight:
		if (p->size < 0)
			delete (ns1__AccessRight*)p->ptr;
		else
			delete[] (ns1__AccessRight*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AccessRightChanges:
		if (p->size < 0)
			delete (ns1__AccessRightChanges*)p->ptr;
		else
			delete[] (ns1__AccessRightChanges*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AccessRightList:
		if (p->size < 0)
			delete (ns1__AccessRightList*)p->ptr;
		else
			delete[] (ns1__AccessRightList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AddressBookList:
		if (p->size < 0)
			delete (ns1__AddressBookList*)p->ptr;
		else
			delete[] (ns1__AddressBookList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AttachmentInfo:
		if (p->size < 0)
			delete (ns1__AttachmentInfo*)p->ptr;
		else
			delete[] (ns1__AttachmentInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AttachmentItemInfo:
		if (p->size < 0)
			delete (ns1__AttachmentItemInfo*)p->ptr;
		else
			delete[] (ns1__AttachmentItemInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Authentication:
		if (p->size < 0)
			delete (ns1__Authentication*)p->ptr;
		else
			delete[] (ns1__Authentication*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CategoryList:
		if (p->size < 0)
			delete (ns1__CategoryList*)p->ptr;
		else
			delete[] (ns1__CategoryList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CategoryRefList:
		if (p->size < 0)
			delete (ns1__CategoryRefList*)p->ptr;
		else
			delete[] (ns1__CategoryRefList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Custom:
		if (p->size < 0)
			delete (ns1__Custom*)p->ptr;
		else
			delete[] (ns1__Custom*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CustomList:
		if (p->size < 0)
			delete (ns1__CustomList*)p->ptr;
		else
			delete[] (ns1__CustomList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DeltaList:
		if (p->size < 0)
			delete (ns1__DeltaList*)p->ptr;
		else
			delete[] (ns1__DeltaList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Distribution:
		if (p->size < 0)
			delete (ns1__Distribution*)p->ptr;
		else
			delete[] (ns1__Distribution*)p->ptr;
		break;
	case SOAP_TYPE_ns1__EmailAddressList:
		if (p->size < 0)
			delete (ns1__EmailAddressList*)p->ptr;
		else
			delete[] (ns1__EmailAddressList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Filter:
		if (p->size < 0)
			delete (ns1__Filter*)p->ptr;
		else
			delete[] (ns1__Filter*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FilterElement:
		if (p->size < 0)
			delete (ns1__FilterElement*)p->ptr;
		else
			delete[] (ns1__FilterElement*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FolderACL:
		if (p->size < 0)
			delete (ns1__FolderACL*)p->ptr;
		else
			delete[] (ns1__FolderACL*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FolderList:
		if (p->size < 0)
			delete (ns1__FolderList*)p->ptr;
		else
			delete[] (ns1__FolderList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FreeBusyBlockList:
		if (p->size < 0)
			delete (ns1__FreeBusyBlockList*)p->ptr;
		else
			delete[] (ns1__FreeBusyBlockList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FreeBusyBlock:
		if (p->size < 0)
			delete (ns1__FreeBusyBlock*)p->ptr;
		else
			delete[] (ns1__FreeBusyBlock*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FreeBusyUserList:
		if (p->size < 0)
			delete (ns1__FreeBusyUserList*)p->ptr;
		else
			delete[] (ns1__FreeBusyUserList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FreeBusyInfoList:
		if (p->size < 0)
			delete (ns1__FreeBusyInfoList*)p->ptr;
		else
			delete[] (ns1__FreeBusyInfoList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FreeBusyStats:
		if (p->size < 0)
			delete (ns1__FreeBusyStats*)p->ptr;
		else
			delete[] (ns1__FreeBusyStats*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FullName:
		if (p->size < 0)
			delete (ns1__FullName*)p->ptr;
		else
			delete[] (ns1__FullName*)p->ptr;
		break;
	case SOAP_TYPE_ns1__GroupMember:
		if (p->size < 0)
			delete (ns1__GroupMember*)p->ptr;
		else
			delete[] (ns1__GroupMember*)p->ptr;
		break;
	case SOAP_TYPE_ns1__GroupMemberList:
		if (p->size < 0)
			delete (ns1__GroupMemberList*)p->ptr;
		else
			delete[] (ns1__GroupMemberList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ImAddress:
		if (p->size < 0)
			delete (ns1__ImAddress*)p->ptr;
		else
			delete[] (ns1__ImAddress*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ImAddressList:
		if (p->size < 0)
			delete (ns1__ImAddressList*)p->ptr;
		else
			delete[] (ns1__ImAddressList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Item:
		if (p->size < 0)
			delete (ns1__Item*)p->ptr;
		else
			delete[] (ns1__Item*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ItemChanges:
		if (p->size < 0)
			delete (ns1__ItemChanges*)p->ptr;
		else
			delete[] (ns1__ItemChanges*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ItemOptions:
		if (p->size < 0)
			delete (ns1__ItemOptions*)p->ptr;
		else
			delete[] (ns1__ItemOptions*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ItemRefList:
		if (p->size < 0)
			delete (ns1__ItemRefList*)p->ptr;
		else
			delete[] (ns1__ItemRefList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Items:
		if (p->size < 0)
			delete (ns1__Items*)p->ptr;
		else
			delete[] (ns1__Items*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ItemStatus:
		if (p->size < 0)
			delete (ns1__ItemStatus*)p->ptr;
		else
			delete[] (ns1__ItemStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MessageBody:
		if (p->size < 0)
			delete (ns1__MessageBody*)p->ptr;
		else
			delete[] (ns1__MessageBody*)p->ptr;
		break;
	case SOAP_TYPE_ns1__NameAndEmail:
		if (p->size < 0)
			delete (ns1__NameAndEmail*)p->ptr;
		else
			delete[] (ns1__NameAndEmail*)p->ptr;
		break;
	case SOAP_TYPE_ns1__OfficeInfo:
		if (p->size < 0)
			delete (ns1__OfficeInfo*)p->ptr;
		else
			delete[] (ns1__OfficeInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PersonalInfo:
		if (p->size < 0)
			delete (ns1__PersonalInfo*)p->ptr;
		else
			delete[] (ns1__PersonalInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PhoneFlags:
		if (p->size < 0)
			delete (ns1__PhoneFlags*)p->ptr;
		else
			delete[] (ns1__PhoneFlags*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PostalAddress:
		if (p->size < 0)
			delete (ns1__PostalAddress*)p->ptr;
		else
			delete[] (ns1__PostalAddress*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PostalAddressList:
		if (p->size < 0)
			delete (ns1__PostalAddressList*)p->ptr;
		else
			delete[] (ns1__PostalAddressList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ProblemEntry:
		if (p->size < 0)
			delete (ns1__ProblemEntry*)p->ptr;
		else
			delete[] (ns1__ProblemEntry*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ProblemList:
		if (p->size < 0)
			delete (ns1__ProblemList*)p->ptr;
		else
			delete[] (ns1__ProblemList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ProxyList:
		if (p->size < 0)
			delete (ns1__ProxyList*)p->ptr;
		else
			delete[] (ns1__ProxyList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Query:
		if (p->size < 0)
			delete (ns1__Query*)p->ptr;
		else
			delete[] (ns1__Query*)p->ptr;
		break;
	case SOAP_TYPE_ns1__QueryTarget:
		if (p->size < 0)
			delete (ns1__QueryTarget*)p->ptr;
		else
			delete[] (ns1__QueryTarget*)p->ptr;
		break;
	case SOAP_TYPE_ns1__RecipientList:
		if (p->size < 0)
			delete (ns1__RecipientList*)p->ptr;
		else
			delete[] (ns1__RecipientList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__RecipientStatus:
		if (p->size < 0)
			delete (ns1__RecipientStatus*)p->ptr;
		else
			delete[] (ns1__RecipientStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns1__RecurrenceDateType:
		if (p->size < 0)
			delete (ns1__RecurrenceDateType*)p->ptr;
		else
			delete[] (ns1__RecurrenceDateType*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ReturnNotification:
		if (p->size < 0)
			delete (ns1__ReturnNotification*)p->ptr;
		else
			delete[] (ns1__ReturnNotification*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ReturnNotificationOptions:
		if (p->size < 0)
			delete (ns1__ReturnNotificationOptions*)p->ptr;
		else
			delete[] (ns1__ReturnNotificationOptions*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Rights:
		if (p->size < 0)
			delete (ns1__Rights*)p->ptr;
		else
			delete[] (ns1__Rights*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SendOptionsRequestReply:
		if (p->size < 0)
			delete (ns1__SendOptionsRequestReply*)p->ptr;
		else
			delete[] (ns1__SendOptionsRequestReply*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SendOptions:
		if (p->size < 0)
			delete (ns1__SendOptions*)p->ptr;
		else
			delete[] (ns1__SendOptions*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Settings:
		if (p->size < 0)
			delete (ns1__Settings*)p->ptr;
		else
			delete[] (ns1__Settings*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SettingsGroup:
		if (p->size < 0)
			delete (ns1__SettingsGroup*)p->ptr;
		else
			delete[] (ns1__SettingsGroup*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SettingsList:
		if (p->size < 0)
			delete (ns1__SettingsList*)p->ptr;
		else
			delete[] (ns1__SettingsList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SharedFolderNotification:
		if (p->size < 0)
			delete (ns1__SharedFolderNotification*)p->ptr;
		else
			delete[] (ns1__SharedFolderNotification*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Status:
		if (p->size < 0)
			delete (ns1__Status*)p->ptr;
		else
			delete[] (ns1__Status*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Timezone:
		if (p->size < 0)
			delete (ns1__Timezone*)p->ptr;
		else
			delete[] (ns1__Timezone*)p->ptr;
		break;
	case SOAP_TYPE_ns1__TimezoneComponent:
		if (p->size < 0)
			delete (ns1__TimezoneComponent*)p->ptr;
		else
			delete[] (ns1__TimezoneComponent*)p->ptr;
		break;
	case SOAP_TYPE_ns1__TimezoneList:
		if (p->size < 0)
			delete (ns1__TimezoneList*)p->ptr;
		else
			delete[] (ns1__TimezoneList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__UserInfo:
		if (p->size < 0)
			delete (ns1__UserInfo*)p->ptr;
		else
			delete[] (ns1__UserInfo*)p->ptr;
		break;
	case SOAP_TYPE__ns1__acceptRequest:
		if (p->size < 0)
			delete (_ns1__acceptRequest*)p->ptr;
		else
			delete[] (_ns1__acceptRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__acceptResponse:
		if (p->size < 0)
			delete (_ns1__acceptResponse*)p->ptr;
		else
			delete[] (_ns1__acceptResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__addItemRequest:
		if (p->size < 0)
			delete (_ns1__addItemRequest*)p->ptr;
		else
			delete[] (_ns1__addItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__addItemResponse:
		if (p->size < 0)
			delete (_ns1__addItemResponse*)p->ptr;
		else
			delete[] (_ns1__addItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__addItemsRequest:
		if (p->size < 0)
			delete (_ns1__addItemsRequest*)p->ptr;
		else
			delete[] (_ns1__addItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__addItemsResponse:
		if (p->size < 0)
			delete (_ns1__addItemsResponse*)p->ptr;
		else
			delete[] (_ns1__addItemsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__addMembersRequest:
		if (p->size < 0)
			delete (_ns1__addMembersRequest*)p->ptr;
		else
			delete[] (_ns1__addMembersRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__addMembersResponse:
		if (p->size < 0)
			delete (_ns1__addMembersResponse*)p->ptr;
		else
			delete[] (_ns1__addMembersResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__closeFreeBusySessionRequest:
		if (p->size < 0)
			delete (_ns1__closeFreeBusySessionRequest*)p->ptr;
		else
			delete[] (_ns1__closeFreeBusySessionRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__closeFreeBusySessionResponse:
		if (p->size < 0)
			delete (_ns1__closeFreeBusySessionResponse*)p->ptr;
		else
			delete[] (_ns1__closeFreeBusySessionResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__completeRequest:
		if (p->size < 0)
			delete (_ns1__completeRequest*)p->ptr;
		else
			delete[] (_ns1__completeRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__completeResponse:
		if (p->size < 0)
			delete (_ns1__completeResponse*)p->ptr;
		else
			delete[] (_ns1__completeResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__createCursorRequest:
		if (p->size < 0)
			delete (_ns1__createCursorRequest*)p->ptr;
		else
			delete[] (_ns1__createCursorRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__createCursorResponse:
		if (p->size < 0)
			delete (_ns1__createCursorResponse*)p->ptr;
		else
			delete[] (_ns1__createCursorResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__createItemRequest:
		if (p->size < 0)
			delete (_ns1__createItemRequest*)p->ptr;
		else
			delete[] (_ns1__createItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__createItemResponse:
		if (p->size < 0)
			delete (_ns1__createItemResponse*)p->ptr;
		else
			delete[] (_ns1__createItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__createProxyAccessRequest:
		if (p->size < 0)
			delete (_ns1__createProxyAccessRequest*)p->ptr;
		else
			delete[] (_ns1__createProxyAccessRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__createProxyAccessResponse:
		if (p->size < 0)
			delete (_ns1__createProxyAccessResponse*)p->ptr;
		else
			delete[] (_ns1__createProxyAccessResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__declineRequest:
		if (p->size < 0)
			delete (_ns1__declineRequest*)p->ptr;
		else
			delete[] (_ns1__declineRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__declineResponse:
		if (p->size < 0)
			delete (_ns1__declineResponse*)p->ptr;
		else
			delete[] (_ns1__declineResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__delegateRequest:
		if (p->size < 0)
			delete (_ns1__delegateRequest*)p->ptr;
		else
			delete[] (_ns1__delegateRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__delegateResponse:
		if (p->size < 0)
			delete (_ns1__delegateResponse*)p->ptr;
		else
			delete[] (_ns1__delegateResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__destroyCursorRequest:
		if (p->size < 0)
			delete (_ns1__destroyCursorRequest*)p->ptr;
		else
			delete[] (_ns1__destroyCursorRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__destroyCursorResponse:
		if (p->size < 0)
			delete (_ns1__destroyCursorResponse*)p->ptr;
		else
			delete[] (_ns1__destroyCursorResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getAddressBookListResponse:
		if (p->size < 0)
			delete (_ns1__getAddressBookListResponse*)p->ptr;
		else
			delete[] (_ns1__getAddressBookListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getAttachmentRequest:
		if (p->size < 0)
			delete (_ns1__getAttachmentRequest*)p->ptr;
		else
			delete[] (_ns1__getAttachmentRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getAttachmentResponse:
		if (p->size < 0)
			delete (_ns1__getAttachmentResponse*)p->ptr;
		else
			delete[] (_ns1__getAttachmentResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getCategoryListResponse:
		if (p->size < 0)
			delete (_ns1__getCategoryListResponse*)p->ptr;
		else
			delete[] (_ns1__getCategoryListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getCustomListResponse:
		if (p->size < 0)
			delete (_ns1__getCustomListResponse*)p->ptr;
		else
			delete[] (_ns1__getCustomListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getDeltaRequest:
		if (p->size < 0)
			delete (_ns1__getDeltaRequest*)p->ptr;
		else
			delete[] (_ns1__getDeltaRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getDeltaResponse:
		if (p->size < 0)
			delete (_ns1__getDeltaResponse*)p->ptr;
		else
			delete[] (_ns1__getDeltaResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getFolderListRequest:
		if (p->size < 0)
			delete (_ns1__getFolderListRequest*)p->ptr;
		else
			delete[] (_ns1__getFolderListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getFolderListResponse:
		if (p->size < 0)
			delete (_ns1__getFolderListResponse*)p->ptr;
		else
			delete[] (_ns1__getFolderListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getFreeBusyRequest:
		if (p->size < 0)
			delete (_ns1__getFreeBusyRequest*)p->ptr;
		else
			delete[] (_ns1__getFreeBusyRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getFreeBusyResponse:
		if (p->size < 0)
			delete (_ns1__getFreeBusyResponse*)p->ptr;
		else
			delete[] (_ns1__getFreeBusyResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getItemRequest:
		if (p->size < 0)
			delete (_ns1__getItemRequest*)p->ptr;
		else
			delete[] (_ns1__getItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getItemResponse:
		if (p->size < 0)
			delete (_ns1__getItemResponse*)p->ptr;
		else
			delete[] (_ns1__getItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getItemsRequest:
		if (p->size < 0)
			delete (_ns1__getItemsRequest*)p->ptr;
		else
			delete[] (_ns1__getItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getItemsResponse:
		if (p->size < 0)
			delete (_ns1__getItemsResponse*)p->ptr;
		else
			delete[] (_ns1__getItemsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getProxyAccessListResponse:
		if (p->size < 0)
			delete (_ns1__getProxyAccessListResponse*)p->ptr;
		else
			delete[] (_ns1__getProxyAccessListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getProxyListResponse:
		if (p->size < 0)
			delete (_ns1__getProxyListResponse*)p->ptr;
		else
			delete[] (_ns1__getProxyListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getSettingsRequest:
		if (p->size < 0)
			delete (_ns1__getSettingsRequest*)p->ptr;
		else
			delete[] (_ns1__getSettingsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getSettingsResponse:
		if (p->size < 0)
			delete (_ns1__getSettingsResponse*)p->ptr;
		else
			delete[] (_ns1__getSettingsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getTimezoneListResponse:
		if (p->size < 0)
			delete (_ns1__getTimezoneListResponse*)p->ptr;
		else
			delete[] (_ns1__getTimezoneListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__loginRequest:
		if (p->size < 0)
			delete (_ns1__loginRequest*)p->ptr;
		else
			delete[] (_ns1__loginRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__loginResponse:
		if (p->size < 0)
			delete (_ns1__loginResponse*)p->ptr;
		else
			delete[] (_ns1__loginResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__logoutResponse:
		if (p->size < 0)
			delete (_ns1__logoutResponse*)p->ptr;
		else
			delete[] (_ns1__logoutResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__markReadRequest:
		if (p->size < 0)
			delete (_ns1__markReadRequest*)p->ptr;
		else
			delete[] (_ns1__markReadRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__markReadResponse:
		if (p->size < 0)
			delete (_ns1__markReadResponse*)p->ptr;
		else
			delete[] (_ns1__markReadResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__markUnReadRequest:
		if (p->size < 0)
			delete (_ns1__markUnReadRequest*)p->ptr;
		else
			delete[] (_ns1__markUnReadRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__markUnReadResponse:
		if (p->size < 0)
			delete (_ns1__markUnReadResponse*)p->ptr;
		else
			delete[] (_ns1__markUnReadResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__modifyItemRequest:
		if (p->size < 0)
			delete (_ns1__modifyItemRequest*)p->ptr;
		else
			delete[] (_ns1__modifyItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__modifyItemResponse:
		if (p->size < 0)
			delete (_ns1__modifyItemResponse*)p->ptr;
		else
			delete[] (_ns1__modifyItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__modifyProxyAccessRequest:
		if (p->size < 0)
			delete (_ns1__modifyProxyAccessRequest*)p->ptr;
		else
			delete[] (_ns1__modifyProxyAccessRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__modifyProxyAccessResponse:
		if (p->size < 0)
			delete (_ns1__modifyProxyAccessResponse*)p->ptr;
		else
			delete[] (_ns1__modifyProxyAccessResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__modifySettingsRequest:
		if (p->size < 0)
			delete (_ns1__modifySettingsRequest*)p->ptr;
		else
			delete[] (_ns1__modifySettingsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__modifySettingsResponse:
		if (p->size < 0)
			delete (_ns1__modifySettingsResponse*)p->ptr;
		else
			delete[] (_ns1__modifySettingsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__positionCursorRequest:
		if (p->size < 0)
			delete (_ns1__positionCursorRequest*)p->ptr;
		else
			delete[] (_ns1__positionCursorRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__positionCursorResponse:
		if (p->size < 0)
			delete (_ns1__positionCursorResponse*)p->ptr;
		else
			delete[] (_ns1__positionCursorResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__purgeDeletedItemsRequest:
		if (p->size < 0)
			delete (_ns1__purgeDeletedItemsRequest*)p->ptr;
		else
			delete[] (_ns1__purgeDeletedItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__purgeDeletedItemsResponse:
		if (p->size < 0)
			delete (_ns1__purgeDeletedItemsResponse*)p->ptr;
		else
			delete[] (_ns1__purgeDeletedItemsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__purgeItemRequest:
		if (p->size < 0)
			delete (_ns1__purgeItemRequest*)p->ptr;
		else
			delete[] (_ns1__purgeItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__purgeItemResponse:
		if (p->size < 0)
			delete (_ns1__purgeItemResponse*)p->ptr;
		else
			delete[] (_ns1__purgeItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__readCursorRequest:
		if (p->size < 0)
			delete (_ns1__readCursorRequest*)p->ptr;
		else
			delete[] (_ns1__readCursorRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__readCursorResponse:
		if (p->size < 0)
			delete (_ns1__readCursorResponse*)p->ptr;
		else
			delete[] (_ns1__readCursorResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__removeItemRequest:
		if (p->size < 0)
			delete (_ns1__removeItemRequest*)p->ptr;
		else
			delete[] (_ns1__removeItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__removeItemResponse:
		if (p->size < 0)
			delete (_ns1__removeItemResponse*)p->ptr;
		else
			delete[] (_ns1__removeItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__removeItemsRequest:
		if (p->size < 0)
			delete (_ns1__removeItemsRequest*)p->ptr;
		else
			delete[] (_ns1__removeItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__removeItemsResponse:
		if (p->size < 0)
			delete (_ns1__removeItemsResponse*)p->ptr;
		else
			delete[] (_ns1__removeItemsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__removeMembersRequest:
		if (p->size < 0)
			delete (_ns1__removeMembersRequest*)p->ptr;
		else
			delete[] (_ns1__removeMembersRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__removeMembersResponse:
		if (p->size < 0)
			delete (_ns1__removeMembersResponse*)p->ptr;
		else
			delete[] (_ns1__removeMembersResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__removeProxyAccessRequest:
		if (p->size < 0)
			delete (_ns1__removeProxyAccessRequest*)p->ptr;
		else
			delete[] (_ns1__removeProxyAccessRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__removeProxyAccessResponse:
		if (p->size < 0)
			delete (_ns1__removeProxyAccessResponse*)p->ptr;
		else
			delete[] (_ns1__removeProxyAccessResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__retractRequest:
		if (p->size < 0)
			delete (_ns1__retractRequest*)p->ptr;
		else
			delete[] (_ns1__retractRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__retractResponse:
		if (p->size < 0)
			delete (_ns1__retractResponse*)p->ptr;
		else
			delete[] (_ns1__retractResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__sendItemRequest:
		if (p->size < 0)
			delete (_ns1__sendItemRequest*)p->ptr;
		else
			delete[] (_ns1__sendItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__sendItemResponse:
		if (p->size < 0)
			delete (_ns1__sendItemResponse*)p->ptr;
		else
			delete[] (_ns1__sendItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__startFreeBusySessionRequest:
		if (p->size < 0)
			delete (_ns1__startFreeBusySessionRequest*)p->ptr;
		else
			delete[] (_ns1__startFreeBusySessionRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__startFreeBusySessionResponse:
		if (p->size < 0)
			delete (_ns1__startFreeBusySessionResponse*)p->ptr;
		else
			delete[] (_ns1__startFreeBusySessionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AccessControlListEntry:
		if (p->size < 0)
			delete (ns1__AccessControlListEntry*)p->ptr;
		else
			delete[] (ns1__AccessControlListEntry*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AccessRightEntry:
		if (p->size < 0)
			delete (ns1__AccessRightEntry*)p->ptr;
		else
			delete[] (ns1__AccessRightEntry*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AddressBook:
		if (p->size < 0)
			delete (ns1__AddressBook*)p->ptr;
		else
			delete[] (ns1__AddressBook*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Alarm:
		if (p->size < 0)
			delete (ns1__Alarm*)p->ptr;
		else
			delete[] (ns1__Alarm*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Category:
		if (p->size < 0)
			delete (ns1__Category*)p->ptr;
		else
			delete[] (ns1__Category*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CommentStatus:
		if (p->size < 0)
			delete (ns1__CommentStatus*)p->ptr;
		else
			delete[] (ns1__CommentStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ContainerItem:
		if (p->size < 0)
			delete (ns1__ContainerItem*)p->ptr;
		else
			delete[] (ns1__ContainerItem*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ContainerRef:
		if (p->size < 0)
			delete (ns1__ContainerRef*)p->ptr;
		else
			delete[] (ns1__ContainerRef*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DelegatedStatus:
		if (p->size < 0)
			delete (ns1__DelegatedStatus*)p->ptr;
		else
			delete[] (ns1__DelegatedStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DelegateeStatus:
		if (p->size < 0)
			delete (ns1__DelegateeStatus*)p->ptr;
		else
			delete[] (ns1__DelegateeStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FilterEntry:
		if (p->size < 0)
			delete (ns1__FilterEntry*)p->ptr;
		else
			delete[] (ns1__FilterEntry*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FilterGroup:
		if (p->size < 0)
			delete (ns1__FilterGroup*)p->ptr;
		else
			delete[] (ns1__FilterGroup*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Folder:
		if (p->size < 0)
			delete (ns1__Folder*)p->ptr;
		else
			delete[] (ns1__Folder*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FreeBusyUser:
		if (p->size < 0)
			delete (ns1__FreeBusyUser*)p->ptr;
		else
			delete[] (ns1__FreeBusyUser*)p->ptr;
		break;
	case SOAP_TYPE_ns1__From:
		if (p->size < 0)
			delete (ns1__From*)p->ptr;
		else
			delete[] (ns1__From*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ItemList:
		if (p->size < 0)
			delete (ns1__ItemList*)p->ptr;
		else
			delete[] (ns1__ItemList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ItemRef:
		if (p->size < 0)
			delete (ns1__ItemRef*)p->ptr;
		else
			delete[] (ns1__ItemRef*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MessagePart:
		if (p->size < 0)
			delete (ns1__MessagePart*)p->ptr;
		else
			delete[] (ns1__MessagePart*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PlainText:
		if (p->size < 0)
			delete (ns1__PlainText*)p->ptr;
		else
			delete[] (ns1__PlainText*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Proxy:
		if (p->size < 0)
			delete (ns1__Proxy*)p->ptr;
		else
			delete[] (ns1__Proxy*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Recipient:
		if (p->size < 0)
			delete (ns1__Recipient*)p->ptr;
		else
			delete[] (ns1__Recipient*)p->ptr;
		break;
	case SOAP_TYPE_ns1__TrustedApplication:
		if (p->size < 0)
			delete (ns1__TrustedApplication*)p->ptr;
		else
			delete[] (ns1__TrustedApplication*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AddressBookItem:
		if (p->size < 0)
			delete (ns1__AddressBookItem*)p->ptr;
		else
			delete[] (ns1__AddressBookItem*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AttachmentID:
		if (p->size < 0)
			delete (ns1__AttachmentID*)p->ptr;
		else
			delete[] (ns1__AttachmentID*)p->ptr;
		break;
	case SOAP_TYPE_ns1__BoxEntry:
		if (p->size < 0)
			delete (ns1__BoxEntry*)p->ptr;
		else
			delete[] (ns1__BoxEntry*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DayOfWeek:
		if (p->size < 0)
			delete (ns1__DayOfWeek*)p->ptr;
		else
			delete[] (ns1__DayOfWeek*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FolderACLEntry:
		if (p->size < 0)
			delete (ns1__FolderACLEntry*)p->ptr;
		else
			delete[] (ns1__FolderACLEntry*)p->ptr;
		break;
	case SOAP_TYPE_ns1__FreeBusyInfo:
		if (p->size < 0)
			delete (ns1__FreeBusyInfo*)p->ptr;
		else
			delete[] (ns1__FreeBusyInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__QueryFolder:
		if (p->size < 0)
			delete (ns1__QueryFolder*)p->ptr;
		else
			delete[] (ns1__QueryFolder*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SharedFolder:
		if (p->size < 0)
			delete (ns1__SharedFolder*)p->ptr;
		else
			delete[] (ns1__SharedFolder*)p->ptr;
		break;
	case SOAP_TYPE_ns1__StatusTracking:
		if (p->size < 0)
			delete (ns1__StatusTracking*)p->ptr;
		else
			delete[] (ns1__StatusTracking*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SystemFolder:
		if (p->size < 0)
			delete (ns1__SystemFolder*)p->ptr;
		else
			delete[] (ns1__SystemFolder*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Contact:
		if (p->size < 0)
			delete (ns1__Contact*)p->ptr;
		else
			delete[] (ns1__Contact*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ContactFolder:
		if (p->size < 0)
			delete (ns1__ContactFolder*)p->ptr;
		else
			delete[] (ns1__ContactFolder*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Group:
		if (p->size < 0)
			delete (ns1__Group*)p->ptr;
		else
			delete[] (ns1__Group*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Mail:
		if (p->size < 0)
			delete (ns1__Mail*)p->ptr;
		else
			delete[] (ns1__Mail*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Organization:
		if (p->size < 0)
			delete (ns1__Organization*)p->ptr;
		else
			delete[] (ns1__Organization*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Resource:
		if (p->size < 0)
			delete (ns1__Resource*)p->ptr;
		else
			delete[] (ns1__Resource*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CalendarItem:
		if (p->size < 0)
			delete (ns1__CalendarItem*)p->ptr;
		else
			delete[] (ns1__CalendarItem*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DocumentRef:
		if (p->size < 0)
			delete (ns1__DocumentRef*)p->ptr;
		else
			delete[] (ns1__DocumentRef*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PhoneMessage:
		if (p->size < 0)
			delete (ns1__PhoneMessage*)p->ptr;
		else
			delete[] (ns1__PhoneMessage*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Appointment:
		if (p->size < 0)
			delete (ns1__Appointment*)p->ptr;
		else
			delete[] (ns1__Appointment*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Note:
		if (p->size < 0)
			delete (ns1__Note*)p->ptr;
		else
			delete[] (ns1__Note*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Task:
		if (p->size < 0)
			delete (ns1__Task*)p->ptr;
		else
			delete[] (ns1__Task*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE___ns3__getCategoryListRequest:
		if (p->size < 0)
			delete (struct __ns3__getCategoryListRequest*)p->ptr;
		else
			delete[] (struct __ns3__getCategoryListRequest*)p->ptr;
		break;
	case SOAP_TYPE___ns4__getAddressBookListRequest:
		if (p->size < 0)
			delete (struct __ns4__getAddressBookListRequest*)p->ptr;
		else
			delete[] (struct __ns4__getAddressBookListRequest*)p->ptr;
		break;
	case SOAP_TYPE_ns1__View:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ns1__uid:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ns1__UUID:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FilterElement:

		if (p->size < 0)
			delete (std::vector<ns1__FilterElement * >*)p->ptr;
		else
			delete[] (std::vector<ns1__FilterElement * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ContainerRef:

		if (p->size < 0)
			delete (std::vector<ns1__ContainerRef * >*)p->ptr;
		else
			delete[] (std::vector<ns1__ContainerRef * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Timezone:

		if (p->size < 0)
			delete (std::vector<ns1__Timezone * >*)p->ptr;
		else
			delete[] (std::vector<ns1__Timezone * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SettingsGroup:

		if (p->size < 0)
			delete (std::vector<ns1__SettingsGroup * >*)p->ptr;
		else
			delete[] (std::vector<ns1__SettingsGroup * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__date:

		if (p->size < 0)
			delete (std::vector<char * >*)p->ptr;
		else
			delete[] (std::vector<char * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Recipient:

		if (p->size < 0)
			delete (std::vector<ns1__Recipient * >*)p->ptr;
		else
			delete[] (std::vector<ns1__Recipient * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__NameAndEmail:

		if (p->size < 0)
			delete (std::vector<ns1__NameAndEmail * >*)p->ptr;
		else
			delete[] (std::vector<ns1__NameAndEmail * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProblemEntry:

		if (p->size < 0)
			delete (std::vector<ns1__ProblemEntry * >*)p->ptr;
		else
			delete[] (std::vector<ns1__ProblemEntry * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PostalAddress:

		if (p->size < 0)
			delete (std::vector<ns1__PostalAddress * >*)p->ptr;
		else
			delete[] (std::vector<ns1__PostalAddress * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MessagePart:

		if (p->size < 0)
			delete (std::vector<ns1__MessagePart * >*)p->ptr;
		else
			delete[] (std::vector<ns1__MessagePart * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Item:

		if (p->size < 0)
			delete (std::vector<ns1__Item * >*)p->ptr;
		else
			delete[] (std::vector<ns1__Item * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ImAddress:

		if (p->size < 0)
			delete (std::vector<ns1__ImAddress * >*)p->ptr;
		else
			delete[] (std::vector<ns1__ImAddress * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupMember:

		if (p->size < 0)
			delete (std::vector<ns1__GroupMember * >*)p->ptr;
		else
			delete[] (std::vector<ns1__GroupMember * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyInfo:

		if (p->size < 0)
			delete (std::vector<ns1__FreeBusyInfo * >*)p->ptr;
		else
			delete[] (std::vector<ns1__FreeBusyInfo * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyUser:

		if (p->size < 0)
			delete (std::vector<ns1__FreeBusyUser * >*)p->ptr;
		else
			delete[] (std::vector<ns1__FreeBusyUser * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyBlock:

		if (p->size < 0)
			delete (std::vector<ns1__FreeBusyBlock * >*)p->ptr;
		else
			delete[] (std::vector<ns1__FreeBusyBlock * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Folder:

		if (p->size < 0)
			delete (std::vector<ns1__Folder * >*)p->ptr;
		else
			delete[] (std::vector<ns1__Folder * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FolderACLEntry:

		if (p->size < 0)
			delete (std::vector<ns1__FolderACLEntry * >*)p->ptr;
		else
			delete[] (std::vector<ns1__FolderACLEntry * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:

		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Custom:

		if (p->size < 0)
			delete (std::vector<ns1__Custom * >*)p->ptr;
		else
			delete[] (std::vector<ns1__Custom * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__uid:

		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Category:

		if (p->size < 0)
			delete (std::vector<ns1__Category * >*)p->ptr;
		else
			delete[] (std::vector<ns1__Category * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttachmentItemInfo:

		if (p->size < 0)
			delete (std::vector<ns1__AttachmentItemInfo * >*)p->ptr;
		else
			delete[] (std::vector<ns1__AttachmentItemInfo * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AddressBook:

		if (p->size < 0)
			delete (std::vector<ns1__AddressBook * >*)p->ptr;
		else
			delete[] (std::vector<ns1__AddressBook * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessRightEntry:

		if (p->size < 0)
			delete (std::vector<ns1__AccessRightEntry * >*)p->ptr;
		else
			delete[] (std::vector<ns1__AccessRightEntry * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessControlListEntry:

		if (p->size < 0)
			delete (std::vector<ns1__AccessControlListEntry * >*)p->ptr;
		else
			delete[] (std::vector<ns1__AccessControlListEntry * >*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	struct soap_ilist *ip;
	DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Class id enter id='%s' t=%d loc=%p type='%s' arrayType='%s'\n", id, t, p, type?type:"", arrayType?arrayType:""));
	soap->alloced = 0;
	if (!*id)
	{	if (!p)
			return soap_instantiate(soap, t, type, arrayType, NULL);
		else
			return p;
	}
	ip = soap_lookup(soap, id);
	if (!ip)
	{	ip = soap_enter(soap, id);
		ip->type = t;
		ip->link = NULL;
		ip->copy = NULL;
		ip->flist = NULL;
		if (!p)
			p = soap_instantiate(soap, t, type, arrayType, &n);
		ip->ptr = p;
		ip->size = n;
		ip->level = 0;
	}
	else if (ip->ptr)
	{	if (p)
		{	soap->error = SOAP_MULTI_ID;
			return NULL;
		}
	}
	else
	{	if (!p)
			p = soap_instantiate(soap, t, type, arrayType, &n);
		ip->ptr = p;
		ip->size = n;
		ip->level = 0;
		if (!soap->blist)
			soap_resolve_ptr(ip);
	}
	return ip->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, int t, void *p, unsigned int k)
{	struct soap_ilist *ip = soap_lookup(soap, href);
	if (ip)
	{	if (ip->ptr && ip->level == k)
			soap_container_insert(soap, t, p, ip->ptr);
		else
		{	register struct soap_flist *fp = (struct soap_flist*)SOAP_MALLOC(sizeof(struct soap_flist));
			if (fp)
			{	fp->next = ip->flist;
				fp->type = t;
				fp->ptr = p;
				fp->level = k;
				fp->finsert = soap_container_insert;
				ip->flist = fp;
			}
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container forwarding type=%d location=%p level=%d\n", t, p, k));
		}
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int t, void *p, void *q)
{	switch (t)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FilterElement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__FilterElement * >*)p)->insert(((std::vector<ns1__FilterElement * >*)p)->end(), *(ns1__FilterElement **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ContainerRef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__ContainerRef * >*)p)->insert(((std::vector<ns1__ContainerRef * >*)p)->end(), *(ns1__ContainerRef **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Timezone:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__Timezone * >*)p)->insert(((std::vector<ns1__Timezone * >*)p)->end(), *(ns1__Timezone **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SettingsGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__SettingsGroup * >*)p)->insert(((std::vector<ns1__SettingsGroup * >*)p)->end(), *(ns1__SettingsGroup **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__date:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<char * >*)p)->insert(((std::vector<char * >*)p)->end(), *(char **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Recipient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__Recipient * >*)p)->insert(((std::vector<ns1__Recipient * >*)p)->end(), *(ns1__Recipient **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__NameAndEmail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__NameAndEmail * >*)p)->insert(((std::vector<ns1__NameAndEmail * >*)p)->end(), *(ns1__NameAndEmail **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProblemEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__ProblemEntry * >*)p)->insert(((std::vector<ns1__ProblemEntry * >*)p)->end(), *(ns1__ProblemEntry **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PostalAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__PostalAddress * >*)p)->insert(((std::vector<ns1__PostalAddress * >*)p)->end(), *(ns1__PostalAddress **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MessagePart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__MessagePart * >*)p)->insert(((std::vector<ns1__MessagePart * >*)p)->end(), *(ns1__MessagePart **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Item:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__Item * >*)p)->insert(((std::vector<ns1__Item * >*)p)->end(), *(ns1__Item **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ImAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__ImAddress * >*)p)->insert(((std::vector<ns1__ImAddress * >*)p)->end(), *(ns1__ImAddress **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupMember:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__GroupMember * >*)p)->insert(((std::vector<ns1__GroupMember * >*)p)->end(), *(ns1__GroupMember **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__FreeBusyInfo * >*)p)->insert(((std::vector<ns1__FreeBusyInfo * >*)p)->end(), *(ns1__FreeBusyInfo **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__FreeBusyUser * >*)p)->insert(((std::vector<ns1__FreeBusyUser * >*)p)->end(), *(ns1__FreeBusyUser **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyBlock:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__FreeBusyBlock * >*)p)->insert(((std::vector<ns1__FreeBusyBlock * >*)p)->end(), *(ns1__FreeBusyBlock **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Folder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__Folder * >*)p)->insert(((std::vector<ns1__Folder * >*)p)->end(), *(ns1__Folder **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FolderACLEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__FolderACLEntry * >*)p)->insert(((std::vector<ns1__FolderACLEntry * >*)p)->end(), *(ns1__FolderACLEntry **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<std::string >*)p)->insert(((std::vector<std::string >*)p)->end(), *(std::string *)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Custom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__Custom * >*)p)->insert(((std::vector<ns1__Custom * >*)p)->end(), *(ns1__Custom **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__uid:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<std::string >*)p)->insert(((std::vector<std::string >*)p)->end(), *(std::string *)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Category:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__Category * >*)p)->insert(((std::vector<ns1__Category * >*)p)->end(), *(ns1__Category **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttachmentItemInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__AttachmentItemInfo * >*)p)->insert(((std::vector<ns1__AttachmentItemInfo * >*)p)->end(), *(ns1__AttachmentItemInfo **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AddressBook:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__AddressBook * >*)p)->insert(((std::vector<ns1__AddressBook * >*)p)->end(), *(ns1__AddressBook **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessRightEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__AccessRightEntry * >*)p)->insert(((std::vector<ns1__AccessRightEntry * >*)p)->end(), *(ns1__AccessRightEntry **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessControlListEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d location=%p\n", t, p));
		((std::vector<ns1__AccessControlListEntry * >*)p)->insert(((std::vector<ns1__AccessControlListEntry * >*)p)->end(), *(ns1__AccessControlListEntry **)q);
		break;
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_byte(struct soap *soap, char const*a)
{
	soap_reference(soap, a, SOAP_TYPE_byte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_byte);
	soap_out_byte(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GMTOffset(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_ns1__GMTOffset
	*a = SOAP_DEFAULT_ns1__GMTOffset;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GMTOffset(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__GMTOffset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GMTOffset(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__GMTOffset);
	soap_out_ns1__GMTOffset(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GMTOffset(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns1__GMTOffset);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns1__GMTOffset(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GMTOffset(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_ns1__GMTOffset(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_ns1__GMTOffset);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_int);
	soap_out_int(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_long(struct soap *soap, long const*a)
{
	soap_reference(soap, a, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_long);
	soap_out_long(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{
	return soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Month(struct soap *soap, unsigned char *a)
{
#ifdef SOAP_DEFAULT_ns1__Month
	*a = SOAP_DEFAULT_ns1__Month;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Month(struct soap *soap, unsigned char const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__Month);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Month(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__Month);
	soap_out_ns1__Month(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Month(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_ns1__Month);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_ns1__Month(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Month(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_ns1__Month(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_ns1__Month);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Minute(struct soap *soap, unsigned char *a)
{
#ifdef SOAP_DEFAULT_ns1__Minute
	*a = SOAP_DEFAULT_ns1__Minute;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Minute(struct soap *soap, unsigned char const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__Minute);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Minute(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__Minute);
	soap_out_ns1__Minute(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Minute(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_ns1__Minute);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_ns1__Minute(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Minute(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_ns1__Minute(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_ns1__Minute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Hour(struct soap *soap, unsigned char *a)
{
#ifdef SOAP_DEFAULT_ns1__Hour
	*a = SOAP_DEFAULT_ns1__Hour;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Hour(struct soap *soap, unsigned char const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__Hour);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Hour(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__Hour);
	soap_out_ns1__Hour(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Hour(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_ns1__Hour);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_ns1__Hour(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Hour(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_ns1__Hour(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_ns1__Hour);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Day(struct soap *soap, unsigned char *a)
{
#ifdef SOAP_DEFAULT_ns1__Day
	*a = SOAP_DEFAULT_ns1__Day;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Day(struct soap *soap, unsigned char const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__Day);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Day(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__Day);
	soap_out_ns1__Day(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Day(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_ns1__Day);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_ns1__Day(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Day(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_ns1__Day(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_ns1__Day);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedByte(struct soap *soap, unsigned char const*a)
{
	soap_reference(soap, a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_unsignedByte);
	soap_out_unsignedByte(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedInt(struct soap *soap, unsigned int const*a)
{
	soap_reference(soap, a, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_unsignedInt);
	soap_out_unsignedInt(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLong(struct soap *soap, unsigned long *a)
{
#ifdef SOAP_DEFAULT_unsignedLong
	*a = SOAP_DEFAULT_unsignedLong;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_unsignedLong(struct soap *soap, unsigned long const*a)
{
	soap_reference(soap, a, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLong(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_unsignedLong);
	soap_out_unsignedLong(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLong(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_unsignedLong(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_unsignedLong(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bool(struct soap *soap, bool const*a)
{
	soap_reference(soap, a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_bool);
	soap_out_bool(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_bool2s(struct soap *soap, bool n)
{	const char *s = soap_str_code(soap_codes_bool, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (bool)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (!a || soap_s2bool(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0), SOAP_TYPE_bool, sizeof(bool));
		if (a && soap->alloced)
			soap_default_bool(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__WeekDay(struct soap *soap, enum ns1__WeekDay *a)
{
#ifdef SOAP_DEFAULT_ns1__WeekDay
	*a = SOAP_DEFAULT_ns1__WeekDay;
#else
	*a = (enum ns1__WeekDay)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__WeekDay(struct soap *soap, enum ns1__WeekDay const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__WeekDay);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__WeekDay(struct soap *soap, const enum ns1__WeekDay *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__WeekDay);
	soap_out_ns1__WeekDay(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__WeekDay[] =
{	{ (long)Sunday, "Sunday" },
	{ (long)Monday, "Monday" },
	{ (long)Tuesday, "Tuesday" },
	{ (long)Wednesday, "Wednesday" },
	{ (long)Thursday, "Thursday" },
	{ (long)Friday, "Friday" },
	{ (long)Saturday, "Saturday" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__WeekDay2s(struct soap *soap, enum ns1__WeekDay n)
{	const char *s = soap_str_code(soap_codes_ns1__WeekDay, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WeekDay(struct soap *soap, const char *tag, int id, const enum ns1__WeekDay *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WeekDay), type);
	soap_send(soap, soap_ns1__WeekDay2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__WeekDay * SOAP_FMAC4 soap_get_ns1__WeekDay(struct soap *soap, enum ns1__WeekDay *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WeekDay(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__WeekDay(struct soap *soap, const char *s, enum ns1__WeekDay *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__WeekDay, s);
	if (map)
		*a = (enum ns1__WeekDay)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__WeekDay)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__WeekDay * SOAP_FMAC4 soap_in_ns1__WeekDay(struct soap *soap, const char *tag, enum ns1__WeekDay *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__WeekDay *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WeekDay, sizeof(enum ns1__WeekDay), 0);
		if (!a || soap_s2ns1__WeekDay(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__WeekDay *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WeekDay, sizeof(enum ns1__WeekDay), 0), SOAP_TYPE_ns1__WeekDay, sizeof(enum ns1__WeekDay));
		if (a && soap->alloced)
			soap_default_ns1__WeekDay(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__StatusTrackingOptions(struct soap *soap, enum ns1__StatusTrackingOptions *a)
{
#ifdef SOAP_DEFAULT_ns1__StatusTrackingOptions
	*a = SOAP_DEFAULT_ns1__StatusTrackingOptions;
#else
	*a = (enum ns1__StatusTrackingOptions)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__StatusTrackingOptions(struct soap *soap, enum ns1__StatusTrackingOptions const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__StatusTrackingOptions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StatusTrackingOptions(struct soap *soap, const enum ns1__StatusTrackingOptions *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__StatusTrackingOptions);
	soap_out_ns1__StatusTrackingOptions(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__StatusTrackingOptions[] =
{	{ (long)None, "None" },
	{ (long)Delivered, "Delivered" },
	{ (long)DeliveredAndOpened, "DeliveredAndOpened" },
	{ (long)All, "All" },
	{ (long)Full, "Full" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__StatusTrackingOptions2s(struct soap *soap, enum ns1__StatusTrackingOptions n)
{	const char *s = soap_str_code(soap_codes_ns1__StatusTrackingOptions, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StatusTrackingOptions(struct soap *soap, const char *tag, int id, const enum ns1__StatusTrackingOptions *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StatusTrackingOptions), type);
	soap_send(soap, soap_ns1__StatusTrackingOptions2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__StatusTrackingOptions * SOAP_FMAC4 soap_get_ns1__StatusTrackingOptions(struct soap *soap, enum ns1__StatusTrackingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StatusTrackingOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__StatusTrackingOptions(struct soap *soap, const char *s, enum ns1__StatusTrackingOptions *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__StatusTrackingOptions, s);
	if (map)
		*a = (enum ns1__StatusTrackingOptions)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__StatusTrackingOptions)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__StatusTrackingOptions * SOAP_FMAC4 soap_in_ns1__StatusTrackingOptions(struct soap *soap, const char *tag, enum ns1__StatusTrackingOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__StatusTrackingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StatusTrackingOptions, sizeof(enum ns1__StatusTrackingOptions), 0);
		if (!a || soap_s2ns1__StatusTrackingOptions(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__StatusTrackingOptions *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StatusTrackingOptions, sizeof(enum ns1__StatusTrackingOptions), 0), SOAP_TYPE_ns1__StatusTrackingOptions, sizeof(enum ns1__StatusTrackingOptions));
		if (a && soap->alloced)
			soap_default_ns1__StatusTrackingOptions(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RecipientType(struct soap *soap, enum ns1__RecipientType *a)
{
#ifdef SOAP_DEFAULT_ns1__RecipientType
	*a = SOAP_DEFAULT_ns1__RecipientType;
#else
	*a = (enum ns1__RecipientType)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__RecipientType(struct soap *soap, enum ns1__RecipientType const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__RecipientType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RecipientType(struct soap *soap, const enum ns1__RecipientType *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__RecipientType);
	soap_out_ns1__RecipientType(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__RecipientType[] =
{	{ (long)User, "User" },
	{ (long)PersonalGroup, "PersonalGroup" },
	{ (long)SystemGroup, "SystemGroup" },
	{ (long)PersonalGroupMember, "PersonalGroupMember" },
	{ (long)SystemGroupMember, "SystemGroupMember" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__RecipientType2s(struct soap *soap, enum ns1__RecipientType n)
{	const char *s = soap_str_code(soap_codes_ns1__RecipientType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RecipientType(struct soap *soap, const char *tag, int id, const enum ns1__RecipientType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RecipientType), type);
	soap_send(soap, soap_ns1__RecipientType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__RecipientType * SOAP_FMAC4 soap_get_ns1__RecipientType(struct soap *soap, enum ns1__RecipientType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RecipientType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__RecipientType(struct soap *soap, const char *s, enum ns1__RecipientType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__RecipientType, s);
	if (map)
		*a = (enum ns1__RecipientType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__RecipientType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__RecipientType * SOAP_FMAC4 soap_in_ns1__RecipientType(struct soap *soap, const char *tag, enum ns1__RecipientType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__RecipientType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipientType, sizeof(enum ns1__RecipientType), 0);
		if (!a || soap_s2ns1__RecipientType(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__RecipientType *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipientType, sizeof(enum ns1__RecipientType), 0), SOAP_TYPE_ns1__RecipientType, sizeof(enum ns1__RecipientType));
		if (a && soap->alloced)
			soap_default_ns1__RecipientType(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PostalAddressType(struct soap *soap, enum ns1__PostalAddressType *a)
{
#ifdef SOAP_DEFAULT_ns1__PostalAddressType
	*a = SOAP_DEFAULT_ns1__PostalAddressType;
#else
	*a = (enum ns1__PostalAddressType)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PostalAddressType(struct soap *soap, enum ns1__PostalAddressType const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__PostalAddressType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PostalAddressType(struct soap *soap, const enum ns1__PostalAddressType *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__PostalAddressType);
	soap_out_ns1__PostalAddressType(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__PostalAddressType[] =
{	{ (long)Home, "Home" },
	{ (long)Office, "Office" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__PostalAddressType2s(struct soap *soap, enum ns1__PostalAddressType n)
{	const char *s = soap_str_code(soap_codes_ns1__PostalAddressType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PostalAddressType(struct soap *soap, const char *tag, int id, const enum ns1__PostalAddressType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PostalAddressType), type);
	soap_send(soap, soap_ns1__PostalAddressType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__PostalAddressType * SOAP_FMAC4 soap_get_ns1__PostalAddressType(struct soap *soap, enum ns1__PostalAddressType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PostalAddressType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__PostalAddressType(struct soap *soap, const char *s, enum ns1__PostalAddressType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__PostalAddressType, s);
	if (map)
		*a = (enum ns1__PostalAddressType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__PostalAddressType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PostalAddressType * SOAP_FMAC4 soap_in_ns1__PostalAddressType(struct soap *soap, const char *tag, enum ns1__PostalAddressType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__PostalAddressType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PostalAddressType, sizeof(enum ns1__PostalAddressType), 0);
		if (!a || soap_s2ns1__PostalAddressType(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__PostalAddressType *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PostalAddressType, sizeof(enum ns1__PostalAddressType), 0), SOAP_TYPE_ns1__PostalAddressType, sizeof(enum ns1__PostalAddressType));
		if (a && soap->alloced)
			soap_default_ns1__PostalAddressType(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__OccurrenceType(struct soap *soap, enum ns1__OccurrenceType *a)
{
#ifdef SOAP_DEFAULT_ns1__OccurrenceType
	*a = SOAP_DEFAULT_ns1__OccurrenceType;
#else
	*a = (enum ns1__OccurrenceType)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__OccurrenceType(struct soap *soap, enum ns1__OccurrenceType const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__OccurrenceType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__OccurrenceType(struct soap *soap, const enum ns1__OccurrenceType *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__OccurrenceType);
	soap_out_ns1__OccurrenceType(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__OccurrenceType[] =
{	{ (long)First, "First" },
	{ (long)Second, "Second" },
	{ (long)Third, "Third" },
	{ (long)Fourth, "Fourth" },
	{ (long)Last, "Last" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__OccurrenceType2s(struct soap *soap, enum ns1__OccurrenceType n)
{	const char *s = soap_str_code(soap_codes_ns1__OccurrenceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OccurrenceType(struct soap *soap, const char *tag, int id, const enum ns1__OccurrenceType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OccurrenceType), type);
	soap_send(soap, soap_ns1__OccurrenceType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__OccurrenceType * SOAP_FMAC4 soap_get_ns1__OccurrenceType(struct soap *soap, enum ns1__OccurrenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OccurrenceType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__OccurrenceType(struct soap *soap, const char *s, enum ns1__OccurrenceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__OccurrenceType, s);
	if (map)
		*a = (enum ns1__OccurrenceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__OccurrenceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__OccurrenceType * SOAP_FMAC4 soap_in_ns1__OccurrenceType(struct soap *soap, const char *tag, enum ns1__OccurrenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__OccurrenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OccurrenceType, sizeof(enum ns1__OccurrenceType), 0);
		if (!a || soap_s2ns1__OccurrenceType(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__OccurrenceType *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OccurrenceType, sizeof(enum ns1__OccurrenceType), 0), SOAP_TYPE_ns1__OccurrenceType, sizeof(enum ns1__OccurrenceType));
		if (a && soap->alloced)
			soap_default_ns1__OccurrenceType(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ItemSource(struct soap *soap, enum ns1__ItemSource *a)
{
#ifdef SOAP_DEFAULT_ns1__ItemSource
	*a = SOAP_DEFAULT_ns1__ItemSource;
#else
	*a = (enum ns1__ItemSource)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ItemSource(struct soap *soap, enum ns1__ItemSource const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__ItemSource);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ItemSource(struct soap *soap, const enum ns1__ItemSource *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__ItemSource);
	soap_out_ns1__ItemSource(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__ItemSource[] =
{	{ (long)received, "received" },
	{ (long)sent, "sent" },
	{ (long)draft, "draft" },
	{ (long)personal, "personal" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__ItemSource2s(struct soap *soap, enum ns1__ItemSource n)
{	const char *s = soap_str_code(soap_codes_ns1__ItemSource, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemSource(struct soap *soap, const char *tag, int id, const enum ns1__ItemSource *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemSource), type);
	soap_send(soap, soap_ns1__ItemSource2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__ItemSource * SOAP_FMAC4 soap_get_ns1__ItemSource(struct soap *soap, enum ns1__ItemSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemSource(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__ItemSource(struct soap *soap, const char *s, enum ns1__ItemSource *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__ItemSource, s);
	if (map)
		*a = (enum ns1__ItemSource)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__ItemSource)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ItemSource * SOAP_FMAC4 soap_in_ns1__ItemSource(struct soap *soap, const char *tag, enum ns1__ItemSource *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__ItemSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemSource, sizeof(enum ns1__ItemSource), 0);
		if (!a || soap_s2ns1__ItemSource(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ItemSource *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemSource, sizeof(enum ns1__ItemSource), 0), SOAP_TYPE_ns1__ItemSource, sizeof(enum ns1__ItemSource));
		if (a && soap->alloced)
			soap_default_ns1__ItemSource(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ItemOptionsPriority(struct soap *soap, enum ns1__ItemOptionsPriority *a)
{
#ifdef SOAP_DEFAULT_ns1__ItemOptionsPriority
	*a = SOAP_DEFAULT_ns1__ItemOptionsPriority;
#else
	*a = (enum ns1__ItemOptionsPriority)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ItemOptionsPriority(struct soap *soap, enum ns1__ItemOptionsPriority const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__ItemOptionsPriority);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ItemOptionsPriority(struct soap *soap, const enum ns1__ItemOptionsPriority *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__ItemOptionsPriority);
	soap_out_ns1__ItemOptionsPriority(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__ItemOptionsPriority[] =
{	{ (long)High, "High" },
	{ (long)Standard, "Standard" },
	{ (long)Low, "Low" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__ItemOptionsPriority2s(struct soap *soap, enum ns1__ItemOptionsPriority n)
{	const char *s = soap_str_code(soap_codes_ns1__ItemOptionsPriority, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemOptionsPriority(struct soap *soap, const char *tag, int id, const enum ns1__ItemOptionsPriority *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemOptionsPriority), type);
	soap_send(soap, soap_ns1__ItemOptionsPriority2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__ItemOptionsPriority * SOAP_FMAC4 soap_get_ns1__ItemOptionsPriority(struct soap *soap, enum ns1__ItemOptionsPriority *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemOptionsPriority(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__ItemOptionsPriority(struct soap *soap, const char *s, enum ns1__ItemOptionsPriority *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__ItemOptionsPriority, s);
	if (map)
		*a = (enum ns1__ItemOptionsPriority)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__ItemOptionsPriority)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ItemOptionsPriority * SOAP_FMAC4 soap_in_ns1__ItemOptionsPriority(struct soap *soap, const char *tag, enum ns1__ItemOptionsPriority *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__ItemOptionsPriority *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemOptionsPriority, sizeof(enum ns1__ItemOptionsPriority), 0);
		if (!a || soap_s2ns1__ItemOptionsPriority(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ItemOptionsPriority *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemOptionsPriority, sizeof(enum ns1__ItemOptionsPriority), 0), SOAP_TYPE_ns1__ItemOptionsPriority, sizeof(enum ns1__ItemOptionsPriority));
		if (a && soap->alloced)
			soap_default_ns1__ItemOptionsPriority(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ItemClass(struct soap *soap, enum ns1__ItemClass *a)
{
#ifdef SOAP_DEFAULT_ns1__ItemClass
	*a = SOAP_DEFAULT_ns1__ItemClass;
#else
	*a = (enum ns1__ItemClass)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ItemClass(struct soap *soap, enum ns1__ItemClass const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__ItemClass);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ItemClass(struct soap *soap, const enum ns1__ItemClass *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__ItemClass);
	soap_out_ns1__ItemClass(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__ItemClass[] =
{	{ (long)Public, "Public" },
	{ (long)Private, "Private" },
	{ (long)Confidential, "Confidential" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__ItemClass2s(struct soap *soap, enum ns1__ItemClass n)
{	const char *s = soap_str_code(soap_codes_ns1__ItemClass, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemClass(struct soap *soap, const char *tag, int id, const enum ns1__ItemClass *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemClass), type);
	soap_send(soap, soap_ns1__ItemClass2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__ItemClass * SOAP_FMAC4 soap_get_ns1__ItemClass(struct soap *soap, enum ns1__ItemClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemClass(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__ItemClass(struct soap *soap, const char *s, enum ns1__ItemClass *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__ItemClass, s);
	if (map)
		*a = (enum ns1__ItemClass)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__ItemClass)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ItemClass * SOAP_FMAC4 soap_in_ns1__ItemClass(struct soap *soap, const char *tag, enum ns1__ItemClass *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__ItemClass *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemClass, sizeof(enum ns1__ItemClass), 0);
		if (!a || soap_s2ns1__ItemClass(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ItemClass *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemClass, sizeof(enum ns1__ItemClass), 0), SOAP_TYPE_ns1__ItemClass, sizeof(enum ns1__ItemClass));
		if (a && soap->alloced)
			soap_default_ns1__ItemClass(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__FolderType(struct soap *soap, enum ns1__FolderType *a)
{
#ifdef SOAP_DEFAULT_ns1__FolderType
	*a = SOAP_DEFAULT_ns1__FolderType;
#else
	*a = (enum ns1__FolderType)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__FolderType(struct soap *soap, enum ns1__FolderType const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__FolderType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FolderType(struct soap *soap, const enum ns1__FolderType *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__FolderType);
	soap_out_ns1__FolderType(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__FolderType[] =
{	{ (long)Mailbox, "Mailbox" },
	{ (long)SentItems, "SentItems" },
	{ (long)WorkInProgress, "WorkInProgress" },
	{ (long)Trash, "Trash" },
	{ (long)Calendar, "Calendar" },
	{ (long)Contacts, "Contacts" },
	{ (long)Documents, "Documents" },
	{ (long)Checklist, "Checklist" },
	{ (long)Cabinet, "Cabinet" },
	{ (long)Normal_, "Normal" },
	{ (long)NNTP, "NNTP" },
	{ (long)IMAP, "IMAP" },
	{ (long)Query, "Query" },
	{ (long)JunkMail, "JunkMail" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__FolderType2s(struct soap *soap, enum ns1__FolderType n)
{	const char *s = soap_str_code(soap_codes_ns1__FolderType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FolderType(struct soap *soap, const char *tag, int id, const enum ns1__FolderType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FolderType), type);
	soap_send(soap, soap_ns1__FolderType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__FolderType * SOAP_FMAC4 soap_get_ns1__FolderType(struct soap *soap, enum ns1__FolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FolderType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__FolderType(struct soap *soap, const char *s, enum ns1__FolderType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__FolderType, s);
	if (map)
		*a = (enum ns1__FolderType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__FolderType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__FolderType * SOAP_FMAC4 soap_in_ns1__FolderType(struct soap *soap, const char *tag, enum ns1__FolderType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__FolderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FolderType, sizeof(enum ns1__FolderType), 0);
		if (!a || soap_s2ns1__FolderType(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__FolderType *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FolderType, sizeof(enum ns1__FolderType), 0), SOAP_TYPE_ns1__FolderType, sizeof(enum ns1__FolderType));
		if (a && soap->alloced)
			soap_default_ns1__FolderType(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__FolderACLStatus(struct soap *soap, enum ns1__FolderACLStatus *a)
{
#ifdef SOAP_DEFAULT_ns1__FolderACLStatus
	*a = SOAP_DEFAULT_ns1__FolderACLStatus;
#else
	*a = (enum ns1__FolderACLStatus)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__FolderACLStatus(struct soap *soap, enum ns1__FolderACLStatus const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__FolderACLStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FolderACLStatus(struct soap *soap, const enum ns1__FolderACLStatus *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__FolderACLStatus);
	soap_out_ns1__FolderACLStatus(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__FolderACLStatus[] =
{	{ (long)pending, "pending" },
	{ (long)accepted, "accepted" },
	{ (long)deleted, "deleted" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__FolderACLStatus2s(struct soap *soap, enum ns1__FolderACLStatus n)
{	const char *s = soap_str_code(soap_codes_ns1__FolderACLStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FolderACLStatus(struct soap *soap, const char *tag, int id, const enum ns1__FolderACLStatus *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FolderACLStatus), type);
	soap_send(soap, soap_ns1__FolderACLStatus2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__FolderACLStatus * SOAP_FMAC4 soap_get_ns1__FolderACLStatus(struct soap *soap, enum ns1__FolderACLStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FolderACLStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__FolderACLStatus(struct soap *soap, const char *s, enum ns1__FolderACLStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__FolderACLStatus, s);
	if (map)
		*a = (enum ns1__FolderACLStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__FolderACLStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__FolderACLStatus * SOAP_FMAC4 soap_in_ns1__FolderACLStatus(struct soap *soap, const char *tag, enum ns1__FolderACLStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__FolderACLStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FolderACLStatus, sizeof(enum ns1__FolderACLStatus), 0);
		if (!a || soap_s2ns1__FolderACLStatus(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__FolderACLStatus *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FolderACLStatus, sizeof(enum ns1__FolderACLStatus), 0), SOAP_TYPE_ns1__FolderACLStatus, sizeof(enum ns1__FolderACLStatus));
		if (a && soap->alloced)
			soap_default_ns1__FolderACLStatus(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__FilterOp(struct soap *soap, enum ns1__FilterOp *a)
{
#ifdef SOAP_DEFAULT_ns1__FilterOp
	*a = SOAP_DEFAULT_ns1__FilterOp;
#else
	*a = (enum ns1__FilterOp)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__FilterOp(struct soap *soap, enum ns1__FilterOp const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__FilterOp);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FilterOp(struct soap *soap, const enum ns1__FilterOp *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__FilterOp);
	soap_out_ns1__FilterOp(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__FilterOp[] =
{	{ (long)and_, "and" },
	{ (long)or_, "or" },
	{ (long)not_, "not" },
	{ (long)eq, "eq" },
	{ (long)ne, "ne" },
	{ (long)gt, "gt" },
	{ (long)lt, "lt" },
	{ (long)gte, "gte" },
	{ (long)lte, "lte" },
	{ (long)contains, "contains" },
	{ (long)containsWord, "containsWord" },
	{ (long)begins, "begins" },
	{ (long)exists, "exists" },
	{ (long)notExist, "notExist" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__FilterOp2s(struct soap *soap, enum ns1__FilterOp n)
{	const char *s = soap_str_code(soap_codes_ns1__FilterOp, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FilterOp(struct soap *soap, const char *tag, int id, const enum ns1__FilterOp *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FilterOp), type);
	soap_send(soap, soap_ns1__FilterOp2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__FilterOp * SOAP_FMAC4 soap_get_ns1__FilterOp(struct soap *soap, enum ns1__FilterOp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FilterOp(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__FilterOp(struct soap *soap, const char *s, enum ns1__FilterOp *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__FilterOp, s);
	if (map)
		*a = (enum ns1__FilterOp)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__FilterOp)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__FilterOp * SOAP_FMAC4 soap_in_ns1__FilterOp(struct soap *soap, const char *tag, enum ns1__FilterOp *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__FilterOp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FilterOp, sizeof(enum ns1__FilterOp), 0);
		if (!a || soap_s2ns1__FilterOp(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__FilterOp *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FilterOp, sizeof(enum ns1__FilterOp), 0), SOAP_TYPE_ns1__FilterOp, sizeof(enum ns1__FilterOp));
		if (a && soap->alloced)
			soap_default_ns1__FilterOp(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DistributionType(struct soap *soap, enum ns1__DistributionType *a)
{
#ifdef SOAP_DEFAULT_ns1__DistributionType
	*a = SOAP_DEFAULT_ns1__DistributionType;
#else
	*a = (enum ns1__DistributionType)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DistributionType(struct soap *soap, enum ns1__DistributionType const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__DistributionType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DistributionType(struct soap *soap, const enum ns1__DistributionType *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__DistributionType);
	soap_out_ns1__DistributionType(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__DistributionType[] =
{	{ (long)TO, "TO" },
	{ (long)CC, "CC" },
	{ (long)BC, "BC" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__DistributionType2s(struct soap *soap, enum ns1__DistributionType n)
{	const char *s = soap_str_code(soap_codes_ns1__DistributionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DistributionType(struct soap *soap, const char *tag, int id, const enum ns1__DistributionType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DistributionType), type);
	soap_send(soap, soap_ns1__DistributionType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__DistributionType * SOAP_FMAC4 soap_get_ns1__DistributionType(struct soap *soap, enum ns1__DistributionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DistributionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__DistributionType(struct soap *soap, const char *s, enum ns1__DistributionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__DistributionType, s);
	if (map)
		*a = (enum ns1__DistributionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__DistributionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DistributionType * SOAP_FMAC4 soap_in_ns1__DistributionType(struct soap *soap, const char *tag, enum ns1__DistributionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__DistributionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DistributionType, sizeof(enum ns1__DistributionType), 0);
		if (!a || soap_s2ns1__DistributionType(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__DistributionType *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DistributionType, sizeof(enum ns1__DistributionType), 0), SOAP_TYPE_ns1__DistributionType, sizeof(enum ns1__DistributionType));
		if (a && soap->alloced)
			soap_default_ns1__DistributionType(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CursorSeek(struct soap *soap, enum ns1__CursorSeek *a)
{
#ifdef SOAP_DEFAULT_ns1__CursorSeek
	*a = SOAP_DEFAULT_ns1__CursorSeek;
#else
	*a = (enum ns1__CursorSeek)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CursorSeek(struct soap *soap, enum ns1__CursorSeek const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__CursorSeek);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CursorSeek(struct soap *soap, const enum ns1__CursorSeek *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__CursorSeek);
	soap_out_ns1__CursorSeek(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__CursorSeek[] =
{	{ (long)current, "current" },
	{ (long)start, "start" },
	{ (long)end, "end" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__CursorSeek2s(struct soap *soap, enum ns1__CursorSeek n)
{	const char *s = soap_str_code(soap_codes_ns1__CursorSeek, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CursorSeek(struct soap *soap, const char *tag, int id, const enum ns1__CursorSeek *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CursorSeek), type);
	soap_send(soap, soap_ns1__CursorSeek2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__CursorSeek * SOAP_FMAC4 soap_get_ns1__CursorSeek(struct soap *soap, enum ns1__CursorSeek *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CursorSeek(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__CursorSeek(struct soap *soap, const char *s, enum ns1__CursorSeek *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__CursorSeek, s);
	if (map)
		*a = (enum ns1__CursorSeek)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__CursorSeek)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__CursorSeek * SOAP_FMAC4 soap_in_ns1__CursorSeek(struct soap *soap, const char *tag, enum ns1__CursorSeek *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__CursorSeek *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CursorSeek, sizeof(enum ns1__CursorSeek), 0);
		if (!a || soap_s2ns1__CursorSeek(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__CursorSeek *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CursorSeek, sizeof(enum ns1__CursorSeek), 0), SOAP_TYPE_ns1__CursorSeek, sizeof(enum ns1__CursorSeek));
		if (a && soap->alloced)
			soap_default_ns1__CursorSeek(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ContactType(struct soap *soap, enum ns1__ContactType *a)
{
#ifdef SOAP_DEFAULT_ns1__ContactType
	*a = SOAP_DEFAULT_ns1__ContactType;
#else
	*a = (enum ns1__ContactType)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ContactType(struct soap *soap, enum ns1__ContactType const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__ContactType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ContactType(struct soap *soap, const enum ns1__ContactType *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__ContactType);
	soap_out_ns1__ContactType(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__ContactType[] =
{	{ (long)Contact, "Contact" },
	{ (long)Group, "Group" },
	{ (long)Resource, "Resource" },
	{ (long)Organization, "Organization" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__ContactType2s(struct soap *soap, enum ns1__ContactType n)
{	const char *s = soap_str_code(soap_codes_ns1__ContactType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ContactType(struct soap *soap, const char *tag, int id, const enum ns1__ContactType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ContactType), type);
	soap_send(soap, soap_ns1__ContactType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__ContactType * SOAP_FMAC4 soap_get_ns1__ContactType(struct soap *soap, enum ns1__ContactType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ContactType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__ContactType(struct soap *soap, const char *s, enum ns1__ContactType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__ContactType, s);
	if (map)
		*a = (enum ns1__ContactType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__ContactType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ContactType * SOAP_FMAC4 soap_in_ns1__ContactType(struct soap *soap, const char *tag, enum ns1__ContactType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__ContactType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ContactType, sizeof(enum ns1__ContactType), 0);
		if (!a || soap_s2ns1__ContactType(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ContactType *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ContactType, sizeof(enum ns1__ContactType), 0), SOAP_TYPE_ns1__ContactType, sizeof(enum ns1__ContactType));
		if (a && soap->alloced)
			soap_default_ns1__ContactType(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CategoryType(struct soap *soap, enum ns1__CategoryType *a)
{
#ifdef SOAP_DEFAULT_ns1__CategoryType
	*a = SOAP_DEFAULT_ns1__CategoryType;
#else
	*a = (enum ns1__CategoryType)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CategoryType(struct soap *soap, enum ns1__CategoryType const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__CategoryType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CategoryType(struct soap *soap, const enum ns1__CategoryType *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__CategoryType);
	soap_out_ns1__CategoryType(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__CategoryType[] =
{	{ (long)Normal, "Normal" },
	{ (long)Personal, "Personal" },
	{ (long)Follow_up, "Follow-up" },
	{ (long)Urgent, "Urgent" },
	{ (long)LowPriority, "LowPriority" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__CategoryType2s(struct soap *soap, enum ns1__CategoryType n)
{	const char *s = soap_str_code(soap_codes_ns1__CategoryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CategoryType(struct soap *soap, const char *tag, int id, const enum ns1__CategoryType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CategoryType), type);
	soap_send(soap, soap_ns1__CategoryType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__CategoryType * SOAP_FMAC4 soap_get_ns1__CategoryType(struct soap *soap, enum ns1__CategoryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CategoryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__CategoryType(struct soap *soap, const char *s, enum ns1__CategoryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__CategoryType, s);
	if (map)
		*a = (enum ns1__CategoryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__CategoryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__CategoryType * SOAP_FMAC4 soap_in_ns1__CategoryType(struct soap *soap, const char *tag, enum ns1__CategoryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__CategoryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CategoryType, sizeof(enum ns1__CategoryType), 0);
		if (!a || soap_s2ns1__CategoryType(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__CategoryType *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CategoryType, sizeof(enum ns1__CategoryType), 0), SOAP_TYPE_ns1__CategoryType, sizeof(enum ns1__CategoryType));
		if (a && soap->alloced)
			soap_default_ns1__CategoryType(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AcceptLevel(struct soap *soap, enum ns1__AcceptLevel *a)
{
#ifdef SOAP_DEFAULT_ns1__AcceptLevel
	*a = SOAP_DEFAULT_ns1__AcceptLevel;
#else
	*a = (enum ns1__AcceptLevel)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AcceptLevel(struct soap *soap, enum ns1__AcceptLevel const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__AcceptLevel);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AcceptLevel(struct soap *soap, const enum ns1__AcceptLevel *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__AcceptLevel);
	soap_out_ns1__AcceptLevel(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__AcceptLevel[] =
{	{ (long)Free, "Free" },
	{ (long)Tentative, "Tentative" },
	{ (long)Busy, "Busy" },
	{ (long)OutOfOffice, "OutOfOffice" },
	{ 0, NULL }
};

SOAP_FMAC3 const char* SOAP_FMAC4 soap_ns1__AcceptLevel2s(struct soap *soap, enum ns1__AcceptLevel n)
{	const char *s = soap_str_code(soap_codes_ns1__AcceptLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AcceptLevel(struct soap *soap, const char *tag, int id, const enum ns1__AcceptLevel *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AcceptLevel), type);
	soap_send(soap, soap_ns1__AcceptLevel2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__AcceptLevel * SOAP_FMAC4 soap_get_ns1__AcceptLevel(struct soap *soap, enum ns1__AcceptLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AcceptLevel(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_s2ns1__AcceptLevel(struct soap *soap, const char *s, enum ns1__AcceptLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__AcceptLevel, s);
	if (map)
		*a = (enum ns1__AcceptLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
				return soap->error;
			*a = (enum ns1__AcceptLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__AcceptLevel * SOAP_FMAC4 soap_in_ns1__AcceptLevel(struct soap *soap, const char *tag, enum ns1__AcceptLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (enum ns1__AcceptLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AcceptLevel, sizeof(enum ns1__AcceptLevel), 0);
		if (!a || soap_s2ns1__AcceptLevel(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__AcceptLevel *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AcceptLevel, sizeof(enum ns1__AcceptLevel), 0), SOAP_TYPE_ns1__AcceptLevel, sizeof(enum ns1__AcceptLevel));
		if (a && soap->alloced)
			soap_default_ns1__AcceptLevel(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UUID(struct soap *soap, std::string const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__UUID);
}
SOAP_FMAC3 void SOAP_FMAC4 soap_mark_ns1__UUID(struct soap *soap, const std::string *p)
{ }
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UUID(struct soap *soap, std::string *p)
{	p->erase();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UUID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__UUID);
	soap_out_ns1__UUID(soap, tag, i, a, type);
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UUID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__UUID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__UUID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UUID(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}
SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_ns1__UUID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__UUID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			s->assign(soap_string_in(soap, 1));
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__UUID, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_ns1__UUID, sizeof(std::string));
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_ns1__UUID(struct soap *soap, int n)
{	return soap_instantiate_ns1__UUID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__UUID(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_ns1__UUID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UUID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UUID, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__uid(struct soap *soap, std::string const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__uid);
}
SOAP_FMAC3 void SOAP_FMAC4 soap_mark_ns1__uid(struct soap *soap, const std::string *p)
{ }
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__uid(struct soap *soap, std::string *p)
{	p->erase();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__uid(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__uid);
	soap_out_ns1__uid(soap, tag, i, a, type);
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__uid(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__uid), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__uid(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__uid(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}
SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_ns1__uid(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__uid, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			s->assign(soap_string_in(soap, 1));
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__uid, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_ns1__uid, sizeof(std::string));
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_ns1__uid(struct soap *soap, int n)
{	return soap_instantiate_ns1__uid(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__uid(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_ns1__uid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__uid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__uid, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__View(struct soap *soap, std::string const*a)
{
	soap_reference(soap, a, SOAP_TYPE_ns1__View);
}
SOAP_FMAC3 void SOAP_FMAC4 soap_mark_ns1__View(struct soap *soap, const std::string *p)
{ }
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__View(struct soap *soap, std::string *p)
{	p->erase();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__View(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_ns1__View);
	soap_out_ns1__View(soap, tag, i, a, type);
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__View(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__View), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__View(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__View(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}
SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_ns1__View(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__View, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			s->assign(soap_string_in(soap, 1));
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__View, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_ns1__View, sizeof(std::string));
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_ns1__View(struct soap *soap, int n)
{	return soap_instantiate_ns1__View(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__View(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_ns1__View(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__View(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__View, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, std::string const*a)
{
	soap_reference(soap, a, SOAP_TYPE_std__string);
}
SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__string(struct soap *soap, const std::string *p)
{ }
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	p->erase();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__string);
	soap_out_std__string(soap, tag, i, a, type);
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}
SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			s->assign(soap_string_in(soap, 1));
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_std__string, sizeof(std::string));
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
	return (std::string*)cp->ptr;
}

void _ns1__startFreeBusySessionResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__startFreeBusySessionResponse))
		this->soap_mark(soap);
}

void _ns1__startFreeBusySessionResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__startFreeBusySessionResponse*)this)->freeBusySessionId, SOAP_TYPE_int);
	soap_embedded(soap, &((_ns1__startFreeBusySessionResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__startFreeBusySessionResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__startFreeBusySessionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((_ns1__startFreeBusySessionResponse*)this)->freeBusySessionId);
	soap_default_PointerTons1__Status(soap, &((_ns1__startFreeBusySessionResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__startFreeBusySessionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__startFreeBusySessionResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__startFreeBusySessionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__startFreeBusySessionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__startFreeBusySessionResponse(struct soap *soap, const char *tag, int id, const _ns1__startFreeBusySessionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__startFreeBusySessionResponse), "");
	soap_out_int(soap, "freeBusySessionId", -1, &(((_ns1__startFreeBusySessionResponse*)a)->freeBusySessionId), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__startFreeBusySessionResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__startFreeBusySessionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__startFreeBusySessionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__startFreeBusySessionResponse * SOAP_FMAC4 soap_get__ns1__startFreeBusySessionResponse(struct soap *soap, _ns1__startFreeBusySessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__startFreeBusySessionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__startFreeBusySessionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__startFreeBusySessionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__startFreeBusySessionResponse * SOAP_FMAC4 soap_in__ns1__startFreeBusySessionResponse(struct soap *soap, const char *tag, _ns1__startFreeBusySessionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__startFreeBusySessionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__startFreeBusySessionResponse, sizeof(_ns1__startFreeBusySessionResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__startFreeBusySessionResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__startFreeBusySessionResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_freeBusySessionId1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_freeBusySessionId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "freeBusySessionId", &(((_ns1__startFreeBusySessionResponse*)a)->freeBusySessionId), ""))
				{	soap_flag_freeBusySessionId1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__startFreeBusySessionResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_freeBusySessionId1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__startFreeBusySessionResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__startFreeBusySessionResponse, sizeof(_ns1__startFreeBusySessionResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__startFreeBusySessionResponse, sizeof(_ns1__startFreeBusySessionResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__startFreeBusySessionResponse * SOAP_FMAC6 soap_new__ns1__startFreeBusySessionResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__startFreeBusySessionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__startFreeBusySessionResponse(struct soap *soap, _ns1__startFreeBusySessionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__startFreeBusySessionResponse * SOAP_FMAC6 soap_instantiate__ns1__startFreeBusySessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__startFreeBusySessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__startFreeBusySessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__startFreeBusySessionResponse;
		if (size)
			*size = sizeof(_ns1__startFreeBusySessionResponse);
		((_ns1__startFreeBusySessionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__startFreeBusySessionResponse[n];
		if (size)
			*size = n * sizeof(_ns1__startFreeBusySessionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__startFreeBusySessionResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__startFreeBusySessionResponse*)cp->ptr;
}

void _ns1__startFreeBusySessionRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__startFreeBusySessionRequest))
		this->soap_mark(soap);
}

void _ns1__startFreeBusySessionRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__startFreeBusySessionRequest*)this)->users, SOAP_TYPE_PointerTons1__FreeBusyUserList);
	soap_mark_PointerTons1__FreeBusyUserList(soap, &((_ns1__startFreeBusySessionRequest*)this)->users);
	soap_embedded(soap, &((_ns1__startFreeBusySessionRequest*)this)->startDate, SOAP_TYPE_string);
	soap_mark_string(soap, &((_ns1__startFreeBusySessionRequest*)this)->startDate);
	soap_embedded(soap, &((_ns1__startFreeBusySessionRequest*)this)->endDate, SOAP_TYPE_string);
	soap_mark_string(soap, &((_ns1__startFreeBusySessionRequest*)this)->endDate);
	/* transient soap skipped */
}

void _ns1__startFreeBusySessionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__FreeBusyUserList(soap, &((_ns1__startFreeBusySessionRequest*)this)->users);
	soap_default_string(soap, &((_ns1__startFreeBusySessionRequest*)this)->startDate);
	soap_default_string(soap, &((_ns1__startFreeBusySessionRequest*)this)->endDate);
	/* transient soap skipped */
}

int _ns1__startFreeBusySessionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__startFreeBusySessionRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__startFreeBusySessionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__startFreeBusySessionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__startFreeBusySessionRequest(struct soap *soap, const char *tag, int id, const _ns1__startFreeBusySessionRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__startFreeBusySessionRequest), "");
	soap_out_PointerTons1__FreeBusyUserList(soap, "users", -1, &(((_ns1__startFreeBusySessionRequest*)a)->users), "ns1:FreeBusyUserList");
	soap_out_string(soap, "startDate", -1, &(((_ns1__startFreeBusySessionRequest*)a)->startDate), "");
	soap_out_string(soap, "endDate", -1, &(((_ns1__startFreeBusySessionRequest*)a)->endDate), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__startFreeBusySessionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__startFreeBusySessionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__startFreeBusySessionRequest * SOAP_FMAC4 soap_get__ns1__startFreeBusySessionRequest(struct soap *soap, _ns1__startFreeBusySessionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__startFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__startFreeBusySessionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__startFreeBusySessionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__startFreeBusySessionRequest * SOAP_FMAC4 soap_in__ns1__startFreeBusySessionRequest(struct soap *soap, const char *tag, _ns1__startFreeBusySessionRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__startFreeBusySessionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__startFreeBusySessionRequest, sizeof(_ns1__startFreeBusySessionRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__startFreeBusySessionRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__startFreeBusySessionRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_users1 = 1, soap_flag_startDate1 = 1, soap_flag_endDate1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_users1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FreeBusyUserList(soap, "users", &(((_ns1__startFreeBusySessionRequest*)a)->users), "ns1:FreeBusyUserList"))
				{	soap_flag_users1 = 0;
					continue;
				}

			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "startDate", &(((_ns1__startFreeBusySessionRequest*)a)->startDate), ""))
				{	soap_flag_startDate1 = 0;
					continue;
				}

			if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "endDate", &(((_ns1__startFreeBusySessionRequest*)a)->endDate), ""))
				{	soap_flag_endDate1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__startFreeBusySessionRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__startFreeBusySessionRequest, sizeof(_ns1__startFreeBusySessionRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__startFreeBusySessionRequest, sizeof(_ns1__startFreeBusySessionRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__startFreeBusySessionRequest * SOAP_FMAC6 soap_new__ns1__startFreeBusySessionRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__startFreeBusySessionRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__startFreeBusySessionRequest(struct soap *soap, _ns1__startFreeBusySessionRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__startFreeBusySessionRequest * SOAP_FMAC6 soap_instantiate__ns1__startFreeBusySessionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__startFreeBusySessionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__startFreeBusySessionRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__startFreeBusySessionRequest;
		if (size)
			*size = sizeof(_ns1__startFreeBusySessionRequest);
		((_ns1__startFreeBusySessionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__startFreeBusySessionRequest[n];
		if (size)
			*size = n * sizeof(_ns1__startFreeBusySessionRequest);
		for (int i = 0; i < n; i++)
			((_ns1__startFreeBusySessionRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__startFreeBusySessionRequest*)cp->ptr;
}

void _ns1__sendItemResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__sendItemResponse))
		this->soap_mark(soap);
}

void _ns1__sendItemResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__sendItemResponse*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__sendItemResponse*)this)->id);
	soap_embedded(soap, &((_ns1__sendItemResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__sendItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__sendItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__sendItemResponse*)this)->id);
	soap_default_PointerTons1__Status(soap, &((_ns1__sendItemResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__sendItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__sendItemResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__sendItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__sendItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sendItemResponse(struct soap *soap, const char *tag, int id, const _ns1__sendItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sendItemResponse), "");
	soap_out_ns1__uid(soap, "id", -1, &(((_ns1__sendItemResponse*)a)->id), "ns1:uid");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__sendItemResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__sendItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__sendItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__sendItemResponse * SOAP_FMAC4 soap_get__ns1__sendItemResponse(struct soap *soap, _ns1__sendItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sendItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__sendItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__sendItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__sendItemResponse * SOAP_FMAC4 soap_in__ns1__sendItemResponse(struct soap *soap, const char *tag, _ns1__sendItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__sendItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendItemResponse, sizeof(_ns1__sendItemResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__sendItemResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__sendItemResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((_ns1__sendItemResponse*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__sendItemResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__sendItemResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendItemResponse, sizeof(_ns1__sendItemResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__sendItemResponse, sizeof(_ns1__sendItemResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__sendItemResponse * SOAP_FMAC6 soap_new__ns1__sendItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__sendItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__sendItemResponse(struct soap *soap, _ns1__sendItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__sendItemResponse * SOAP_FMAC6 soap_instantiate__ns1__sendItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__sendItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__sendItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__sendItemResponse;
		if (size)
			*size = sizeof(_ns1__sendItemResponse);
		((_ns1__sendItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__sendItemResponse[n];
		if (size)
			*size = n * sizeof(_ns1__sendItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__sendItemResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__sendItemResponse*)cp->ptr;
}

void _ns1__sendItemRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__sendItemRequest))
		this->soap_mark(soap);
}

void _ns1__sendItemRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__sendItemRequest*)this)->item, SOAP_TYPE_PointerTons1__Item);
	soap_mark_PointerTons1__Item(soap, &((_ns1__sendItemRequest*)this)->item);
	/* transient soap skipped */
}

void _ns1__sendItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Item(soap, &((_ns1__sendItemRequest*)this)->item);
	/* transient soap skipped */
}

int _ns1__sendItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__sendItemRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__sendItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__sendItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sendItemRequest(struct soap *soap, const char *tag, int id, const _ns1__sendItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sendItemRequest), "");
	soap_out_PointerTons1__Item(soap, "item", -1, &(((_ns1__sendItemRequest*)a)->item), "ns1:Item");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__sendItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__sendItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__sendItemRequest * SOAP_FMAC4 soap_get__ns1__sendItemRequest(struct soap *soap, _ns1__sendItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sendItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__sendItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__sendItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__sendItemRequest * SOAP_FMAC4 soap_in__ns1__sendItemRequest(struct soap *soap, const char *tag, _ns1__sendItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__sendItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendItemRequest, sizeof(_ns1__sendItemRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__sendItemRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__sendItemRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_item1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Item(soap, "item", &(((_ns1__sendItemRequest*)a)->item), "ns1:Item"))
				{	soap_flag_item1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__sendItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sendItemRequest, sizeof(_ns1__sendItemRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__sendItemRequest, sizeof(_ns1__sendItemRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__sendItemRequest * SOAP_FMAC6 soap_new__ns1__sendItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__sendItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__sendItemRequest(struct soap *soap, _ns1__sendItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__sendItemRequest * SOAP_FMAC6 soap_instantiate__ns1__sendItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__sendItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__sendItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__sendItemRequest;
		if (size)
			*size = sizeof(_ns1__sendItemRequest);
		((_ns1__sendItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__sendItemRequest[n];
		if (size)
			*size = n * sizeof(_ns1__sendItemRequest);
		for (int i = 0; i < n; i++)
			((_ns1__sendItemRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__sendItemRequest*)cp->ptr;
}

void _ns1__retractResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__retractResponse))
		this->soap_mark(soap);
}

void _ns1__retractResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__retractResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__retractResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__retractResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__retractResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__retractResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__retractResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__retractResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__retractResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__retractResponse(struct soap *soap, const char *tag, int id, const _ns1__retractResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__retractResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__retractResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__retractResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__retractResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__retractResponse * SOAP_FMAC4 soap_get__ns1__retractResponse(struct soap *soap, _ns1__retractResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__retractResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__retractResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__retractResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__retractResponse * SOAP_FMAC4 soap_in__ns1__retractResponse(struct soap *soap, const char *tag, _ns1__retractResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__retractResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__retractResponse, sizeof(_ns1__retractResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__retractResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__retractResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__retractResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__retractResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__retractResponse, sizeof(_ns1__retractResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__retractResponse, sizeof(_ns1__retractResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__retractResponse * SOAP_FMAC6 soap_new__ns1__retractResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__retractResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__retractResponse(struct soap *soap, _ns1__retractResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__retractResponse * SOAP_FMAC6 soap_instantiate__ns1__retractResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__retractResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__retractResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__retractResponse;
		if (size)
			*size = sizeof(_ns1__retractResponse);
		((_ns1__retractResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__retractResponse[n];
		if (size)
			*size = n * sizeof(_ns1__retractResponse);
		for (int i = 0; i < n; i++)
			((_ns1__retractResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__retractResponse*)cp->ptr;
}

void _ns1__retractRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__retractRequest))
		this->soap_mark(soap);
}

void _ns1__retractRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__retractRequest*)this)->items, SOAP_TYPE_PointerTons1__ItemRefList);
	soap_mark_PointerTons1__ItemRefList(soap, &((_ns1__retractRequest*)this)->items);
	soap_embedded(soap, &((_ns1__retractRequest*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__retractRequest*)this)->comment);
	soap_embedded(soap, &((_ns1__retractRequest*)this)->retractingAllInstances, SOAP_TYPE_xsd__bool);
	soap_mark_xsd__bool(soap, &((_ns1__retractRequest*)this)->retractingAllInstances);
	soap_embedded(soap, &((_ns1__retractRequest*)this)->retractCausedByResend, SOAP_TYPE_xsd__bool);
	soap_mark_xsd__bool(soap, &((_ns1__retractRequest*)this)->retractCausedByResend);
	/* transient soap skipped */
}

void _ns1__retractRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ItemRefList(soap, &((_ns1__retractRequest*)this)->items);
	soap_default_PointerTostd__string(soap, &((_ns1__retractRequest*)this)->comment);
	soap_default_xsd__bool(soap, &((_ns1__retractRequest*)this)->retractingAllInstances);
	soap_default_xsd__bool(soap, &((_ns1__retractRequest*)this)->retractCausedByResend);
	/* transient soap skipped */
}

int _ns1__retractRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__retractRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__retractRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__retractRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__retractRequest(struct soap *soap, const char *tag, int id, const _ns1__retractRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__retractRequest), "");
	soap_out_PointerTons1__ItemRefList(soap, "items", -1, &(((_ns1__retractRequest*)a)->items), "ns1:ItemRefList");
	soap_out_PointerTostd__string(soap, "comment", -1, &(((_ns1__retractRequest*)a)->comment), "xsd:string");
	soap_out_xsd__bool(soap, "retractingAllInstances", -1, &(((_ns1__retractRequest*)a)->retractingAllInstances), "xsd:bool");
	soap_out_xsd__bool(soap, "retractCausedByResend", -1, &(((_ns1__retractRequest*)a)->retractCausedByResend), "xsd:bool");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__retractRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__retractRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__retractRequest * SOAP_FMAC4 soap_get__ns1__retractRequest(struct soap *soap, _ns1__retractRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__retractRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__retractRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__retractRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__retractRequest * SOAP_FMAC4 soap_in__ns1__retractRequest(struct soap *soap, const char *tag, _ns1__retractRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__retractRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__retractRequest, sizeof(_ns1__retractRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__retractRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__retractRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_items1 = 1, soap_flag_comment1 = 1, soap_flag_retractingAllInstances1 = 1, soap_flag_retractCausedByResend1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRefList(soap, "items", &(((_ns1__retractRequest*)a)->items), "ns1:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}

			if (soap_flag_comment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "comment", &(((_ns1__retractRequest*)a)->comment), "xsd:string"))
				{	soap_flag_comment1 = 0;
					continue;
				}

			if (soap_flag_retractingAllInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__bool(soap, "retractingAllInstances", &(((_ns1__retractRequest*)a)->retractingAllInstances), "xsd:bool"))
				{	soap_flag_retractingAllInstances1 = 0;
					continue;
				}

			if (soap_flag_retractCausedByResend1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__bool(soap, "retractCausedByResend", &(((_ns1__retractRequest*)a)->retractCausedByResend), "xsd:bool"))
				{	soap_flag_retractCausedByResend1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__retractRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__retractRequest, sizeof(_ns1__retractRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__retractRequest, sizeof(_ns1__retractRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__retractRequest * SOAP_FMAC6 soap_new__ns1__retractRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__retractRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__retractRequest(struct soap *soap, _ns1__retractRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__retractRequest * SOAP_FMAC6 soap_instantiate__ns1__retractRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__retractRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__retractRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__retractRequest;
		if (size)
			*size = sizeof(_ns1__retractRequest);
		((_ns1__retractRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__retractRequest[n];
		if (size)
			*size = n * sizeof(_ns1__retractRequest);
		for (int i = 0; i < n; i++)
			((_ns1__retractRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__retractRequest*)cp->ptr;
}

void _ns1__removeProxyAccessResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__removeProxyAccessResponse))
		this->soap_mark(soap);
}

void _ns1__removeProxyAccessResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__removeProxyAccessResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__removeProxyAccessResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__removeProxyAccessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__removeProxyAccessResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__removeProxyAccessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__removeProxyAccessResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__removeProxyAccessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeProxyAccessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeProxyAccessResponse(struct soap *soap, const char *tag, int id, const _ns1__removeProxyAccessResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeProxyAccessResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__removeProxyAccessResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__removeProxyAccessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeProxyAccessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeProxyAccessResponse * SOAP_FMAC4 soap_get__ns1__removeProxyAccessResponse(struct soap *soap, _ns1__removeProxyAccessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeProxyAccessResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__removeProxyAccessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeProxyAccessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeProxyAccessResponse * SOAP_FMAC4 soap_in__ns1__removeProxyAccessResponse(struct soap *soap, const char *tag, _ns1__removeProxyAccessResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__removeProxyAccessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeProxyAccessResponse, sizeof(_ns1__removeProxyAccessResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__removeProxyAccessResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__removeProxyAccessResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__removeProxyAccessResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__removeProxyAccessResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeProxyAccessResponse, sizeof(_ns1__removeProxyAccessResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__removeProxyAccessResponse, sizeof(_ns1__removeProxyAccessResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__removeProxyAccessResponse * SOAP_FMAC6 soap_new__ns1__removeProxyAccessResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__removeProxyAccessResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__removeProxyAccessResponse(struct soap *soap, _ns1__removeProxyAccessResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__removeProxyAccessResponse * SOAP_FMAC6 soap_instantiate__ns1__removeProxyAccessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeProxyAccessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeProxyAccessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__removeProxyAccessResponse;
		if (size)
			*size = sizeof(_ns1__removeProxyAccessResponse);
		((_ns1__removeProxyAccessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__removeProxyAccessResponse[n];
		if (size)
			*size = n * sizeof(_ns1__removeProxyAccessResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeProxyAccessResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__removeProxyAccessResponse*)cp->ptr;
}

void _ns1__removeProxyAccessRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__removeProxyAccessRequest))
		this->soap_mark(soap);
}

void _ns1__removeProxyAccessRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__removeProxyAccessRequest*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__removeProxyAccessRequest*)this)->id);
	/* transient soap skipped */
}

void _ns1__removeProxyAccessRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__removeProxyAccessRequest*)this)->id);
	/* transient soap skipped */
}

int _ns1__removeProxyAccessRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__removeProxyAccessRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__removeProxyAccessRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeProxyAccessRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeProxyAccessRequest(struct soap *soap, const char *tag, int id, const _ns1__removeProxyAccessRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeProxyAccessRequest), "");
	soap_out_ns1__uid(soap, "id", -1, &(((_ns1__removeProxyAccessRequest*)a)->id), "ns1:uid");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__removeProxyAccessRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeProxyAccessRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeProxyAccessRequest * SOAP_FMAC4 soap_get__ns1__removeProxyAccessRequest(struct soap *soap, _ns1__removeProxyAccessRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__removeProxyAccessRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeProxyAccessRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeProxyAccessRequest * SOAP_FMAC4 soap_in__ns1__removeProxyAccessRequest(struct soap *soap, const char *tag, _ns1__removeProxyAccessRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__removeProxyAccessRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeProxyAccessRequest, sizeof(_ns1__removeProxyAccessRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__removeProxyAccessRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__removeProxyAccessRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((_ns1__removeProxyAccessRequest*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__removeProxyAccessRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeProxyAccessRequest, sizeof(_ns1__removeProxyAccessRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__removeProxyAccessRequest, sizeof(_ns1__removeProxyAccessRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__removeProxyAccessRequest * SOAP_FMAC6 soap_new__ns1__removeProxyAccessRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__removeProxyAccessRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__removeProxyAccessRequest(struct soap *soap, _ns1__removeProxyAccessRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__removeProxyAccessRequest * SOAP_FMAC6 soap_instantiate__ns1__removeProxyAccessRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeProxyAccessRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeProxyAccessRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__removeProxyAccessRequest;
		if (size)
			*size = sizeof(_ns1__removeProxyAccessRequest);
		((_ns1__removeProxyAccessRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__removeProxyAccessRequest[n];
		if (size)
			*size = n * sizeof(_ns1__removeProxyAccessRequest);
		for (int i = 0; i < n; i++)
			((_ns1__removeProxyAccessRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__removeProxyAccessRequest*)cp->ptr;
}

void _ns1__removeMembersResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__removeMembersResponse))
		this->soap_mark(soap);
}

void _ns1__removeMembersResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__removeMembersResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__removeMembersResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__removeMembersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__removeMembersResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__removeMembersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__removeMembersResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__removeMembersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeMembersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeMembersResponse(struct soap *soap, const char *tag, int id, const _ns1__removeMembersResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeMembersResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__removeMembersResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__removeMembersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeMembersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeMembersResponse * SOAP_FMAC4 soap_get__ns1__removeMembersResponse(struct soap *soap, _ns1__removeMembersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeMembersResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__removeMembersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeMembersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeMembersResponse * SOAP_FMAC4 soap_in__ns1__removeMembersResponse(struct soap *soap, const char *tag, _ns1__removeMembersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__removeMembersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeMembersResponse, sizeof(_ns1__removeMembersResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__removeMembersResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__removeMembersResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__removeMembersResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__removeMembersResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeMembersResponse, sizeof(_ns1__removeMembersResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__removeMembersResponse, sizeof(_ns1__removeMembersResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__removeMembersResponse * SOAP_FMAC6 soap_new__ns1__removeMembersResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__removeMembersResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__removeMembersResponse(struct soap *soap, _ns1__removeMembersResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__removeMembersResponse * SOAP_FMAC6 soap_instantiate__ns1__removeMembersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeMembersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeMembersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__removeMembersResponse;
		if (size)
			*size = sizeof(_ns1__removeMembersResponse);
		((_ns1__removeMembersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__removeMembersResponse[n];
		if (size)
			*size = n * sizeof(_ns1__removeMembersResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeMembersResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__removeMembersResponse*)cp->ptr;
}

void _ns1__removeMembersRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__removeMembersRequest))
		this->soap_mark(soap);
}

void _ns1__removeMembersRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__removeMembersRequest*)this)->container, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__removeMembersRequest*)this)->container);
	soap_embedded(soap, &((_ns1__removeMembersRequest*)this)->members, SOAP_TYPE_PointerTons1__GroupMemberList);
	soap_mark_PointerTons1__GroupMemberList(soap, &((_ns1__removeMembersRequest*)this)->members);
	/* transient soap skipped */
}

void _ns1__removeMembersRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__removeMembersRequest*)this)->container);
	soap_default_PointerTons1__GroupMemberList(soap, &((_ns1__removeMembersRequest*)this)->members);
	/* transient soap skipped */
}

int _ns1__removeMembersRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__removeMembersRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__removeMembersRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeMembersRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeMembersRequest(struct soap *soap, const char *tag, int id, const _ns1__removeMembersRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeMembersRequest), "");
	soap_out_ns1__uid(soap, "container", -1, &(((_ns1__removeMembersRequest*)a)->container), "ns1:uid");
	soap_out_PointerTons1__GroupMemberList(soap, "members", -1, &(((_ns1__removeMembersRequest*)a)->members), "ns1:GroupMemberList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__removeMembersRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeMembersRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeMembersRequest * SOAP_FMAC4 soap_get__ns1__removeMembersRequest(struct soap *soap, _ns1__removeMembersRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeMembersRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__removeMembersRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeMembersRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeMembersRequest * SOAP_FMAC4 soap_in__ns1__removeMembersRequest(struct soap *soap, const char *tag, _ns1__removeMembersRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__removeMembersRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeMembersRequest, sizeof(_ns1__removeMembersRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__removeMembersRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__removeMembersRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_container1 = 1, soap_flag_members1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_container1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "container", &(((_ns1__removeMembersRequest*)a)->container), "ns1:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}

			if (soap_flag_members1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GroupMemberList(soap, "members", &(((_ns1__removeMembersRequest*)a)->members), "ns1:GroupMemberList"))
				{	soap_flag_members1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__removeMembersRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeMembersRequest, sizeof(_ns1__removeMembersRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__removeMembersRequest, sizeof(_ns1__removeMembersRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__removeMembersRequest * SOAP_FMAC6 soap_new__ns1__removeMembersRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__removeMembersRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__removeMembersRequest(struct soap *soap, _ns1__removeMembersRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__removeMembersRequest * SOAP_FMAC6 soap_instantiate__ns1__removeMembersRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeMembersRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeMembersRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__removeMembersRequest;
		if (size)
			*size = sizeof(_ns1__removeMembersRequest);
		((_ns1__removeMembersRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__removeMembersRequest[n];
		if (size)
			*size = n * sizeof(_ns1__removeMembersRequest);
		for (int i = 0; i < n; i++)
			((_ns1__removeMembersRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__removeMembersRequest*)cp->ptr;
}

void _ns1__removeItemsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__removeItemsResponse))
		this->soap_mark(soap);
}

void _ns1__removeItemsResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__removeItemsResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__removeItemsResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__removeItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__removeItemsResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__removeItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__removeItemsResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__removeItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeItemsResponse(struct soap *soap, const char *tag, int id, const _ns1__removeItemsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeItemsResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__removeItemsResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__removeItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeItemsResponse * SOAP_FMAC4 soap_get__ns1__removeItemsResponse(struct soap *soap, _ns1__removeItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__removeItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeItemsResponse * SOAP_FMAC4 soap_in__ns1__removeItemsResponse(struct soap *soap, const char *tag, _ns1__removeItemsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__removeItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeItemsResponse, sizeof(_ns1__removeItemsResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__removeItemsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__removeItemsResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__removeItemsResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__removeItemsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeItemsResponse, sizeof(_ns1__removeItemsResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__removeItemsResponse, sizeof(_ns1__removeItemsResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__removeItemsResponse * SOAP_FMAC6 soap_new__ns1__removeItemsResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__removeItemsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__removeItemsResponse(struct soap *soap, _ns1__removeItemsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__removeItemsResponse * SOAP_FMAC6 soap_instantiate__ns1__removeItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__removeItemsResponse;
		if (size)
			*size = sizeof(_ns1__removeItemsResponse);
		((_ns1__removeItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__removeItemsResponse[n];
		if (size)
			*size = n * sizeof(_ns1__removeItemsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeItemsResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__removeItemsResponse*)cp->ptr;
}

void _ns1__removeItemsRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__removeItemsRequest))
		this->soap_mark(soap);
}

void _ns1__removeItemsRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__removeItemsRequest*)this)->container, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__removeItemsRequest*)this)->container);
	soap_embedded(soap, &((_ns1__removeItemsRequest*)this)->items, SOAP_TYPE_PointerTons1__ItemRefList);
	soap_mark_PointerTons1__ItemRefList(soap, &((_ns1__removeItemsRequest*)this)->items);
	/* transient soap skipped */
}

void _ns1__removeItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__removeItemsRequest*)this)->container);
	soap_default_PointerTons1__ItemRefList(soap, &((_ns1__removeItemsRequest*)this)->items);
	/* transient soap skipped */
}

int _ns1__removeItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__removeItemsRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__removeItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeItemsRequest(struct soap *soap, const char *tag, int id, const _ns1__removeItemsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeItemsRequest), "");
	soap_out_ns1__uid(soap, "container", -1, &(((_ns1__removeItemsRequest*)a)->container), "ns1:uid");
	soap_out_PointerTons1__ItemRefList(soap, "items", -1, &(((_ns1__removeItemsRequest*)a)->items), "ns1:ItemRefList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__removeItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeItemsRequest * SOAP_FMAC4 soap_get__ns1__removeItemsRequest(struct soap *soap, _ns1__removeItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__removeItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeItemsRequest * SOAP_FMAC4 soap_in__ns1__removeItemsRequest(struct soap *soap, const char *tag, _ns1__removeItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__removeItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeItemsRequest, sizeof(_ns1__removeItemsRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__removeItemsRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__removeItemsRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_container1 = 1, soap_flag_items1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_container1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "container", &(((_ns1__removeItemsRequest*)a)->container), "ns1:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRefList(soap, "items", &(((_ns1__removeItemsRequest*)a)->items), "ns1:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__removeItemsRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeItemsRequest, sizeof(_ns1__removeItemsRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__removeItemsRequest, sizeof(_ns1__removeItemsRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__removeItemsRequest * SOAP_FMAC6 soap_new__ns1__removeItemsRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__removeItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__removeItemsRequest(struct soap *soap, _ns1__removeItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__removeItemsRequest * SOAP_FMAC6 soap_instantiate__ns1__removeItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__removeItemsRequest;
		if (size)
			*size = sizeof(_ns1__removeItemsRequest);
		((_ns1__removeItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__removeItemsRequest[n];
		if (size)
			*size = n * sizeof(_ns1__removeItemsRequest);
		for (int i = 0; i < n; i++)
			((_ns1__removeItemsRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__removeItemsRequest*)cp->ptr;
}

void _ns1__removeItemResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__removeItemResponse))
		this->soap_mark(soap);
}

void _ns1__removeItemResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__removeItemResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__removeItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__removeItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__removeItemResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__removeItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__removeItemResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__removeItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeItemResponse(struct soap *soap, const char *tag, int id, const _ns1__removeItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeItemResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__removeItemResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__removeItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeItemResponse * SOAP_FMAC4 soap_get__ns1__removeItemResponse(struct soap *soap, _ns1__removeItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__removeItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeItemResponse * SOAP_FMAC4 soap_in__ns1__removeItemResponse(struct soap *soap, const char *tag, _ns1__removeItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__removeItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeItemResponse, sizeof(_ns1__removeItemResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__removeItemResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__removeItemResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__removeItemResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__removeItemResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeItemResponse, sizeof(_ns1__removeItemResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__removeItemResponse, sizeof(_ns1__removeItemResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__removeItemResponse * SOAP_FMAC6 soap_new__ns1__removeItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__removeItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__removeItemResponse(struct soap *soap, _ns1__removeItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__removeItemResponse * SOAP_FMAC6 soap_instantiate__ns1__removeItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__removeItemResponse;
		if (size)
			*size = sizeof(_ns1__removeItemResponse);
		((_ns1__removeItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__removeItemResponse[n];
		if (size)
			*size = n * sizeof(_ns1__removeItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeItemResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__removeItemResponse*)cp->ptr;
}

void _ns1__removeItemRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__removeItemRequest))
		this->soap_mark(soap);
}

void _ns1__removeItemRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__removeItemRequest*)this)->container, SOAP_TYPE_PointerTons1__uid);
	soap_mark_PointerTons1__uid(soap, &((_ns1__removeItemRequest*)this)->container);
	soap_embedded(soap, &((_ns1__removeItemRequest*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__removeItemRequest*)this)->id);
	/* transient soap skipped */
}

void _ns1__removeItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__uid(soap, &((_ns1__removeItemRequest*)this)->container);
	soap_default_ns1__uid(soap, &((_ns1__removeItemRequest*)this)->id);
	/* transient soap skipped */
}

int _ns1__removeItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__removeItemRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__removeItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeItemRequest(struct soap *soap, const char *tag, int id, const _ns1__removeItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeItemRequest), "");
	soap_out_PointerTons1__uid(soap, "container", -1, &(((_ns1__removeItemRequest*)a)->container), "ns1:uid");
	soap_out_ns1__uid(soap, "id", -1, &(((_ns1__removeItemRequest*)a)->id), "ns1:uid");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__removeItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeItemRequest * SOAP_FMAC4 soap_get__ns1__removeItemRequest(struct soap *soap, _ns1__removeItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__removeItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeItemRequest * SOAP_FMAC4 soap_in__ns1__removeItemRequest(struct soap *soap, const char *tag, _ns1__removeItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__removeItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeItemRequest, sizeof(_ns1__removeItemRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__removeItemRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__removeItemRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_container1 = 1, soap_flag_id1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_container1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__uid(soap, "container", &(((_ns1__removeItemRequest*)a)->container), "ns1:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((_ns1__removeItemRequest*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__removeItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeItemRequest, sizeof(_ns1__removeItemRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__removeItemRequest, sizeof(_ns1__removeItemRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__removeItemRequest * SOAP_FMAC6 soap_new__ns1__removeItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__removeItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__removeItemRequest(struct soap *soap, _ns1__removeItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__removeItemRequest * SOAP_FMAC6 soap_instantiate__ns1__removeItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__removeItemRequest;
		if (size)
			*size = sizeof(_ns1__removeItemRequest);
		((_ns1__removeItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__removeItemRequest[n];
		if (size)
			*size = n * sizeof(_ns1__removeItemRequest);
		for (int i = 0; i < n; i++)
			((_ns1__removeItemRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__removeItemRequest*)cp->ptr;
}

void _ns1__readCursorResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__readCursorResponse))
		this->soap_mark(soap);
}

void _ns1__readCursorResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__readCursorResponse*)this)->items, SOAP_TYPE_PointerTons1__ItemList);
	soap_mark_PointerTons1__ItemList(soap, &((_ns1__readCursorResponse*)this)->items);
	soap_embedded(soap, &((_ns1__readCursorResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__readCursorResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__readCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ItemList(soap, &((_ns1__readCursorResponse*)this)->items);
	soap_default_PointerTons1__Status(soap, &((_ns1__readCursorResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__readCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__readCursorResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__readCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__readCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__readCursorResponse(struct soap *soap, const char *tag, int id, const _ns1__readCursorResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__readCursorResponse), "");
	soap_out_PointerTons1__ItemList(soap, "items", -1, &(((_ns1__readCursorResponse*)a)->items), "ns1:ItemList");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__readCursorResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__readCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__readCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__readCursorResponse * SOAP_FMAC4 soap_get__ns1__readCursorResponse(struct soap *soap, _ns1__readCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__readCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__readCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__readCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__readCursorResponse * SOAP_FMAC4 soap_in__ns1__readCursorResponse(struct soap *soap, const char *tag, _ns1__readCursorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__readCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__readCursorResponse, sizeof(_ns1__readCursorResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__readCursorResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__readCursorResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_items1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemList(soap, "items", &(((_ns1__readCursorResponse*)a)->items), "ns1:ItemList"))
				{	soap_flag_items1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__readCursorResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__readCursorResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__readCursorResponse, sizeof(_ns1__readCursorResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__readCursorResponse, sizeof(_ns1__readCursorResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__readCursorResponse * SOAP_FMAC6 soap_new__ns1__readCursorResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__readCursorResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__readCursorResponse(struct soap *soap, _ns1__readCursorResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__readCursorResponse * SOAP_FMAC6 soap_instantiate__ns1__readCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__readCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__readCursorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__readCursorResponse;
		if (size)
			*size = sizeof(_ns1__readCursorResponse);
		((_ns1__readCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__readCursorResponse[n];
		if (size)
			*size = n * sizeof(_ns1__readCursorResponse);
		for (int i = 0; i < n; i++)
			((_ns1__readCursorResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__readCursorResponse*)cp->ptr;
}

void _ns1__readCursorRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__readCursorRequest))
		this->soap_mark(soap);
}

void _ns1__readCursorRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__readCursorRequest*)this)->cursor, SOAP_TYPE_int);
	soap_embedded(soap, &((_ns1__readCursorRequest*)this)->forward, SOAP_TYPE_bool);
	soap_embedded(soap, &((_ns1__readCursorRequest*)this)->count, SOAP_TYPE_int);
	/* transient soap skipped */
}

void _ns1__readCursorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((_ns1__readCursorRequest*)this)->cursor);
	soap_default_bool(soap, &((_ns1__readCursorRequest*)this)->forward);
	soap_default_int(soap, &((_ns1__readCursorRequest*)this)->count);
	/* transient soap skipped */
}

int _ns1__readCursorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__readCursorRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__readCursorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__readCursorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__readCursorRequest(struct soap *soap, const char *tag, int id, const _ns1__readCursorRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__readCursorRequest), "");
	soap_out_int(soap, "cursor", -1, &(((_ns1__readCursorRequest*)a)->cursor), "");
	soap_out_bool(soap, "forward", -1, &(((_ns1__readCursorRequest*)a)->forward), "");
	soap_out_int(soap, "count", -1, &(((_ns1__readCursorRequest*)a)->count), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__readCursorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__readCursorRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__readCursorRequest * SOAP_FMAC4 soap_get__ns1__readCursorRequest(struct soap *soap, _ns1__readCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__readCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__readCursorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__readCursorRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__readCursorRequest * SOAP_FMAC4 soap_in__ns1__readCursorRequest(struct soap *soap, const char *tag, _ns1__readCursorRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__readCursorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__readCursorRequest, sizeof(_ns1__readCursorRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__readCursorRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__readCursorRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_cursor1 = 1, soap_flag_forward1 = 1, soap_flag_count1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_cursor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursor", &(((_ns1__readCursorRequest*)a)->cursor), ""))
				{	soap_flag_cursor1 = 0;
					continue;
				}

			if (soap_flag_forward1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "forward", &(((_ns1__readCursorRequest*)a)->forward), ""))
				{	soap_flag_forward1 = 0;
					continue;
				}

			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "count", &(((_ns1__readCursorRequest*)a)->count), ""))
				{	soap_flag_count1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cursor1 || soap_flag_forward1 || soap_flag_count1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__readCursorRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__readCursorRequest, sizeof(_ns1__readCursorRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__readCursorRequest, sizeof(_ns1__readCursorRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__readCursorRequest * SOAP_FMAC6 soap_new__ns1__readCursorRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__readCursorRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__readCursorRequest(struct soap *soap, _ns1__readCursorRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__readCursorRequest * SOAP_FMAC6 soap_instantiate__ns1__readCursorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__readCursorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__readCursorRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__readCursorRequest;
		if (size)
			*size = sizeof(_ns1__readCursorRequest);
		((_ns1__readCursorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__readCursorRequest[n];
		if (size)
			*size = n * sizeof(_ns1__readCursorRequest);
		for (int i = 0; i < n; i++)
			((_ns1__readCursorRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__readCursorRequest*)cp->ptr;
}

void _ns1__purgeItemResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__purgeItemResponse))
		this->soap_mark(soap);
}

void _ns1__purgeItemResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__purgeItemResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__purgeItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__purgeItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__purgeItemResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__purgeItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__purgeItemResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__purgeItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__purgeItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__purgeItemResponse(struct soap *soap, const char *tag, int id, const _ns1__purgeItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__purgeItemResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__purgeItemResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__purgeItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__purgeItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__purgeItemResponse * SOAP_FMAC4 soap_get__ns1__purgeItemResponse(struct soap *soap, _ns1__purgeItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__purgeItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__purgeItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__purgeItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__purgeItemResponse * SOAP_FMAC4 soap_in__ns1__purgeItemResponse(struct soap *soap, const char *tag, _ns1__purgeItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__purgeItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__purgeItemResponse, sizeof(_ns1__purgeItemResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__purgeItemResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__purgeItemResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__purgeItemResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__purgeItemResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__purgeItemResponse, sizeof(_ns1__purgeItemResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__purgeItemResponse, sizeof(_ns1__purgeItemResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__purgeItemResponse * SOAP_FMAC6 soap_new__ns1__purgeItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__purgeItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__purgeItemResponse(struct soap *soap, _ns1__purgeItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__purgeItemResponse * SOAP_FMAC6 soap_instantiate__ns1__purgeItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__purgeItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__purgeItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__purgeItemResponse;
		if (size)
			*size = sizeof(_ns1__purgeItemResponse);
		((_ns1__purgeItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__purgeItemResponse[n];
		if (size)
			*size = n * sizeof(_ns1__purgeItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__purgeItemResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__purgeItemResponse*)cp->ptr;
}

void _ns1__purgeItemRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__purgeItemRequest))
		this->soap_mark(soap);
}

void _ns1__purgeItemRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__purgeItemRequest*)this)->container, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__purgeItemRequest*)this)->container);
	soap_embedded(soap, &((_ns1__purgeItemRequest*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__purgeItemRequest*)this)->id);
	/* transient soap skipped */
}

void _ns1__purgeItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__purgeItemRequest*)this)->container);
	soap_default_ns1__uid(soap, &((_ns1__purgeItemRequest*)this)->id);
	/* transient soap skipped */
}

int _ns1__purgeItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__purgeItemRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__purgeItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__purgeItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__purgeItemRequest(struct soap *soap, const char *tag, int id, const _ns1__purgeItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__purgeItemRequest), "");
	soap_out_ns1__uid(soap, "container", -1, &(((_ns1__purgeItemRequest*)a)->container), "ns1:uid");
	soap_out_ns1__uid(soap, "id", -1, &(((_ns1__purgeItemRequest*)a)->id), "ns1:uid");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__purgeItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__purgeItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__purgeItemRequest * SOAP_FMAC4 soap_get__ns1__purgeItemRequest(struct soap *soap, _ns1__purgeItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__purgeItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__purgeItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__purgeItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__purgeItemRequest * SOAP_FMAC4 soap_in__ns1__purgeItemRequest(struct soap *soap, const char *tag, _ns1__purgeItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__purgeItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__purgeItemRequest, sizeof(_ns1__purgeItemRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__purgeItemRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__purgeItemRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_container1 = 1, soap_flag_id1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_container1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "container", &(((_ns1__purgeItemRequest*)a)->container), "ns1:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((_ns1__purgeItemRequest*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__purgeItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__purgeItemRequest, sizeof(_ns1__purgeItemRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__purgeItemRequest, sizeof(_ns1__purgeItemRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__purgeItemRequest * SOAP_FMAC6 soap_new__ns1__purgeItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__purgeItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__purgeItemRequest(struct soap *soap, _ns1__purgeItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__purgeItemRequest * SOAP_FMAC6 soap_instantiate__ns1__purgeItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__purgeItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__purgeItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__purgeItemRequest;
		if (size)
			*size = sizeof(_ns1__purgeItemRequest);
		((_ns1__purgeItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__purgeItemRequest[n];
		if (size)
			*size = n * sizeof(_ns1__purgeItemRequest);
		for (int i = 0; i < n; i++)
			((_ns1__purgeItemRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__purgeItemRequest*)cp->ptr;
}

void _ns1__purgeDeletedItemsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__purgeDeletedItemsResponse))
		this->soap_mark(soap);
}

void _ns1__purgeDeletedItemsResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__purgeDeletedItemsResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__purgeDeletedItemsResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__purgeDeletedItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__purgeDeletedItemsResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__purgeDeletedItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__purgeDeletedItemsResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__purgeDeletedItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__purgeDeletedItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__purgeDeletedItemsResponse(struct soap *soap, const char *tag, int id, const _ns1__purgeDeletedItemsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__purgeDeletedItemsResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__purgeDeletedItemsResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__purgeDeletedItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__purgeDeletedItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__purgeDeletedItemsResponse * SOAP_FMAC4 soap_get__ns1__purgeDeletedItemsResponse(struct soap *soap, _ns1__purgeDeletedItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__purgeDeletedItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__purgeDeletedItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__purgeDeletedItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__purgeDeletedItemsResponse * SOAP_FMAC4 soap_in__ns1__purgeDeletedItemsResponse(struct soap *soap, const char *tag, _ns1__purgeDeletedItemsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__purgeDeletedItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__purgeDeletedItemsResponse, sizeof(_ns1__purgeDeletedItemsResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__purgeDeletedItemsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__purgeDeletedItemsResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__purgeDeletedItemsResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__purgeDeletedItemsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__purgeDeletedItemsResponse, sizeof(_ns1__purgeDeletedItemsResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__purgeDeletedItemsResponse, sizeof(_ns1__purgeDeletedItemsResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__purgeDeletedItemsResponse * SOAP_FMAC6 soap_new__ns1__purgeDeletedItemsResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__purgeDeletedItemsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__purgeDeletedItemsResponse(struct soap *soap, _ns1__purgeDeletedItemsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__purgeDeletedItemsResponse * SOAP_FMAC6 soap_instantiate__ns1__purgeDeletedItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__purgeDeletedItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__purgeDeletedItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__purgeDeletedItemsResponse;
		if (size)
			*size = sizeof(_ns1__purgeDeletedItemsResponse);
		((_ns1__purgeDeletedItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__purgeDeletedItemsResponse[n];
		if (size)
			*size = n * sizeof(_ns1__purgeDeletedItemsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__purgeDeletedItemsResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__purgeDeletedItemsResponse*)cp->ptr;
}

void _ns1__purgeDeletedItemsRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__purgeDeletedItemsRequest))
		this->soap_mark(soap);
}

void _ns1__purgeDeletedItemsRequest::soap_mark(struct soap *soap) const
{
	/* transient soap skipped */
}

void _ns1__purgeDeletedItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ns1__purgeDeletedItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__purgeDeletedItemsRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__purgeDeletedItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__purgeDeletedItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__purgeDeletedItemsRequest(struct soap *soap, const char *tag, int id, const _ns1__purgeDeletedItemsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__purgeDeletedItemsRequest), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__purgeDeletedItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__purgeDeletedItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__purgeDeletedItemsRequest * SOAP_FMAC4 soap_get__ns1__purgeDeletedItemsRequest(struct soap *soap, _ns1__purgeDeletedItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__purgeDeletedItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__purgeDeletedItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__purgeDeletedItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__purgeDeletedItemsRequest * SOAP_FMAC4 soap_in__ns1__purgeDeletedItemsRequest(struct soap *soap, const char *tag, _ns1__purgeDeletedItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__purgeDeletedItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__purgeDeletedItemsRequest, sizeof(_ns1__purgeDeletedItemsRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__purgeDeletedItemsRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__purgeDeletedItemsRequest *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__purgeDeletedItemsRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__purgeDeletedItemsRequest, sizeof(_ns1__purgeDeletedItemsRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__purgeDeletedItemsRequest, sizeof(_ns1__purgeDeletedItemsRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__purgeDeletedItemsRequest * SOAP_FMAC6 soap_new__ns1__purgeDeletedItemsRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__purgeDeletedItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__purgeDeletedItemsRequest(struct soap *soap, _ns1__purgeDeletedItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__purgeDeletedItemsRequest * SOAP_FMAC6 soap_instantiate__ns1__purgeDeletedItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__purgeDeletedItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__purgeDeletedItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__purgeDeletedItemsRequest;
		if (size)
			*size = sizeof(_ns1__purgeDeletedItemsRequest);
		((_ns1__purgeDeletedItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__purgeDeletedItemsRequest[n];
		if (size)
			*size = n * sizeof(_ns1__purgeDeletedItemsRequest);
		for (int i = 0; i < n; i++)
			((_ns1__purgeDeletedItemsRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__purgeDeletedItemsRequest*)cp->ptr;
}

void _ns1__positionCursorResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__positionCursorResponse))
		this->soap_mark(soap);
}

void _ns1__positionCursorResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__positionCursorResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__positionCursorResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__positionCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__positionCursorResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__positionCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__positionCursorResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__positionCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__positionCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__positionCursorResponse(struct soap *soap, const char *tag, int id, const _ns1__positionCursorResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__positionCursorResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__positionCursorResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__positionCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__positionCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__positionCursorResponse * SOAP_FMAC4 soap_get__ns1__positionCursorResponse(struct soap *soap, _ns1__positionCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__positionCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__positionCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__positionCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__positionCursorResponse * SOAP_FMAC4 soap_in__ns1__positionCursorResponse(struct soap *soap, const char *tag, _ns1__positionCursorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__positionCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__positionCursorResponse, sizeof(_ns1__positionCursorResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__positionCursorResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__positionCursorResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__positionCursorResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__positionCursorResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__positionCursorResponse, sizeof(_ns1__positionCursorResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__positionCursorResponse, sizeof(_ns1__positionCursorResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__positionCursorResponse * SOAP_FMAC6 soap_new__ns1__positionCursorResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__positionCursorResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__positionCursorResponse(struct soap *soap, _ns1__positionCursorResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__positionCursorResponse * SOAP_FMAC6 soap_instantiate__ns1__positionCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__positionCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__positionCursorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__positionCursorResponse;
		if (size)
			*size = sizeof(_ns1__positionCursorResponse);
		((_ns1__positionCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__positionCursorResponse[n];
		if (size)
			*size = n * sizeof(_ns1__positionCursorResponse);
		for (int i = 0; i < n; i++)
			((_ns1__positionCursorResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__positionCursorResponse*)cp->ptr;
}

void _ns1__positionCursorRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__positionCursorRequest))
		this->soap_mark(soap);
}

void _ns1__positionCursorRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__positionCursorRequest*)this)->cursor, SOAP_TYPE_int);
	soap_embedded(soap, &((_ns1__positionCursorRequest*)this)->seek, SOAP_TYPE_ns1__CursorSeek);
	soap_embedded(soap, &((_ns1__positionCursorRequest*)this)->offset, SOAP_TYPE_int);
	/* transient soap skipped */
}

void _ns1__positionCursorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((_ns1__positionCursorRequest*)this)->cursor);
	soap_default_ns1__CursorSeek(soap, &((_ns1__positionCursorRequest*)this)->seek);
	soap_default_int(soap, &((_ns1__positionCursorRequest*)this)->offset);
	/* transient soap skipped */
}

int _ns1__positionCursorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__positionCursorRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__positionCursorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__positionCursorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__positionCursorRequest(struct soap *soap, const char *tag, int id, const _ns1__positionCursorRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__positionCursorRequest), "");
	soap_out_int(soap, "cursor", -1, &(((_ns1__positionCursorRequest*)a)->cursor), "");
	soap_out_ns1__CursorSeek(soap, "seek", -1, &(((_ns1__positionCursorRequest*)a)->seek), "ns1:CursorSeek");
	soap_out_int(soap, "offset", -1, &(((_ns1__positionCursorRequest*)a)->offset), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__positionCursorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__positionCursorRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__positionCursorRequest * SOAP_FMAC4 soap_get__ns1__positionCursorRequest(struct soap *soap, _ns1__positionCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__positionCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__positionCursorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__positionCursorRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__positionCursorRequest * SOAP_FMAC4 soap_in__ns1__positionCursorRequest(struct soap *soap, const char *tag, _ns1__positionCursorRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__positionCursorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__positionCursorRequest, sizeof(_ns1__positionCursorRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__positionCursorRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__positionCursorRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_cursor1 = 1, soap_flag_seek1 = 1, soap_flag_offset1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_cursor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursor", &(((_ns1__positionCursorRequest*)a)->cursor), ""))
				{	soap_flag_cursor1 = 0;
					continue;
				}

			if (soap_flag_seek1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__CursorSeek(soap, "seek", &(((_ns1__positionCursorRequest*)a)->seek), "ns1:CursorSeek"))
				{	soap_flag_seek1 = 0;
					continue;
				}

			if (soap_flag_offset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &(((_ns1__positionCursorRequest*)a)->offset), ""))
				{	soap_flag_offset1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cursor1 || soap_flag_seek1 || soap_flag_offset1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__positionCursorRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__positionCursorRequest, sizeof(_ns1__positionCursorRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__positionCursorRequest, sizeof(_ns1__positionCursorRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__positionCursorRequest * SOAP_FMAC6 soap_new__ns1__positionCursorRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__positionCursorRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__positionCursorRequest(struct soap *soap, _ns1__positionCursorRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__positionCursorRequest * SOAP_FMAC6 soap_instantiate__ns1__positionCursorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__positionCursorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__positionCursorRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__positionCursorRequest;
		if (size)
			*size = sizeof(_ns1__positionCursorRequest);
		((_ns1__positionCursorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__positionCursorRequest[n];
		if (size)
			*size = n * sizeof(_ns1__positionCursorRequest);
		for (int i = 0; i < n; i++)
			((_ns1__positionCursorRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__positionCursorRequest*)cp->ptr;
}

void _ns1__modifySettingsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__modifySettingsResponse))
		this->soap_mark(soap);
}

void _ns1__modifySettingsResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__modifySettingsResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__modifySettingsResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__modifySettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__modifySettingsResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__modifySettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__modifySettingsResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__modifySettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__modifySettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__modifySettingsResponse(struct soap *soap, const char *tag, int id, const _ns1__modifySettingsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__modifySettingsResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__modifySettingsResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__modifySettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__modifySettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__modifySettingsResponse * SOAP_FMAC4 soap_get__ns1__modifySettingsResponse(struct soap *soap, _ns1__modifySettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__modifySettingsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__modifySettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__modifySettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__modifySettingsResponse * SOAP_FMAC4 soap_in__ns1__modifySettingsResponse(struct soap *soap, const char *tag, _ns1__modifySettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__modifySettingsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifySettingsResponse, sizeof(_ns1__modifySettingsResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__modifySettingsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__modifySettingsResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__modifySettingsResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__modifySettingsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifySettingsResponse, sizeof(_ns1__modifySettingsResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__modifySettingsResponse, sizeof(_ns1__modifySettingsResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__modifySettingsResponse * SOAP_FMAC6 soap_new__ns1__modifySettingsResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__modifySettingsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__modifySettingsResponse(struct soap *soap, _ns1__modifySettingsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__modifySettingsResponse * SOAP_FMAC6 soap_instantiate__ns1__modifySettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__modifySettingsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__modifySettingsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__modifySettingsResponse;
		if (size)
			*size = sizeof(_ns1__modifySettingsResponse);
		((_ns1__modifySettingsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__modifySettingsResponse[n];
		if (size)
			*size = n * sizeof(_ns1__modifySettingsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__modifySettingsResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__modifySettingsResponse*)cp->ptr;
}

void _ns1__modifySettingsRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__modifySettingsRequest))
		this->soap_mark(soap);
}

void _ns1__modifySettingsRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__modifySettingsRequest*)this)->settings, SOAP_TYPE_PointerTons1__SettingsList);
	soap_mark_PointerTons1__SettingsList(soap, &((_ns1__modifySettingsRequest*)this)->settings);
	/* transient soap skipped */
}

void _ns1__modifySettingsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__SettingsList(soap, &((_ns1__modifySettingsRequest*)this)->settings);
	/* transient soap skipped */
}

int _ns1__modifySettingsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__modifySettingsRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__modifySettingsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__modifySettingsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__modifySettingsRequest(struct soap *soap, const char *tag, int id, const _ns1__modifySettingsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__modifySettingsRequest), "");
	soap_out_PointerTons1__SettingsList(soap, "settings", -1, &(((_ns1__modifySettingsRequest*)a)->settings), "ns1:SettingsList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__modifySettingsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__modifySettingsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__modifySettingsRequest * SOAP_FMAC4 soap_get__ns1__modifySettingsRequest(struct soap *soap, _ns1__modifySettingsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__modifySettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__modifySettingsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__modifySettingsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__modifySettingsRequest * SOAP_FMAC4 soap_in__ns1__modifySettingsRequest(struct soap *soap, const char *tag, _ns1__modifySettingsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__modifySettingsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifySettingsRequest, sizeof(_ns1__modifySettingsRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__modifySettingsRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__modifySettingsRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_settings1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_settings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SettingsList(soap, "settings", &(((_ns1__modifySettingsRequest*)a)->settings), "ns1:SettingsList"))
				{	soap_flag_settings1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__modifySettingsRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifySettingsRequest, sizeof(_ns1__modifySettingsRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__modifySettingsRequest, sizeof(_ns1__modifySettingsRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__modifySettingsRequest * SOAP_FMAC6 soap_new__ns1__modifySettingsRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__modifySettingsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__modifySettingsRequest(struct soap *soap, _ns1__modifySettingsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__modifySettingsRequest * SOAP_FMAC6 soap_instantiate__ns1__modifySettingsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__modifySettingsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__modifySettingsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__modifySettingsRequest;
		if (size)
			*size = sizeof(_ns1__modifySettingsRequest);
		((_ns1__modifySettingsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__modifySettingsRequest[n];
		if (size)
			*size = n * sizeof(_ns1__modifySettingsRequest);
		for (int i = 0; i < n; i++)
			((_ns1__modifySettingsRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__modifySettingsRequest*)cp->ptr;
}

void _ns1__modifyProxyAccessResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__modifyProxyAccessResponse))
		this->soap_mark(soap);
}

void _ns1__modifyProxyAccessResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__modifyProxyAccessResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__modifyProxyAccessResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__modifyProxyAccessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__modifyProxyAccessResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__modifyProxyAccessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__modifyProxyAccessResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__modifyProxyAccessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__modifyProxyAccessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__modifyProxyAccessResponse(struct soap *soap, const char *tag, int id, const _ns1__modifyProxyAccessResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__modifyProxyAccessResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__modifyProxyAccessResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__modifyProxyAccessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__modifyProxyAccessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__modifyProxyAccessResponse * SOAP_FMAC4 soap_get__ns1__modifyProxyAccessResponse(struct soap *soap, _ns1__modifyProxyAccessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__modifyProxyAccessResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__modifyProxyAccessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__modifyProxyAccessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__modifyProxyAccessResponse * SOAP_FMAC4 soap_in__ns1__modifyProxyAccessResponse(struct soap *soap, const char *tag, _ns1__modifyProxyAccessResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__modifyProxyAccessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifyProxyAccessResponse, sizeof(_ns1__modifyProxyAccessResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__modifyProxyAccessResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__modifyProxyAccessResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__modifyProxyAccessResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__modifyProxyAccessResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifyProxyAccessResponse, sizeof(_ns1__modifyProxyAccessResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__modifyProxyAccessResponse, sizeof(_ns1__modifyProxyAccessResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__modifyProxyAccessResponse * SOAP_FMAC6 soap_new__ns1__modifyProxyAccessResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__modifyProxyAccessResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__modifyProxyAccessResponse(struct soap *soap, _ns1__modifyProxyAccessResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__modifyProxyAccessResponse * SOAP_FMAC6 soap_instantiate__ns1__modifyProxyAccessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__modifyProxyAccessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__modifyProxyAccessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__modifyProxyAccessResponse;
		if (size)
			*size = sizeof(_ns1__modifyProxyAccessResponse);
		((_ns1__modifyProxyAccessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__modifyProxyAccessResponse[n];
		if (size)
			*size = n * sizeof(_ns1__modifyProxyAccessResponse);
		for (int i = 0; i < n; i++)
			((_ns1__modifyProxyAccessResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__modifyProxyAccessResponse*)cp->ptr;
}

void _ns1__modifyProxyAccessRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__modifyProxyAccessRequest))
		this->soap_mark(soap);
}

void _ns1__modifyProxyAccessRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__modifyProxyAccessRequest*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__modifyProxyAccessRequest*)this)->id);
	soap_embedded(soap, &((_ns1__modifyProxyAccessRequest*)this)->updates, SOAP_TYPE_PointerTons1__AccessRightChanges);
	soap_mark_PointerTons1__AccessRightChanges(soap, &((_ns1__modifyProxyAccessRequest*)this)->updates);
	/* transient soap skipped */
}

void _ns1__modifyProxyAccessRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__modifyProxyAccessRequest*)this)->id);
	soap_default_PointerTons1__AccessRightChanges(soap, &((_ns1__modifyProxyAccessRequest*)this)->updates);
	/* transient soap skipped */
}

int _ns1__modifyProxyAccessRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__modifyProxyAccessRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__modifyProxyAccessRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__modifyProxyAccessRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__modifyProxyAccessRequest(struct soap *soap, const char *tag, int id, const _ns1__modifyProxyAccessRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__modifyProxyAccessRequest), "");
	soap_out_ns1__uid(soap, "id", -1, &(((_ns1__modifyProxyAccessRequest*)a)->id), "ns1:uid");
	soap_out_PointerTons1__AccessRightChanges(soap, "updates", -1, &(((_ns1__modifyProxyAccessRequest*)a)->updates), "ns1:AccessRightChanges");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__modifyProxyAccessRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__modifyProxyAccessRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__modifyProxyAccessRequest * SOAP_FMAC4 soap_get__ns1__modifyProxyAccessRequest(struct soap *soap, _ns1__modifyProxyAccessRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__modifyProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__modifyProxyAccessRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__modifyProxyAccessRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__modifyProxyAccessRequest * SOAP_FMAC4 soap_in__ns1__modifyProxyAccessRequest(struct soap *soap, const char *tag, _ns1__modifyProxyAccessRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__modifyProxyAccessRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifyProxyAccessRequest, sizeof(_ns1__modifyProxyAccessRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__modifyProxyAccessRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__modifyProxyAccessRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_updates1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((_ns1__modifyProxyAccessRequest*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_updates1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessRightChanges(soap, "updates", &(((_ns1__modifyProxyAccessRequest*)a)->updates), "ns1:AccessRightChanges"))
				{	soap_flag_updates1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__modifyProxyAccessRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifyProxyAccessRequest, sizeof(_ns1__modifyProxyAccessRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__modifyProxyAccessRequest, sizeof(_ns1__modifyProxyAccessRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__modifyProxyAccessRequest * SOAP_FMAC6 soap_new__ns1__modifyProxyAccessRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__modifyProxyAccessRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__modifyProxyAccessRequest(struct soap *soap, _ns1__modifyProxyAccessRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__modifyProxyAccessRequest * SOAP_FMAC6 soap_instantiate__ns1__modifyProxyAccessRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__modifyProxyAccessRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__modifyProxyAccessRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__modifyProxyAccessRequest;
		if (size)
			*size = sizeof(_ns1__modifyProxyAccessRequest);
		((_ns1__modifyProxyAccessRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__modifyProxyAccessRequest[n];
		if (size)
			*size = n * sizeof(_ns1__modifyProxyAccessRequest);
		for (int i = 0; i < n; i++)
			((_ns1__modifyProxyAccessRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__modifyProxyAccessRequest*)cp->ptr;
}

void _ns1__modifyItemResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__modifyItemResponse))
		this->soap_mark(soap);
}

void _ns1__modifyItemResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__modifyItemResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__modifyItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__modifyItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__modifyItemResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__modifyItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__modifyItemResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__modifyItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__modifyItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__modifyItemResponse(struct soap *soap, const char *tag, int id, const _ns1__modifyItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__modifyItemResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__modifyItemResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__modifyItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__modifyItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__modifyItemResponse * SOAP_FMAC4 soap_get__ns1__modifyItemResponse(struct soap *soap, _ns1__modifyItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__modifyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__modifyItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__modifyItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__modifyItemResponse * SOAP_FMAC4 soap_in__ns1__modifyItemResponse(struct soap *soap, const char *tag, _ns1__modifyItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__modifyItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifyItemResponse, sizeof(_ns1__modifyItemResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__modifyItemResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__modifyItemResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__modifyItemResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__modifyItemResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifyItemResponse, sizeof(_ns1__modifyItemResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__modifyItemResponse, sizeof(_ns1__modifyItemResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__modifyItemResponse * SOAP_FMAC6 soap_new__ns1__modifyItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__modifyItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__modifyItemResponse(struct soap *soap, _ns1__modifyItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__modifyItemResponse * SOAP_FMAC6 soap_instantiate__ns1__modifyItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__modifyItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__modifyItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__modifyItemResponse;
		if (size)
			*size = sizeof(_ns1__modifyItemResponse);
		((_ns1__modifyItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__modifyItemResponse[n];
		if (size)
			*size = n * sizeof(_ns1__modifyItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__modifyItemResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__modifyItemResponse*)cp->ptr;
}

void _ns1__modifyItemRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__modifyItemRequest))
		this->soap_mark(soap);
}

void _ns1__modifyItemRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__modifyItemRequest*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__modifyItemRequest*)this)->id);
	soap_embedded(soap, &((_ns1__modifyItemRequest*)this)->updates, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((_ns1__modifyItemRequest*)this)->updates);
	/* transient soap skipped */
}

void _ns1__modifyItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__modifyItemRequest*)this)->id);
	soap_default_PointerTons1__ItemChanges(soap, &((_ns1__modifyItemRequest*)this)->updates);
	/* transient soap skipped */
}

int _ns1__modifyItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__modifyItemRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__modifyItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__modifyItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__modifyItemRequest(struct soap *soap, const char *tag, int id, const _ns1__modifyItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__modifyItemRequest), "");
	soap_out_ns1__uid(soap, "id", -1, &(((_ns1__modifyItemRequest*)a)->id), "ns1:uid");
	soap_out_PointerTons1__ItemChanges(soap, "updates", -1, &(((_ns1__modifyItemRequest*)a)->updates), "ns1:ItemChanges");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__modifyItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__modifyItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__modifyItemRequest * SOAP_FMAC4 soap_get__ns1__modifyItemRequest(struct soap *soap, _ns1__modifyItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__modifyItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__modifyItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__modifyItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__modifyItemRequest * SOAP_FMAC4 soap_in__ns1__modifyItemRequest(struct soap *soap, const char *tag, _ns1__modifyItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__modifyItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifyItemRequest, sizeof(_ns1__modifyItemRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__modifyItemRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__modifyItemRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_updates1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((_ns1__modifyItemRequest*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_updates1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "updates", &(((_ns1__modifyItemRequest*)a)->updates), "ns1:ItemChanges"))
				{	soap_flag_updates1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__modifyItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__modifyItemRequest, sizeof(_ns1__modifyItemRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__modifyItemRequest, sizeof(_ns1__modifyItemRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__modifyItemRequest * SOAP_FMAC6 soap_new__ns1__modifyItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__modifyItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__modifyItemRequest(struct soap *soap, _ns1__modifyItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__modifyItemRequest * SOAP_FMAC6 soap_instantiate__ns1__modifyItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__modifyItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__modifyItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__modifyItemRequest;
		if (size)
			*size = sizeof(_ns1__modifyItemRequest);
		((_ns1__modifyItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__modifyItemRequest[n];
		if (size)
			*size = n * sizeof(_ns1__modifyItemRequest);
		for (int i = 0; i < n; i++)
			((_ns1__modifyItemRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__modifyItemRequest*)cp->ptr;
}

void _ns1__markUnReadResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__markUnReadResponse))
		this->soap_mark(soap);
}

void _ns1__markUnReadResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__markUnReadResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__markUnReadResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__markUnReadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__markUnReadResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__markUnReadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__markUnReadResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__markUnReadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__markUnReadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__markUnReadResponse(struct soap *soap, const char *tag, int id, const _ns1__markUnReadResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__markUnReadResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__markUnReadResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__markUnReadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__markUnReadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__markUnReadResponse * SOAP_FMAC4 soap_get__ns1__markUnReadResponse(struct soap *soap, _ns1__markUnReadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__markUnReadResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__markUnReadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__markUnReadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__markUnReadResponse * SOAP_FMAC4 soap_in__ns1__markUnReadResponse(struct soap *soap, const char *tag, _ns1__markUnReadResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__markUnReadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__markUnReadResponse, sizeof(_ns1__markUnReadResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__markUnReadResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__markUnReadResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__markUnReadResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__markUnReadResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__markUnReadResponse, sizeof(_ns1__markUnReadResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__markUnReadResponse, sizeof(_ns1__markUnReadResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__markUnReadResponse * SOAP_FMAC6 soap_new__ns1__markUnReadResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__markUnReadResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__markUnReadResponse(struct soap *soap, _ns1__markUnReadResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__markUnReadResponse * SOAP_FMAC6 soap_instantiate__ns1__markUnReadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__markUnReadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__markUnReadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__markUnReadResponse;
		if (size)
			*size = sizeof(_ns1__markUnReadResponse);
		((_ns1__markUnReadResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__markUnReadResponse[n];
		if (size)
			*size = n * sizeof(_ns1__markUnReadResponse);
		for (int i = 0; i < n; i++)
			((_ns1__markUnReadResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__markUnReadResponse*)cp->ptr;
}

void _ns1__markUnReadRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__markUnReadRequest))
		this->soap_mark(soap);
}

void _ns1__markUnReadRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__markUnReadRequest*)this)->items, SOAP_TYPE_PointerTons1__ItemRefList);
	soap_mark_PointerTons1__ItemRefList(soap, &((_ns1__markUnReadRequest*)this)->items);
	/* transient soap skipped */
}

void _ns1__markUnReadRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ItemRefList(soap, &((_ns1__markUnReadRequest*)this)->items);
	/* transient soap skipped */
}

int _ns1__markUnReadRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__markUnReadRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__markUnReadRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__markUnReadRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__markUnReadRequest(struct soap *soap, const char *tag, int id, const _ns1__markUnReadRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__markUnReadRequest), "");
	soap_out_PointerTons1__ItemRefList(soap, "items", -1, &(((_ns1__markUnReadRequest*)a)->items), "ns1:ItemRefList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__markUnReadRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__markUnReadRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__markUnReadRequest * SOAP_FMAC4 soap_get__ns1__markUnReadRequest(struct soap *soap, _ns1__markUnReadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__markUnReadRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__markUnReadRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__markUnReadRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__markUnReadRequest * SOAP_FMAC4 soap_in__ns1__markUnReadRequest(struct soap *soap, const char *tag, _ns1__markUnReadRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__markUnReadRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__markUnReadRequest, sizeof(_ns1__markUnReadRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__markUnReadRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__markUnReadRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_items1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRefList(soap, "items", &(((_ns1__markUnReadRequest*)a)->items), "ns1:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__markUnReadRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__markUnReadRequest, sizeof(_ns1__markUnReadRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__markUnReadRequest, sizeof(_ns1__markUnReadRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__markUnReadRequest * SOAP_FMAC6 soap_new__ns1__markUnReadRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__markUnReadRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__markUnReadRequest(struct soap *soap, _ns1__markUnReadRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__markUnReadRequest * SOAP_FMAC6 soap_instantiate__ns1__markUnReadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__markUnReadRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__markUnReadRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__markUnReadRequest;
		if (size)
			*size = sizeof(_ns1__markUnReadRequest);
		((_ns1__markUnReadRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__markUnReadRequest[n];
		if (size)
			*size = n * sizeof(_ns1__markUnReadRequest);
		for (int i = 0; i < n; i++)
			((_ns1__markUnReadRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__markUnReadRequest*)cp->ptr;
}

void _ns1__markReadResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__markReadResponse))
		this->soap_mark(soap);
}

void _ns1__markReadResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__markReadResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__markReadResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__markReadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__markReadResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__markReadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__markReadResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__markReadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__markReadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__markReadResponse(struct soap *soap, const char *tag, int id, const _ns1__markReadResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__markReadResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__markReadResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__markReadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__markReadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__markReadResponse * SOAP_FMAC4 soap_get__ns1__markReadResponse(struct soap *soap, _ns1__markReadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__markReadResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__markReadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__markReadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__markReadResponse * SOAP_FMAC4 soap_in__ns1__markReadResponse(struct soap *soap, const char *tag, _ns1__markReadResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__markReadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__markReadResponse, sizeof(_ns1__markReadResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__markReadResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__markReadResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__markReadResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__markReadResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__markReadResponse, sizeof(_ns1__markReadResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__markReadResponse, sizeof(_ns1__markReadResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__markReadResponse * SOAP_FMAC6 soap_new__ns1__markReadResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__markReadResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__markReadResponse(struct soap *soap, _ns1__markReadResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__markReadResponse * SOAP_FMAC6 soap_instantiate__ns1__markReadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__markReadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__markReadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__markReadResponse;
		if (size)
			*size = sizeof(_ns1__markReadResponse);
		((_ns1__markReadResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__markReadResponse[n];
		if (size)
			*size = n * sizeof(_ns1__markReadResponse);
		for (int i = 0; i < n; i++)
			((_ns1__markReadResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__markReadResponse*)cp->ptr;
}

void _ns1__markReadRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__markReadRequest))
		this->soap_mark(soap);
}

void _ns1__markReadRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__markReadRequest*)this)->items, SOAP_TYPE_PointerTons1__ItemRefList);
	soap_mark_PointerTons1__ItemRefList(soap, &((_ns1__markReadRequest*)this)->items);
	/* transient soap skipped */
}

void _ns1__markReadRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ItemRefList(soap, &((_ns1__markReadRequest*)this)->items);
	/* transient soap skipped */
}

int _ns1__markReadRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__markReadRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__markReadRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__markReadRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__markReadRequest(struct soap *soap, const char *tag, int id, const _ns1__markReadRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__markReadRequest), "");
	soap_out_PointerTons1__ItemRefList(soap, "items", -1, &(((_ns1__markReadRequest*)a)->items), "ns1:ItemRefList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__markReadRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__markReadRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__markReadRequest * SOAP_FMAC4 soap_get__ns1__markReadRequest(struct soap *soap, _ns1__markReadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__markReadRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__markReadRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__markReadRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__markReadRequest * SOAP_FMAC4 soap_in__ns1__markReadRequest(struct soap *soap, const char *tag, _ns1__markReadRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__markReadRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__markReadRequest, sizeof(_ns1__markReadRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__markReadRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__markReadRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_items1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRefList(soap, "items", &(((_ns1__markReadRequest*)a)->items), "ns1:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__markReadRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__markReadRequest, sizeof(_ns1__markReadRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__markReadRequest, sizeof(_ns1__markReadRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__markReadRequest * SOAP_FMAC6 soap_new__ns1__markReadRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__markReadRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__markReadRequest(struct soap *soap, _ns1__markReadRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__markReadRequest * SOAP_FMAC6 soap_instantiate__ns1__markReadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__markReadRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__markReadRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__markReadRequest;
		if (size)
			*size = sizeof(_ns1__markReadRequest);
		((_ns1__markReadRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__markReadRequest[n];
		if (size)
			*size = n * sizeof(_ns1__markReadRequest);
		for (int i = 0; i < n; i++)
			((_ns1__markReadRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__markReadRequest*)cp->ptr;
}

void _ns1__logoutResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__logoutResponse))
		this->soap_mark(soap);
}

void _ns1__logoutResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__logoutResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__logoutResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__logoutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__logoutResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__logoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__logoutResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__logoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__logoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__logoutResponse(struct soap *soap, const char *tag, int id, const _ns1__logoutResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__logoutResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__logoutResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__logoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__logoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__logoutResponse * SOAP_FMAC4 soap_get__ns1__logoutResponse(struct soap *soap, _ns1__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__logoutResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__logoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__logoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__logoutResponse * SOAP_FMAC4 soap_in__ns1__logoutResponse(struct soap *soap, const char *tag, _ns1__logoutResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__logoutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__logoutResponse, sizeof(_ns1__logoutResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__logoutResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__logoutResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__logoutResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__logoutResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__logoutResponse, sizeof(_ns1__logoutResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__logoutResponse, sizeof(_ns1__logoutResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__logoutResponse * SOAP_FMAC6 soap_new__ns1__logoutResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__logoutResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__logoutResponse(struct soap *soap, _ns1__logoutResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__logoutResponse * SOAP_FMAC6 soap_instantiate__ns1__logoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__logoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__logoutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__logoutResponse;
		if (size)
			*size = sizeof(_ns1__logoutResponse);
		((_ns1__logoutResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__logoutResponse[n];
		if (size)
			*size = n * sizeof(_ns1__logoutResponse);
		for (int i = 0; i < n; i++)
			((_ns1__logoutResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__logoutResponse*)cp->ptr;
}

void _ns1__loginResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__loginResponse))
		this->soap_mark(soap);
}

void _ns1__loginResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__loginResponse*)this)->session, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((_ns1__loginResponse*)this)->session);
	soap_embedded(soap, &((_ns1__loginResponse*)this)->userinfo, SOAP_TYPE_PointerTons1__UserInfo);
	soap_mark_PointerTons1__UserInfo(soap, &((_ns1__loginResponse*)this)->userinfo);
	soap_embedded(soap, &((_ns1__loginResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__loginResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__loginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((_ns1__loginResponse*)this)->session);
	soap_default_PointerTons1__UserInfo(soap, &((_ns1__loginResponse*)this)->userinfo);
	soap_default_PointerTons1__Status(soap, &((_ns1__loginResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__loginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__loginResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loginResponse(struct soap *soap, const char *tag, int id, const _ns1__loginResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__loginResponse), "");
	soap_out_std__string(soap, "session", -1, &(((_ns1__loginResponse*)a)->session), "xsd:string");
	soap_out_PointerTons1__UserInfo(soap, "userinfo", -1, &(((_ns1__loginResponse*)a)->userinfo), "ns1:UserInfo");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__loginResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loginResponse * SOAP_FMAC4 soap_get__ns1__loginResponse(struct soap *soap, _ns1__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loginResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loginResponse * SOAP_FMAC4 soap_in__ns1__loginResponse(struct soap *soap, const char *tag, _ns1__loginResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__loginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loginResponse, sizeof(_ns1__loginResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__loginResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__loginResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_session1 = 1, soap_flag_userinfo1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_session1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "session", &(((_ns1__loginResponse*)a)->session), "xsd:string"))
				{	soap_flag_session1 = 0;
					continue;
				}

			if (soap_flag_userinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UserInfo(soap, "userinfo", &(((_ns1__loginResponse*)a)->userinfo), "ns1:UserInfo"))
				{	soap_flag_userinfo1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__loginResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_session1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__loginResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loginResponse, sizeof(_ns1__loginResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__loginResponse, sizeof(_ns1__loginResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__loginResponse * SOAP_FMAC6 soap_new__ns1__loginResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__loginResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__loginResponse(struct soap *soap, _ns1__loginResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__loginResponse * SOAP_FMAC6 soap_instantiate__ns1__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__loginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__loginResponse;
		if (size)
			*size = sizeof(_ns1__loginResponse);
		((_ns1__loginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__loginResponse[n];
		if (size)
			*size = n * sizeof(_ns1__loginResponse);
		for (int i = 0; i < n; i++)
			((_ns1__loginResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__loginResponse*)cp->ptr;
}

void _ns1__loginRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__loginRequest))
		this->soap_mark(soap);
}

void _ns1__loginRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__loginRequest*)this)->auth, SOAP_TYPE_PointerTons1__Authentication);
	soap_mark_PointerTons1__Authentication(soap, &((_ns1__loginRequest*)this)->auth);
	soap_embedded(soap, &((_ns1__loginRequest*)this)->language, SOAP_TYPE_xsd__language);
	soap_mark_xsd__language(soap, &((_ns1__loginRequest*)this)->language);
	soap_embedded(soap, &((_ns1__loginRequest*)this)->version, SOAP_TYPE_xsd__decimal);
	soap_mark_xsd__decimal(soap, &((_ns1__loginRequest*)this)->version);
	/* transient soap skipped */
}

void _ns1__loginRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Authentication(soap, &((_ns1__loginRequest*)this)->auth);
	soap_default_xsd__language(soap, &((_ns1__loginRequest*)this)->language);
	soap_default_xsd__decimal(soap, &((_ns1__loginRequest*)this)->version);
	/* transient soap skipped */
}

int _ns1__loginRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__loginRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__loginRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loginRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loginRequest(struct soap *soap, const char *tag, int id, const _ns1__loginRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__loginRequest), "");
	soap_out_PointerTons1__Authentication(soap, "auth", -1, &(((_ns1__loginRequest*)a)->auth), "ns1:Authentication");
	soap_out_xsd__language(soap, "language", -1, &(((_ns1__loginRequest*)a)->language), "xsd:language");
	soap_out_xsd__decimal(soap, "version", -1, &(((_ns1__loginRequest*)a)->version), "xsd:decimal");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__loginRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loginRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loginRequest * SOAP_FMAC4 soap_get__ns1__loginRequest(struct soap *soap, _ns1__loginRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loginRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__loginRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__loginRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loginRequest * SOAP_FMAC4 soap_in__ns1__loginRequest(struct soap *soap, const char *tag, _ns1__loginRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__loginRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loginRequest, sizeof(_ns1__loginRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__loginRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__loginRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_auth1 = 1, soap_flag_language1 = 1, soap_flag_version1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_auth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Authentication(soap, "auth", &(((_ns1__loginRequest*)a)->auth), "ns1:Authentication"))
				{	soap_flag_auth1 = 0;
					continue;
				}

			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__language(soap, "language", &(((_ns1__loginRequest*)a)->language), "xsd:language"))
				{	soap_flag_language1 = 0;
					continue;
				}

			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__decimal(soap, "version", &(((_ns1__loginRequest*)a)->version), "xsd:decimal"))
				{	soap_flag_version1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__loginRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loginRequest, sizeof(_ns1__loginRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__loginRequest, sizeof(_ns1__loginRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__loginRequest * SOAP_FMAC6 soap_new__ns1__loginRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__loginRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__loginRequest(struct soap *soap, _ns1__loginRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__loginRequest * SOAP_FMAC6 soap_instantiate__ns1__loginRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loginRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__loginRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__loginRequest;
		if (size)
			*size = sizeof(_ns1__loginRequest);
		((_ns1__loginRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__loginRequest[n];
		if (size)
			*size = n * sizeof(_ns1__loginRequest);
		for (int i = 0; i < n; i++)
			((_ns1__loginRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__loginRequest*)cp->ptr;
}

void _ns1__getTimezoneListResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getTimezoneListResponse))
		this->soap_mark(soap);
}

void _ns1__getTimezoneListResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getTimezoneListResponse*)this)->timezones, SOAP_TYPE_PointerTons1__TimezoneList);
	soap_mark_PointerTons1__TimezoneList(soap, &((_ns1__getTimezoneListResponse*)this)->timezones);
	soap_embedded(soap, &((_ns1__getTimezoneListResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getTimezoneListResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getTimezoneListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__TimezoneList(soap, &((_ns1__getTimezoneListResponse*)this)->timezones);
	soap_default_PointerTons1__Status(soap, &((_ns1__getTimezoneListResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getTimezoneListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getTimezoneListResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getTimezoneListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTimezoneListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTimezoneListResponse(struct soap *soap, const char *tag, int id, const _ns1__getTimezoneListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTimezoneListResponse), "");
	soap_out_PointerTons1__TimezoneList(soap, "timezones", -1, &(((_ns1__getTimezoneListResponse*)a)->timezones), "ns1:TimezoneList");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getTimezoneListResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getTimezoneListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTimezoneListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTimezoneListResponse * SOAP_FMAC4 soap_get__ns1__getTimezoneListResponse(struct soap *soap, _ns1__getTimezoneListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTimezoneListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getTimezoneListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTimezoneListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTimezoneListResponse * SOAP_FMAC4 soap_in__ns1__getTimezoneListResponse(struct soap *soap, const char *tag, _ns1__getTimezoneListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getTimezoneListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTimezoneListResponse, sizeof(_ns1__getTimezoneListResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getTimezoneListResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getTimezoneListResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_timezones1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_timezones1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TimezoneList(soap, "timezones", &(((_ns1__getTimezoneListResponse*)a)->timezones), "ns1:TimezoneList"))
				{	soap_flag_timezones1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getTimezoneListResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getTimezoneListResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTimezoneListResponse, sizeof(_ns1__getTimezoneListResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getTimezoneListResponse, sizeof(_ns1__getTimezoneListResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getTimezoneListResponse * SOAP_FMAC6 soap_new__ns1__getTimezoneListResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getTimezoneListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getTimezoneListResponse(struct soap *soap, _ns1__getTimezoneListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getTimezoneListResponse * SOAP_FMAC6 soap_instantiate__ns1__getTimezoneListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTimezoneListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTimezoneListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getTimezoneListResponse;
		if (size)
			*size = sizeof(_ns1__getTimezoneListResponse);
		((_ns1__getTimezoneListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getTimezoneListResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getTimezoneListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTimezoneListResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getTimezoneListResponse*)cp->ptr;
}

void _ns1__getSettingsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getSettingsResponse))
		this->soap_mark(soap);
}

void _ns1__getSettingsResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getSettingsResponse*)this)->settings, SOAP_TYPE_PointerTons1__Settings);
	soap_mark_PointerTons1__Settings(soap, &((_ns1__getSettingsResponse*)this)->settings);
	soap_embedded(soap, &((_ns1__getSettingsResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getSettingsResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getSettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Settings(soap, &((_ns1__getSettingsResponse*)this)->settings);
	soap_default_PointerTons1__Status(soap, &((_ns1__getSettingsResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getSettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getSettingsResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getSettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSettingsResponse(struct soap *soap, const char *tag, int id, const _ns1__getSettingsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSettingsResponse), "");
	soap_out_PointerTons1__Settings(soap, "settings", -1, &(((_ns1__getSettingsResponse*)a)->settings), "ns1:Settings");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getSettingsResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getSettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSettingsResponse * SOAP_FMAC4 soap_get__ns1__getSettingsResponse(struct soap *soap, _ns1__getSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSettingsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getSettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSettingsResponse * SOAP_FMAC4 soap_in__ns1__getSettingsResponse(struct soap *soap, const char *tag, _ns1__getSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getSettingsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSettingsResponse, sizeof(_ns1__getSettingsResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getSettingsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getSettingsResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_settings1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_settings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Settings(soap, "settings", &(((_ns1__getSettingsResponse*)a)->settings), "ns1:Settings"))
				{	soap_flag_settings1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getSettingsResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getSettingsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSettingsResponse, sizeof(_ns1__getSettingsResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getSettingsResponse, sizeof(_ns1__getSettingsResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getSettingsResponse * SOAP_FMAC6 soap_new__ns1__getSettingsResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getSettingsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getSettingsResponse(struct soap *soap, _ns1__getSettingsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getSettingsResponse * SOAP_FMAC6 soap_instantiate__ns1__getSettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSettingsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSettingsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getSettingsResponse;
		if (size)
			*size = sizeof(_ns1__getSettingsResponse);
		((_ns1__getSettingsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getSettingsResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getSettingsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getSettingsResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getSettingsResponse*)cp->ptr;
}

void _ns1__getSettingsRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getSettingsRequest))
		this->soap_mark(soap);
}

void _ns1__getSettingsRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getSettingsRequest*)this)->id, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getSettingsRequest*)this)->id);
	/* transient soap skipped */
}

void _ns1__getSettingsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__string(soap, &((_ns1__getSettingsRequest*)this)->id);
	/* transient soap skipped */
}

int _ns1__getSettingsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getSettingsRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getSettingsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSettingsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSettingsRequest(struct soap *soap, const char *tag, int id, const _ns1__getSettingsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSettingsRequest), "");
	soap_out_PointerTostd__string(soap, "id", -1, &(((_ns1__getSettingsRequest*)a)->id), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getSettingsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSettingsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSettingsRequest * SOAP_FMAC4 soap_get__ns1__getSettingsRequest(struct soap *soap, _ns1__getSettingsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getSettingsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSettingsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSettingsRequest * SOAP_FMAC4 soap_in__ns1__getSettingsRequest(struct soap *soap, const char *tag, _ns1__getSettingsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getSettingsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSettingsRequest, sizeof(_ns1__getSettingsRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getSettingsRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getSettingsRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "id", &(((_ns1__getSettingsRequest*)a)->id), "xsd:string"))
				{	soap_flag_id1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getSettingsRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSettingsRequest, sizeof(_ns1__getSettingsRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__getSettingsRequest, sizeof(_ns1__getSettingsRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getSettingsRequest * SOAP_FMAC6 soap_new__ns1__getSettingsRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__getSettingsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getSettingsRequest(struct soap *soap, _ns1__getSettingsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getSettingsRequest * SOAP_FMAC6 soap_instantiate__ns1__getSettingsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSettingsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSettingsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getSettingsRequest;
		if (size)
			*size = sizeof(_ns1__getSettingsRequest);
		((_ns1__getSettingsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getSettingsRequest[n];
		if (size)
			*size = n * sizeof(_ns1__getSettingsRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getSettingsRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getSettingsRequest*)cp->ptr;
}

void _ns1__getProxyListResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getProxyListResponse))
		this->soap_mark(soap);
}

void _ns1__getProxyListResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getProxyListResponse*)this)->proxies, SOAP_TYPE_PointerTons1__ProxyList);
	soap_mark_PointerTons1__ProxyList(soap, &((_ns1__getProxyListResponse*)this)->proxies);
	soap_embedded(soap, &((_ns1__getProxyListResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getProxyListResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getProxyListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ProxyList(soap, &((_ns1__getProxyListResponse*)this)->proxies);
	soap_default_PointerTons1__Status(soap, &((_ns1__getProxyListResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getProxyListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getProxyListResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getProxyListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getProxyListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getProxyListResponse(struct soap *soap, const char *tag, int id, const _ns1__getProxyListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getProxyListResponse), "");
	soap_out_PointerTons1__ProxyList(soap, "proxies", -1, &(((_ns1__getProxyListResponse*)a)->proxies), "ns1:ProxyList");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getProxyListResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getProxyListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getProxyListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getProxyListResponse * SOAP_FMAC4 soap_get__ns1__getProxyListResponse(struct soap *soap, _ns1__getProxyListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getProxyListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getProxyListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getProxyListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getProxyListResponse * SOAP_FMAC4 soap_in__ns1__getProxyListResponse(struct soap *soap, const char *tag, _ns1__getProxyListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getProxyListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getProxyListResponse, sizeof(_ns1__getProxyListResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getProxyListResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getProxyListResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_proxies1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_proxies1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProxyList(soap, "proxies", &(((_ns1__getProxyListResponse*)a)->proxies), "ns1:ProxyList"))
				{	soap_flag_proxies1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getProxyListResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getProxyListResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getProxyListResponse, sizeof(_ns1__getProxyListResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getProxyListResponse, sizeof(_ns1__getProxyListResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getProxyListResponse * SOAP_FMAC6 soap_new__ns1__getProxyListResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getProxyListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getProxyListResponse(struct soap *soap, _ns1__getProxyListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getProxyListResponse * SOAP_FMAC6 soap_instantiate__ns1__getProxyListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getProxyListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getProxyListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getProxyListResponse;
		if (size)
			*size = sizeof(_ns1__getProxyListResponse);
		((_ns1__getProxyListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getProxyListResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getProxyListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getProxyListResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getProxyListResponse*)cp->ptr;
}

void _ns1__getProxyAccessListResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getProxyAccessListResponse))
		this->soap_mark(soap);
}

void _ns1__getProxyAccessListResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getProxyAccessListResponse*)this)->accessRights, SOAP_TYPE_PointerTons1__AccessRightList);
	soap_mark_PointerTons1__AccessRightList(soap, &((_ns1__getProxyAccessListResponse*)this)->accessRights);
	soap_embedded(soap, &((_ns1__getProxyAccessListResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getProxyAccessListResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getProxyAccessListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__AccessRightList(soap, &((_ns1__getProxyAccessListResponse*)this)->accessRights);
	soap_default_PointerTons1__Status(soap, &((_ns1__getProxyAccessListResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getProxyAccessListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getProxyAccessListResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getProxyAccessListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getProxyAccessListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getProxyAccessListResponse(struct soap *soap, const char *tag, int id, const _ns1__getProxyAccessListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getProxyAccessListResponse), "");
	soap_out_PointerTons1__AccessRightList(soap, "accessRights", -1, &(((_ns1__getProxyAccessListResponse*)a)->accessRights), "ns1:AccessRightList");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getProxyAccessListResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getProxyAccessListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getProxyAccessListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getProxyAccessListResponse * SOAP_FMAC4 soap_get__ns1__getProxyAccessListResponse(struct soap *soap, _ns1__getProxyAccessListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getProxyAccessListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getProxyAccessListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getProxyAccessListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getProxyAccessListResponse * SOAP_FMAC4 soap_in__ns1__getProxyAccessListResponse(struct soap *soap, const char *tag, _ns1__getProxyAccessListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getProxyAccessListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getProxyAccessListResponse, sizeof(_ns1__getProxyAccessListResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getProxyAccessListResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getProxyAccessListResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_accessRights1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_accessRights1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessRightList(soap, "accessRights", &(((_ns1__getProxyAccessListResponse*)a)->accessRights), "ns1:AccessRightList"))
				{	soap_flag_accessRights1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getProxyAccessListResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getProxyAccessListResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getProxyAccessListResponse, sizeof(_ns1__getProxyAccessListResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getProxyAccessListResponse, sizeof(_ns1__getProxyAccessListResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getProxyAccessListResponse * SOAP_FMAC6 soap_new__ns1__getProxyAccessListResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getProxyAccessListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getProxyAccessListResponse(struct soap *soap, _ns1__getProxyAccessListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getProxyAccessListResponse * SOAP_FMAC6 soap_instantiate__ns1__getProxyAccessListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getProxyAccessListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getProxyAccessListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getProxyAccessListResponse;
		if (size)
			*size = sizeof(_ns1__getProxyAccessListResponse);
		((_ns1__getProxyAccessListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getProxyAccessListResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getProxyAccessListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getProxyAccessListResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getProxyAccessListResponse*)cp->ptr;
}

void _ns1__getItemsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getItemsResponse))
		this->soap_mark(soap);
}

void _ns1__getItemsResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getItemsResponse*)this)->items, SOAP_TYPE_PointerTons1__Items);
	soap_mark_PointerTons1__Items(soap, &((_ns1__getItemsResponse*)this)->items);
	soap_embedded(soap, &((_ns1__getItemsResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getItemsResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Items(soap, &((_ns1__getItemsResponse*)this)->items);
	soap_default_PointerTons1__Status(soap, &((_ns1__getItemsResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getItemsResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getItemsResponse(struct soap *soap, const char *tag, int id, const _ns1__getItemsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getItemsResponse), "");
	soap_out_PointerTons1__Items(soap, "items", -1, &(((_ns1__getItemsResponse*)a)->items), "ns1:Items");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getItemsResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getItemsResponse * SOAP_FMAC4 soap_get__ns1__getItemsResponse(struct soap *soap, _ns1__getItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getItemsResponse * SOAP_FMAC4 soap_in__ns1__getItemsResponse(struct soap *soap, const char *tag, _ns1__getItemsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getItemsResponse, sizeof(_ns1__getItemsResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getItemsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getItemsResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_items1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Items(soap, "items", &(((_ns1__getItemsResponse*)a)->items), "ns1:Items"))
				{	soap_flag_items1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getItemsResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getItemsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getItemsResponse, sizeof(_ns1__getItemsResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getItemsResponse, sizeof(_ns1__getItemsResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getItemsResponse * SOAP_FMAC6 soap_new__ns1__getItemsResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getItemsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getItemsResponse(struct soap *soap, _ns1__getItemsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getItemsResponse * SOAP_FMAC6 soap_instantiate__ns1__getItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getItemsResponse;
		if (size)
			*size = sizeof(_ns1__getItemsResponse);
		((_ns1__getItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getItemsResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getItemsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getItemsResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getItemsResponse*)cp->ptr;
}

void _ns1__getItemsRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getItemsRequest))
		this->soap_mark(soap);
}

void _ns1__getItemsRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getItemsRequest*)this)->container, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__getItemsRequest*)this)->container);
	soap_embedded(soap, &((_ns1__getItemsRequest*)this)->view, SOAP_TYPE_ns1__View);
	soap_mark_ns1__View(soap, &((_ns1__getItemsRequest*)this)->view);
	soap_embedded(soap, &((_ns1__getItemsRequest*)this)->filter, SOAP_TYPE_PointerTons1__Filter);
	soap_mark_PointerTons1__Filter(soap, &((_ns1__getItemsRequest*)this)->filter);
	soap_embedded(soap, &((_ns1__getItemsRequest*)this)->items, SOAP_TYPE_PointerTons1__ItemRefList);
	soap_mark_PointerTons1__ItemRefList(soap, &((_ns1__getItemsRequest*)this)->items);
	/* transient soap skipped */
}

void _ns1__getItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__getItemsRequest*)this)->container);
	soap_default_ns1__View(soap, &((_ns1__getItemsRequest*)this)->view);
	soap_default_PointerTons1__Filter(soap, &((_ns1__getItemsRequest*)this)->filter);
	soap_default_PointerTons1__ItemRefList(soap, &((_ns1__getItemsRequest*)this)->items);
	/* transient soap skipped */
}

int _ns1__getItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getItemsRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getItemsRequest(struct soap *soap, const char *tag, int id, const _ns1__getItemsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getItemsRequest), "");
	soap_out_ns1__uid(soap, "container", -1, &(((_ns1__getItemsRequest*)a)->container), "ns1:uid");
	soap_out_ns1__View(soap, "view", -1, &(((_ns1__getItemsRequest*)a)->view), "ns1:View");
	soap_out_PointerTons1__Filter(soap, "filter", -1, &(((_ns1__getItemsRequest*)a)->filter), "ns1:Filter");
	soap_out_PointerTons1__ItemRefList(soap, "items", -1, &(((_ns1__getItemsRequest*)a)->items), "ns1:ItemRefList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getItemsRequest * SOAP_FMAC4 soap_get__ns1__getItemsRequest(struct soap *soap, _ns1__getItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getItemsRequest * SOAP_FMAC4 soap_in__ns1__getItemsRequest(struct soap *soap, const char *tag, _ns1__getItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getItemsRequest, sizeof(_ns1__getItemsRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getItemsRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getItemsRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_container1 = 1, soap_flag_view1 = 1, soap_flag_filter1 = 1, soap_flag_items1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_container1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "container", &(((_ns1__getItemsRequest*)a)->container), "ns1:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}

			if (soap_flag_view1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__View(soap, "view", &(((_ns1__getItemsRequest*)a)->view), "ns1:View"))
				{	soap_flag_view1 = 0;
					continue;
				}

			if (soap_flag_filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Filter(soap, "filter", &(((_ns1__getItemsRequest*)a)->filter), "ns1:Filter"))
				{	soap_flag_filter1 = 0;
					continue;
				}

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRefList(soap, "items", &(((_ns1__getItemsRequest*)a)->items), "ns1:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_view1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getItemsRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getItemsRequest, sizeof(_ns1__getItemsRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__getItemsRequest, sizeof(_ns1__getItemsRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getItemsRequest * SOAP_FMAC6 soap_new__ns1__getItemsRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__getItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getItemsRequest(struct soap *soap, _ns1__getItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getItemsRequest * SOAP_FMAC6 soap_instantiate__ns1__getItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getItemsRequest;
		if (size)
			*size = sizeof(_ns1__getItemsRequest);
		((_ns1__getItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getItemsRequest[n];
		if (size)
			*size = n * sizeof(_ns1__getItemsRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getItemsRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getItemsRequest*)cp->ptr;
}

void _ns1__getItemResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getItemResponse))
		this->soap_mark(soap);
}

void _ns1__getItemResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getItemResponse*)this)->item, SOAP_TYPE_PointerTons1__Item);
	soap_mark_PointerTons1__Item(soap, &((_ns1__getItemResponse*)this)->item);
	soap_embedded(soap, &((_ns1__getItemResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Item(soap, &((_ns1__getItemResponse*)this)->item);
	soap_default_PointerTons1__Status(soap, &((_ns1__getItemResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getItemResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getItemResponse(struct soap *soap, const char *tag, int id, const _ns1__getItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getItemResponse), "");
	soap_out_PointerTons1__Item(soap, "item", -1, &(((_ns1__getItemResponse*)a)->item), "ns1:Item");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getItemResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getItemResponse * SOAP_FMAC4 soap_get__ns1__getItemResponse(struct soap *soap, _ns1__getItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getItemResponse * SOAP_FMAC4 soap_in__ns1__getItemResponse(struct soap *soap, const char *tag, _ns1__getItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getItemResponse, sizeof(_ns1__getItemResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getItemResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getItemResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_item1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Item(soap, "item", &(((_ns1__getItemResponse*)a)->item), "ns1:Item"))
				{	soap_flag_item1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getItemResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getItemResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getItemResponse, sizeof(_ns1__getItemResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getItemResponse, sizeof(_ns1__getItemResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getItemResponse * SOAP_FMAC6 soap_new__ns1__getItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getItemResponse(struct soap *soap, _ns1__getItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getItemResponse * SOAP_FMAC6 soap_instantiate__ns1__getItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getItemResponse;
		if (size)
			*size = sizeof(_ns1__getItemResponse);
		((_ns1__getItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getItemResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getItemResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getItemResponse*)cp->ptr;
}

void _ns1__getItemRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getItemRequest))
		this->soap_mark(soap);
}

void _ns1__getItemRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getItemRequest*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__getItemRequest*)this)->id);
	soap_embedded(soap, &((_ns1__getItemRequest*)this)->view, SOAP_TYPE_PointerTons1__View);
	soap_mark_PointerTons1__View(soap, &((_ns1__getItemRequest*)this)->view);
	/* transient soap skipped */
}

void _ns1__getItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__getItemRequest*)this)->id);
	soap_default_PointerTons1__View(soap, &((_ns1__getItemRequest*)this)->view);
	/* transient soap skipped */
}

int _ns1__getItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getItemRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getItemRequest(struct soap *soap, const char *tag, int id, const _ns1__getItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getItemRequest), "");
	soap_out_ns1__uid(soap, "id", -1, &(((_ns1__getItemRequest*)a)->id), "ns1:uid");
	soap_out_PointerTons1__View(soap, "view", -1, &(((_ns1__getItemRequest*)a)->view), "ns1:View");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getItemRequest * SOAP_FMAC4 soap_get__ns1__getItemRequest(struct soap *soap, _ns1__getItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getItemRequest * SOAP_FMAC4 soap_in__ns1__getItemRequest(struct soap *soap, const char *tag, _ns1__getItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getItemRequest, sizeof(_ns1__getItemRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getItemRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getItemRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_view1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((_ns1__getItemRequest*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_view1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__View(soap, "view", &(((_ns1__getItemRequest*)a)->view), "ns1:View"))
				{	soap_flag_view1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getItemRequest, sizeof(_ns1__getItemRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__getItemRequest, sizeof(_ns1__getItemRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getItemRequest * SOAP_FMAC6 soap_new__ns1__getItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__getItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getItemRequest(struct soap *soap, _ns1__getItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getItemRequest * SOAP_FMAC6 soap_instantiate__ns1__getItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getItemRequest;
		if (size)
			*size = sizeof(_ns1__getItemRequest);
		((_ns1__getItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getItemRequest[n];
		if (size)
			*size = n * sizeof(_ns1__getItemRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getItemRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getItemRequest*)cp->ptr;
}

void _ns1__getFreeBusyResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getFreeBusyResponse))
		this->soap_mark(soap);
}

void _ns1__getFreeBusyResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getFreeBusyResponse*)this)->freeBusyStats, SOAP_TYPE_PointerTons1__FreeBusyStats);
	soap_mark_PointerTons1__FreeBusyStats(soap, &((_ns1__getFreeBusyResponse*)this)->freeBusyStats);
	soap_embedded(soap, &((_ns1__getFreeBusyResponse*)this)->freeBusyInfo, SOAP_TYPE_PointerTons1__FreeBusyInfoList);
	soap_mark_PointerTons1__FreeBusyInfoList(soap, &((_ns1__getFreeBusyResponse*)this)->freeBusyInfo);
	soap_embedded(soap, &((_ns1__getFreeBusyResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getFreeBusyResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getFreeBusyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__FreeBusyStats(soap, &((_ns1__getFreeBusyResponse*)this)->freeBusyStats);
	soap_default_PointerTons1__FreeBusyInfoList(soap, &((_ns1__getFreeBusyResponse*)this)->freeBusyInfo);
	soap_default_PointerTons1__Status(soap, &((_ns1__getFreeBusyResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getFreeBusyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getFreeBusyResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getFreeBusyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getFreeBusyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getFreeBusyResponse(struct soap *soap, const char *tag, int id, const _ns1__getFreeBusyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getFreeBusyResponse), "");
	soap_out_PointerTons1__FreeBusyStats(soap, "freeBusyStats", -1, &(((_ns1__getFreeBusyResponse*)a)->freeBusyStats), "ns1:FreeBusyStats");
	soap_out_PointerTons1__FreeBusyInfoList(soap, "freeBusyInfo", -1, &(((_ns1__getFreeBusyResponse*)a)->freeBusyInfo), "ns1:FreeBusyInfoList");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getFreeBusyResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getFreeBusyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getFreeBusyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getFreeBusyResponse * SOAP_FMAC4 soap_get__ns1__getFreeBusyResponse(struct soap *soap, _ns1__getFreeBusyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getFreeBusyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getFreeBusyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getFreeBusyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getFreeBusyResponse * SOAP_FMAC4 soap_in__ns1__getFreeBusyResponse(struct soap *soap, const char *tag, _ns1__getFreeBusyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getFreeBusyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFreeBusyResponse, sizeof(_ns1__getFreeBusyResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getFreeBusyResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getFreeBusyResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_freeBusyStats1 = 1, soap_flag_freeBusyInfo1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_freeBusyStats1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FreeBusyStats(soap, "freeBusyStats", &(((_ns1__getFreeBusyResponse*)a)->freeBusyStats), "ns1:FreeBusyStats"))
				{	soap_flag_freeBusyStats1 = 0;
					continue;
				}

			if (soap_flag_freeBusyInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FreeBusyInfoList(soap, "freeBusyInfo", &(((_ns1__getFreeBusyResponse*)a)->freeBusyInfo), "ns1:FreeBusyInfoList"))
				{	soap_flag_freeBusyInfo1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getFreeBusyResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getFreeBusyResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFreeBusyResponse, sizeof(_ns1__getFreeBusyResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getFreeBusyResponse, sizeof(_ns1__getFreeBusyResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getFreeBusyResponse * SOAP_FMAC6 soap_new__ns1__getFreeBusyResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getFreeBusyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getFreeBusyResponse(struct soap *soap, _ns1__getFreeBusyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getFreeBusyResponse * SOAP_FMAC6 soap_instantiate__ns1__getFreeBusyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getFreeBusyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getFreeBusyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getFreeBusyResponse;
		if (size)
			*size = sizeof(_ns1__getFreeBusyResponse);
		((_ns1__getFreeBusyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getFreeBusyResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getFreeBusyResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getFreeBusyResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getFreeBusyResponse*)cp->ptr;
}

void _ns1__getFreeBusyRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getFreeBusyRequest))
		this->soap_mark(soap);
}

void _ns1__getFreeBusyRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getFreeBusyRequest*)this)->freeBusySessionId, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((_ns1__getFreeBusyRequest*)this)->freeBusySessionId);
	/* transient soap skipped */
}

void _ns1__getFreeBusyRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((_ns1__getFreeBusyRequest*)this)->freeBusySessionId);
	/* transient soap skipped */
}

int _ns1__getFreeBusyRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getFreeBusyRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getFreeBusyRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getFreeBusyRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getFreeBusyRequest(struct soap *soap, const char *tag, int id, const _ns1__getFreeBusyRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getFreeBusyRequest), "");
	soap_out_std__string(soap, "freeBusySessionId", -1, &(((_ns1__getFreeBusyRequest*)a)->freeBusySessionId), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getFreeBusyRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getFreeBusyRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getFreeBusyRequest * SOAP_FMAC4 soap_get__ns1__getFreeBusyRequest(struct soap *soap, _ns1__getFreeBusyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getFreeBusyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getFreeBusyRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getFreeBusyRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getFreeBusyRequest * SOAP_FMAC4 soap_in__ns1__getFreeBusyRequest(struct soap *soap, const char *tag, _ns1__getFreeBusyRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getFreeBusyRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFreeBusyRequest, sizeof(_ns1__getFreeBusyRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getFreeBusyRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getFreeBusyRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_freeBusySessionId1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_freeBusySessionId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "freeBusySessionId", &(((_ns1__getFreeBusyRequest*)a)->freeBusySessionId), "xsd:string"))
				{	soap_flag_freeBusySessionId1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_freeBusySessionId1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getFreeBusyRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFreeBusyRequest, sizeof(_ns1__getFreeBusyRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__getFreeBusyRequest, sizeof(_ns1__getFreeBusyRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getFreeBusyRequest * SOAP_FMAC6 soap_new__ns1__getFreeBusyRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__getFreeBusyRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getFreeBusyRequest(struct soap *soap, _ns1__getFreeBusyRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getFreeBusyRequest * SOAP_FMAC6 soap_instantiate__ns1__getFreeBusyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getFreeBusyRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getFreeBusyRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getFreeBusyRequest;
		if (size)
			*size = sizeof(_ns1__getFreeBusyRequest);
		((_ns1__getFreeBusyRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getFreeBusyRequest[n];
		if (size)
			*size = n * sizeof(_ns1__getFreeBusyRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getFreeBusyRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getFreeBusyRequest*)cp->ptr;
}

void _ns1__getFolderListResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getFolderListResponse))
		this->soap_mark(soap);
}

void _ns1__getFolderListResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getFolderListResponse*)this)->folders, SOAP_TYPE_PointerTons1__FolderList);
	soap_mark_PointerTons1__FolderList(soap, &((_ns1__getFolderListResponse*)this)->folders);
	soap_embedded(soap, &((_ns1__getFolderListResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getFolderListResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getFolderListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__FolderList(soap, &((_ns1__getFolderListResponse*)this)->folders);
	soap_default_PointerTons1__Status(soap, &((_ns1__getFolderListResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getFolderListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getFolderListResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getFolderListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getFolderListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getFolderListResponse(struct soap *soap, const char *tag, int id, const _ns1__getFolderListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getFolderListResponse), "");
	soap_out_PointerTons1__FolderList(soap, "folders", -1, &(((_ns1__getFolderListResponse*)a)->folders), "ns1:FolderList");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getFolderListResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getFolderListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getFolderListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getFolderListResponse * SOAP_FMAC4 soap_get__ns1__getFolderListResponse(struct soap *soap, _ns1__getFolderListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getFolderListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getFolderListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getFolderListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getFolderListResponse * SOAP_FMAC4 soap_in__ns1__getFolderListResponse(struct soap *soap, const char *tag, _ns1__getFolderListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getFolderListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFolderListResponse, sizeof(_ns1__getFolderListResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getFolderListResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getFolderListResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_folders1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_folders1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FolderList(soap, "folders", &(((_ns1__getFolderListResponse*)a)->folders), "ns1:FolderList"))
				{	soap_flag_folders1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getFolderListResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getFolderListResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFolderListResponse, sizeof(_ns1__getFolderListResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getFolderListResponse, sizeof(_ns1__getFolderListResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getFolderListResponse * SOAP_FMAC6 soap_new__ns1__getFolderListResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getFolderListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getFolderListResponse(struct soap *soap, _ns1__getFolderListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getFolderListResponse * SOAP_FMAC6 soap_instantiate__ns1__getFolderListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getFolderListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getFolderListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getFolderListResponse;
		if (size)
			*size = sizeof(_ns1__getFolderListResponse);
		((_ns1__getFolderListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getFolderListResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getFolderListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getFolderListResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getFolderListResponse*)cp->ptr;
}

void _ns1__getFolderListRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getFolderListRequest))
		this->soap_mark(soap);
}

void _ns1__getFolderListRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getFolderListRequest*)this)->parent, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__getFolderListRequest*)this)->parent);
	soap_embedded(soap, &((_ns1__getFolderListRequest*)this)->view, SOAP_TYPE_ns1__View);
	soap_mark_ns1__View(soap, &((_ns1__getFolderListRequest*)this)->view);
	soap_embedded(soap, &((_ns1__getFolderListRequest*)this)->recurse, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void _ns1__getFolderListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__getFolderListRequest*)this)->parent);
	soap_default_ns1__View(soap, &((_ns1__getFolderListRequest*)this)->view);
	soap_default_bool(soap, &((_ns1__getFolderListRequest*)this)->recurse);
	/* transient soap skipped */
}

int _ns1__getFolderListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getFolderListRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getFolderListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getFolderListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getFolderListRequest(struct soap *soap, const char *tag, int id, const _ns1__getFolderListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getFolderListRequest), "");
	soap_out_ns1__uid(soap, "parent", -1, &(((_ns1__getFolderListRequest*)a)->parent), "ns1:uid");
	soap_out_ns1__View(soap, "view", -1, &(((_ns1__getFolderListRequest*)a)->view), "ns1:View");
	soap_out_bool(soap, "recurse", -1, &(((_ns1__getFolderListRequest*)a)->recurse), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getFolderListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getFolderListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getFolderListRequest * SOAP_FMAC4 soap_get__ns1__getFolderListRequest(struct soap *soap, _ns1__getFolderListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getFolderListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getFolderListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getFolderListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getFolderListRequest * SOAP_FMAC4 soap_in__ns1__getFolderListRequest(struct soap *soap, const char *tag, _ns1__getFolderListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getFolderListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFolderListRequest, sizeof(_ns1__getFolderListRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getFolderListRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getFolderListRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_parent1 = 1, soap_flag_view1 = 1, soap_flag_recurse1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_parent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "parent", &(((_ns1__getFolderListRequest*)a)->parent), "ns1:uid"))
				{	soap_flag_parent1 = 0;
					continue;
				}

			if (soap_flag_view1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__View(soap, "view", &(((_ns1__getFolderListRequest*)a)->view), "ns1:View"))
				{	soap_flag_view1 = 0;
					continue;
				}

			if (soap_flag_recurse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "recurse", &(((_ns1__getFolderListRequest*)a)->recurse), ""))
				{	soap_flag_recurse1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent1 || soap_flag_view1 || soap_flag_recurse1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getFolderListRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFolderListRequest, sizeof(_ns1__getFolderListRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__getFolderListRequest, sizeof(_ns1__getFolderListRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getFolderListRequest * SOAP_FMAC6 soap_new__ns1__getFolderListRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__getFolderListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getFolderListRequest(struct soap *soap, _ns1__getFolderListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getFolderListRequest * SOAP_FMAC6 soap_instantiate__ns1__getFolderListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getFolderListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getFolderListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getFolderListRequest;
		if (size)
			*size = sizeof(_ns1__getFolderListRequest);
		((_ns1__getFolderListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getFolderListRequest[n];
		if (size)
			*size = n * sizeof(_ns1__getFolderListRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getFolderListRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getFolderListRequest*)cp->ptr;
}

void _ns1__getDeltaResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getDeltaResponse))
		this->soap_mark(soap);
}

void _ns1__getDeltaResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getDeltaResponse*)this)->used, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((_ns1__getDeltaResponse*)this)->changed, SOAP_TYPE_bool);
	soap_embedded(soap, &((_ns1__getDeltaResponse*)this)->deltas, SOAP_TYPE_PointerTons1__DeltaList);
	soap_mark_PointerTons1__DeltaList(soap, &((_ns1__getDeltaResponse*)this)->deltas);
	soap_embedded(soap, &((_ns1__getDeltaResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getDeltaResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getDeltaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedLong(soap, &((_ns1__getDeltaResponse*)this)->used);
	soap_default_bool(soap, &((_ns1__getDeltaResponse*)this)->changed);
	soap_default_PointerTons1__DeltaList(soap, &((_ns1__getDeltaResponse*)this)->deltas);
	soap_default_PointerTons1__Status(soap, &((_ns1__getDeltaResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getDeltaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getDeltaResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getDeltaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getDeltaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDeltaResponse(struct soap *soap, const char *tag, int id, const _ns1__getDeltaResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDeltaResponse), "");
	soap_out_unsignedLong(soap, "used", -1, &(((_ns1__getDeltaResponse*)a)->used), "");
	soap_out_bool(soap, "changed", -1, &(((_ns1__getDeltaResponse*)a)->changed), "");
	soap_out_PointerTons1__DeltaList(soap, "deltas", -1, &(((_ns1__getDeltaResponse*)a)->deltas), "ns1:DeltaList");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getDeltaResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getDeltaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getDeltaResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getDeltaResponse * SOAP_FMAC4 soap_get__ns1__getDeltaResponse(struct soap *soap, _ns1__getDeltaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDeltaResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getDeltaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getDeltaResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getDeltaResponse * SOAP_FMAC4 soap_in__ns1__getDeltaResponse(struct soap *soap, const char *tag, _ns1__getDeltaResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getDeltaResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDeltaResponse, sizeof(_ns1__getDeltaResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getDeltaResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getDeltaResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_used1 = 1, soap_flag_changed1 = 1, soap_flag_deltas1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_used1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "used", &(((_ns1__getDeltaResponse*)a)->used), ""))
				{	soap_flag_used1 = 0;
					continue;
				}

			if (soap_flag_changed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "changed", &(((_ns1__getDeltaResponse*)a)->changed), ""))
				{	soap_flag_changed1 = 0;
					continue;
				}

			if (soap_flag_deltas1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DeltaList(soap, "deltas", &(((_ns1__getDeltaResponse*)a)->deltas), "ns1:DeltaList"))
				{	soap_flag_deltas1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getDeltaResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_used1 || soap_flag_changed1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getDeltaResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDeltaResponse, sizeof(_ns1__getDeltaResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getDeltaResponse, sizeof(_ns1__getDeltaResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getDeltaResponse * SOAP_FMAC6 soap_new__ns1__getDeltaResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getDeltaResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getDeltaResponse(struct soap *soap, _ns1__getDeltaResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getDeltaResponse * SOAP_FMAC6 soap_instantiate__ns1__getDeltaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getDeltaResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getDeltaResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getDeltaResponse;
		if (size)
			*size = sizeof(_ns1__getDeltaResponse);
		((_ns1__getDeltaResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getDeltaResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getDeltaResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getDeltaResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getDeltaResponse*)cp->ptr;
}

void _ns1__getDeltaRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getDeltaRequest))
		this->soap_mark(soap);
}

void _ns1__getDeltaRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getDeltaRequest*)this)->AddressBookItem, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->AddressBookItem);
	soap_embedded(soap, &((_ns1__getDeltaRequest*)this)->Appointment, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Appointment);
	soap_embedded(soap, &((_ns1__getDeltaRequest*)this)->CalendarItem, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->CalendarItem);
	soap_embedded(soap, &((_ns1__getDeltaRequest*)this)->Contact, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Contact);
	soap_embedded(soap, &((_ns1__getDeltaRequest*)this)->Folder, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Folder);
	soap_embedded(soap, &((_ns1__getDeltaRequest*)this)->Group, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Group);
	soap_embedded(soap, &((_ns1__getDeltaRequest*)this)->Item, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Item);
	soap_embedded(soap, &((_ns1__getDeltaRequest*)this)->Mail, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Mail);
	soap_embedded(soap, &((_ns1__getDeltaRequest*)this)->Note, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Note);
	soap_embedded(soap, &((_ns1__getDeltaRequest*)this)->PhoneMessage, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->PhoneMessage);
	soap_embedded(soap, &((_ns1__getDeltaRequest*)this)->Task, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Task);
	/* transient soap skipped */
}

void _ns1__getDeltaRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->AddressBookItem);
	soap_default_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Appointment);
	soap_default_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->CalendarItem);
	soap_default_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Contact);
	soap_default_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Folder);
	soap_default_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Group);
	soap_default_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Item);
	soap_default_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Mail);
	soap_default_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Note);
	soap_default_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->PhoneMessage);
	soap_default_PointerTostd__string(soap, &((_ns1__getDeltaRequest*)this)->Task);
	/* transient soap skipped */
}

int _ns1__getDeltaRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getDeltaRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getDeltaRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getDeltaRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDeltaRequest(struct soap *soap, const char *tag, int id, const _ns1__getDeltaRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDeltaRequest), "");
	soap_out_PointerTostd__string(soap, "AddressBookItem", -1, &(((_ns1__getDeltaRequest*)a)->AddressBookItem), "xsd:string");
	soap_out_PointerTostd__string(soap, "Appointment", -1, &(((_ns1__getDeltaRequest*)a)->Appointment), "xsd:string");
	soap_out_PointerTostd__string(soap, "CalendarItem", -1, &(((_ns1__getDeltaRequest*)a)->CalendarItem), "xsd:string");
	soap_out_PointerTostd__string(soap, "Contact", -1, &(((_ns1__getDeltaRequest*)a)->Contact), "xsd:string");
	soap_out_PointerTostd__string(soap, "Folder", -1, &(((_ns1__getDeltaRequest*)a)->Folder), "xsd:string");
	soap_out_PointerTostd__string(soap, "Group", -1, &(((_ns1__getDeltaRequest*)a)->Group), "xsd:string");
	soap_out_PointerTostd__string(soap, "Item", -1, &(((_ns1__getDeltaRequest*)a)->Item), "xsd:string");
	soap_out_PointerTostd__string(soap, "Mail", -1, &(((_ns1__getDeltaRequest*)a)->Mail), "xsd:string");
	soap_out_PointerTostd__string(soap, "Note", -1, &(((_ns1__getDeltaRequest*)a)->Note), "xsd:string");
	soap_out_PointerTostd__string(soap, "PhoneMessage", -1, &(((_ns1__getDeltaRequest*)a)->PhoneMessage), "xsd:string");
	soap_out_PointerTostd__string(soap, "Task", -1, &(((_ns1__getDeltaRequest*)a)->Task), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getDeltaRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getDeltaRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getDeltaRequest * SOAP_FMAC4 soap_get__ns1__getDeltaRequest(struct soap *soap, _ns1__getDeltaRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDeltaRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getDeltaRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getDeltaRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getDeltaRequest * SOAP_FMAC4 soap_in__ns1__getDeltaRequest(struct soap *soap, const char *tag, _ns1__getDeltaRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getDeltaRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDeltaRequest, sizeof(_ns1__getDeltaRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getDeltaRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getDeltaRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_AddressBookItem1 = 1, soap_flag_Appointment1 = 1, soap_flag_CalendarItem1 = 1, soap_flag_Contact1 = 1, soap_flag_Folder1 = 1, soap_flag_Group1 = 1, soap_flag_Item1 = 1, soap_flag_Mail1 = 1, soap_flag_Note1 = 1, soap_flag_PhoneMessage1 = 1, soap_flag_Task1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_AddressBookItem1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "AddressBookItem", &(((_ns1__getDeltaRequest*)a)->AddressBookItem), "xsd:string"))
				{	soap_flag_AddressBookItem1 = 0;
					continue;
				}

			if (soap_flag_Appointment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "Appointment", &(((_ns1__getDeltaRequest*)a)->Appointment), "xsd:string"))
				{	soap_flag_Appointment1 = 0;
					continue;
				}

			if (soap_flag_CalendarItem1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "CalendarItem", &(((_ns1__getDeltaRequest*)a)->CalendarItem), "xsd:string"))
				{	soap_flag_CalendarItem1 = 0;
					continue;
				}

			if (soap_flag_Contact1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "Contact", &(((_ns1__getDeltaRequest*)a)->Contact), "xsd:string"))
				{	soap_flag_Contact1 = 0;
					continue;
				}

			if (soap_flag_Folder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "Folder", &(((_ns1__getDeltaRequest*)a)->Folder), "xsd:string"))
				{	soap_flag_Folder1 = 0;
					continue;
				}

			if (soap_flag_Group1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "Group", &(((_ns1__getDeltaRequest*)a)->Group), "xsd:string"))
				{	soap_flag_Group1 = 0;
					continue;
				}

			if (soap_flag_Item1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "Item", &(((_ns1__getDeltaRequest*)a)->Item), "xsd:string"))
				{	soap_flag_Item1 = 0;
					continue;
				}

			if (soap_flag_Mail1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "Mail", &(((_ns1__getDeltaRequest*)a)->Mail), "xsd:string"))
				{	soap_flag_Mail1 = 0;
					continue;
				}

			if (soap_flag_Note1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "Note", &(((_ns1__getDeltaRequest*)a)->Note), "xsd:string"))
				{	soap_flag_Note1 = 0;
					continue;
				}

			if (soap_flag_PhoneMessage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "PhoneMessage", &(((_ns1__getDeltaRequest*)a)->PhoneMessage), "xsd:string"))
				{	soap_flag_PhoneMessage1 = 0;
					continue;
				}

			if (soap_flag_Task1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "Task", &(((_ns1__getDeltaRequest*)a)->Task), "xsd:string"))
				{	soap_flag_Task1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getDeltaRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDeltaRequest, sizeof(_ns1__getDeltaRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__getDeltaRequest, sizeof(_ns1__getDeltaRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getDeltaRequest * SOAP_FMAC6 soap_new__ns1__getDeltaRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__getDeltaRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getDeltaRequest(struct soap *soap, _ns1__getDeltaRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getDeltaRequest * SOAP_FMAC6 soap_instantiate__ns1__getDeltaRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getDeltaRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getDeltaRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getDeltaRequest;
		if (size)
			*size = sizeof(_ns1__getDeltaRequest);
		((_ns1__getDeltaRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getDeltaRequest[n];
		if (size)
			*size = n * sizeof(_ns1__getDeltaRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getDeltaRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getDeltaRequest*)cp->ptr;
}

void _ns1__getCustomListResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getCustomListResponse))
		this->soap_mark(soap);
}

void _ns1__getCustomListResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getCustomListResponse*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((_ns1__getCustomListResponse*)this)->customs);
	soap_embedded(soap, &((_ns1__getCustomListResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getCustomListResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getCustomListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__CustomList(soap, &((_ns1__getCustomListResponse*)this)->customs);
	soap_default_PointerTons1__Status(soap, &((_ns1__getCustomListResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getCustomListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getCustomListResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getCustomListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getCustomListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCustomListResponse(struct soap *soap, const char *tag, int id, const _ns1__getCustomListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCustomListResponse), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((_ns1__getCustomListResponse*)a)->customs), "ns1:CustomList");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getCustomListResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getCustomListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getCustomListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getCustomListResponse * SOAP_FMAC4 soap_get__ns1__getCustomListResponse(struct soap *soap, _ns1__getCustomListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCustomListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getCustomListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getCustomListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getCustomListResponse * SOAP_FMAC4 soap_in__ns1__getCustomListResponse(struct soap *soap, const char *tag, _ns1__getCustomListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getCustomListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCustomListResponse, sizeof(_ns1__getCustomListResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getCustomListResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getCustomListResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_customs1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_customs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((_ns1__getCustomListResponse*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getCustomListResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getCustomListResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCustomListResponse, sizeof(_ns1__getCustomListResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getCustomListResponse, sizeof(_ns1__getCustomListResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getCustomListResponse * SOAP_FMAC6 soap_new__ns1__getCustomListResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getCustomListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getCustomListResponse(struct soap *soap, _ns1__getCustomListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getCustomListResponse * SOAP_FMAC6 soap_instantiate__ns1__getCustomListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getCustomListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getCustomListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getCustomListResponse;
		if (size)
			*size = sizeof(_ns1__getCustomListResponse);
		((_ns1__getCustomListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getCustomListResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getCustomListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getCustomListResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getCustomListResponse*)cp->ptr;
}

void _ns1__getCategoryListResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getCategoryListResponse))
		this->soap_mark(soap);
}

void _ns1__getCategoryListResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getCategoryListResponse*)this)->categories, SOAP_TYPE_PointerTons1__CategoryList);
	soap_mark_PointerTons1__CategoryList(soap, &((_ns1__getCategoryListResponse*)this)->categories);
	soap_embedded(soap, &((_ns1__getCategoryListResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getCategoryListResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getCategoryListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__CategoryList(soap, &((_ns1__getCategoryListResponse*)this)->categories);
	soap_default_PointerTons1__Status(soap, &((_ns1__getCategoryListResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getCategoryListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getCategoryListResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getCategoryListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getCategoryListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCategoryListResponse(struct soap *soap, const char *tag, int id, const _ns1__getCategoryListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCategoryListResponse), "");
	soap_out_PointerTons1__CategoryList(soap, "categories", -1, &(((_ns1__getCategoryListResponse*)a)->categories), "ns1:CategoryList");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getCategoryListResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getCategoryListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getCategoryListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getCategoryListResponse * SOAP_FMAC4 soap_get__ns1__getCategoryListResponse(struct soap *soap, _ns1__getCategoryListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCategoryListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getCategoryListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getCategoryListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getCategoryListResponse * SOAP_FMAC4 soap_in__ns1__getCategoryListResponse(struct soap *soap, const char *tag, _ns1__getCategoryListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getCategoryListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCategoryListResponse, sizeof(_ns1__getCategoryListResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getCategoryListResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getCategoryListResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_categories1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_categories1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryList(soap, "categories", &(((_ns1__getCategoryListResponse*)a)->categories), "ns1:CategoryList"))
				{	soap_flag_categories1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getCategoryListResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getCategoryListResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCategoryListResponse, sizeof(_ns1__getCategoryListResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getCategoryListResponse, sizeof(_ns1__getCategoryListResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getCategoryListResponse * SOAP_FMAC6 soap_new__ns1__getCategoryListResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getCategoryListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getCategoryListResponse(struct soap *soap, _ns1__getCategoryListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getCategoryListResponse * SOAP_FMAC6 soap_instantiate__ns1__getCategoryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getCategoryListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getCategoryListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getCategoryListResponse;
		if (size)
			*size = sizeof(_ns1__getCategoryListResponse);
		((_ns1__getCategoryListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getCategoryListResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getCategoryListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getCategoryListResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getCategoryListResponse*)cp->ptr;
}

void _ns1__getAttachmentResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getAttachmentResponse))
		this->soap_mark(soap);
}

void _ns1__getAttachmentResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getAttachmentResponse*)this)->part, SOAP_TYPE_PointerTons1__MessagePart);
	soap_mark_PointerTons1__MessagePart(soap, &((_ns1__getAttachmentResponse*)this)->part);
	soap_embedded(soap, &((_ns1__getAttachmentResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getAttachmentResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getAttachmentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__MessagePart(soap, &((_ns1__getAttachmentResponse*)this)->part);
	soap_default_PointerTons1__Status(soap, &((_ns1__getAttachmentResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getAttachmentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getAttachmentResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getAttachmentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAttachmentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAttachmentResponse(struct soap *soap, const char *tag, int id, const _ns1__getAttachmentResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAttachmentResponse), "");
	soap_out_PointerTons1__MessagePart(soap, "part", -1, &(((_ns1__getAttachmentResponse*)a)->part), "ns1:MessagePart");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getAttachmentResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getAttachmentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAttachmentResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAttachmentResponse * SOAP_FMAC4 soap_get__ns1__getAttachmentResponse(struct soap *soap, _ns1__getAttachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAttachmentResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getAttachmentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAttachmentResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAttachmentResponse * SOAP_FMAC4 soap_in__ns1__getAttachmentResponse(struct soap *soap, const char *tag, _ns1__getAttachmentResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getAttachmentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAttachmentResponse, sizeof(_ns1__getAttachmentResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getAttachmentResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getAttachmentResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_part1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_part1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MessagePart(soap, "part", &(((_ns1__getAttachmentResponse*)a)->part), "ns1:MessagePart"))
				{	soap_flag_part1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getAttachmentResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getAttachmentResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAttachmentResponse, sizeof(_ns1__getAttachmentResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getAttachmentResponse, sizeof(_ns1__getAttachmentResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getAttachmentResponse * SOAP_FMAC6 soap_new__ns1__getAttachmentResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getAttachmentResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getAttachmentResponse(struct soap *soap, _ns1__getAttachmentResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getAttachmentResponse * SOAP_FMAC6 soap_instantiate__ns1__getAttachmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAttachmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAttachmentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getAttachmentResponse;
		if (size)
			*size = sizeof(_ns1__getAttachmentResponse);
		((_ns1__getAttachmentResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getAttachmentResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getAttachmentResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getAttachmentResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getAttachmentResponse*)cp->ptr;
}

void _ns1__getAttachmentRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getAttachmentRequest))
		this->soap_mark(soap);
}

void _ns1__getAttachmentRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getAttachmentRequest*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__getAttachmentRequest*)this)->id);
	soap_embedded(soap, &((_ns1__getAttachmentRequest*)this)->offset, SOAP_TYPE_int);
	soap_embedded(soap, &((_ns1__getAttachmentRequest*)this)->length, SOAP_TYPE_int);
	/* transient soap skipped */
}

void _ns1__getAttachmentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__getAttachmentRequest*)this)->id);
	soap_default_int(soap, &((_ns1__getAttachmentRequest*)this)->offset);
	soap_default_int(soap, &((_ns1__getAttachmentRequest*)this)->length);
	/* transient soap skipped */
}

int _ns1__getAttachmentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getAttachmentRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getAttachmentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAttachmentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAttachmentRequest(struct soap *soap, const char *tag, int id, const _ns1__getAttachmentRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAttachmentRequest), "");
	soap_out_ns1__uid(soap, "id", -1, &(((_ns1__getAttachmentRequest*)a)->id), "ns1:uid");
	soap_out_int(soap, "offset", -1, &(((_ns1__getAttachmentRequest*)a)->offset), "");
	soap_out_int(soap, "length", -1, &(((_ns1__getAttachmentRequest*)a)->length), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getAttachmentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAttachmentRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAttachmentRequest * SOAP_FMAC4 soap_get__ns1__getAttachmentRequest(struct soap *soap, _ns1__getAttachmentRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAttachmentRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getAttachmentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAttachmentRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAttachmentRequest * SOAP_FMAC4 soap_in__ns1__getAttachmentRequest(struct soap *soap, const char *tag, _ns1__getAttachmentRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getAttachmentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAttachmentRequest, sizeof(_ns1__getAttachmentRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getAttachmentRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getAttachmentRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_offset1 = 1, soap_flag_length1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((_ns1__getAttachmentRequest*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_offset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &(((_ns1__getAttachmentRequest*)a)->offset), ""))
				{	soap_flag_offset1 = 0;
					continue;
				}

			if (soap_flag_length1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "length", &(((_ns1__getAttachmentRequest*)a)->length), ""))
				{	soap_flag_length1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_offset1 || soap_flag_length1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getAttachmentRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAttachmentRequest, sizeof(_ns1__getAttachmentRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__getAttachmentRequest, sizeof(_ns1__getAttachmentRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getAttachmentRequest * SOAP_FMAC6 soap_new__ns1__getAttachmentRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__getAttachmentRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getAttachmentRequest(struct soap *soap, _ns1__getAttachmentRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getAttachmentRequest * SOAP_FMAC6 soap_instantiate__ns1__getAttachmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAttachmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAttachmentRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getAttachmentRequest;
		if (size)
			*size = sizeof(_ns1__getAttachmentRequest);
		((_ns1__getAttachmentRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getAttachmentRequest[n];
		if (size)
			*size = n * sizeof(_ns1__getAttachmentRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getAttachmentRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getAttachmentRequest*)cp->ptr;
}

void _ns1__getAddressBookListResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__getAddressBookListResponse))
		this->soap_mark(soap);
}

void _ns1__getAddressBookListResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__getAddressBookListResponse*)this)->books, SOAP_TYPE_PointerTons1__AddressBookList);
	soap_mark_PointerTons1__AddressBookList(soap, &((_ns1__getAddressBookListResponse*)this)->books);
	soap_embedded(soap, &((_ns1__getAddressBookListResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__getAddressBookListResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__getAddressBookListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__AddressBookList(soap, &((_ns1__getAddressBookListResponse*)this)->books);
	soap_default_PointerTons1__Status(soap, &((_ns1__getAddressBookListResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__getAddressBookListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__getAddressBookListResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__getAddressBookListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAddressBookListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAddressBookListResponse(struct soap *soap, const char *tag, int id, const _ns1__getAddressBookListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAddressBookListResponse), "");
	soap_out_PointerTons1__AddressBookList(soap, "books", -1, &(((_ns1__getAddressBookListResponse*)a)->books), "ns1:AddressBookList");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__getAddressBookListResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__getAddressBookListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAddressBookListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAddressBookListResponse * SOAP_FMAC4 soap_get__ns1__getAddressBookListResponse(struct soap *soap, _ns1__getAddressBookListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAddressBookListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__getAddressBookListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAddressBookListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAddressBookListResponse * SOAP_FMAC4 soap_in__ns1__getAddressBookListResponse(struct soap *soap, const char *tag, _ns1__getAddressBookListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__getAddressBookListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAddressBookListResponse, sizeof(_ns1__getAddressBookListResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__getAddressBookListResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__getAddressBookListResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_books1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_books1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AddressBookList(soap, "books", &(((_ns1__getAddressBookListResponse*)a)->books), "ns1:AddressBookList"))
				{	soap_flag_books1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__getAddressBookListResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__getAddressBookListResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAddressBookListResponse, sizeof(_ns1__getAddressBookListResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__getAddressBookListResponse, sizeof(_ns1__getAddressBookListResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__getAddressBookListResponse * SOAP_FMAC6 soap_new__ns1__getAddressBookListResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__getAddressBookListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__getAddressBookListResponse(struct soap *soap, _ns1__getAddressBookListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__getAddressBookListResponse * SOAP_FMAC6 soap_instantiate__ns1__getAddressBookListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAddressBookListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAddressBookListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getAddressBookListResponse;
		if (size)
			*size = sizeof(_ns1__getAddressBookListResponse);
		((_ns1__getAddressBookListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getAddressBookListResponse[n];
		if (size)
			*size = n * sizeof(_ns1__getAddressBookListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getAddressBookListResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__getAddressBookListResponse*)cp->ptr;
}

void _ns1__destroyCursorResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__destroyCursorResponse))
		this->soap_mark(soap);
}

void _ns1__destroyCursorResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__destroyCursorResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__destroyCursorResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__destroyCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__destroyCursorResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__destroyCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__destroyCursorResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__destroyCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__destroyCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__destroyCursorResponse(struct soap *soap, const char *tag, int id, const _ns1__destroyCursorResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__destroyCursorResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__destroyCursorResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__destroyCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__destroyCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__destroyCursorResponse * SOAP_FMAC4 soap_get__ns1__destroyCursorResponse(struct soap *soap, _ns1__destroyCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__destroyCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__destroyCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__destroyCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__destroyCursorResponse * SOAP_FMAC4 soap_in__ns1__destroyCursorResponse(struct soap *soap, const char *tag, _ns1__destroyCursorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__destroyCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__destroyCursorResponse, sizeof(_ns1__destroyCursorResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__destroyCursorResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__destroyCursorResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__destroyCursorResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__destroyCursorResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__destroyCursorResponse, sizeof(_ns1__destroyCursorResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__destroyCursorResponse, sizeof(_ns1__destroyCursorResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__destroyCursorResponse * SOAP_FMAC6 soap_new__ns1__destroyCursorResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__destroyCursorResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__destroyCursorResponse(struct soap *soap, _ns1__destroyCursorResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__destroyCursorResponse * SOAP_FMAC6 soap_instantiate__ns1__destroyCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__destroyCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__destroyCursorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__destroyCursorResponse;
		if (size)
			*size = sizeof(_ns1__destroyCursorResponse);
		((_ns1__destroyCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__destroyCursorResponse[n];
		if (size)
			*size = n * sizeof(_ns1__destroyCursorResponse);
		for (int i = 0; i < n; i++)
			((_ns1__destroyCursorResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__destroyCursorResponse*)cp->ptr;
}

void _ns1__destroyCursorRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__destroyCursorRequest))
		this->soap_mark(soap);
}

void _ns1__destroyCursorRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__destroyCursorRequest*)this)->cursor, SOAP_TYPE_int);
	/* transient soap skipped */
}

void _ns1__destroyCursorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((_ns1__destroyCursorRequest*)this)->cursor);
	/* transient soap skipped */
}

int _ns1__destroyCursorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__destroyCursorRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__destroyCursorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__destroyCursorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__destroyCursorRequest(struct soap *soap, const char *tag, int id, const _ns1__destroyCursorRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__destroyCursorRequest), "");
	soap_out_int(soap, "cursor", -1, &(((_ns1__destroyCursorRequest*)a)->cursor), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__destroyCursorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__destroyCursorRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__destroyCursorRequest * SOAP_FMAC4 soap_get__ns1__destroyCursorRequest(struct soap *soap, _ns1__destroyCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__destroyCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__destroyCursorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__destroyCursorRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__destroyCursorRequest * SOAP_FMAC4 soap_in__ns1__destroyCursorRequest(struct soap *soap, const char *tag, _ns1__destroyCursorRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__destroyCursorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__destroyCursorRequest, sizeof(_ns1__destroyCursorRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__destroyCursorRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__destroyCursorRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_cursor1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_cursor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursor", &(((_ns1__destroyCursorRequest*)a)->cursor), ""))
				{	soap_flag_cursor1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cursor1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__destroyCursorRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__destroyCursorRequest, sizeof(_ns1__destroyCursorRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__destroyCursorRequest, sizeof(_ns1__destroyCursorRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__destroyCursorRequest * SOAP_FMAC6 soap_new__ns1__destroyCursorRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__destroyCursorRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__destroyCursorRequest(struct soap *soap, _ns1__destroyCursorRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__destroyCursorRequest * SOAP_FMAC6 soap_instantiate__ns1__destroyCursorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__destroyCursorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__destroyCursorRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__destroyCursorRequest;
		if (size)
			*size = sizeof(_ns1__destroyCursorRequest);
		((_ns1__destroyCursorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__destroyCursorRequest[n];
		if (size)
			*size = n * sizeof(_ns1__destroyCursorRequest);
		for (int i = 0; i < n; i++)
			((_ns1__destroyCursorRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__destroyCursorRequest*)cp->ptr;
}

void _ns1__delegateResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__delegateResponse))
		this->soap_mark(soap);
}

void _ns1__delegateResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__delegateResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__delegateResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__delegateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__delegateResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__delegateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__delegateResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__delegateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__delegateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__delegateResponse(struct soap *soap, const char *tag, int id, const _ns1__delegateResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__delegateResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__delegateResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__delegateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__delegateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__delegateResponse * SOAP_FMAC4 soap_get__ns1__delegateResponse(struct soap *soap, _ns1__delegateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__delegateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__delegateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__delegateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__delegateResponse * SOAP_FMAC4 soap_in__ns1__delegateResponse(struct soap *soap, const char *tag, _ns1__delegateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__delegateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__delegateResponse, sizeof(_ns1__delegateResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__delegateResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__delegateResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__delegateResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__delegateResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__delegateResponse, sizeof(_ns1__delegateResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__delegateResponse, sizeof(_ns1__delegateResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__delegateResponse * SOAP_FMAC6 soap_new__ns1__delegateResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__delegateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__delegateResponse(struct soap *soap, _ns1__delegateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__delegateResponse * SOAP_FMAC6 soap_instantiate__ns1__delegateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__delegateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__delegateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__delegateResponse;
		if (size)
			*size = sizeof(_ns1__delegateResponse);
		((_ns1__delegateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__delegateResponse[n];
		if (size)
			*size = n * sizeof(_ns1__delegateResponse);
		for (int i = 0; i < n; i++)
			((_ns1__delegateResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__delegateResponse*)cp->ptr;
}

void _ns1__delegateRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__delegateRequest))
		this->soap_mark(soap);
}

void _ns1__delegateRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__delegateRequest*)this)->items, SOAP_TYPE_PointerTons1__ItemRefList);
	soap_mark_PointerTons1__ItemRefList(soap, &((_ns1__delegateRequest*)this)->items);
	soap_embedded(soap, &((_ns1__delegateRequest*)this)->commentToOrganizer, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((_ns1__delegateRequest*)this)->commentToOrganizer);
	soap_embedded(soap, &((_ns1__delegateRequest*)this)->commentToDelegatee, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((_ns1__delegateRequest*)this)->commentToDelegatee);
	soap_embedded(soap, &((_ns1__delegateRequest*)this)->distribution, SOAP_TYPE_PointerTons1__Distribution);
	soap_mark_PointerTons1__Distribution(soap, &((_ns1__delegateRequest*)this)->distribution);
	soap_embedded(soap, &((_ns1__delegateRequest*)this)->recurrenceAllInstances, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((_ns1__delegateRequest*)this)->recurrenceAllInstances);
	/* transient soap skipped */
}

void _ns1__delegateRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ItemRefList(soap, &((_ns1__delegateRequest*)this)->items);
	soap_default_std__string(soap, &((_ns1__delegateRequest*)this)->commentToOrganizer);
	soap_default_std__string(soap, &((_ns1__delegateRequest*)this)->commentToDelegatee);
	soap_default_PointerTons1__Distribution(soap, &((_ns1__delegateRequest*)this)->distribution);
	soap_default_PointerTobool(soap, &((_ns1__delegateRequest*)this)->recurrenceAllInstances);
	/* transient soap skipped */
}

int _ns1__delegateRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__delegateRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__delegateRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__delegateRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__delegateRequest(struct soap *soap, const char *tag, int id, const _ns1__delegateRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__delegateRequest), "");
	soap_out_PointerTons1__ItemRefList(soap, "items", -1, &(((_ns1__delegateRequest*)a)->items), "ns1:ItemRefList");
	soap_out_std__string(soap, "commentToOrganizer", -1, &(((_ns1__delegateRequest*)a)->commentToOrganizer), "xsd:string");
	soap_out_std__string(soap, "commentToDelegatee", -1, &(((_ns1__delegateRequest*)a)->commentToDelegatee), "xsd:string");
	soap_out_PointerTons1__Distribution(soap, "distribution", -1, &(((_ns1__delegateRequest*)a)->distribution), "ns1:Distribution");
	soap_out_PointerTobool(soap, "recurrenceAllInstances", -1, &(((_ns1__delegateRequest*)a)->recurrenceAllInstances), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__delegateRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__delegateRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__delegateRequest * SOAP_FMAC4 soap_get__ns1__delegateRequest(struct soap *soap, _ns1__delegateRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__delegateRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__delegateRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__delegateRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__delegateRequest * SOAP_FMAC4 soap_in__ns1__delegateRequest(struct soap *soap, const char *tag, _ns1__delegateRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__delegateRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__delegateRequest, sizeof(_ns1__delegateRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__delegateRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__delegateRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_items1 = 1, soap_flag_commentToOrganizer1 = 1, soap_flag_commentToDelegatee1 = 1, soap_flag_distribution1 = 1, soap_flag_recurrenceAllInstances1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRefList(soap, "items", &(((_ns1__delegateRequest*)a)->items), "ns1:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}

			if (soap_flag_commentToOrganizer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "commentToOrganizer", &(((_ns1__delegateRequest*)a)->commentToOrganizer), "xsd:string"))
				{	soap_flag_commentToOrganizer1 = 0;
					continue;
				}

			if (soap_flag_commentToDelegatee1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "commentToDelegatee", &(((_ns1__delegateRequest*)a)->commentToDelegatee), "xsd:string"))
				{	soap_flag_commentToDelegatee1 = 0;
					continue;
				}

			if (soap_flag_distribution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Distribution(soap, "distribution", &(((_ns1__delegateRequest*)a)->distribution), "ns1:Distribution"))
				{	soap_flag_distribution1 = 0;
					continue;
				}

			if (soap_flag_recurrenceAllInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "recurrenceAllInstances", &(((_ns1__delegateRequest*)a)->recurrenceAllInstances), ""))
				{	soap_flag_recurrenceAllInstances1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_commentToOrganizer1 || soap_flag_commentToDelegatee1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__delegateRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__delegateRequest, sizeof(_ns1__delegateRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__delegateRequest, sizeof(_ns1__delegateRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__delegateRequest * SOAP_FMAC6 soap_new__ns1__delegateRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__delegateRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__delegateRequest(struct soap *soap, _ns1__delegateRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__delegateRequest * SOAP_FMAC6 soap_instantiate__ns1__delegateRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__delegateRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__delegateRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__delegateRequest;
		if (size)
			*size = sizeof(_ns1__delegateRequest);
		((_ns1__delegateRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__delegateRequest[n];
		if (size)
			*size = n * sizeof(_ns1__delegateRequest);
		for (int i = 0; i < n; i++)
			((_ns1__delegateRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__delegateRequest*)cp->ptr;
}

void _ns1__declineResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__declineResponse))
		this->soap_mark(soap);
}

void _ns1__declineResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__declineResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__declineResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__declineResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__declineResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__declineResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__declineResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__declineResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__declineResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__declineResponse(struct soap *soap, const char *tag, int id, const _ns1__declineResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__declineResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__declineResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__declineResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__declineResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__declineResponse * SOAP_FMAC4 soap_get__ns1__declineResponse(struct soap *soap, _ns1__declineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__declineResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__declineResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__declineResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__declineResponse * SOAP_FMAC4 soap_in__ns1__declineResponse(struct soap *soap, const char *tag, _ns1__declineResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__declineResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__declineResponse, sizeof(_ns1__declineResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__declineResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__declineResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__declineResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__declineResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__declineResponse, sizeof(_ns1__declineResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__declineResponse, sizeof(_ns1__declineResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__declineResponse * SOAP_FMAC6 soap_new__ns1__declineResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__declineResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__declineResponse(struct soap *soap, _ns1__declineResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__declineResponse * SOAP_FMAC6 soap_instantiate__ns1__declineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__declineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__declineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__declineResponse;
		if (size)
			*size = sizeof(_ns1__declineResponse);
		((_ns1__declineResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__declineResponse[n];
		if (size)
			*size = n * sizeof(_ns1__declineResponse);
		for (int i = 0; i < n; i++)
			((_ns1__declineResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__declineResponse*)cp->ptr;
}

void _ns1__declineRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__declineRequest))
		this->soap_mark(soap);
}

void _ns1__declineRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__declineRequest*)this)->items, SOAP_TYPE_PointerTons1__ItemRefList);
	soap_mark_PointerTons1__ItemRefList(soap, &((_ns1__declineRequest*)this)->items);
	soap_embedded(soap, &((_ns1__declineRequest*)this)->comment, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((_ns1__declineRequest*)this)->comment);
	soap_embedded(soap, &((_ns1__declineRequest*)this)->recurrenceAllInstances, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((_ns1__declineRequest*)this)->recurrenceAllInstances);
	/* transient soap skipped */
}

void _ns1__declineRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ItemRefList(soap, &((_ns1__declineRequest*)this)->items);
	soap_default_std__string(soap, &((_ns1__declineRequest*)this)->comment);
	soap_default_PointerTobool(soap, &((_ns1__declineRequest*)this)->recurrenceAllInstances);
	/* transient soap skipped */
}

int _ns1__declineRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__declineRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__declineRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__declineRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__declineRequest(struct soap *soap, const char *tag, int id, const _ns1__declineRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__declineRequest), "");
	soap_out_PointerTons1__ItemRefList(soap, "items", -1, &(((_ns1__declineRequest*)a)->items), "ns1:ItemRefList");
	soap_out_std__string(soap, "comment", -1, &(((_ns1__declineRequest*)a)->comment), "xsd:string");
	soap_out_PointerTobool(soap, "recurrenceAllInstances", -1, &(((_ns1__declineRequest*)a)->recurrenceAllInstances), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__declineRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__declineRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__declineRequest * SOAP_FMAC4 soap_get__ns1__declineRequest(struct soap *soap, _ns1__declineRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__declineRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__declineRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__declineRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__declineRequest * SOAP_FMAC4 soap_in__ns1__declineRequest(struct soap *soap, const char *tag, _ns1__declineRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__declineRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__declineRequest, sizeof(_ns1__declineRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__declineRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__declineRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_items1 = 1, soap_flag_comment1 = 1, soap_flag_recurrenceAllInstances1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRefList(soap, "items", &(((_ns1__declineRequest*)a)->items), "ns1:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}

			if (soap_flag_comment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "comment", &(((_ns1__declineRequest*)a)->comment), "xsd:string"))
				{	soap_flag_comment1 = 0;
					continue;
				}

			if (soap_flag_recurrenceAllInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "recurrenceAllInstances", &(((_ns1__declineRequest*)a)->recurrenceAllInstances), ""))
				{	soap_flag_recurrenceAllInstances1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_comment1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__declineRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__declineRequest, sizeof(_ns1__declineRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__declineRequest, sizeof(_ns1__declineRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__declineRequest * SOAP_FMAC6 soap_new__ns1__declineRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__declineRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__declineRequest(struct soap *soap, _ns1__declineRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__declineRequest * SOAP_FMAC6 soap_instantiate__ns1__declineRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__declineRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__declineRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__declineRequest;
		if (size)
			*size = sizeof(_ns1__declineRequest);
		((_ns1__declineRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__declineRequest[n];
		if (size)
			*size = n * sizeof(_ns1__declineRequest);
		for (int i = 0; i < n; i++)
			((_ns1__declineRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__declineRequest*)cp->ptr;
}

void _ns1__createProxyAccessResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__createProxyAccessResponse))
		this->soap_mark(soap);
}

void _ns1__createProxyAccessResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__createProxyAccessResponse*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__createProxyAccessResponse*)this)->id);
	soap_embedded(soap, &((_ns1__createProxyAccessResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__createProxyAccessResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__createProxyAccessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__createProxyAccessResponse*)this)->id);
	soap_default_PointerTons1__Status(soap, &((_ns1__createProxyAccessResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__createProxyAccessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__createProxyAccessResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__createProxyAccessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__createProxyAccessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createProxyAccessResponse(struct soap *soap, const char *tag, int id, const _ns1__createProxyAccessResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createProxyAccessResponse), "");
	soap_out_ns1__uid(soap, "id", -1, &(((_ns1__createProxyAccessResponse*)a)->id), "ns1:uid");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__createProxyAccessResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__createProxyAccessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__createProxyAccessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__createProxyAccessResponse * SOAP_FMAC4 soap_get__ns1__createProxyAccessResponse(struct soap *soap, _ns1__createProxyAccessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createProxyAccessResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__createProxyAccessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__createProxyAccessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__createProxyAccessResponse * SOAP_FMAC4 soap_in__ns1__createProxyAccessResponse(struct soap *soap, const char *tag, _ns1__createProxyAccessResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__createProxyAccessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createProxyAccessResponse, sizeof(_ns1__createProxyAccessResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__createProxyAccessResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__createProxyAccessResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((_ns1__createProxyAccessResponse*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__createProxyAccessResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__createProxyAccessResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createProxyAccessResponse, sizeof(_ns1__createProxyAccessResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__createProxyAccessResponse, sizeof(_ns1__createProxyAccessResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__createProxyAccessResponse * SOAP_FMAC6 soap_new__ns1__createProxyAccessResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__createProxyAccessResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__createProxyAccessResponse(struct soap *soap, _ns1__createProxyAccessResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__createProxyAccessResponse * SOAP_FMAC6 soap_instantiate__ns1__createProxyAccessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__createProxyAccessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__createProxyAccessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__createProxyAccessResponse;
		if (size)
			*size = sizeof(_ns1__createProxyAccessResponse);
		((_ns1__createProxyAccessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__createProxyAccessResponse[n];
		if (size)
			*size = n * sizeof(_ns1__createProxyAccessResponse);
		for (int i = 0; i < n; i++)
			((_ns1__createProxyAccessResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__createProxyAccessResponse*)cp->ptr;
}

void _ns1__createProxyAccessRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__createProxyAccessRequest))
		this->soap_mark(soap);
}

void _ns1__createProxyAccessRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__createProxyAccessRequest*)this)->entry, SOAP_TYPE_PointerTons1__AccessRightEntry);
	soap_mark_PointerTons1__AccessRightEntry(soap, &((_ns1__createProxyAccessRequest*)this)->entry);
	/* transient soap skipped */
}

void _ns1__createProxyAccessRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__AccessRightEntry(soap, &((_ns1__createProxyAccessRequest*)this)->entry);
	/* transient soap skipped */
}

int _ns1__createProxyAccessRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__createProxyAccessRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__createProxyAccessRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__createProxyAccessRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createProxyAccessRequest(struct soap *soap, const char *tag, int id, const _ns1__createProxyAccessRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createProxyAccessRequest), "");
	soap_out_PointerTons1__AccessRightEntry(soap, "entry", -1, &(((_ns1__createProxyAccessRequest*)a)->entry), "ns1:AccessRightEntry");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__createProxyAccessRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__createProxyAccessRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__createProxyAccessRequest * SOAP_FMAC4 soap_get__ns1__createProxyAccessRequest(struct soap *soap, _ns1__createProxyAccessRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__createProxyAccessRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__createProxyAccessRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__createProxyAccessRequest * SOAP_FMAC4 soap_in__ns1__createProxyAccessRequest(struct soap *soap, const char *tag, _ns1__createProxyAccessRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__createProxyAccessRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createProxyAccessRequest, sizeof(_ns1__createProxyAccessRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__createProxyAccessRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__createProxyAccessRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_entry1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_entry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessRightEntry(soap, "entry", &(((_ns1__createProxyAccessRequest*)a)->entry), "ns1:AccessRightEntry"))
				{	soap_flag_entry1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__createProxyAccessRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createProxyAccessRequest, sizeof(_ns1__createProxyAccessRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__createProxyAccessRequest, sizeof(_ns1__createProxyAccessRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__createProxyAccessRequest * SOAP_FMAC6 soap_new__ns1__createProxyAccessRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__createProxyAccessRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__createProxyAccessRequest(struct soap *soap, _ns1__createProxyAccessRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__createProxyAccessRequest * SOAP_FMAC6 soap_instantiate__ns1__createProxyAccessRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__createProxyAccessRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__createProxyAccessRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__createProxyAccessRequest;
		if (size)
			*size = sizeof(_ns1__createProxyAccessRequest);
		((_ns1__createProxyAccessRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__createProxyAccessRequest[n];
		if (size)
			*size = n * sizeof(_ns1__createProxyAccessRequest);
		for (int i = 0; i < n; i++)
			((_ns1__createProxyAccessRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__createProxyAccessRequest*)cp->ptr;
}

void _ns1__createItemResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__createItemResponse))
		this->soap_mark(soap);
}

void _ns1__createItemResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__createItemResponse*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__createItemResponse*)this)->id);
	soap_embedded(soap, &((_ns1__createItemResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__createItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__createItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__createItemResponse*)this)->id);
	soap_default_PointerTons1__Status(soap, &((_ns1__createItemResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__createItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__createItemResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__createItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__createItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createItemResponse(struct soap *soap, const char *tag, int id, const _ns1__createItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createItemResponse), "");
	soap_out_ns1__uid(soap, "id", -1, &(((_ns1__createItemResponse*)a)->id), "ns1:uid");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__createItemResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__createItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__createItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__createItemResponse * SOAP_FMAC4 soap_get__ns1__createItemResponse(struct soap *soap, _ns1__createItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__createItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__createItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__createItemResponse * SOAP_FMAC4 soap_in__ns1__createItemResponse(struct soap *soap, const char *tag, _ns1__createItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__createItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createItemResponse, sizeof(_ns1__createItemResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__createItemResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__createItemResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((_ns1__createItemResponse*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__createItemResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__createItemResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createItemResponse, sizeof(_ns1__createItemResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__createItemResponse, sizeof(_ns1__createItemResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__createItemResponse * SOAP_FMAC6 soap_new__ns1__createItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__createItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__createItemResponse(struct soap *soap, _ns1__createItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__createItemResponse * SOAP_FMAC6 soap_instantiate__ns1__createItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__createItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__createItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__createItemResponse;
		if (size)
			*size = sizeof(_ns1__createItemResponse);
		((_ns1__createItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__createItemResponse[n];
		if (size)
			*size = n * sizeof(_ns1__createItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__createItemResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__createItemResponse*)cp->ptr;
}

void _ns1__createItemRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__createItemRequest))
		this->soap_mark(soap);
}

void _ns1__createItemRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__createItemRequest*)this)->item, SOAP_TYPE_PointerTons1__Item);
	soap_mark_PointerTons1__Item(soap, &((_ns1__createItemRequest*)this)->item);
	/* transient soap skipped */
}

void _ns1__createItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Item(soap, &((_ns1__createItemRequest*)this)->item);
	/* transient soap skipped */
}

int _ns1__createItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__createItemRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__createItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__createItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createItemRequest(struct soap *soap, const char *tag, int id, const _ns1__createItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createItemRequest), "");
	soap_out_PointerTons1__Item(soap, "item", -1, &(((_ns1__createItemRequest*)a)->item), "ns1:Item");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__createItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__createItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__createItemRequest * SOAP_FMAC4 soap_get__ns1__createItemRequest(struct soap *soap, _ns1__createItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__createItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__createItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__createItemRequest * SOAP_FMAC4 soap_in__ns1__createItemRequest(struct soap *soap, const char *tag, _ns1__createItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__createItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createItemRequest, sizeof(_ns1__createItemRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__createItemRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__createItemRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_item1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Item(soap, "item", &(((_ns1__createItemRequest*)a)->item), "ns1:Item"))
				{	soap_flag_item1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__createItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createItemRequest, sizeof(_ns1__createItemRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__createItemRequest, sizeof(_ns1__createItemRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__createItemRequest * SOAP_FMAC6 soap_new__ns1__createItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__createItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__createItemRequest(struct soap *soap, _ns1__createItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__createItemRequest * SOAP_FMAC6 soap_instantiate__ns1__createItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__createItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__createItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__createItemRequest;
		if (size)
			*size = sizeof(_ns1__createItemRequest);
		((_ns1__createItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__createItemRequest[n];
		if (size)
			*size = n * sizeof(_ns1__createItemRequest);
		for (int i = 0; i < n; i++)
			((_ns1__createItemRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__createItemRequest*)cp->ptr;
}

void _ns1__createCursorResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__createCursorResponse))
		this->soap_mark(soap);
}

void _ns1__createCursorResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__createCursorResponse*)this)->cursor, SOAP_TYPE_int);
	soap_embedded(soap, &((_ns1__createCursorResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__createCursorResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__createCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((_ns1__createCursorResponse*)this)->cursor);
	soap_default_PointerTons1__Status(soap, &((_ns1__createCursorResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__createCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__createCursorResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__createCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__createCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createCursorResponse(struct soap *soap, const char *tag, int id, const _ns1__createCursorResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createCursorResponse), "");
	soap_out_int(soap, "cursor", -1, &(((_ns1__createCursorResponse*)a)->cursor), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__createCursorResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__createCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__createCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__createCursorResponse * SOAP_FMAC4 soap_get__ns1__createCursorResponse(struct soap *soap, _ns1__createCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__createCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__createCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__createCursorResponse * SOAP_FMAC4 soap_in__ns1__createCursorResponse(struct soap *soap, const char *tag, _ns1__createCursorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__createCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createCursorResponse, sizeof(_ns1__createCursorResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__createCursorResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__createCursorResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_cursor1 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_cursor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursor", &(((_ns1__createCursorResponse*)a)->cursor), ""))
				{	soap_flag_cursor1 = 0;
					continue;
				}

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__createCursorResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cursor1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__createCursorResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createCursorResponse, sizeof(_ns1__createCursorResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__createCursorResponse, sizeof(_ns1__createCursorResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__createCursorResponse * SOAP_FMAC6 soap_new__ns1__createCursorResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__createCursorResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__createCursorResponse(struct soap *soap, _ns1__createCursorResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__createCursorResponse * SOAP_FMAC6 soap_instantiate__ns1__createCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__createCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__createCursorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__createCursorResponse;
		if (size)
			*size = sizeof(_ns1__createCursorResponse);
		((_ns1__createCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__createCursorResponse[n];
		if (size)
			*size = n * sizeof(_ns1__createCursorResponse);
		for (int i = 0; i < n; i++)
			((_ns1__createCursorResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__createCursorResponse*)cp->ptr;
}

void _ns1__createCursorRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__createCursorRequest))
		this->soap_mark(soap);
}

void _ns1__createCursorRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__createCursorRequest*)this)->container, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__createCursorRequest*)this)->container);
	soap_embedded(soap, &((_ns1__createCursorRequest*)this)->view, SOAP_TYPE_ns1__View);
	soap_mark_ns1__View(soap, &((_ns1__createCursorRequest*)this)->view);
	soap_embedded(soap, &((_ns1__createCursorRequest*)this)->filter, SOAP_TYPE_PointerTons1__Filter);
	soap_mark_PointerTons1__Filter(soap, &((_ns1__createCursorRequest*)this)->filter);
	/* transient soap skipped */
}

void _ns1__createCursorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__createCursorRequest*)this)->container);
	soap_default_ns1__View(soap, &((_ns1__createCursorRequest*)this)->view);
	soap_default_PointerTons1__Filter(soap, &((_ns1__createCursorRequest*)this)->filter);
	/* transient soap skipped */
}

int _ns1__createCursorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__createCursorRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__createCursorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__createCursorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createCursorRequest(struct soap *soap, const char *tag, int id, const _ns1__createCursorRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createCursorRequest), "");
	soap_out_ns1__uid(soap, "container", -1, &(((_ns1__createCursorRequest*)a)->container), "ns1:uid");
	soap_out_ns1__View(soap, "view", -1, &(((_ns1__createCursorRequest*)a)->view), "ns1:View");
	soap_out_PointerTons1__Filter(soap, "filter", -1, &(((_ns1__createCursorRequest*)a)->filter), "ns1:Filter");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__createCursorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__createCursorRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__createCursorRequest * SOAP_FMAC4 soap_get__ns1__createCursorRequest(struct soap *soap, _ns1__createCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__createCursorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__createCursorRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__createCursorRequest * SOAP_FMAC4 soap_in__ns1__createCursorRequest(struct soap *soap, const char *tag, _ns1__createCursorRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__createCursorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createCursorRequest, sizeof(_ns1__createCursorRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__createCursorRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__createCursorRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_container1 = 1, soap_flag_view1 = 1, soap_flag_filter1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_container1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "container", &(((_ns1__createCursorRequest*)a)->container), "ns1:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}

			if (soap_flag_view1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__View(soap, "view", &(((_ns1__createCursorRequest*)a)->view), "ns1:View"))
				{	soap_flag_view1 = 0;
					continue;
				}

			if (soap_flag_filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Filter(soap, "filter", &(((_ns1__createCursorRequest*)a)->filter), "ns1:Filter"))
				{	soap_flag_filter1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_view1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__createCursorRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createCursorRequest, sizeof(_ns1__createCursorRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__createCursorRequest, sizeof(_ns1__createCursorRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__createCursorRequest * SOAP_FMAC6 soap_new__ns1__createCursorRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__createCursorRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__createCursorRequest(struct soap *soap, _ns1__createCursorRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__createCursorRequest * SOAP_FMAC6 soap_instantiate__ns1__createCursorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__createCursorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__createCursorRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__createCursorRequest;
		if (size)
			*size = sizeof(_ns1__createCursorRequest);
		((_ns1__createCursorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__createCursorRequest[n];
		if (size)
			*size = n * sizeof(_ns1__createCursorRequest);
		for (int i = 0; i < n; i++)
			((_ns1__createCursorRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__createCursorRequest*)cp->ptr;
}

void _ns1__completeResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__completeResponse))
		this->soap_mark(soap);
}

void _ns1__completeResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__completeResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__completeResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__completeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__completeResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__completeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__completeResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__completeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__completeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__completeResponse(struct soap *soap, const char *tag, int id, const _ns1__completeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__completeResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__completeResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__completeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__completeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__completeResponse * SOAP_FMAC4 soap_get__ns1__completeResponse(struct soap *soap, _ns1__completeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__completeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__completeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__completeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__completeResponse * SOAP_FMAC4 soap_in__ns1__completeResponse(struct soap *soap, const char *tag, _ns1__completeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__completeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__completeResponse, sizeof(_ns1__completeResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__completeResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__completeResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__completeResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__completeResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__completeResponse, sizeof(_ns1__completeResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__completeResponse, sizeof(_ns1__completeResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__completeResponse * SOAP_FMAC6 soap_new__ns1__completeResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__completeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__completeResponse(struct soap *soap, _ns1__completeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__completeResponse * SOAP_FMAC6 soap_instantiate__ns1__completeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__completeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__completeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__completeResponse;
		if (size)
			*size = sizeof(_ns1__completeResponse);
		((_ns1__completeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__completeResponse[n];
		if (size)
			*size = n * sizeof(_ns1__completeResponse);
		for (int i = 0; i < n; i++)
			((_ns1__completeResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__completeResponse*)cp->ptr;
}

void _ns1__completeRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__completeRequest))
		this->soap_mark(soap);
}

void _ns1__completeRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__completeRequest*)this)->items, SOAP_TYPE_PointerTons1__ItemRefList);
	soap_mark_PointerTons1__ItemRefList(soap, &((_ns1__completeRequest*)this)->items);
	/* transient soap skipped */
}

void _ns1__completeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ItemRefList(soap, &((_ns1__completeRequest*)this)->items);
	/* transient soap skipped */
}

int _ns1__completeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__completeRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__completeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__completeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__completeRequest(struct soap *soap, const char *tag, int id, const _ns1__completeRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__completeRequest), "");
	soap_out_PointerTons1__ItemRefList(soap, "items", -1, &(((_ns1__completeRequest*)a)->items), "ns1:ItemRefList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__completeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__completeRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__completeRequest * SOAP_FMAC4 soap_get__ns1__completeRequest(struct soap *soap, _ns1__completeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__completeRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__completeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__completeRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__completeRequest * SOAP_FMAC4 soap_in__ns1__completeRequest(struct soap *soap, const char *tag, _ns1__completeRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__completeRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__completeRequest, sizeof(_ns1__completeRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__completeRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__completeRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_items1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRefList(soap, "items", &(((_ns1__completeRequest*)a)->items), "ns1:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__completeRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__completeRequest, sizeof(_ns1__completeRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__completeRequest, sizeof(_ns1__completeRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__completeRequest * SOAP_FMAC6 soap_new__ns1__completeRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__completeRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__completeRequest(struct soap *soap, _ns1__completeRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__completeRequest * SOAP_FMAC6 soap_instantiate__ns1__completeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__completeRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__completeRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__completeRequest;
		if (size)
			*size = sizeof(_ns1__completeRequest);
		((_ns1__completeRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__completeRequest[n];
		if (size)
			*size = n * sizeof(_ns1__completeRequest);
		for (int i = 0; i < n; i++)
			((_ns1__completeRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__completeRequest*)cp->ptr;
}

void _ns1__closeFreeBusySessionResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__closeFreeBusySessionResponse))
		this->soap_mark(soap);
}

void _ns1__closeFreeBusySessionResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__closeFreeBusySessionResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__closeFreeBusySessionResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__closeFreeBusySessionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__closeFreeBusySessionResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__closeFreeBusySessionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__closeFreeBusySessionResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__closeFreeBusySessionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__closeFreeBusySessionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__closeFreeBusySessionResponse(struct soap *soap, const char *tag, int id, const _ns1__closeFreeBusySessionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__closeFreeBusySessionResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__closeFreeBusySessionResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__closeFreeBusySessionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__closeFreeBusySessionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__closeFreeBusySessionResponse * SOAP_FMAC4 soap_get__ns1__closeFreeBusySessionResponse(struct soap *soap, _ns1__closeFreeBusySessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__closeFreeBusySessionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__closeFreeBusySessionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__closeFreeBusySessionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__closeFreeBusySessionResponse * SOAP_FMAC4 soap_in__ns1__closeFreeBusySessionResponse(struct soap *soap, const char *tag, _ns1__closeFreeBusySessionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__closeFreeBusySessionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__closeFreeBusySessionResponse, sizeof(_ns1__closeFreeBusySessionResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__closeFreeBusySessionResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__closeFreeBusySessionResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__closeFreeBusySessionResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__closeFreeBusySessionResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__closeFreeBusySessionResponse, sizeof(_ns1__closeFreeBusySessionResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__closeFreeBusySessionResponse, sizeof(_ns1__closeFreeBusySessionResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__closeFreeBusySessionResponse * SOAP_FMAC6 soap_new__ns1__closeFreeBusySessionResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__closeFreeBusySessionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__closeFreeBusySessionResponse(struct soap *soap, _ns1__closeFreeBusySessionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__closeFreeBusySessionResponse * SOAP_FMAC6 soap_instantiate__ns1__closeFreeBusySessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__closeFreeBusySessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__closeFreeBusySessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__closeFreeBusySessionResponse;
		if (size)
			*size = sizeof(_ns1__closeFreeBusySessionResponse);
		((_ns1__closeFreeBusySessionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__closeFreeBusySessionResponse[n];
		if (size)
			*size = n * sizeof(_ns1__closeFreeBusySessionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__closeFreeBusySessionResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__closeFreeBusySessionResponse*)cp->ptr;
}

void _ns1__closeFreeBusySessionRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__closeFreeBusySessionRequest))
		this->soap_mark(soap);
}

void _ns1__closeFreeBusySessionRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__closeFreeBusySessionRequest*)this)->freeBusySessionId, SOAP_TYPE_int);
	/* transient soap skipped */
}

void _ns1__closeFreeBusySessionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((_ns1__closeFreeBusySessionRequest*)this)->freeBusySessionId);
	/* transient soap skipped */
}

int _ns1__closeFreeBusySessionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__closeFreeBusySessionRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__closeFreeBusySessionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__closeFreeBusySessionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__closeFreeBusySessionRequest(struct soap *soap, const char *tag, int id, const _ns1__closeFreeBusySessionRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__closeFreeBusySessionRequest), "");
	soap_out_int(soap, "freeBusySessionId", -1, &(((_ns1__closeFreeBusySessionRequest*)a)->freeBusySessionId), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__closeFreeBusySessionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__closeFreeBusySessionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__closeFreeBusySessionRequest * SOAP_FMAC4 soap_get__ns1__closeFreeBusySessionRequest(struct soap *soap, _ns1__closeFreeBusySessionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__closeFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__closeFreeBusySessionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__closeFreeBusySessionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__closeFreeBusySessionRequest * SOAP_FMAC4 soap_in__ns1__closeFreeBusySessionRequest(struct soap *soap, const char *tag, _ns1__closeFreeBusySessionRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__closeFreeBusySessionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__closeFreeBusySessionRequest, sizeof(_ns1__closeFreeBusySessionRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__closeFreeBusySessionRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__closeFreeBusySessionRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_freeBusySessionId1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_freeBusySessionId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "freeBusySessionId", &(((_ns1__closeFreeBusySessionRequest*)a)->freeBusySessionId), ""))
				{	soap_flag_freeBusySessionId1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_freeBusySessionId1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__closeFreeBusySessionRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__closeFreeBusySessionRequest, sizeof(_ns1__closeFreeBusySessionRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__closeFreeBusySessionRequest, sizeof(_ns1__closeFreeBusySessionRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__closeFreeBusySessionRequest * SOAP_FMAC6 soap_new__ns1__closeFreeBusySessionRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__closeFreeBusySessionRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__closeFreeBusySessionRequest(struct soap *soap, _ns1__closeFreeBusySessionRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__closeFreeBusySessionRequest * SOAP_FMAC6 soap_instantiate__ns1__closeFreeBusySessionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__closeFreeBusySessionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__closeFreeBusySessionRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__closeFreeBusySessionRequest;
		if (size)
			*size = sizeof(_ns1__closeFreeBusySessionRequest);
		((_ns1__closeFreeBusySessionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__closeFreeBusySessionRequest[n];
		if (size)
			*size = n * sizeof(_ns1__closeFreeBusySessionRequest);
		for (int i = 0; i < n; i++)
			((_ns1__closeFreeBusySessionRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__closeFreeBusySessionRequest*)cp->ptr;
}

void _ns1__addMembersResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__addMembersResponse))
		this->soap_mark(soap);
}

void _ns1__addMembersResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__addMembersResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__addMembersResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__addMembersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__addMembersResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__addMembersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__addMembersResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__addMembersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addMembersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addMembersResponse(struct soap *soap, const char *tag, int id, const _ns1__addMembersResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addMembersResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__addMembersResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__addMembersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addMembersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addMembersResponse * SOAP_FMAC4 soap_get__ns1__addMembersResponse(struct soap *soap, _ns1__addMembersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addMembersResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__addMembersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addMembersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addMembersResponse * SOAP_FMAC4 soap_in__ns1__addMembersResponse(struct soap *soap, const char *tag, _ns1__addMembersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__addMembersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addMembersResponse, sizeof(_ns1__addMembersResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__addMembersResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__addMembersResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__addMembersResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__addMembersResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addMembersResponse, sizeof(_ns1__addMembersResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__addMembersResponse, sizeof(_ns1__addMembersResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__addMembersResponse * SOAP_FMAC6 soap_new__ns1__addMembersResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__addMembersResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__addMembersResponse(struct soap *soap, _ns1__addMembersResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__addMembersResponse * SOAP_FMAC6 soap_instantiate__ns1__addMembersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addMembersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addMembersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__addMembersResponse;
		if (size)
			*size = sizeof(_ns1__addMembersResponse);
		((_ns1__addMembersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__addMembersResponse[n];
		if (size)
			*size = n * sizeof(_ns1__addMembersResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addMembersResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__addMembersResponse*)cp->ptr;
}

void _ns1__addMembersRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__addMembersRequest))
		this->soap_mark(soap);
}

void _ns1__addMembersRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__addMembersRequest*)this)->container, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__addMembersRequest*)this)->container);
	soap_embedded(soap, &((_ns1__addMembersRequest*)this)->members, SOAP_TYPE_PointerTons1__GroupMemberList);
	soap_mark_PointerTons1__GroupMemberList(soap, &((_ns1__addMembersRequest*)this)->members);
	/* transient soap skipped */
}

void _ns1__addMembersRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__addMembersRequest*)this)->container);
	soap_default_PointerTons1__GroupMemberList(soap, &((_ns1__addMembersRequest*)this)->members);
	/* transient soap skipped */
}

int _ns1__addMembersRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__addMembersRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__addMembersRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addMembersRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addMembersRequest(struct soap *soap, const char *tag, int id, const _ns1__addMembersRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addMembersRequest), "");
	soap_out_ns1__uid(soap, "container", -1, &(((_ns1__addMembersRequest*)a)->container), "ns1:uid");
	soap_out_PointerTons1__GroupMemberList(soap, "members", -1, &(((_ns1__addMembersRequest*)a)->members), "ns1:GroupMemberList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__addMembersRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addMembersRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addMembersRequest * SOAP_FMAC4 soap_get__ns1__addMembersRequest(struct soap *soap, _ns1__addMembersRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addMembersRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__addMembersRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addMembersRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addMembersRequest * SOAP_FMAC4 soap_in__ns1__addMembersRequest(struct soap *soap, const char *tag, _ns1__addMembersRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__addMembersRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addMembersRequest, sizeof(_ns1__addMembersRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__addMembersRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__addMembersRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_container1 = 1, soap_flag_members1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_container1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "container", &(((_ns1__addMembersRequest*)a)->container), "ns1:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}

			if (soap_flag_members1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GroupMemberList(soap, "members", &(((_ns1__addMembersRequest*)a)->members), "ns1:GroupMemberList"))
				{	soap_flag_members1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__addMembersRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addMembersRequest, sizeof(_ns1__addMembersRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__addMembersRequest, sizeof(_ns1__addMembersRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__addMembersRequest * SOAP_FMAC6 soap_new__ns1__addMembersRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__addMembersRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__addMembersRequest(struct soap *soap, _ns1__addMembersRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__addMembersRequest * SOAP_FMAC6 soap_instantiate__ns1__addMembersRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addMembersRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addMembersRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__addMembersRequest;
		if (size)
			*size = sizeof(_ns1__addMembersRequest);
		((_ns1__addMembersRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__addMembersRequest[n];
		if (size)
			*size = n * sizeof(_ns1__addMembersRequest);
		for (int i = 0; i < n; i++)
			((_ns1__addMembersRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__addMembersRequest*)cp->ptr;
}

void _ns1__addItemsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__addItemsResponse))
		this->soap_mark(soap);
}

void _ns1__addItemsResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__addItemsResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__addItemsResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__addItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__addItemsResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__addItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__addItemsResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__addItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addItemsResponse(struct soap *soap, const char *tag, int id, const _ns1__addItemsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addItemsResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__addItemsResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__addItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addItemsResponse * SOAP_FMAC4 soap_get__ns1__addItemsResponse(struct soap *soap, _ns1__addItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__addItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addItemsResponse * SOAP_FMAC4 soap_in__ns1__addItemsResponse(struct soap *soap, const char *tag, _ns1__addItemsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__addItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addItemsResponse, sizeof(_ns1__addItemsResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__addItemsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__addItemsResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__addItemsResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__addItemsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addItemsResponse, sizeof(_ns1__addItemsResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__addItemsResponse, sizeof(_ns1__addItemsResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__addItemsResponse * SOAP_FMAC6 soap_new__ns1__addItemsResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__addItemsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__addItemsResponse(struct soap *soap, _ns1__addItemsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__addItemsResponse * SOAP_FMAC6 soap_instantiate__ns1__addItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__addItemsResponse;
		if (size)
			*size = sizeof(_ns1__addItemsResponse);
		((_ns1__addItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__addItemsResponse[n];
		if (size)
			*size = n * sizeof(_ns1__addItemsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addItemsResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__addItemsResponse*)cp->ptr;
}

void _ns1__addItemsRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__addItemsRequest))
		this->soap_mark(soap);
}

void _ns1__addItemsRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__addItemsRequest*)this)->container, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__addItemsRequest*)this)->container);
	soap_embedded(soap, &((_ns1__addItemsRequest*)this)->items, SOAP_TYPE_PointerTons1__ItemRefList);
	soap_mark_PointerTons1__ItemRefList(soap, &((_ns1__addItemsRequest*)this)->items);
	/* transient soap skipped */
}

void _ns1__addItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__addItemsRequest*)this)->container);
	soap_default_PointerTons1__ItemRefList(soap, &((_ns1__addItemsRequest*)this)->items);
	/* transient soap skipped */
}

int _ns1__addItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__addItemsRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__addItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addItemsRequest(struct soap *soap, const char *tag, int id, const _ns1__addItemsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addItemsRequest), "");
	soap_out_ns1__uid(soap, "container", -1, &(((_ns1__addItemsRequest*)a)->container), "ns1:uid");
	soap_out_PointerTons1__ItemRefList(soap, "items", -1, &(((_ns1__addItemsRequest*)a)->items), "ns1:ItemRefList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__addItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addItemsRequest * SOAP_FMAC4 soap_get__ns1__addItemsRequest(struct soap *soap, _ns1__addItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__addItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addItemsRequest * SOAP_FMAC4 soap_in__ns1__addItemsRequest(struct soap *soap, const char *tag, _ns1__addItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__addItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addItemsRequest, sizeof(_ns1__addItemsRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__addItemsRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__addItemsRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_container1 = 1, soap_flag_items1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_container1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "container", &(((_ns1__addItemsRequest*)a)->container), "ns1:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRefList(soap, "items", &(((_ns1__addItemsRequest*)a)->items), "ns1:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__addItemsRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addItemsRequest, sizeof(_ns1__addItemsRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__addItemsRequest, sizeof(_ns1__addItemsRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__addItemsRequest * SOAP_FMAC6 soap_new__ns1__addItemsRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__addItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__addItemsRequest(struct soap *soap, _ns1__addItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__addItemsRequest * SOAP_FMAC6 soap_instantiate__ns1__addItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__addItemsRequest;
		if (size)
			*size = sizeof(_ns1__addItemsRequest);
		((_ns1__addItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__addItemsRequest[n];
		if (size)
			*size = n * sizeof(_ns1__addItemsRequest);
		for (int i = 0; i < n; i++)
			((_ns1__addItemsRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__addItemsRequest*)cp->ptr;
}

void _ns1__addItemResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__addItemResponse))
		this->soap_mark(soap);
}

void _ns1__addItemResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__addItemResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__addItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__addItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__addItemResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__addItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__addItemResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__addItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addItemResponse(struct soap *soap, const char *tag, int id, const _ns1__addItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addItemResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__addItemResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__addItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addItemResponse * SOAP_FMAC4 soap_get__ns1__addItemResponse(struct soap *soap, _ns1__addItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__addItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addItemResponse * SOAP_FMAC4 soap_in__ns1__addItemResponse(struct soap *soap, const char *tag, _ns1__addItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__addItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addItemResponse, sizeof(_ns1__addItemResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__addItemResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__addItemResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__addItemResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__addItemResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addItemResponse, sizeof(_ns1__addItemResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__addItemResponse, sizeof(_ns1__addItemResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__addItemResponse * SOAP_FMAC6 soap_new__ns1__addItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__addItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__addItemResponse(struct soap *soap, _ns1__addItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__addItemResponse * SOAP_FMAC6 soap_instantiate__ns1__addItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__addItemResponse;
		if (size)
			*size = sizeof(_ns1__addItemResponse);
		((_ns1__addItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__addItemResponse[n];
		if (size)
			*size = n * sizeof(_ns1__addItemResponse);
		for (int i = 0; i < n; i++)
			((_ns1__addItemResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__addItemResponse*)cp->ptr;
}

void _ns1__addItemRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__addItemRequest))
		this->soap_mark(soap);
}

void _ns1__addItemRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__addItemRequest*)this)->container, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__addItemRequest*)this)->container);
	soap_embedded(soap, &((_ns1__addItemRequest*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((_ns1__addItemRequest*)this)->id);
	/* transient soap skipped */
}

void _ns1__addItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((_ns1__addItemRequest*)this)->container);
	soap_default_ns1__uid(soap, &((_ns1__addItemRequest*)this)->id);
	/* transient soap skipped */
}

int _ns1__addItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__addItemRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__addItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addItemRequest(struct soap *soap, const char *tag, int id, const _ns1__addItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addItemRequest), "");
	soap_out_ns1__uid(soap, "container", -1, &(((_ns1__addItemRequest*)a)->container), "ns1:uid");
	soap_out_ns1__uid(soap, "id", -1, &(((_ns1__addItemRequest*)a)->id), "ns1:uid");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__addItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addItemRequest * SOAP_FMAC4 soap_get__ns1__addItemRequest(struct soap *soap, _ns1__addItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__addItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addItemRequest * SOAP_FMAC4 soap_in__ns1__addItemRequest(struct soap *soap, const char *tag, _ns1__addItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__addItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addItemRequest, sizeof(_ns1__addItemRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__addItemRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__addItemRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_container1 = 1, soap_flag_id1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_container1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "container", &(((_ns1__addItemRequest*)a)->container), "ns1:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((_ns1__addItemRequest*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__addItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addItemRequest, sizeof(_ns1__addItemRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__addItemRequest, sizeof(_ns1__addItemRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__addItemRequest * SOAP_FMAC6 soap_new__ns1__addItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__addItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__addItemRequest(struct soap *soap, _ns1__addItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__addItemRequest * SOAP_FMAC6 soap_instantiate__ns1__addItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__addItemRequest;
		if (size)
			*size = sizeof(_ns1__addItemRequest);
		((_ns1__addItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__addItemRequest[n];
		if (size)
			*size = n * sizeof(_ns1__addItemRequest);
		for (int i = 0; i < n; i++)
			((_ns1__addItemRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__addItemRequest*)cp->ptr;
}

void _ns1__acceptResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__acceptResponse))
		this->soap_mark(soap);
}

void _ns1__acceptResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__acceptResponse*)this)->status, SOAP_TYPE_PointerTons1__Status);
	soap_mark_PointerTons1__Status(soap, &((_ns1__acceptResponse*)this)->status);
	/* transient soap skipped */
}

void _ns1__acceptResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Status(soap, &((_ns1__acceptResponse*)this)->status);
	/* transient soap skipped */
}

int _ns1__acceptResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__acceptResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__acceptResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__acceptResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__acceptResponse(struct soap *soap, const char *tag, int id, const _ns1__acceptResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__acceptResponse), "");
	soap_out_PointerTons1__Status(soap, "status", -1, &(((_ns1__acceptResponse*)a)->status), "ns1:Status");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__acceptResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__acceptResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__acceptResponse * SOAP_FMAC4 soap_get__ns1__acceptResponse(struct soap *soap, _ns1__acceptResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__acceptResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__acceptResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__acceptResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__acceptResponse * SOAP_FMAC4 soap_in__ns1__acceptResponse(struct soap *soap, const char *tag, _ns1__acceptResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__acceptResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__acceptResponse, sizeof(_ns1__acceptResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__acceptResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__acceptResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "status", &(((_ns1__acceptResponse*)a)->status), "ns1:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (_ns1__acceptResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__acceptResponse, sizeof(_ns1__acceptResponse), soap->type, soap->arrayType), SOAP_TYPE__ns1__acceptResponse, sizeof(_ns1__acceptResponse));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__acceptResponse * SOAP_FMAC6 soap_new__ns1__acceptResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__acceptResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__acceptResponse(struct soap *soap, _ns1__acceptResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__acceptResponse * SOAP_FMAC6 soap_instantiate__ns1__acceptResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__acceptResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__acceptResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__acceptResponse;
		if (size)
			*size = sizeof(_ns1__acceptResponse);
		((_ns1__acceptResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__acceptResponse[n];
		if (size)
			*size = n * sizeof(_ns1__acceptResponse);
		for (int i = 0; i < n; i++)
			((_ns1__acceptResponse*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__acceptResponse*)cp->ptr;
}

void _ns1__acceptRequest::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE__ns1__acceptRequest))
		this->soap_mark(soap);
}

void _ns1__acceptRequest::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((_ns1__acceptRequest*)this)->items, SOAP_TYPE_PointerTons1__ItemRefList);
	soap_mark_PointerTons1__ItemRefList(soap, &((_ns1__acceptRequest*)this)->items);
	soap_embedded(soap, &((_ns1__acceptRequest*)this)->comment, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((_ns1__acceptRequest*)this)->comment);
	soap_embedded(soap, &((_ns1__acceptRequest*)this)->acceptLevel, SOAP_TYPE_ns1__AcceptLevel);
	soap_embedded(soap, &((_ns1__acceptRequest*)this)->recurrenceAllInstances, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((_ns1__acceptRequest*)this)->recurrenceAllInstances);
	/* transient soap skipped */
}

void _ns1__acceptRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ItemRefList(soap, &((_ns1__acceptRequest*)this)->items);
	soap_default_std__string(soap, &((_ns1__acceptRequest*)this)->comment);
	soap_default_ns1__AcceptLevel(soap, &((_ns1__acceptRequest*)this)->acceptLevel);
	soap_default_PointerTobool(soap, &((_ns1__acceptRequest*)this)->recurrenceAllInstances);
	/* transient soap skipped */
}

int _ns1__acceptRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE__ns1__acceptRequest);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int _ns1__acceptRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__acceptRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__acceptRequest(struct soap *soap, const char *tag, int id, const _ns1__acceptRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__acceptRequest), "");
	soap_out_PointerTons1__ItemRefList(soap, "items", -1, &(((_ns1__acceptRequest*)a)->items), "ns1:ItemRefList");
	soap_out_std__string(soap, "comment", -1, &(((_ns1__acceptRequest*)a)->comment), "xsd:string");
	soap_out_ns1__AcceptLevel(soap, "acceptLevel", -1, &(((_ns1__acceptRequest*)a)->acceptLevel), "ns1:AcceptLevel");
	soap_out_PointerTobool(soap, "recurrenceAllInstances", -1, &(((_ns1__acceptRequest*)a)->recurrenceAllInstances), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__acceptRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__acceptRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__acceptRequest * SOAP_FMAC4 soap_get__ns1__acceptRequest(struct soap *soap, _ns1__acceptRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__acceptRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__acceptRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__acceptRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__acceptRequest * SOAP_FMAC4 soap_in__ns1__acceptRequest(struct soap *soap, const char *tag, _ns1__acceptRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (_ns1__acceptRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__acceptRequest, sizeof(_ns1__acceptRequest), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE__ns1__acceptRequest)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (_ns1__acceptRequest *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_items1 = 1, soap_flag_comment1 = 1, soap_flag_acceptLevel1 = 1, soap_flag_recurrenceAllInstances1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRefList(soap, "items", &(((_ns1__acceptRequest*)a)->items), "ns1:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}

			if (soap_flag_comment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "comment", &(((_ns1__acceptRequest*)a)->comment), "xsd:string"))
				{	soap_flag_comment1 = 0;
					continue;
				}

			if (soap_flag_acceptLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__AcceptLevel(soap, "acceptLevel", &(((_ns1__acceptRequest*)a)->acceptLevel), "ns1:AcceptLevel"))
				{	soap_flag_acceptLevel1 = 0;
					continue;
				}

			if (soap_flag_recurrenceAllInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "recurrenceAllInstances", &(((_ns1__acceptRequest*)a)->recurrenceAllInstances), ""))
				{	soap_flag_recurrenceAllInstances1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_comment1 || soap_flag_acceptLevel1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (_ns1__acceptRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__acceptRequest, sizeof(_ns1__acceptRequest), soap->type, soap->arrayType), SOAP_TYPE__ns1__acceptRequest, sizeof(_ns1__acceptRequest));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__acceptRequest * SOAP_FMAC6 soap_new__ns1__acceptRequest(struct soap *soap, int n)
{	return soap_instantiate__ns1__acceptRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__acceptRequest(struct soap *soap, _ns1__acceptRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ns1__acceptRequest * SOAP_FMAC6 soap_instantiate__ns1__acceptRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__acceptRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__acceptRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__acceptRequest;
		if (size)
			*size = sizeof(_ns1__acceptRequest);
		((_ns1__acceptRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__acceptRequest[n];
		if (size)
			*size = n * sizeof(_ns1__acceptRequest);
		for (int i = 0; i < n; i++)
			((_ns1__acceptRequest*)cp->ptr)[i].soap = soap;
	}
	return (_ns1__acceptRequest*)cp->ptr;
}

void ns1__UserInfo::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__UserInfo))
		this->soap_mark(soap);
}

void ns1__UserInfo::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__UserInfo*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__UserInfo*)this)->name);
	soap_embedded(soap, &((ns1__UserInfo*)this)->email, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__UserInfo*)this)->email);
	soap_embedded(soap, &((ns1__UserInfo*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__UserInfo*)this)->uuid);
	/* transient soap skipped */
}

void ns1__UserInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__UserInfo*)this)->name);
	soap_default_std__string(soap, &((ns1__UserInfo*)this)->email);
	soap_default_ns1__UUID(soap, &((ns1__UserInfo*)this)->uuid);
	/* transient soap skipped */
}

int ns1__UserInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__UserInfo);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__UserInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UserInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UserInfo(struct soap *soap, const char *tag, int id, const ns1__UserInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UserInfo), "ns1:UserInfo");
	soap_out_std__string(soap, "name", -1, &(((ns1__UserInfo*)a)->name), "xsd:string");
	soap_out_std__string(soap, "email", -1, &(((ns1__UserInfo*)a)->email), "xsd:string");
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__UserInfo*)a)->uuid), "ns1:UUID");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__UserInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UserInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UserInfo * SOAP_FMAC4 soap_get_ns1__UserInfo(struct soap *soap, ns1__UserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UserInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__UserInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UserInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UserInfo * SOAP_FMAC4 soap_in_ns1__UserInfo(struct soap *soap, const char *tag, ns1__UserInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__UserInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserInfo, sizeof(ns1__UserInfo), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__UserInfo)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__UserInfo *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_name1 = 1, soap_flag_email1 = 1, soap_flag_uuid1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__UserInfo*)a)->name), "xsd:string"))
				{	soap_flag_name1 = 0;
					continue;
				}

			if (soap_flag_email1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "email", &(((ns1__UserInfo*)a)->email), "xsd:string"))
				{	soap_flag_email1 = 0;
					continue;
				}

			if (soap_flag_uuid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__UserInfo*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__UserInfo *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserInfo, sizeof(ns1__UserInfo), soap->type, soap->arrayType), SOAP_TYPE_ns1__UserInfo, sizeof(ns1__UserInfo));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__UserInfo * SOAP_FMAC6 soap_new_ns1__UserInfo(struct soap *soap, int n)
{	return soap_instantiate_ns1__UserInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__UserInfo(struct soap *soap, ns1__UserInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__UserInfo * SOAP_FMAC6 soap_instantiate_ns1__UserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__UserInfo;
		if (size)
			*size = sizeof(ns1__UserInfo);
		((ns1__UserInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__UserInfo[n];
		if (size)
			*size = n * sizeof(ns1__UserInfo);
		for (int i = 0; i < n; i++)
			((ns1__UserInfo*)cp->ptr)[i].soap = soap;
	}
	return (ns1__UserInfo*)cp->ptr;
}

void ns1__TrustedApplication::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__TrustedApplication))
		this->soap_mark(soap);
}

void ns1__TrustedApplication::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__TrustedApplication*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__TrustedApplication*)this)->name);
	soap_embedded(soap, &((ns1__TrustedApplication*)this)->key, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__TrustedApplication*)this)->key);
	/* transient soap skipped */
	/* transient soap skipped */
}

void ns1__TrustedApplication::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__TrustedApplication*)this)->name);
	soap_default_std__string(soap, &((ns1__TrustedApplication*)this)->key);
	/* transient soap skipped */
	/* transient soap skipped */
}

int ns1__TrustedApplication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__TrustedApplication);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__TrustedApplication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TrustedApplication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TrustedApplication(struct soap *soap, const char *tag, int id, const ns1__TrustedApplication *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TrustedApplication), "ns1:TrustedApplication");
	/* transient soap skipped */
	soap_out_std__string(soap, "name", -1, &(((ns1__TrustedApplication*)a)->name), "xsd:string");
	soap_out_std__string(soap, "key", -1, &(((ns1__TrustedApplication*)a)->key), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__TrustedApplication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TrustedApplication(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TrustedApplication * SOAP_FMAC4 soap_get_ns1__TrustedApplication(struct soap *soap, ns1__TrustedApplication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TrustedApplication(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__TrustedApplication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TrustedApplication(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TrustedApplication * SOAP_FMAC4 soap_in_ns1__TrustedApplication(struct soap *soap, const char *tag, ns1__TrustedApplication *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__TrustedApplication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TrustedApplication, sizeof(ns1__TrustedApplication), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__TrustedApplication)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__TrustedApplication *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_name1 = 1, soap_flag_key1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			/* transient soap skipped */
			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__TrustedApplication*)a)->name), "xsd:string"))
				{	soap_flag_name1 = 0;
					continue;
				}

			if (soap_flag_key1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "key", &(((ns1__TrustedApplication*)a)->key), "xsd:string"))
				{	soap_flag_key1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 || soap_flag_key1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__TrustedApplication *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TrustedApplication, sizeof(ns1__TrustedApplication), soap->type, soap->arrayType), SOAP_TYPE_ns1__TrustedApplication, sizeof(ns1__TrustedApplication));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__TrustedApplication * SOAP_FMAC6 soap_new_ns1__TrustedApplication(struct soap *soap, int n)
{	return soap_instantiate_ns1__TrustedApplication(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__TrustedApplication(struct soap *soap, ns1__TrustedApplication *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__TrustedApplication * SOAP_FMAC6 soap_instantiate_ns1__TrustedApplication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TrustedApplication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TrustedApplication, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__TrustedApplication;
		if (size)
			*size = sizeof(ns1__TrustedApplication);
		((ns1__TrustedApplication*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__TrustedApplication[n];
		if (size)
			*size = n * sizeof(ns1__TrustedApplication);
		for (int i = 0; i < n; i++)
			((ns1__TrustedApplication*)cp->ptr)[i].soap = soap;
	}
	return (ns1__TrustedApplication*)cp->ptr;
}

void ns1__TimezoneList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__TimezoneList))
		this->soap_mark(soap);
}

void ns1__TimezoneList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__TimezoneList*)this)->timezone, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Timezone);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Timezone(soap, &((ns1__TimezoneList*)this)->timezone);
	/* transient soap skipped */
}

void ns1__TimezoneList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__Timezone(soap, &((ns1__TimezoneList*)this)->timezone);
	/* transient soap skipped */
}

int ns1__TimezoneList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__TimezoneList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__TimezoneList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TimezoneList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TimezoneList(struct soap *soap, const char *tag, int id, const ns1__TimezoneList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TimezoneList), "ns1:TimezoneList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Timezone(soap, "timezone", -1, &(((ns1__TimezoneList*)a)->timezone), "ns1:Timezone");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__TimezoneList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TimezoneList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TimezoneList * SOAP_FMAC4 soap_get_ns1__TimezoneList(struct soap *soap, ns1__TimezoneList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TimezoneList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__TimezoneList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TimezoneList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TimezoneList * SOAP_FMAC4 soap_in_ns1__TimezoneList(struct soap *soap, const char *tag, ns1__TimezoneList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__TimezoneList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TimezoneList, sizeof(ns1__TimezoneList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__TimezoneList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__TimezoneList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__Timezone(soap, "timezone", &(((ns1__TimezoneList*)a)->timezone), "ns1:Timezone"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__TimezoneList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TimezoneList, sizeof(ns1__TimezoneList), soap->type, soap->arrayType), SOAP_TYPE_ns1__TimezoneList, sizeof(ns1__TimezoneList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__TimezoneList * SOAP_FMAC6 soap_new_ns1__TimezoneList(struct soap *soap, int n)
{	return soap_instantiate_ns1__TimezoneList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__TimezoneList(struct soap *soap, ns1__TimezoneList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__TimezoneList * SOAP_FMAC6 soap_instantiate_ns1__TimezoneList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TimezoneList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TimezoneList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__TimezoneList;
		if (size)
			*size = sizeof(ns1__TimezoneList);
		((ns1__TimezoneList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__TimezoneList[n];
		if (size)
			*size = n * sizeof(ns1__TimezoneList);
		for (int i = 0; i < n; i++)
			((ns1__TimezoneList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__TimezoneList*)cp->ptr;
}

void ns1__TimezoneComponent::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__TimezoneComponent))
		this->soap_mark(soap);
}

void ns1__TimezoneComponent::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__TimezoneComponent*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__TimezoneComponent*)this)->name);
	soap_embedded(soap, &((ns1__TimezoneComponent*)this)->month, SOAP_TYPE_PointerTons1__Month);
	soap_mark_PointerTons1__Month(soap, &((ns1__TimezoneComponent*)this)->month);
	soap_embedded(soap, &((ns1__TimezoneComponent*)this)->hour, SOAP_TYPE_PointerTons1__Hour);
	soap_mark_PointerTons1__Hour(soap, &((ns1__TimezoneComponent*)this)->hour);
	soap_embedded(soap, &((ns1__TimezoneComponent*)this)->minute, SOAP_TYPE_PointerTons1__Minute);
	soap_mark_PointerTons1__Minute(soap, &((ns1__TimezoneComponent*)this)->minute);
	soap_embedded(soap, &((ns1__TimezoneComponent*)this)->offset, SOAP_TYPE_ns1__GMTOffset);
	soap_embedded(soap, &((ns1__TimezoneComponent*)this)->day, SOAP_TYPE_PointerTons1__Day);
	soap_mark_PointerTons1__Day(soap, &((ns1__TimezoneComponent*)this)->day);
	soap_embedded(soap, &((ns1__TimezoneComponent*)this)->dayOfWeek, SOAP_TYPE_PointerTons1__DayOfWeek);
	soap_mark_PointerTons1__DayOfWeek(soap, &((ns1__TimezoneComponent*)this)->dayOfWeek);
	/* transient soap skipped */
}

void ns1__TimezoneComponent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__TimezoneComponent*)this)->name);
	soap_default_PointerTons1__Month(soap, &((ns1__TimezoneComponent*)this)->month);
	soap_default_PointerTons1__Hour(soap, &((ns1__TimezoneComponent*)this)->hour);
	soap_default_PointerTons1__Minute(soap, &((ns1__TimezoneComponent*)this)->minute);
	soap_default_ns1__GMTOffset(soap, &((ns1__TimezoneComponent*)this)->offset);
	soap_default_PointerTons1__Day(soap, &((ns1__TimezoneComponent*)this)->day);
	soap_default_PointerTons1__DayOfWeek(soap, &((ns1__TimezoneComponent*)this)->dayOfWeek);
	/* transient soap skipped */
}

int ns1__TimezoneComponent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__TimezoneComponent);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__TimezoneComponent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TimezoneComponent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TimezoneComponent(struct soap *soap, const char *tag, int id, const ns1__TimezoneComponent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TimezoneComponent), "ns1:TimezoneComponent");
	soap_out_std__string(soap, "name", -1, &(((ns1__TimezoneComponent*)a)->name), "xsd:string");
	soap_out_PointerTons1__Month(soap, "month", -1, &(((ns1__TimezoneComponent*)a)->month), "ns1:Month");
	soap_out_PointerTons1__Hour(soap, "hour", -1, &(((ns1__TimezoneComponent*)a)->hour), "ns1:Hour");
	soap_out_PointerTons1__Minute(soap, "minute", -1, &(((ns1__TimezoneComponent*)a)->minute), "ns1:Minute");
	soap_out_ns1__GMTOffset(soap, "offset", -1, &(((ns1__TimezoneComponent*)a)->offset), "ns1:GMTOffset");
	soap_out_PointerTons1__Day(soap, "day", -1, &(((ns1__TimezoneComponent*)a)->day), "ns1:Day");
	soap_out_PointerTons1__DayOfWeek(soap, "dayOfWeek", -1, &(((ns1__TimezoneComponent*)a)->dayOfWeek), "ns1:DayOfWeek");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__TimezoneComponent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TimezoneComponent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TimezoneComponent * SOAP_FMAC4 soap_get_ns1__TimezoneComponent(struct soap *soap, ns1__TimezoneComponent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TimezoneComponent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__TimezoneComponent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TimezoneComponent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TimezoneComponent * SOAP_FMAC4 soap_in_ns1__TimezoneComponent(struct soap *soap, const char *tag, ns1__TimezoneComponent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__TimezoneComponent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TimezoneComponent, sizeof(ns1__TimezoneComponent), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__TimezoneComponent)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__TimezoneComponent *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_name1 = 1, soap_flag_month1 = 1, soap_flag_hour1 = 1, soap_flag_minute1 = 1, soap_flag_offset1 = 1, soap_flag_day1 = 1, soap_flag_dayOfWeek1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__TimezoneComponent*)a)->name), "xsd:string"))
				{	soap_flag_name1 = 0;
					continue;
				}

			if (soap_flag_month1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Month(soap, "month", &(((ns1__TimezoneComponent*)a)->month), "ns1:Month"))
				{	soap_flag_month1 = 0;
					continue;
				}

			if (soap_flag_hour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Hour(soap, "hour", &(((ns1__TimezoneComponent*)a)->hour), "ns1:Hour"))
				{	soap_flag_hour1 = 0;
					continue;
				}

			if (soap_flag_minute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Minute(soap, "minute", &(((ns1__TimezoneComponent*)a)->minute), "ns1:Minute"))
				{	soap_flag_minute1 = 0;
					continue;
				}

			if (soap_flag_offset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__GMTOffset(soap, "offset", &(((ns1__TimezoneComponent*)a)->offset), "ns1:GMTOffset"))
				{	soap_flag_offset1 = 0;
					continue;
				}

			if (soap_flag_day1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Day(soap, "day", &(((ns1__TimezoneComponent*)a)->day), "ns1:Day"))
				{	soap_flag_day1 = 0;
					continue;
				}

			if (soap_flag_dayOfWeek1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DayOfWeek(soap, "dayOfWeek", &(((ns1__TimezoneComponent*)a)->dayOfWeek), "ns1:DayOfWeek"))
				{	soap_flag_dayOfWeek1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 || soap_flag_offset1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__TimezoneComponent *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TimezoneComponent, sizeof(ns1__TimezoneComponent), soap->type, soap->arrayType), SOAP_TYPE_ns1__TimezoneComponent, sizeof(ns1__TimezoneComponent));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__TimezoneComponent * SOAP_FMAC6 soap_new_ns1__TimezoneComponent(struct soap *soap, int n)
{	return soap_instantiate_ns1__TimezoneComponent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__TimezoneComponent(struct soap *soap, ns1__TimezoneComponent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__TimezoneComponent * SOAP_FMAC6 soap_instantiate_ns1__TimezoneComponent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TimezoneComponent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TimezoneComponent, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__TimezoneComponent;
		if (size)
			*size = sizeof(ns1__TimezoneComponent);
		((ns1__TimezoneComponent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__TimezoneComponent[n];
		if (size)
			*size = n * sizeof(ns1__TimezoneComponent);
		for (int i = 0; i < n; i++)
			((ns1__TimezoneComponent*)cp->ptr)[i].soap = soap;
	}
	return (ns1__TimezoneComponent*)cp->ptr;
}

void ns1__Timezone::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Timezone))
		this->soap_mark(soap);
}

void ns1__Timezone::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Timezone*)this)->id, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Timezone*)this)->id);
	soap_embedded(soap, &((ns1__Timezone*)this)->description, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Timezone*)this)->description);
	soap_embedded(soap, &((ns1__Timezone*)this)->daylight, SOAP_TYPE_PointerTons1__TimezoneComponent);
	soap_mark_PointerTons1__TimezoneComponent(soap, &((ns1__Timezone*)this)->daylight);
	soap_embedded(soap, &((ns1__Timezone*)this)->standard, SOAP_TYPE_PointerTons1__TimezoneComponent);
	soap_mark_PointerTons1__TimezoneComponent(soap, &((ns1__Timezone*)this)->standard);
	/* transient soap skipped */
}

void ns1__Timezone::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__Timezone*)this)->id);
	soap_default_std__string(soap, &((ns1__Timezone*)this)->description);
	soap_default_PointerTons1__TimezoneComponent(soap, &((ns1__Timezone*)this)->daylight);
	soap_default_PointerTons1__TimezoneComponent(soap, &((ns1__Timezone*)this)->standard);
	/* transient soap skipped */
}

int ns1__Timezone::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Timezone);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Timezone::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Timezone(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Timezone(struct soap *soap, const char *tag, int id, const ns1__Timezone *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Timezone), "ns1:Timezone");
	soap_out_std__string(soap, "id", -1, &(((ns1__Timezone*)a)->id), "xsd:string");
	soap_out_std__string(soap, "description", -1, &(((ns1__Timezone*)a)->description), "xsd:string");
	soap_out_PointerTons1__TimezoneComponent(soap, "daylight", -1, &(((ns1__Timezone*)a)->daylight), "ns1:TimezoneComponent");
	soap_out_PointerTons1__TimezoneComponent(soap, "standard", -1, &(((ns1__Timezone*)a)->standard), "ns1:TimezoneComponent");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Timezone::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Timezone(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Timezone * SOAP_FMAC4 soap_get_ns1__Timezone(struct soap *soap, ns1__Timezone *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Timezone(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Timezone::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Timezone(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Timezone * SOAP_FMAC4 soap_in_ns1__Timezone(struct soap *soap, const char *tag, ns1__Timezone *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Timezone *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Timezone, sizeof(ns1__Timezone), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Timezone)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Timezone *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_description1 = 1, soap_flag_daylight1 = 1, soap_flag_standard1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "id", &(((ns1__Timezone*)a)->id), "xsd:string"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_description1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "description", &(((ns1__Timezone*)a)->description), "xsd:string"))
				{	soap_flag_description1 = 0;
					continue;
				}

			if (soap_flag_daylight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TimezoneComponent(soap, "daylight", &(((ns1__Timezone*)a)->daylight), "ns1:TimezoneComponent"))
				{	soap_flag_daylight1 = 0;
					continue;
				}

			if (soap_flag_standard1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TimezoneComponent(soap, "standard", &(((ns1__Timezone*)a)->standard), "ns1:TimezoneComponent"))
				{	soap_flag_standard1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_description1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__Timezone *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Timezone, sizeof(ns1__Timezone), soap->type, soap->arrayType), SOAP_TYPE_ns1__Timezone, sizeof(ns1__Timezone));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Timezone * SOAP_FMAC6 soap_new_ns1__Timezone(struct soap *soap, int n)
{	return soap_instantiate_ns1__Timezone(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Timezone(struct soap *soap, ns1__Timezone *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Timezone * SOAP_FMAC6 soap_instantiate_ns1__Timezone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Timezone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Timezone, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Timezone;
		if (size)
			*size = sizeof(ns1__Timezone);
		((ns1__Timezone*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Timezone[n];
		if (size)
			*size = n * sizeof(ns1__Timezone);
		for (int i = 0; i < n; i++)
			((ns1__Timezone*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Timezone*)cp->ptr;
}

void ns1__Task::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Task))
		this->soap_mark(soap);
}

void ns1__Task::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Task*)this)->dueDate, SOAP_TYPE_xsd__date);
	soap_mark_xsd__date(soap, &((ns1__Task*)this)->dueDate);
	soap_embedded(soap, &((ns1__Task*)this)->taskPriority, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Task*)this)->taskPriority);
	soap_embedded(soap, &((ns1__Task*)this)->completed, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Task*)this)->completed);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__CalendarItem*)this)->startDate, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__CalendarItem*)this)->startDate);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->rdate, SOAP_TYPE_PointerTons1__RecurrenceDateType);
	soap_mark_PointerTons1__RecurrenceDateType(soap, &((ns1__CalendarItem*)this)->rdate);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->isRecurring, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__CalendarItem*)this)->isRecurring);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->iCalId, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__CalendarItem*)this)->iCalId);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Mail*)this)->subject, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_embedded(soap, &((ns1__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ns1__Mail*)this)->distribution, SOAP_TYPE_PointerTons1__Distribution);
	soap_mark_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_embedded(soap, &((ns1__Mail*)this)->message, SOAP_TYPE_PointerTons1__MessageBody);
	soap_mark_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_embedded(soap, &((ns1__Mail*)this)->attachments, SOAP_TYPE_PointerTons1__AttachmentInfo);
	soap_mark_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_embedded(soap, &((ns1__Mail*)this)->options, SOAP_TYPE_PointerTons1__ItemOptions);
	soap_mark_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__BoxEntry*)this)->status, SOAP_TYPE_PointerTons1__ItemStatus);
	soap_mark_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->msgid, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->source, SOAP_TYPE_PointerTons1__ItemSource);
	soap_mark_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->class_, SOAP_TYPE_PointerTons1__ItemClass);
	soap_mark_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__Task::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__date(soap, &((ns1__Task*)this)->dueDate);
	soap_default_PointerTostd__string(soap, &((ns1__Task*)this)->taskPriority);
	soap_default_PointerTobool(soap, &((ns1__Task*)this)->completed);
	/* transient soap skipped */
	soap_default_string(soap, &((ns1__CalendarItem*)this)->startDate);
	soap_default_PointerTons1__RecurrenceDateType(soap, &((ns1__CalendarItem*)this)->rdate);
	soap_default_PointerTobool(soap, &((ns1__CalendarItem*)this)->isRecurring);
	soap_default_PointerTostd__string(soap, &((ns1__CalendarItem*)this)->iCalId);
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_default_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_default_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_default_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_default_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_default_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_default_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_default_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_default_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_default_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__Task::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Task);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Task::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Task(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Task(struct soap *soap, const char *tag, int id, const ns1__Task *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Task), "ns1:Task");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_PointerTons1__ItemStatus(soap, "status", -1, &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus");
	soap_out_PointerTostd__string(soap, "thread", -1, &(((ns1__BoxEntry*)a)->thread), "xsd:string");
	soap_out_PointerTostd__string(soap, "msgid", -1, &(((ns1__BoxEntry*)a)->msgid), "xsd:string");
	soap_out_PointerTons1__ItemSource(soap, "source", -1, &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource");
	soap_out_string(soap, "delivered", -1, &(((ns1__BoxEntry*)a)->delivered), "");
	soap_out_PointerTons1__ItemClass(soap, "class", -1, &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass");
	/* transient soap skipped */
	soap_out_std__string(soap, "subject", -1, &(((ns1__Mail*)a)->subject), "xsd:string");
	soap_out_PointerTostd__string(soap, "originalSubject", -1, &(((ns1__Mail*)a)->originalSubject), "xsd:string");
	soap_out_PointerTons1__Distribution(soap, "distribution", -1, &(((ns1__Mail*)a)->distribution), "ns1:Distribution");
	soap_out_PointerTons1__MessageBody(soap, "message", -1, &(((ns1__Mail*)a)->message), "ns1:MessageBody");
	soap_out_PointerTons1__AttachmentInfo(soap, "attachments", -1, &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo");
	soap_out_PointerTons1__ItemOptions(soap, "options", -1, &(((ns1__Mail*)a)->options), "ns1:ItemOptions");
	/* transient soap skipped */
	soap_out_string(soap, "startDate", -1, &(((ns1__CalendarItem*)a)->startDate), "");
	soap_out_PointerTons1__RecurrenceDateType(soap, "rdate", -1, &(((ns1__CalendarItem*)a)->rdate), "ns1:RecurrenceDateType");
	soap_out_PointerTobool(soap, "isRecurring", -1, &(((ns1__CalendarItem*)a)->isRecurring), "");
	soap_out_PointerTostd__string(soap, "iCalId", -1, &(((ns1__CalendarItem*)a)->iCalId), "xsd:string");
	/* transient soap skipped */
	soap_out_xsd__date(soap, "dueDate", -1, &(((ns1__Task*)a)->dueDate), "xsd:date");
	soap_out_PointerTostd__string(soap, "taskPriority", -1, &(((ns1__Task*)a)->taskPriority), "xsd:string");
	soap_out_PointerTobool(soap, "completed", -1, &(((ns1__Task*)a)->completed), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Task::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Task(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Task * SOAP_FMAC4 soap_get_ns1__Task(struct soap *soap, ns1__Task *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Task(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Task::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Task(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Task * SOAP_FMAC4 soap_in_ns1__Task(struct soap *soap, const char *tag, ns1__Task *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Task *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Task, sizeof(ns1__Task), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Task)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Task *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id6 = 1, soap_flag_name6 = 1, soap_flag_version6 = 1, soap_flag_modified6 = 1, soap_flag_changes6 = 1, soap_flag_type6 = 1, soap_flag_categories5 = 1, soap_flag_created5 = 1, soap_flag_customs5 = 1, soap_flag_status4 = 1, soap_flag_thread4 = 1, soap_flag_msgid4 = 1, soap_flag_source4 = 1, soap_flag_delivered4 = 1, soap_flag_class_4 = 1, soap_flag_subject3 = 1, soap_flag_originalSubject3 = 1, soap_flag_distribution3 = 1, soap_flag_message3 = 1, soap_flag_attachments3 = 1, soap_flag_options3 = 1, soap_flag_startDate2 = 1, soap_flag_rdate2 = 1, soap_flag_isRecurring2 = 1, soap_flag_iCalId2 = 1, soap_flag_dueDate1 = 1, soap_flag_taskPriority1 = 1, soap_flag_completed1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id6 = 0;
					continue;
				}

			if (soap_flag_name6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name6 = 0;
					continue;
				}

			if (soap_flag_version6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version6 = 0;
					continue;
				}

			if (soap_flag_modified6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified6 = 0;
					continue;
				}

			if (soap_flag_changes6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes6 = 0;
					continue;
				}

			if (soap_flag_type6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type6 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories5 = 0;
					continue;
				}

			if (soap_flag_created5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created5 = 0;
					continue;
				}

			if (soap_flag_customs5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs5 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_status4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemStatus(soap, "status", &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus"))
				{	soap_flag_status4 = 0;
					continue;
				}

			if (soap_flag_thread4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "thread", &(((ns1__BoxEntry*)a)->thread), "xsd:string"))
				{	soap_flag_thread4 = 0;
					continue;
				}

			if (soap_flag_msgid4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "msgid", &(((ns1__BoxEntry*)a)->msgid), "xsd:string"))
				{	soap_flag_msgid4 = 0;
					continue;
				}

			if (soap_flag_source4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemSource(soap, "source", &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource"))
				{	soap_flag_source4 = 0;
					continue;
				}

			if (soap_flag_delivered4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "delivered", &(((ns1__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered4 = 0;
					continue;
				}

			if (soap_flag_class_4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemClass(soap, "class", &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass"))
				{	soap_flag_class_4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_subject3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "subject", &(((ns1__Mail*)a)->subject), "xsd:string"))
				{	soap_flag_subject3 = 0;
					continue;
				}

			if (soap_flag_originalSubject3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "originalSubject", &(((ns1__Mail*)a)->originalSubject), "xsd:string"))
				{	soap_flag_originalSubject3 = 0;
					continue;
				}

			if (soap_flag_distribution3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Distribution(soap, "distribution", &(((ns1__Mail*)a)->distribution), "ns1:Distribution"))
				{	soap_flag_distribution3 = 0;
					continue;
				}

			if (soap_flag_message3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MessageBody(soap, "message", &(((ns1__Mail*)a)->message), "ns1:MessageBody"))
				{	soap_flag_message3 = 0;
					continue;
				}

			if (soap_flag_attachments3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AttachmentInfo(soap, "attachments", &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo"))
				{	soap_flag_attachments3 = 0;
					continue;
				}

			if (soap_flag_options3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemOptions(soap, "options", &(((ns1__Mail*)a)->options), "ns1:ItemOptions"))
				{	soap_flag_options3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_startDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "startDate", &(((ns1__CalendarItem*)a)->startDate), ""))
				{	soap_flag_startDate2 = 0;
					continue;
				}

			if (soap_flag_rdate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RecurrenceDateType(soap, "rdate", &(((ns1__CalendarItem*)a)->rdate), "ns1:RecurrenceDateType"))
				{	soap_flag_rdate2 = 0;
					continue;
				}

			if (soap_flag_isRecurring2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isRecurring", &(((ns1__CalendarItem*)a)->isRecurring), ""))
				{	soap_flag_isRecurring2 = 0;
					continue;
				}

			if (soap_flag_iCalId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "iCalId", &(((ns1__CalendarItem*)a)->iCalId), "xsd:string"))
				{	soap_flag_iCalId2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_dueDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__date(soap, "dueDate", &(((ns1__Task*)a)->dueDate), "xsd:date"))
				{	soap_flag_dueDate1 = 0;
					continue;
				}

			if (soap_flag_taskPriority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "taskPriority", &(((ns1__Task*)a)->taskPriority), "xsd:string"))
				{	soap_flag_taskPriority1 = 0;
					continue;
				}

			if (soap_flag_completed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "completed", &(((ns1__Task*)a)->completed), ""))
				{	soap_flag_completed1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_subject3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__Task *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Task, sizeof(ns1__Task), soap->type, soap->arrayType), SOAP_TYPE_ns1__Task, sizeof(ns1__Task));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Task * SOAP_FMAC6 soap_new_ns1__Task(struct soap *soap, int n)
{	return soap_instantiate_ns1__Task(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Task(struct soap *soap, ns1__Task *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Task * SOAP_FMAC6 soap_instantiate_ns1__Task(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Task(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Task, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Task;
		if (size)
			*size = sizeof(ns1__Task);
		((ns1__Task*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Task[n];
		if (size)
			*size = n * sizeof(ns1__Task);
		for (int i = 0; i < n; i++)
			((ns1__Task*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Task*)cp->ptr;
}

void ns1__SystemFolder::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__SystemFolder))
		this->soap_mark(soap);
}

void ns1__SystemFolder::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__SystemFolder*)this)->isSystemFolder, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__SystemFolder*)this)->isSystemFolder);
	soap_embedded(soap, &((ns1__SystemFolder*)this)->folder_USCOREtype, SOAP_TYPE_ns1__FolderType);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Folder*)this)->parent, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Folder*)this)->parent);
	soap_embedded(soap, &((ns1__Folder*)this)->description, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Folder*)this)->description);
	soap_embedded(soap, &((ns1__Folder*)this)->count, SOAP_TYPE_PointerToint);
	soap_mark_PointerToint(soap, &((ns1__Folder*)this)->count);
	soap_embedded(soap, &((ns1__Folder*)this)->hasUnread, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Folder*)this)->hasUnread);
	soap_embedded(soap, &((ns1__Folder*)this)->unreadCount, SOAP_TYPE_PointerToint);
	soap_mark_PointerToint(soap, &((ns1__Folder*)this)->unreadCount);
	soap_embedded(soap, &((ns1__Folder*)this)->sequence, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Folder*)this)->settings, SOAP_TYPE_PointerTons1__uid);
	soap_mark_PointerTons1__uid(soap, &((ns1__Folder*)this)->settings);
	soap_embedded(soap, &((ns1__Folder*)this)->hasSubfolders, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Folder*)this)->hasSubfolders);
	soap_embedded(soap, &((ns1__Folder*)this)->notification, SOAP_TYPE_PointerTons1__SharedFolderNotification);
	soap_mark_PointerTons1__SharedFolderNotification(soap, &((ns1__Folder*)this)->notification);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__SystemFolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTobool(soap, &((ns1__SystemFolder*)this)->isSystemFolder);
	soap_default_ns1__FolderType(soap, &((ns1__SystemFolder*)this)->folder_USCOREtype);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Folder*)this)->parent);
	soap_default_std__string(soap, &((ns1__Folder*)this)->description);
	soap_default_PointerToint(soap, &((ns1__Folder*)this)->count);
	soap_default_PointerTobool(soap, &((ns1__Folder*)this)->hasUnread);
	soap_default_PointerToint(soap, &((ns1__Folder*)this)->unreadCount);
	soap_default_unsignedLong(soap, &((ns1__Folder*)this)->sequence);
	soap_default_PointerTons1__uid(soap, &((ns1__Folder*)this)->settings);
	soap_default_PointerTobool(soap, &((ns1__Folder*)this)->hasSubfolders);
	soap_default_PointerTons1__SharedFolderNotification(soap, &((ns1__Folder*)this)->notification);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__SystemFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__SystemFolder);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__SystemFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SystemFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SystemFolder(struct soap *soap, const char *tag, int id, const ns1__SystemFolder *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SystemFolder), "ns1:SystemFolder");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_ns1__uid(soap, "parent", -1, &(((ns1__Folder*)a)->parent), "ns1:uid");
	soap_out_std__string(soap, "description", -1, &(((ns1__Folder*)a)->description), "xsd:string");
	soap_out_PointerToint(soap, "count", -1, &(((ns1__Folder*)a)->count), "");
	soap_out_PointerTobool(soap, "hasUnread", -1, &(((ns1__Folder*)a)->hasUnread), "");
	soap_out_PointerToint(soap, "unreadCount", -1, &(((ns1__Folder*)a)->unreadCount), "");
	soap_out_unsignedLong(soap, "sequence", -1, &(((ns1__Folder*)a)->sequence), "");
	soap_out_PointerTons1__uid(soap, "settings", -1, &(((ns1__Folder*)a)->settings), "ns1:uid");
	soap_out_PointerTobool(soap, "hasSubfolders", -1, &(((ns1__Folder*)a)->hasSubfolders), "");
	soap_out_PointerTons1__SharedFolderNotification(soap, "notification", -1, &(((ns1__Folder*)a)->notification), "ns1:SharedFolderNotification");
	/* transient soap skipped */
	soap_out_PointerTobool(soap, "isSystemFolder", -1, &(((ns1__SystemFolder*)a)->isSystemFolder), "");
	soap_out_ns1__FolderType(soap, "folder_type", -1, &(((ns1__SystemFolder*)a)->folder_USCOREtype), "ns1:FolderType");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SystemFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SystemFolder(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SystemFolder * SOAP_FMAC4 soap_get_ns1__SystemFolder(struct soap *soap, ns1__SystemFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SystemFolder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SystemFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SystemFolder(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SystemFolder * SOAP_FMAC4 soap_in_ns1__SystemFolder(struct soap *soap, const char *tag, ns1__SystemFolder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__SystemFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SystemFolder, sizeof(ns1__SystemFolder), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__SystemFolder)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__SystemFolder *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_type3 = 1, soap_flag_parent2 = 1, soap_flag_description2 = 1, soap_flag_count2 = 1, soap_flag_hasUnread2 = 1, soap_flag_unreadCount2 = 1, soap_flag_sequence2 = 1, soap_flag_settings2 = 1, soap_flag_hasSubfolders2 = 1, soap_flag_notification2 = 1, soap_flag_isSystemFolder1 = 1, soap_flag_folder_USCOREtype1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}

			if (soap_flag_name3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name3 = 0;
					continue;
				}

			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}

			if (soap_flag_modified3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}

			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}

			if (soap_flag_type3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_parent2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "parent", &(((ns1__Folder*)a)->parent), "ns1:uid"))
				{	soap_flag_parent2 = 0;
					continue;
				}

			if (soap_flag_description2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "description", &(((ns1__Folder*)a)->description), "xsd:string"))
				{	soap_flag_description2 = 0;
					continue;
				}

			if (soap_flag_count2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "count", &(((ns1__Folder*)a)->count), ""))
				{	soap_flag_count2 = 0;
					continue;
				}

			if (soap_flag_hasUnread2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasUnread", &(((ns1__Folder*)a)->hasUnread), ""))
				{	soap_flag_hasUnread2 = 0;
					continue;
				}

			if (soap_flag_unreadCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "unreadCount", &(((ns1__Folder*)a)->unreadCount), ""))
				{	soap_flag_unreadCount2 = 0;
					continue;
				}

			if (soap_flag_sequence2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "sequence", &(((ns1__Folder*)a)->sequence), ""))
				{	soap_flag_sequence2 = 0;
					continue;
				}

			if (soap_flag_settings2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__uid(soap, "settings", &(((ns1__Folder*)a)->settings), "ns1:uid"))
				{	soap_flag_settings2 = 0;
					continue;
				}

			if (soap_flag_hasSubfolders2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasSubfolders", &(((ns1__Folder*)a)->hasSubfolders), ""))
				{	soap_flag_hasSubfolders2 = 0;
					continue;
				}

			if (soap_flag_notification2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SharedFolderNotification(soap, "notification", &(((ns1__Folder*)a)->notification), "ns1:SharedFolderNotification"))
				{	soap_flag_notification2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_isSystemFolder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isSystemFolder", &(((ns1__SystemFolder*)a)->isSystemFolder), ""))
				{	soap_flag_isSystemFolder1 = 0;
					continue;
				}

			if (soap_flag_folder_USCOREtype1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__FolderType(soap, "folder_type", &(((ns1__SystemFolder*)a)->folder_USCOREtype), "ns1:FolderType"))
				{	soap_flag_folder_USCOREtype1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent2 || soap_flag_folder_USCOREtype1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__SystemFolder *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SystemFolder, sizeof(ns1__SystemFolder), soap->type, soap->arrayType), SOAP_TYPE_ns1__SystemFolder, sizeof(ns1__SystemFolder));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SystemFolder * SOAP_FMAC6 soap_new_ns1__SystemFolder(struct soap *soap, int n)
{	return soap_instantiate_ns1__SystemFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SystemFolder(struct soap *soap, ns1__SystemFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__SystemFolder * SOAP_FMAC6 soap_instantiate_ns1__SystemFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SystemFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SystemFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:ContactFolder"))
	{	cp->type = SOAP_TYPE_ns1__ContactFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ContactFolder;
			if (size)
				*size = sizeof(ns1__ContactFolder);
			((ns1__ContactFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ContactFolder[n];
			if (size)
				*size = n * sizeof(ns1__ContactFolder);
			for (int i = 0; i < n; i++)
				((ns1__ContactFolder*)cp->ptr)[i].soap = soap;
		}
		return (ns1__ContactFolder*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SystemFolder;
		if (size)
			*size = sizeof(ns1__SystemFolder);
		((ns1__SystemFolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SystemFolder[n];
		if (size)
			*size = n * sizeof(ns1__SystemFolder);
		for (int i = 0; i < n; i++)
			((ns1__SystemFolder*)cp->ptr)[i].soap = soap;
	}
	return (ns1__SystemFolder*)cp->ptr;
}

void ns1__StatusTracking::soap_serialize(struct soap *soap) const
{
		this->soap_mark(soap);
}

void ns1__StatusTracking::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__StatusTracking*)this)->__item, SOAP_TYPE_ns1__StatusTrackingOptions);
	/* transient soap skipped */
}

void ns1__StatusTracking::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__StatusTrackingOptions(soap, &((ns1__StatusTracking*)this)->__item);
	soap_default_bool(soap, &((ns1__StatusTracking*)this)->autoDelete);
	/* transient soap skipped */
}

int ns1__StatusTracking::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__StatusTracking);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__StatusTracking::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StatusTracking(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StatusTracking(struct soap *soap, const char *tag, int id, const ns1__StatusTracking *a, const char *type)
{
	soap_set_attr(soap, "autoDelete", soap_bool2s(soap, ((ns1__StatusTracking *)a)->autoDelete));
	soap_out_ns1__StatusTrackingOptions(soap, tag, id, &(((ns1__StatusTracking*)a)->__item), "ns1:StatusTracking");
	return SOAP_OK;
}

void *ns1__StatusTracking::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StatusTracking(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StatusTracking * SOAP_FMAC4 soap_get_ns1__StatusTracking(struct soap *soap, ns1__StatusTracking *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StatusTracking(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__StatusTracking::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StatusTracking(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StatusTracking * SOAP_FMAC4 soap_in_ns1__StatusTracking(struct soap *soap, const char *tag, ns1__StatusTracking *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ns1__StatusTracking *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StatusTracking, sizeof(ns1__StatusTracking), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__StatusTracking)
			return (ns1__StatusTracking *)a->soap_in(soap, tag, type);
	}
		if (soap_s2bool(soap, soap_attr_value(soap, "autoDelete"), &((ns1__StatusTracking *)a)->autoDelete))
			return NULL;
	if (!soap_in_ns1__StatusTrackingOptions(soap, tag, &(((ns1__StatusTracking*)a)->__item), "ns1:StatusTracking"))
		return NULL;
	return a;
}

SOAP_FMAC5 ns1__StatusTracking * SOAP_FMAC6 soap_new_ns1__StatusTracking(struct soap *soap, int n)
{	return soap_instantiate_ns1__StatusTracking(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__StatusTracking(struct soap *soap, ns1__StatusTracking *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__StatusTracking * SOAP_FMAC6 soap_instantiate_ns1__StatusTracking(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StatusTracking(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StatusTracking, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__StatusTracking;
		if (size)
			*size = sizeof(ns1__StatusTracking);
		((ns1__StatusTracking*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__StatusTracking[n];
		if (size)
			*size = n * sizeof(ns1__StatusTracking);
		for (int i = 0; i < n; i++)
			((ns1__StatusTracking*)cp->ptr)[i].soap = soap;
	}
	return (ns1__StatusTracking*)cp->ptr;
}

void ns1__Status::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Status))
		this->soap_mark(soap);
}

void ns1__Status::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Status*)this)->code, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__Status*)this)->description, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Status*)this)->description);
	soap_embedded(soap, &((ns1__Status*)this)->info, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Status*)this)->info);
	soap_embedded(soap, &((ns1__Status*)this)->problems, SOAP_TYPE_PointerTons1__ProblemList);
	soap_mark_PointerTons1__ProblemList(soap, &((ns1__Status*)this)->problems);
	/* transient soap skipped */
}

void ns1__Status::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ns1__Status*)this)->code);
	soap_default_std__string(soap, &((ns1__Status*)this)->description);
	soap_default_PointerTostd__string(soap, &((ns1__Status*)this)->info);
	soap_default_PointerTons1__ProblemList(soap, &((ns1__Status*)this)->problems);
	/* transient soap skipped */
}

int ns1__Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Status);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Status(struct soap *soap, const char *tag, int id, const ns1__Status *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Status), "ns1:Status");
	soap_out_int(soap, "code", -1, &(((ns1__Status*)a)->code), "");
	soap_out_std__string(soap, "description", -1, &(((ns1__Status*)a)->description), "xsd:string");
	soap_out_PointerTostd__string(soap, "info", -1, &(((ns1__Status*)a)->info), "xsd:string");
	soap_out_PointerTons1__ProblemList(soap, "problems", -1, &(((ns1__Status*)a)->problems), "ns1:ProblemList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Status(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Status * SOAP_FMAC4 soap_get_ns1__Status(struct soap *soap, ns1__Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Status(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Status::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Status(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Status * SOAP_FMAC4 soap_in_ns1__Status(struct soap *soap, const char *tag, ns1__Status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Status *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Status, sizeof(ns1__Status), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Status)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Status *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_code1 = 1, soap_flag_description1 = 1, soap_flag_info1 = 1, soap_flag_problems1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "code", &(((ns1__Status*)a)->code), ""))
				{	soap_flag_code1 = 0;
					continue;
				}

			if (soap_flag_description1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "description", &(((ns1__Status*)a)->description), "xsd:string"))
				{	soap_flag_description1 = 0;
					continue;
				}

			if (soap_flag_info1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "info", &(((ns1__Status*)a)->info), "xsd:string"))
				{	soap_flag_info1 = 0;
					continue;
				}

			if (soap_flag_problems1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProblemList(soap, "problems", &(((ns1__Status*)a)->problems), "ns1:ProblemList"))
				{	soap_flag_problems1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__Status *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Status, sizeof(ns1__Status), soap->type, soap->arrayType), SOAP_TYPE_ns1__Status, sizeof(ns1__Status));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Status * SOAP_FMAC6 soap_new_ns1__Status(struct soap *soap, int n)
{	return soap_instantiate_ns1__Status(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Status(struct soap *soap, ns1__Status *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Status * SOAP_FMAC6 soap_instantiate_ns1__Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Status(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Status, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Status;
		if (size)
			*size = sizeof(ns1__Status);
		((ns1__Status*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Status[n];
		if (size)
			*size = n * sizeof(ns1__Status);
		for (int i = 0; i < n; i++)
			((ns1__Status*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Status*)cp->ptr;
}

void ns1__SharedFolderNotification::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__SharedFolderNotification))
		this->soap_mark(soap);
}

void ns1__SharedFolderNotification::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__SharedFolderNotification*)this)->subject, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__SharedFolderNotification*)this)->subject);
	soap_embedded(soap, &((ns1__SharedFolderNotification*)this)->message, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__SharedFolderNotification*)this)->message);
	soap_embedded(soap, &((ns1__SharedFolderNotification*)this)->description, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__SharedFolderNotification*)this)->description);
	/* transient soap skipped */
}

void ns1__SharedFolderNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__SharedFolderNotification*)this)->subject);
	soap_default_PointerTostd__string(soap, &((ns1__SharedFolderNotification*)this)->message);
	soap_default_std__string(soap, &((ns1__SharedFolderNotification*)this)->description);
	/* transient soap skipped */
}

int ns1__SharedFolderNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__SharedFolderNotification);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__SharedFolderNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SharedFolderNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SharedFolderNotification(struct soap *soap, const char *tag, int id, const ns1__SharedFolderNotification *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SharedFolderNotification), "ns1:SharedFolderNotification");
	soap_out_std__string(soap, "subject", -1, &(((ns1__SharedFolderNotification*)a)->subject), "xsd:string");
	soap_out_PointerTostd__string(soap, "message", -1, &(((ns1__SharedFolderNotification*)a)->message), "xsd:string");
	soap_out_std__string(soap, "description", -1, &(((ns1__SharedFolderNotification*)a)->description), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SharedFolderNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SharedFolderNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SharedFolderNotification * SOAP_FMAC4 soap_get_ns1__SharedFolderNotification(struct soap *soap, ns1__SharedFolderNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SharedFolderNotification(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SharedFolderNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SharedFolderNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SharedFolderNotification * SOAP_FMAC4 soap_in_ns1__SharedFolderNotification(struct soap *soap, const char *tag, ns1__SharedFolderNotification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__SharedFolderNotification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SharedFolderNotification, sizeof(ns1__SharedFolderNotification), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__SharedFolderNotification)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__SharedFolderNotification *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_subject1 = 1, soap_flag_message1 = 1, soap_flag_description1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_subject1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "subject", &(((ns1__SharedFolderNotification*)a)->subject), "xsd:string"))
				{	soap_flag_subject1 = 0;
					continue;
				}

			if (soap_flag_message1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "message", &(((ns1__SharedFolderNotification*)a)->message), "xsd:string"))
				{	soap_flag_message1 = 0;
					continue;
				}

			if (soap_flag_description1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "description", &(((ns1__SharedFolderNotification*)a)->description), "xsd:string"))
				{	soap_flag_description1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__SharedFolderNotification *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SharedFolderNotification, sizeof(ns1__SharedFolderNotification), soap->type, soap->arrayType), SOAP_TYPE_ns1__SharedFolderNotification, sizeof(ns1__SharedFolderNotification));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SharedFolderNotification * SOAP_FMAC6 soap_new_ns1__SharedFolderNotification(struct soap *soap, int n)
{	return soap_instantiate_ns1__SharedFolderNotification(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SharedFolderNotification(struct soap *soap, ns1__SharedFolderNotification *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__SharedFolderNotification * SOAP_FMAC6 soap_instantiate_ns1__SharedFolderNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SharedFolderNotification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SharedFolderNotification, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SharedFolderNotification;
		if (size)
			*size = sizeof(ns1__SharedFolderNotification);
		((ns1__SharedFolderNotification*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SharedFolderNotification[n];
		if (size)
			*size = n * sizeof(ns1__SharedFolderNotification);
		for (int i = 0; i < n; i++)
			((ns1__SharedFolderNotification*)cp->ptr)[i].soap = soap;
	}
	return (ns1__SharedFolderNotification*)cp->ptr;
}

void ns1__SharedFolder::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__SharedFolder))
		this->soap_mark(soap);
}

void ns1__SharedFolder::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__SharedFolder*)this)->rights, SOAP_TYPE_PointerTons1__Rights);
	soap_mark_PointerTons1__Rights(soap, &((ns1__SharedFolder*)this)->rights);
	soap_embedded(soap, &((ns1__SharedFolder*)this)->acl, SOAP_TYPE_PointerTons1__FolderACL);
	soap_mark_PointerTons1__FolderACL(soap, &((ns1__SharedFolder*)this)->acl);
	soap_embedded(soap, &((ns1__SharedFolder*)this)->owner, SOAP_TYPE_PointerTons1__UUID);
	soap_mark_PointerTons1__UUID(soap, &((ns1__SharedFolder*)this)->owner);
	soap_embedded(soap, &((ns1__SharedFolder*)this)->isSharedByMe, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__SharedFolder*)this)->isSharedByMe);
	soap_embedded(soap, &((ns1__SharedFolder*)this)->isSharedToMe, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__SharedFolder*)this)->isSharedToMe);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Folder*)this)->parent, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Folder*)this)->parent);
	soap_embedded(soap, &((ns1__Folder*)this)->description, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Folder*)this)->description);
	soap_embedded(soap, &((ns1__Folder*)this)->count, SOAP_TYPE_PointerToint);
	soap_mark_PointerToint(soap, &((ns1__Folder*)this)->count);
	soap_embedded(soap, &((ns1__Folder*)this)->hasUnread, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Folder*)this)->hasUnread);
	soap_embedded(soap, &((ns1__Folder*)this)->unreadCount, SOAP_TYPE_PointerToint);
	soap_mark_PointerToint(soap, &((ns1__Folder*)this)->unreadCount);
	soap_embedded(soap, &((ns1__Folder*)this)->sequence, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Folder*)this)->settings, SOAP_TYPE_PointerTons1__uid);
	soap_mark_PointerTons1__uid(soap, &((ns1__Folder*)this)->settings);
	soap_embedded(soap, &((ns1__Folder*)this)->hasSubfolders, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Folder*)this)->hasSubfolders);
	soap_embedded(soap, &((ns1__Folder*)this)->notification, SOAP_TYPE_PointerTons1__SharedFolderNotification);
	soap_mark_PointerTons1__SharedFolderNotification(soap, &((ns1__Folder*)this)->notification);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__SharedFolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Rights(soap, &((ns1__SharedFolder*)this)->rights);
	soap_default_PointerTons1__FolderACL(soap, &((ns1__SharedFolder*)this)->acl);
	soap_default_PointerTons1__UUID(soap, &((ns1__SharedFolder*)this)->owner);
	soap_default_PointerTobool(soap, &((ns1__SharedFolder*)this)->isSharedByMe);
	soap_default_PointerTobool(soap, &((ns1__SharedFolder*)this)->isSharedToMe);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Folder*)this)->parent);
	soap_default_std__string(soap, &((ns1__Folder*)this)->description);
	soap_default_PointerToint(soap, &((ns1__Folder*)this)->count);
	soap_default_PointerTobool(soap, &((ns1__Folder*)this)->hasUnread);
	soap_default_PointerToint(soap, &((ns1__Folder*)this)->unreadCount);
	soap_default_unsignedLong(soap, &((ns1__Folder*)this)->sequence);
	soap_default_PointerTons1__uid(soap, &((ns1__Folder*)this)->settings);
	soap_default_PointerTobool(soap, &((ns1__Folder*)this)->hasSubfolders);
	soap_default_PointerTons1__SharedFolderNotification(soap, &((ns1__Folder*)this)->notification);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__SharedFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__SharedFolder);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__SharedFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SharedFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SharedFolder(struct soap *soap, const char *tag, int id, const ns1__SharedFolder *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SharedFolder), "ns1:SharedFolder");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_ns1__uid(soap, "parent", -1, &(((ns1__Folder*)a)->parent), "ns1:uid");
	soap_out_std__string(soap, "description", -1, &(((ns1__Folder*)a)->description), "xsd:string");
	soap_out_PointerToint(soap, "count", -1, &(((ns1__Folder*)a)->count), "");
	soap_out_PointerTobool(soap, "hasUnread", -1, &(((ns1__Folder*)a)->hasUnread), "");
	soap_out_PointerToint(soap, "unreadCount", -1, &(((ns1__Folder*)a)->unreadCount), "");
	soap_out_unsignedLong(soap, "sequence", -1, &(((ns1__Folder*)a)->sequence), "");
	soap_out_PointerTons1__uid(soap, "settings", -1, &(((ns1__Folder*)a)->settings), "ns1:uid");
	soap_out_PointerTobool(soap, "hasSubfolders", -1, &(((ns1__Folder*)a)->hasSubfolders), "");
	soap_out_PointerTons1__SharedFolderNotification(soap, "notification", -1, &(((ns1__Folder*)a)->notification), "ns1:SharedFolderNotification");
	/* transient soap skipped */
	soap_out_PointerTons1__Rights(soap, "rights", -1, &(((ns1__SharedFolder*)a)->rights), "ns1:Rights");
	soap_out_PointerTons1__FolderACL(soap, "acl", -1, &(((ns1__SharedFolder*)a)->acl), "ns1:FolderACL");
	soap_out_PointerTons1__UUID(soap, "owner", -1, &(((ns1__SharedFolder*)a)->owner), "ns1:UUID");
	soap_out_PointerTobool(soap, "isSharedByMe", -1, &(((ns1__SharedFolder*)a)->isSharedByMe), "");
	soap_out_PointerTobool(soap, "isSharedToMe", -1, &(((ns1__SharedFolder*)a)->isSharedToMe), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SharedFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SharedFolder(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SharedFolder * SOAP_FMAC4 soap_get_ns1__SharedFolder(struct soap *soap, ns1__SharedFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SharedFolder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SharedFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SharedFolder(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SharedFolder * SOAP_FMAC4 soap_in_ns1__SharedFolder(struct soap *soap, const char *tag, ns1__SharedFolder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__SharedFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SharedFolder, sizeof(ns1__SharedFolder), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__SharedFolder)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__SharedFolder *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_type3 = 1, soap_flag_parent2 = 1, soap_flag_description2 = 1, soap_flag_count2 = 1, soap_flag_hasUnread2 = 1, soap_flag_unreadCount2 = 1, soap_flag_sequence2 = 1, soap_flag_settings2 = 1, soap_flag_hasSubfolders2 = 1, soap_flag_notification2 = 1, soap_flag_rights1 = 1, soap_flag_acl1 = 1, soap_flag_owner1 = 1, soap_flag_isSharedByMe1 = 1, soap_flag_isSharedToMe1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}

			if (soap_flag_name3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name3 = 0;
					continue;
				}

			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}

			if (soap_flag_modified3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}

			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}

			if (soap_flag_type3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_parent2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "parent", &(((ns1__Folder*)a)->parent), "ns1:uid"))
				{	soap_flag_parent2 = 0;
					continue;
				}

			if (soap_flag_description2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "description", &(((ns1__Folder*)a)->description), "xsd:string"))
				{	soap_flag_description2 = 0;
					continue;
				}

			if (soap_flag_count2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "count", &(((ns1__Folder*)a)->count), ""))
				{	soap_flag_count2 = 0;
					continue;
				}

			if (soap_flag_hasUnread2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasUnread", &(((ns1__Folder*)a)->hasUnread), ""))
				{	soap_flag_hasUnread2 = 0;
					continue;
				}

			if (soap_flag_unreadCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "unreadCount", &(((ns1__Folder*)a)->unreadCount), ""))
				{	soap_flag_unreadCount2 = 0;
					continue;
				}

			if (soap_flag_sequence2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "sequence", &(((ns1__Folder*)a)->sequence), ""))
				{	soap_flag_sequence2 = 0;
					continue;
				}

			if (soap_flag_settings2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__uid(soap, "settings", &(((ns1__Folder*)a)->settings), "ns1:uid"))
				{	soap_flag_settings2 = 0;
					continue;
				}

			if (soap_flag_hasSubfolders2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasSubfolders", &(((ns1__Folder*)a)->hasSubfolders), ""))
				{	soap_flag_hasSubfolders2 = 0;
					continue;
				}

			if (soap_flag_notification2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SharedFolderNotification(soap, "notification", &(((ns1__Folder*)a)->notification), "ns1:SharedFolderNotification"))
				{	soap_flag_notification2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_rights1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Rights(soap, "rights", &(((ns1__SharedFolder*)a)->rights), "ns1:Rights"))
				{	soap_flag_rights1 = 0;
					continue;
				}

			if (soap_flag_acl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FolderACL(soap, "acl", &(((ns1__SharedFolder*)a)->acl), "ns1:FolderACL"))
				{	soap_flag_acl1 = 0;
					continue;
				}

			if (soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UUID(soap, "owner", &(((ns1__SharedFolder*)a)->owner), "ns1:UUID"))
				{	soap_flag_owner1 = 0;
					continue;
				}

			if (soap_flag_isSharedByMe1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isSharedByMe", &(((ns1__SharedFolder*)a)->isSharedByMe), ""))
				{	soap_flag_isSharedByMe1 = 0;
					continue;
				}

			if (soap_flag_isSharedToMe1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isSharedToMe", &(((ns1__SharedFolder*)a)->isSharedToMe), ""))
				{	soap_flag_isSharedToMe1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__SharedFolder *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SharedFolder, sizeof(ns1__SharedFolder), soap->type, soap->arrayType), SOAP_TYPE_ns1__SharedFolder, sizeof(ns1__SharedFolder));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SharedFolder * SOAP_FMAC6 soap_new_ns1__SharedFolder(struct soap *soap, int n)
{	return soap_instantiate_ns1__SharedFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SharedFolder(struct soap *soap, ns1__SharedFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__SharedFolder * SOAP_FMAC6 soap_instantiate_ns1__SharedFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SharedFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SharedFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SharedFolder;
		if (size)
			*size = sizeof(ns1__SharedFolder);
		((ns1__SharedFolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SharedFolder[n];
		if (size)
			*size = n * sizeof(ns1__SharedFolder);
		for (int i = 0; i < n; i++)
			((ns1__SharedFolder*)cp->ptr)[i].soap = soap;
	}
	return (ns1__SharedFolder*)cp->ptr;
}

void ns1__SettingsList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__SettingsList))
		this->soap_mark(soap);
}

void ns1__SettingsList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__SettingsList*)this)->setting, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Custom);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, &((ns1__SettingsList*)this)->setting);
	/* transient soap skipped */
}

void ns1__SettingsList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, &((ns1__SettingsList*)this)->setting);
	/* transient soap skipped */
}

int ns1__SettingsList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__SettingsList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__SettingsList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SettingsList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SettingsList(struct soap *soap, const char *tag, int id, const ns1__SettingsList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SettingsList), "ns1:SettingsList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, "setting", -1, &(((ns1__SettingsList*)a)->setting), "ns1:Custom");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SettingsList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SettingsList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SettingsList * SOAP_FMAC4 soap_get_ns1__SettingsList(struct soap *soap, ns1__SettingsList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SettingsList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SettingsList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SettingsList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SettingsList * SOAP_FMAC4 soap_in_ns1__SettingsList(struct soap *soap, const char *tag, ns1__SettingsList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__SettingsList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SettingsList, sizeof(ns1__SettingsList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__SettingsList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__SettingsList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, "setting", &(((ns1__SettingsList*)a)->setting), "ns1:Custom"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__SettingsList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SettingsList, sizeof(ns1__SettingsList), soap->type, soap->arrayType), SOAP_TYPE_ns1__SettingsList, sizeof(ns1__SettingsList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SettingsList * SOAP_FMAC6 soap_new_ns1__SettingsList(struct soap *soap, int n)
{	return soap_instantiate_ns1__SettingsList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SettingsList(struct soap *soap, ns1__SettingsList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__SettingsList * SOAP_FMAC6 soap_instantiate_ns1__SettingsList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SettingsList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SettingsList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SettingsList;
		if (size)
			*size = sizeof(ns1__SettingsList);
		((ns1__SettingsList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SettingsList[n];
		if (size)
			*size = n * sizeof(ns1__SettingsList);
		for (int i = 0; i < n; i++)
			((ns1__SettingsList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__SettingsList*)cp->ptr;
}

void ns1__SettingsGroup::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__SettingsGroup))
		this->soap_mark(soap);
}

void ns1__SettingsGroup::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__SettingsGroup*)this)->setting, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Custom);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, &((ns1__SettingsGroup*)this)->setting);
	/* transient soap skipped */
}

void ns1__SettingsGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, &((ns1__SettingsGroup*)this)->setting);
	soap_default_std__string(soap, &((ns1__SettingsGroup*)this)->type);
	/* transient soap skipped */
}

int ns1__SettingsGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__SettingsGroup);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__SettingsGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SettingsGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SettingsGroup(struct soap *soap, const char *tag, int id, const ns1__SettingsGroup *a, const char *type)
{
	if (!((ns1__SettingsGroup *)a)->type.empty())
		soap_set_attr(soap, "type", ((ns1__SettingsGroup *)a)->type.c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SettingsGroup), "ns1:SettingsGroup");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, "setting", -1, &(((ns1__SettingsGroup*)a)->setting), "ns1:Custom");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SettingsGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SettingsGroup(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SettingsGroup * SOAP_FMAC4 soap_get_ns1__SettingsGroup(struct soap *soap, ns1__SettingsGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SettingsGroup(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SettingsGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SettingsGroup(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SettingsGroup * SOAP_FMAC4 soap_in_ns1__SettingsGroup(struct soap *soap, const char *tag, ns1__SettingsGroup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__SettingsGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SettingsGroup, sizeof(ns1__SettingsGroup), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__SettingsGroup)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__SettingsGroup *)a->soap_in(soap, tag, type);
			}
		}
		{	const char *t = soap_attr_value(soap, "type");
			if (t)
			{	char *s;
				if (soap_s2string(soap, t, &s))
					return NULL;
				((ns1__SettingsGroup *)a)->type.assign(s);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, "setting", &(((ns1__SettingsGroup*)a)->setting), "ns1:Custom"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__SettingsGroup *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SettingsGroup, sizeof(ns1__SettingsGroup), soap->type, soap->arrayType), SOAP_TYPE_ns1__SettingsGroup, sizeof(ns1__SettingsGroup));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SettingsGroup * SOAP_FMAC6 soap_new_ns1__SettingsGroup(struct soap *soap, int n)
{	return soap_instantiate_ns1__SettingsGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SettingsGroup(struct soap *soap, ns1__SettingsGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__SettingsGroup * SOAP_FMAC6 soap_instantiate_ns1__SettingsGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SettingsGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SettingsGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SettingsGroup;
		if (size)
			*size = sizeof(ns1__SettingsGroup);
		((ns1__SettingsGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SettingsGroup[n];
		if (size)
			*size = n * sizeof(ns1__SettingsGroup);
		for (int i = 0; i < n; i++)
			((ns1__SettingsGroup*)cp->ptr)[i].soap = soap;
	}
	return (ns1__SettingsGroup*)cp->ptr;
}

void ns1__Settings::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Settings))
		this->soap_mark(soap);
}

void ns1__Settings::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Settings*)this)->group, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(soap, &((ns1__Settings*)this)->group);
	soap_embedded(soap, &((ns1__Settings*)this)->setting, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Custom);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, &((ns1__Settings*)this)->setting);
	/* transient soap skipped */
}

void ns1__Settings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(soap, &((ns1__Settings*)this)->group);
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, &((ns1__Settings*)this)->setting);
	/* transient soap skipped */
}

int ns1__Settings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Settings);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Settings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Settings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Settings(struct soap *soap, const char *tag, int id, const ns1__Settings *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Settings), "ns1:Settings");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(soap, "group", -1, &(((ns1__Settings*)a)->group), "ns1:SettingsGroup");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, "setting", -1, &(((ns1__Settings*)a)->setting), "ns1:Custom");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Settings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Settings(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Settings * SOAP_FMAC4 soap_get_ns1__Settings(struct soap *soap, ns1__Settings *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Settings(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Settings::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Settings(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Settings * SOAP_FMAC4 soap_in_ns1__Settings(struct soap *soap, const char *tag, ns1__Settings *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Settings *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Settings, sizeof(ns1__Settings), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Settings)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Settings *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(soap, "group", &(((ns1__Settings*)a)->group), "ns1:SettingsGroup"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, "setting", &(((ns1__Settings*)a)->setting), "ns1:Custom"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Settings *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Settings, sizeof(ns1__Settings), soap->type, soap->arrayType), SOAP_TYPE_ns1__Settings, sizeof(ns1__Settings));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Settings * SOAP_FMAC6 soap_new_ns1__Settings(struct soap *soap, int n)
{	return soap_instantiate_ns1__Settings(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Settings(struct soap *soap, ns1__Settings *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Settings * SOAP_FMAC6 soap_instantiate_ns1__Settings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Settings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Settings, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Settings;
		if (size)
			*size = sizeof(ns1__Settings);
		((ns1__Settings*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Settings[n];
		if (size)
			*size = n * sizeof(ns1__Settings);
		for (int i = 0; i < n; i++)
			((ns1__Settings*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Settings*)cp->ptr;
}

void ns1__SendOptions::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__SendOptions))
		this->soap_mark(soap);
}

void ns1__SendOptions::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__SendOptions*)this)->requestReply, SOAP_TYPE_PointerTons1__SendOptionsRequestReply);
	soap_mark_PointerTons1__SendOptionsRequestReply(soap, &((ns1__SendOptions*)this)->requestReply);
	soap_embedded(soap, &((ns1__SendOptions*)this)->mimeEncoding, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__SendOptions*)this)->mimeEncoding);
	soap_embedded(soap, &((ns1__SendOptions*)this)->statusTracking, SOAP_TYPE_PointerTons1__StatusTracking);
	soap_mark_PointerTons1__StatusTracking(soap, &((ns1__SendOptions*)this)->statusTracking);
	soap_embedded(soap, &((ns1__SendOptions*)this)->notification, SOAP_TYPE_PointerTons1__ReturnNotification);
	soap_mark_PointerTons1__ReturnNotification(soap, &((ns1__SendOptions*)this)->notification);
	/* transient soap skipped */
}

void ns1__SendOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__SendOptionsRequestReply(soap, &((ns1__SendOptions*)this)->requestReply);
	soap_default_PointerTostd__string(soap, &((ns1__SendOptions*)this)->mimeEncoding);
	soap_default_PointerTons1__StatusTracking(soap, &((ns1__SendOptions*)this)->statusTracking);
	soap_default_PointerTons1__ReturnNotification(soap, &((ns1__SendOptions*)this)->notification);
	/* transient soap skipped */
}

int ns1__SendOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__SendOptions);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__SendOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SendOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SendOptions(struct soap *soap, const char *tag, int id, const ns1__SendOptions *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SendOptions), "ns1:SendOptions");
	soap_out_PointerTons1__SendOptionsRequestReply(soap, "requestReply", -1, &(((ns1__SendOptions*)a)->requestReply), "ns1:SendOptionsRequestReply");
	soap_out_PointerTostd__string(soap, "mimeEncoding", -1, &(((ns1__SendOptions*)a)->mimeEncoding), "xsd:string");
	soap_out_PointerTons1__StatusTracking(soap, "statusTracking", -1, &(((ns1__SendOptions*)a)->statusTracking), "ns1:StatusTracking");
	soap_out_PointerTons1__ReturnNotification(soap, "notification", -1, &(((ns1__SendOptions*)a)->notification), "ns1:ReturnNotification");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SendOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SendOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SendOptions * SOAP_FMAC4 soap_get_ns1__SendOptions(struct soap *soap, ns1__SendOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SendOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SendOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SendOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SendOptions * SOAP_FMAC4 soap_in_ns1__SendOptions(struct soap *soap, const char *tag, ns1__SendOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__SendOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SendOptions, sizeof(ns1__SendOptions), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__SendOptions)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__SendOptions *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_requestReply1 = 1, soap_flag_mimeEncoding1 = 1, soap_flag_statusTracking1 = 1, soap_flag_notification1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_requestReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SendOptionsRequestReply(soap, "requestReply", &(((ns1__SendOptions*)a)->requestReply), "ns1:SendOptionsRequestReply"))
				{	soap_flag_requestReply1 = 0;
					continue;
				}

			if (soap_flag_mimeEncoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "mimeEncoding", &(((ns1__SendOptions*)a)->mimeEncoding), "xsd:string"))
				{	soap_flag_mimeEncoding1 = 0;
					continue;
				}

			if (soap_flag_statusTracking1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StatusTracking(soap, "statusTracking", &(((ns1__SendOptions*)a)->statusTracking), "ns1:StatusTracking"))
				{	soap_flag_statusTracking1 = 0;
					continue;
				}

			if (soap_flag_notification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReturnNotification(soap, "notification", &(((ns1__SendOptions*)a)->notification), "ns1:ReturnNotification"))
				{	soap_flag_notification1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__SendOptions *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SendOptions, sizeof(ns1__SendOptions), soap->type, soap->arrayType), SOAP_TYPE_ns1__SendOptions, sizeof(ns1__SendOptions));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SendOptions * SOAP_FMAC6 soap_new_ns1__SendOptions(struct soap *soap, int n)
{	return soap_instantiate_ns1__SendOptions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SendOptions(struct soap *soap, ns1__SendOptions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__SendOptions * SOAP_FMAC6 soap_instantiate_ns1__SendOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SendOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SendOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SendOptions;
		if (size)
			*size = sizeof(ns1__SendOptions);
		((ns1__SendOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SendOptions[n];
		if (size)
			*size = n * sizeof(ns1__SendOptions);
		for (int i = 0; i < n; i++)
			((ns1__SendOptions*)cp->ptr)[i].soap = soap;
	}
	return (ns1__SendOptions*)cp->ptr;
}

void ns1__SendOptionsRequestReply::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__SendOptionsRequestReply))
		this->soap_mark(soap);
}

void ns1__SendOptionsRequestReply::soap_mark(struct soap *soap) const
{
	/* transient soap skipped */
}

void ns1__SendOptionsRequestReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedLong(soap, &((ns1__SendOptionsRequestReply*)this)->withinNDays);
	/* transient soap skipped */
}

int ns1__SendOptionsRequestReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__SendOptionsRequestReply);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__SendOptionsRequestReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SendOptionsRequestReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SendOptionsRequestReply(struct soap *soap, const char *tag, int id, const ns1__SendOptionsRequestReply *a, const char *type)
{
	soap_set_attr(soap, "withinNDays", soap_unsignedLong2s(soap, ((ns1__SendOptionsRequestReply *)a)->withinNDays));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SendOptionsRequestReply), "ns1:SendOptionsRequestReply");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SendOptionsRequestReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SendOptionsRequestReply(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SendOptionsRequestReply * SOAP_FMAC4 soap_get_ns1__SendOptionsRequestReply(struct soap *soap, ns1__SendOptionsRequestReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SendOptionsRequestReply(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SendOptionsRequestReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SendOptionsRequestReply(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SendOptionsRequestReply * SOAP_FMAC4 soap_in_ns1__SendOptionsRequestReply(struct soap *soap, const char *tag, ns1__SendOptionsRequestReply *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__SendOptionsRequestReply *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SendOptionsRequestReply, sizeof(ns1__SendOptionsRequestReply), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__SendOptionsRequestReply)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__SendOptionsRequestReply *)a->soap_in(soap, tag, type);
			}
		}
		if (soap_s2unsignedLong(soap, soap_attr_value(soap, "withinNDays"), &((ns1__SendOptionsRequestReply *)a)->withinNDays))
			return NULL;;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__SendOptionsRequestReply *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SendOptionsRequestReply, sizeof(ns1__SendOptionsRequestReply), soap->type, soap->arrayType), SOAP_TYPE_ns1__SendOptionsRequestReply, sizeof(ns1__SendOptionsRequestReply));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SendOptionsRequestReply * SOAP_FMAC6 soap_new_ns1__SendOptionsRequestReply(struct soap *soap, int n)
{	return soap_instantiate_ns1__SendOptionsRequestReply(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SendOptionsRequestReply(struct soap *soap, ns1__SendOptionsRequestReply *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__SendOptionsRequestReply * SOAP_FMAC6 soap_instantiate_ns1__SendOptionsRequestReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SendOptionsRequestReply(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SendOptionsRequestReply, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SendOptionsRequestReply;
		if (size)
			*size = sizeof(ns1__SendOptionsRequestReply);
		((ns1__SendOptionsRequestReply*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SendOptionsRequestReply[n];
		if (size)
			*size = n * sizeof(ns1__SendOptionsRequestReply);
		for (int i = 0; i < n; i++)
			((ns1__SendOptionsRequestReply*)cp->ptr)[i].soap = soap;
	}
	return (ns1__SendOptionsRequestReply*)cp->ptr;
}

void ns1__Rights::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Rights))
		this->soap_mark(soap);
}

void ns1__Rights::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Rights*)this)->read, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Rights*)this)->read);
	soap_embedded(soap, &((ns1__Rights*)this)->add, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Rights*)this)->add);
	soap_embedded(soap, &((ns1__Rights*)this)->edit, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Rights*)this)->edit);
	soap_embedded(soap, &((ns1__Rights*)this)->_delete, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Rights*)this)->_delete);
	soap_embedded(soap, &((ns1__Rights*)this)->share, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Rights*)this)->share);
	soap_embedded(soap, &((ns1__Rights*)this)->manage, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Rights*)this)->manage);
	/* transient soap skipped */
}

void ns1__Rights::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTobool(soap, &((ns1__Rights*)this)->read);
	soap_default_PointerTobool(soap, &((ns1__Rights*)this)->add);
	soap_default_PointerTobool(soap, &((ns1__Rights*)this)->edit);
	soap_default_PointerTobool(soap, &((ns1__Rights*)this)->_delete);
	soap_default_PointerTobool(soap, &((ns1__Rights*)this)->share);
	soap_default_PointerTobool(soap, &((ns1__Rights*)this)->manage);
	/* transient soap skipped */
}

int ns1__Rights::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Rights);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Rights::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Rights(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Rights(struct soap *soap, const char *tag, int id, const ns1__Rights *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Rights), "ns1:Rights");
	soap_out_PointerTobool(soap, "read", -1, &(((ns1__Rights*)a)->read), "");
	soap_out_PointerTobool(soap, "add", -1, &(((ns1__Rights*)a)->add), "");
	soap_out_PointerTobool(soap, "edit", -1, &(((ns1__Rights*)a)->edit), "");
	soap_out_PointerTobool(soap, "delete", -1, &(((ns1__Rights*)a)->_delete), "");
	soap_out_PointerTobool(soap, "share", -1, &(((ns1__Rights*)a)->share), "");
	soap_out_PointerTobool(soap, "manage", -1, &(((ns1__Rights*)a)->manage), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Rights::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Rights(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Rights * SOAP_FMAC4 soap_get_ns1__Rights(struct soap *soap, ns1__Rights *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Rights(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Rights::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Rights(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Rights * SOAP_FMAC4 soap_in_ns1__Rights(struct soap *soap, const char *tag, ns1__Rights *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Rights *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Rights, sizeof(ns1__Rights), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Rights)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Rights *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_read1 = 1, soap_flag_add1 = 1, soap_flag_edit1 = 1, soap_flag_delete1 = 1, soap_flag_share1 = 1, soap_flag_manage1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_read1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "read", &(((ns1__Rights*)a)->read), ""))
				{	soap_flag_read1 = 0;
					continue;
				}

			if (soap_flag_add1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "add", &(((ns1__Rights*)a)->add), ""))
				{	soap_flag_add1 = 0;
					continue;
				}

			if (soap_flag_edit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "edit", &(((ns1__Rights*)a)->edit), ""))
				{	soap_flag_edit1 = 0;
					continue;
				}

			if (soap_flag_delete1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "delete", &(((ns1__Rights*)a)->_delete), ""))
				{	soap_flag_delete1 = 0;
					continue;
				}

			if (soap_flag_share1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "share", &(((ns1__Rights*)a)->share), ""))
				{	soap_flag_share1 = 0;
					continue;
				}

			if (soap_flag_manage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "manage", &(((ns1__Rights*)a)->manage), ""))
				{	soap_flag_manage1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Rights *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Rights, sizeof(ns1__Rights), soap->type, soap->arrayType), SOAP_TYPE_ns1__Rights, sizeof(ns1__Rights));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Rights * SOAP_FMAC6 soap_new_ns1__Rights(struct soap *soap, int n)
{	return soap_instantiate_ns1__Rights(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Rights(struct soap *soap, ns1__Rights *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Rights * SOAP_FMAC6 soap_instantiate_ns1__Rights(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Rights(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Rights, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Rights;
		if (size)
			*size = sizeof(ns1__Rights);
		((ns1__Rights*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Rights[n];
		if (size)
			*size = n * sizeof(ns1__Rights);
		for (int i = 0; i < n; i++)
			((ns1__Rights*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Rights*)cp->ptr;
}

void ns1__ReturnNotificationOptions::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ReturnNotificationOptions))
		this->soap_mark(soap);
}

void ns1__ReturnNotificationOptions::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ReturnNotificationOptions*)this)->mail, SOAP_TYPE_bool);
	soap_embedded(soap, &((ns1__ReturnNotificationOptions*)this)->notify, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void ns1__ReturnNotificationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ReturnNotificationOptions*)this)->mail = (bool)0;
	((ns1__ReturnNotificationOptions*)this)->notify = (bool)0;
	/* transient soap skipped */
}

int ns1__ReturnNotificationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ReturnNotificationOptions);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ReturnNotificationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReturnNotificationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReturnNotificationOptions(struct soap *soap, const char *tag, int id, const ns1__ReturnNotificationOptions *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReturnNotificationOptions), "ns1:ReturnNotificationOptions");
	soap_out_bool(soap, "mail", -1, &(((ns1__ReturnNotificationOptions*)a)->mail), "");
	soap_out_bool(soap, "notify", -1, &(((ns1__ReturnNotificationOptions*)a)->notify), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ReturnNotificationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReturnNotificationOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReturnNotificationOptions * SOAP_FMAC4 soap_get_ns1__ReturnNotificationOptions(struct soap *soap, ns1__ReturnNotificationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReturnNotificationOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ReturnNotificationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReturnNotificationOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReturnNotificationOptions * SOAP_FMAC4 soap_in_ns1__ReturnNotificationOptions(struct soap *soap, const char *tag, ns1__ReturnNotificationOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ReturnNotificationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnNotificationOptions, sizeof(ns1__ReturnNotificationOptions), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ReturnNotificationOptions)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ReturnNotificationOptions *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_mail1 = 1, soap_flag_notify1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_mail1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "mail", &(((ns1__ReturnNotificationOptions*)a)->mail), ""))
				{	soap_flag_mail1 = 0;
					continue;
				}

			if (soap_flag_notify1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "notify", &(((ns1__ReturnNotificationOptions*)a)->notify), ""))
				{	soap_flag_notify1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mail1 || soap_flag_notify1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__ReturnNotificationOptions *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnNotificationOptions, sizeof(ns1__ReturnNotificationOptions), soap->type, soap->arrayType), SOAP_TYPE_ns1__ReturnNotificationOptions, sizeof(ns1__ReturnNotificationOptions));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ReturnNotificationOptions * SOAP_FMAC6 soap_new_ns1__ReturnNotificationOptions(struct soap *soap, int n)
{	return soap_instantiate_ns1__ReturnNotificationOptions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ReturnNotificationOptions(struct soap *soap, ns1__ReturnNotificationOptions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ReturnNotificationOptions * SOAP_FMAC6 soap_instantiate_ns1__ReturnNotificationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReturnNotificationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ReturnNotificationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ReturnNotificationOptions;
		if (size)
			*size = sizeof(ns1__ReturnNotificationOptions);
		((ns1__ReturnNotificationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ReturnNotificationOptions[n];
		if (size)
			*size = n * sizeof(ns1__ReturnNotificationOptions);
		for (int i = 0; i < n; i++)
			((ns1__ReturnNotificationOptions*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ReturnNotificationOptions*)cp->ptr;
}

void ns1__ReturnNotification::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ReturnNotification))
		this->soap_mark(soap);
}

void ns1__ReturnNotification::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ReturnNotification*)this)->opened, SOAP_TYPE_PointerTons1__ReturnNotificationOptions);
	soap_mark_PointerTons1__ReturnNotificationOptions(soap, &((ns1__ReturnNotification*)this)->opened);
	soap_embedded(soap, &((ns1__ReturnNotification*)this)->deleted, SOAP_TYPE_PointerTons1__ReturnNotificationOptions);
	soap_mark_PointerTons1__ReturnNotificationOptions(soap, &((ns1__ReturnNotification*)this)->deleted);
	soap_embedded(soap, &((ns1__ReturnNotification*)this)->accepted, SOAP_TYPE_PointerTons1__ReturnNotificationOptions);
	soap_mark_PointerTons1__ReturnNotificationOptions(soap, &((ns1__ReturnNotification*)this)->accepted);
	soap_embedded(soap, &((ns1__ReturnNotification*)this)->declined, SOAP_TYPE_PointerTons1__ReturnNotificationOptions);
	soap_mark_PointerTons1__ReturnNotificationOptions(soap, &((ns1__ReturnNotification*)this)->declined);
	/* transient soap skipped */
}

void ns1__ReturnNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ReturnNotificationOptions(soap, &((ns1__ReturnNotification*)this)->opened);
	soap_default_PointerTons1__ReturnNotificationOptions(soap, &((ns1__ReturnNotification*)this)->deleted);
	soap_default_PointerTons1__ReturnNotificationOptions(soap, &((ns1__ReturnNotification*)this)->accepted);
	soap_default_PointerTons1__ReturnNotificationOptions(soap, &((ns1__ReturnNotification*)this)->declined);
	/* transient soap skipped */
}

int ns1__ReturnNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ReturnNotification);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ReturnNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReturnNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReturnNotification(struct soap *soap, const char *tag, int id, const ns1__ReturnNotification *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReturnNotification), "ns1:ReturnNotification");
	soap_out_PointerTons1__ReturnNotificationOptions(soap, "opened", -1, &(((ns1__ReturnNotification*)a)->opened), "ns1:ReturnNotificationOptions");
	soap_out_PointerTons1__ReturnNotificationOptions(soap, "deleted", -1, &(((ns1__ReturnNotification*)a)->deleted), "ns1:ReturnNotificationOptions");
	soap_out_PointerTons1__ReturnNotificationOptions(soap, "accepted", -1, &(((ns1__ReturnNotification*)a)->accepted), "ns1:ReturnNotificationOptions");
	soap_out_PointerTons1__ReturnNotificationOptions(soap, "declined", -1, &(((ns1__ReturnNotification*)a)->declined), "ns1:ReturnNotificationOptions");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ReturnNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReturnNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReturnNotification * SOAP_FMAC4 soap_get_ns1__ReturnNotification(struct soap *soap, ns1__ReturnNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReturnNotification(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ReturnNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReturnNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReturnNotification * SOAP_FMAC4 soap_in_ns1__ReturnNotification(struct soap *soap, const char *tag, ns1__ReturnNotification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ReturnNotification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnNotification, sizeof(ns1__ReturnNotification), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ReturnNotification)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ReturnNotification *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_opened1 = 1, soap_flag_deleted1 = 1, soap_flag_accepted1 = 1, soap_flag_declined1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_opened1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReturnNotificationOptions(soap, "opened", &(((ns1__ReturnNotification*)a)->opened), "ns1:ReturnNotificationOptions"))
				{	soap_flag_opened1 = 0;
					continue;
				}

			if (soap_flag_deleted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReturnNotificationOptions(soap, "deleted", &(((ns1__ReturnNotification*)a)->deleted), "ns1:ReturnNotificationOptions"))
				{	soap_flag_deleted1 = 0;
					continue;
				}

			if (soap_flag_accepted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReturnNotificationOptions(soap, "accepted", &(((ns1__ReturnNotification*)a)->accepted), "ns1:ReturnNotificationOptions"))
				{	soap_flag_accepted1 = 0;
					continue;
				}

			if (soap_flag_declined1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReturnNotificationOptions(soap, "declined", &(((ns1__ReturnNotification*)a)->declined), "ns1:ReturnNotificationOptions"))
				{	soap_flag_declined1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__ReturnNotification *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnNotification, sizeof(ns1__ReturnNotification), soap->type, soap->arrayType), SOAP_TYPE_ns1__ReturnNotification, sizeof(ns1__ReturnNotification));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ReturnNotification * SOAP_FMAC6 soap_new_ns1__ReturnNotification(struct soap *soap, int n)
{	return soap_instantiate_ns1__ReturnNotification(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ReturnNotification(struct soap *soap, ns1__ReturnNotification *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ReturnNotification * SOAP_FMAC6 soap_instantiate_ns1__ReturnNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReturnNotification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ReturnNotification, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ReturnNotification;
		if (size)
			*size = sizeof(ns1__ReturnNotification);
		((ns1__ReturnNotification*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ReturnNotification[n];
		if (size)
			*size = n * sizeof(ns1__ReturnNotification);
		for (int i = 0; i < n; i++)
			((ns1__ReturnNotification*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ReturnNotification*)cp->ptr;
}

void ns1__Resource::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Resource))
		this->soap_mark(soap);
}

void ns1__Resource::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Resource*)this)->phone, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Resource*)this)->phone);
	soap_embedded(soap, &((ns1__Resource*)this)->resourceType, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Resource*)this)->resourceType);
	soap_embedded(soap, &((ns1__Resource*)this)->email, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Resource*)this)->email);
	soap_embedded(soap, &((ns1__Resource*)this)->owner, SOAP_TYPE_PointerTons1__ItemRef);
	soap_mark_PointerTons1__ItemRef(soap, &((ns1__Resource*)this)->owner);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__AddressBookItem*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__AddressBookItem*)this)->uuid);
	soap_embedded(soap, &((ns1__AddressBookItem*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__AddressBookItem*)this)->comment);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__Resource::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__string(soap, &((ns1__Resource*)this)->phone);
	soap_default_PointerTostd__string(soap, &((ns1__Resource*)this)->resourceType);
	soap_default_std__string(soap, &((ns1__Resource*)this)->email);
	soap_default_PointerTons1__ItemRef(soap, &((ns1__Resource*)this)->owner);
	/* transient soap skipped */
	soap_default_ns1__UUID(soap, &((ns1__AddressBookItem*)this)->uuid);
	soap_default_PointerTostd__string(soap, &((ns1__AddressBookItem*)this)->comment);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__Resource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Resource);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Resource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Resource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Resource(struct soap *soap, const char *tag, int id, const ns1__Resource *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Resource), "ns1:Resource");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__AddressBookItem*)a)->uuid), "ns1:UUID");
	soap_out_PointerTostd__string(soap, "comment", -1, &(((ns1__AddressBookItem*)a)->comment), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "phone", -1, &(((ns1__Resource*)a)->phone), "xsd:string");
	soap_out_PointerTostd__string(soap, "resourceType", -1, &(((ns1__Resource*)a)->resourceType), "xsd:string");
	soap_out_std__string(soap, "email", -1, &(((ns1__Resource*)a)->email), "xsd:string");
	soap_out_PointerTons1__ItemRef(soap, "owner", -1, &(((ns1__Resource*)a)->owner), "ns1:ItemRef");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Resource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Resource(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Resource * SOAP_FMAC4 soap_get_ns1__Resource(struct soap *soap, ns1__Resource *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Resource(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Resource::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Resource(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Resource * SOAP_FMAC4 soap_in_ns1__Resource(struct soap *soap, const char *tag, ns1__Resource *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Resource *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Resource, sizeof(ns1__Resource), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Resource)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Resource *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_type4 = 1, soap_flag_categories3 = 1, soap_flag_created3 = 1, soap_flag_customs3 = 1, soap_flag_uuid2 = 1, soap_flag_comment2 = 1, soap_flag_phone1 = 1, soap_flag_resourceType1 = 1, soap_flag_email1 = 1, soap_flag_owner1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}

			if (soap_flag_name4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name4 = 0;
					continue;
				}

			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}

			if (soap_flag_modified4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}

			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}

			if (soap_flag_type4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories3 = 0;
					continue;
				}

			if (soap_flag_created3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created3 = 0;
					continue;
				}

			if (soap_flag_customs3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_uuid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__AddressBookItem*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}

			if (soap_flag_comment2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "comment", &(((ns1__AddressBookItem*)a)->comment), "xsd:string"))
				{	soap_flag_comment2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_phone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "phone", &(((ns1__Resource*)a)->phone), "xsd:string"))
				{	soap_flag_phone1 = 0;
					continue;
				}

			if (soap_flag_resourceType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "resourceType", &(((ns1__Resource*)a)->resourceType), "xsd:string"))
				{	soap_flag_resourceType1 = 0;
					continue;
				}

			if (soap_flag_email1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "email", &(((ns1__Resource*)a)->email), "xsd:string"))
				{	soap_flag_email1 = 0;
					continue;
				}

			if (soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRef(soap, "owner", &(((ns1__Resource*)a)->owner), "ns1:ItemRef"))
				{	soap_flag_owner1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Resource *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Resource, sizeof(ns1__Resource), soap->type, soap->arrayType), SOAP_TYPE_ns1__Resource, sizeof(ns1__Resource));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Resource * SOAP_FMAC6 soap_new_ns1__Resource(struct soap *soap, int n)
{	return soap_instantiate_ns1__Resource(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Resource(struct soap *soap, ns1__Resource *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Resource * SOAP_FMAC6 soap_instantiate_ns1__Resource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Resource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Resource, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Resource;
		if (size)
			*size = sizeof(ns1__Resource);
		((ns1__Resource*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Resource[n];
		if (size)
			*size = n * sizeof(ns1__Resource);
		for (int i = 0; i < n; i++)
			((ns1__Resource*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Resource*)cp->ptr;
}

void ns1__RecurrenceDateType::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__RecurrenceDateType))
		this->soap_mark(soap);
}

void ns1__RecurrenceDateType::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__RecurrenceDateType*)this)->date, SOAP_TYPE_PointerTostd__vectorTemplateOfxsd__date);
	soap_mark_PointerTostd__vectorTemplateOfxsd__date(soap, &((ns1__RecurrenceDateType*)this)->date);
	/* transient soap skipped */
}

void ns1__RecurrenceDateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfxsd__date(soap, &((ns1__RecurrenceDateType*)this)->date);
	/* transient soap skipped */
}

int ns1__RecurrenceDateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__RecurrenceDateType);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__RecurrenceDateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RecurrenceDateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RecurrenceDateType(struct soap *soap, const char *tag, int id, const ns1__RecurrenceDateType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RecurrenceDateType), "ns1:RecurrenceDateType");
	soap_out_PointerTostd__vectorTemplateOfxsd__date(soap, "date", -1, &(((ns1__RecurrenceDateType*)a)->date), "xsd:date");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__RecurrenceDateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RecurrenceDateType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RecurrenceDateType * SOAP_FMAC4 soap_get_ns1__RecurrenceDateType(struct soap *soap, ns1__RecurrenceDateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RecurrenceDateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__RecurrenceDateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RecurrenceDateType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RecurrenceDateType * SOAP_FMAC4 soap_in_ns1__RecurrenceDateType(struct soap *soap, const char *tag, ns1__RecurrenceDateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__RecurrenceDateType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecurrenceDateType, sizeof(ns1__RecurrenceDateType), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__RecurrenceDateType)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__RecurrenceDateType *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfxsd__date(soap, "date", &(((ns1__RecurrenceDateType*)a)->date), "xsd:date"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__RecurrenceDateType *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecurrenceDateType, sizeof(ns1__RecurrenceDateType), soap->type, soap->arrayType), SOAP_TYPE_ns1__RecurrenceDateType, sizeof(ns1__RecurrenceDateType));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__RecurrenceDateType * SOAP_FMAC6 soap_new_ns1__RecurrenceDateType(struct soap *soap, int n)
{	return soap_instantiate_ns1__RecurrenceDateType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__RecurrenceDateType(struct soap *soap, ns1__RecurrenceDateType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__RecurrenceDateType * SOAP_FMAC6 soap_instantiate_ns1__RecurrenceDateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RecurrenceDateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RecurrenceDateType, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__RecurrenceDateType;
		if (size)
			*size = sizeof(ns1__RecurrenceDateType);
		((ns1__RecurrenceDateType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__RecurrenceDateType[n];
		if (size)
			*size = n * sizeof(ns1__RecurrenceDateType);
		for (int i = 0; i < n; i++)
			((ns1__RecurrenceDateType*)cp->ptr)[i].soap = soap;
	}
	return (ns1__RecurrenceDateType*)cp->ptr;
}

void ns1__RecipientStatus::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__RecipientStatus))
		this->soap_mark(soap);
}

void ns1__RecipientStatus::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->delivered, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->delivered);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->undeliverable, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->undeliverable);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->transferred, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->transferred);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->transferDelayed, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->transferDelayed);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->downloaded, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->downloaded);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->retractRequested, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->retractRequested);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->retracted, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->retracted);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->opened, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->opened);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->deleted, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->deleted);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->undeleted, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->undeleted);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->purged, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->purged);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->accepted, SOAP_TYPE_PointerTons1__CommentStatus);
	soap_mark_PointerTons1__CommentStatus(soap, &((ns1__RecipientStatus*)this)->accepted);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->declined, SOAP_TYPE_PointerTons1__CommentStatus);
	soap_mark_PointerTons1__CommentStatus(soap, &((ns1__RecipientStatus*)this)->declined);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->replied, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->replied);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->forwarded, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->forwarded);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->shared, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->shared);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->started, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->started);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->completed, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->completed);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->incomplete, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->incomplete);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->delegated, SOAP_TYPE_PointerTons1__DelegatedStatus);
	soap_mark_PointerTons1__DelegatedStatus(soap, &((ns1__RecipientStatus*)this)->delegated);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->delegateeStatus, SOAP_TYPE_PointerTons1__DelegateeStatus);
	soap_mark_PointerTons1__DelegateeStatus(soap, &((ns1__RecipientStatus*)this)->delegateeStatus);
	/* transient soap skipped */
}

void ns1__RecipientStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->delivered);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->undeliverable);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->transferred);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->transferDelayed);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->downloaded);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->retractRequested);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->retracted);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->opened);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->deleted);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->undeleted);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->purged);
	soap_default_PointerTons1__CommentStatus(soap, &((ns1__RecipientStatus*)this)->accepted);
	soap_default_PointerTons1__CommentStatus(soap, &((ns1__RecipientStatus*)this)->declined);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->replied);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->forwarded);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->shared);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->started);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->completed);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->incomplete);
	soap_default_PointerTons1__DelegatedStatus(soap, &((ns1__RecipientStatus*)this)->delegated);
	soap_default_PointerTons1__DelegateeStatus(soap, &((ns1__RecipientStatus*)this)->delegateeStatus);
	/* transient soap skipped */
}

int ns1__RecipientStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__RecipientStatus);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__RecipientStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RecipientStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RecipientStatus(struct soap *soap, const char *tag, int id, const ns1__RecipientStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RecipientStatus), "ns1:RecipientStatus");
	soap_out_string(soap, "delivered", -1, &(((ns1__RecipientStatus*)a)->delivered), "");
	soap_out_string(soap, "undeliverable", -1, &(((ns1__RecipientStatus*)a)->undeliverable), "");
	soap_out_string(soap, "transferred", -1, &(((ns1__RecipientStatus*)a)->transferred), "");
	soap_out_string(soap, "transferDelayed", -1, &(((ns1__RecipientStatus*)a)->transferDelayed), "");
	soap_out_string(soap, "downloaded", -1, &(((ns1__RecipientStatus*)a)->downloaded), "");
	soap_out_string(soap, "retractRequested", -1, &(((ns1__RecipientStatus*)a)->retractRequested), "");
	soap_out_string(soap, "retracted", -1, &(((ns1__RecipientStatus*)a)->retracted), "");
	soap_out_string(soap, "opened", -1, &(((ns1__RecipientStatus*)a)->opened), "");
	soap_out_string(soap, "deleted", -1, &(((ns1__RecipientStatus*)a)->deleted), "");
	soap_out_string(soap, "undeleted", -1, &(((ns1__RecipientStatus*)a)->undeleted), "");
	soap_out_string(soap, "purged", -1, &(((ns1__RecipientStatus*)a)->purged), "");
	soap_out_PointerTons1__CommentStatus(soap, "accepted", -1, &(((ns1__RecipientStatus*)a)->accepted), "ns1:CommentStatus");
	soap_out_PointerTons1__CommentStatus(soap, "declined", -1, &(((ns1__RecipientStatus*)a)->declined), "ns1:CommentStatus");
	soap_out_string(soap, "replied", -1, &(((ns1__RecipientStatus*)a)->replied), "");
	soap_out_string(soap, "forwarded", -1, &(((ns1__RecipientStatus*)a)->forwarded), "");
	soap_out_string(soap, "shared", -1, &(((ns1__RecipientStatus*)a)->shared), "");
	soap_out_string(soap, "started", -1, &(((ns1__RecipientStatus*)a)->started), "");
	soap_out_string(soap, "completed", -1, &(((ns1__RecipientStatus*)a)->completed), "");
	soap_out_string(soap, "incomplete", -1, &(((ns1__RecipientStatus*)a)->incomplete), "");
	soap_out_PointerTons1__DelegatedStatus(soap, "delegated", -1, &(((ns1__RecipientStatus*)a)->delegated), "ns1:DelegatedStatus");
	soap_out_PointerTons1__DelegateeStatus(soap, "delegateeStatus", -1, &(((ns1__RecipientStatus*)a)->delegateeStatus), "ns1:DelegateeStatus");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__RecipientStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RecipientStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RecipientStatus * SOAP_FMAC4 soap_get_ns1__RecipientStatus(struct soap *soap, ns1__RecipientStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RecipientStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__RecipientStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RecipientStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RecipientStatus * SOAP_FMAC4 soap_in_ns1__RecipientStatus(struct soap *soap, const char *tag, ns1__RecipientStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__RecipientStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipientStatus, sizeof(ns1__RecipientStatus), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__RecipientStatus)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__RecipientStatus *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_delivered1 = 1, soap_flag_undeliverable1 = 1, soap_flag_transferred1 = 1, soap_flag_transferDelayed1 = 1, soap_flag_downloaded1 = 1, soap_flag_retractRequested1 = 1, soap_flag_retracted1 = 1, soap_flag_opened1 = 1, soap_flag_deleted1 = 1, soap_flag_undeleted1 = 1, soap_flag_purged1 = 1, soap_flag_accepted1 = 1, soap_flag_declined1 = 1, soap_flag_replied1 = 1, soap_flag_forwarded1 = 1, soap_flag_shared1 = 1, soap_flag_started1 = 1, soap_flag_completed1 = 1, soap_flag_incomplete1 = 1, soap_flag_delegated1 = 1, soap_flag_delegateeStatus1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_delivered1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "delivered", &(((ns1__RecipientStatus*)a)->delivered), ""))
				{	soap_flag_delivered1 = 0;
					continue;
				}

			if (soap_flag_undeliverable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "undeliverable", &(((ns1__RecipientStatus*)a)->undeliverable), ""))
				{	soap_flag_undeliverable1 = 0;
					continue;
				}

			if (soap_flag_transferred1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "transferred", &(((ns1__RecipientStatus*)a)->transferred), ""))
				{	soap_flag_transferred1 = 0;
					continue;
				}

			if (soap_flag_transferDelayed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "transferDelayed", &(((ns1__RecipientStatus*)a)->transferDelayed), ""))
				{	soap_flag_transferDelayed1 = 0;
					continue;
				}

			if (soap_flag_downloaded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "downloaded", &(((ns1__RecipientStatus*)a)->downloaded), ""))
				{	soap_flag_downloaded1 = 0;
					continue;
				}

			if (soap_flag_retractRequested1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "retractRequested", &(((ns1__RecipientStatus*)a)->retractRequested), ""))
				{	soap_flag_retractRequested1 = 0;
					continue;
				}

			if (soap_flag_retracted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "retracted", &(((ns1__RecipientStatus*)a)->retracted), ""))
				{	soap_flag_retracted1 = 0;
					continue;
				}

			if (soap_flag_opened1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "opened", &(((ns1__RecipientStatus*)a)->opened), ""))
				{	soap_flag_opened1 = 0;
					continue;
				}

			if (soap_flag_deleted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "deleted", &(((ns1__RecipientStatus*)a)->deleted), ""))
				{	soap_flag_deleted1 = 0;
					continue;
				}

			if (soap_flag_undeleted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "undeleted", &(((ns1__RecipientStatus*)a)->undeleted), ""))
				{	soap_flag_undeleted1 = 0;
					continue;
				}

			if (soap_flag_purged1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "purged", &(((ns1__RecipientStatus*)a)->purged), ""))
				{	soap_flag_purged1 = 0;
					continue;
				}

			if (soap_flag_accepted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CommentStatus(soap, "accepted", &(((ns1__RecipientStatus*)a)->accepted), "ns1:CommentStatus"))
				{	soap_flag_accepted1 = 0;
					continue;
				}

			if (soap_flag_declined1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CommentStatus(soap, "declined", &(((ns1__RecipientStatus*)a)->declined), "ns1:CommentStatus"))
				{	soap_flag_declined1 = 0;
					continue;
				}

			if (soap_flag_replied1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "replied", &(((ns1__RecipientStatus*)a)->replied), ""))
				{	soap_flag_replied1 = 0;
					continue;
				}

			if (soap_flag_forwarded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "forwarded", &(((ns1__RecipientStatus*)a)->forwarded), ""))
				{	soap_flag_forwarded1 = 0;
					continue;
				}

			if (soap_flag_shared1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "shared", &(((ns1__RecipientStatus*)a)->shared), ""))
				{	soap_flag_shared1 = 0;
					continue;
				}

			if (soap_flag_started1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "started", &(((ns1__RecipientStatus*)a)->started), ""))
				{	soap_flag_started1 = 0;
					continue;
				}

			if (soap_flag_completed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "completed", &(((ns1__RecipientStatus*)a)->completed), ""))
				{	soap_flag_completed1 = 0;
					continue;
				}

			if (soap_flag_incomplete1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "incomplete", &(((ns1__RecipientStatus*)a)->incomplete), ""))
				{	soap_flag_incomplete1 = 0;
					continue;
				}

			if (soap_flag_delegated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DelegatedStatus(soap, "delegated", &(((ns1__RecipientStatus*)a)->delegated), "ns1:DelegatedStatus"))
				{	soap_flag_delegated1 = 0;
					continue;
				}

			if (soap_flag_delegateeStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DelegateeStatus(soap, "delegateeStatus", &(((ns1__RecipientStatus*)a)->delegateeStatus), "ns1:DelegateeStatus"))
				{	soap_flag_delegateeStatus1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__RecipientStatus *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipientStatus, sizeof(ns1__RecipientStatus), soap->type, soap->arrayType), SOAP_TYPE_ns1__RecipientStatus, sizeof(ns1__RecipientStatus));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__RecipientStatus * SOAP_FMAC6 soap_new_ns1__RecipientStatus(struct soap *soap, int n)
{	return soap_instantiate_ns1__RecipientStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__RecipientStatus(struct soap *soap, ns1__RecipientStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__RecipientStatus * SOAP_FMAC6 soap_instantiate_ns1__RecipientStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RecipientStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RecipientStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:DelegateeStatus"))
	{	cp->type = SOAP_TYPE_ns1__DelegateeStatus;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__DelegateeStatus;
			if (size)
				*size = sizeof(ns1__DelegateeStatus);
			((ns1__DelegateeStatus*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__DelegateeStatus[n];
			if (size)
				*size = n * sizeof(ns1__DelegateeStatus);
			for (int i = 0; i < n; i++)
				((ns1__DelegateeStatus*)cp->ptr)[i].soap = soap;
		}
		return (ns1__DelegateeStatus*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__RecipientStatus;
		if (size)
			*size = sizeof(ns1__RecipientStatus);
		((ns1__RecipientStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__RecipientStatus[n];
		if (size)
			*size = n * sizeof(ns1__RecipientStatus);
		for (int i = 0; i < n; i++)
			((ns1__RecipientStatus*)cp->ptr)[i].soap = soap;
	}
	return (ns1__RecipientStatus*)cp->ptr;
}

void ns1__RecipientList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__RecipientList))
		this->soap_mark(soap);
}

void ns1__RecipientList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__RecipientList*)this)->recipient, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Recipient);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Recipient(soap, &((ns1__RecipientList*)this)->recipient);
	/* transient soap skipped */
}

void ns1__RecipientList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__Recipient(soap, &((ns1__RecipientList*)this)->recipient);
	/* transient soap skipped */
}

int ns1__RecipientList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__RecipientList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__RecipientList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RecipientList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RecipientList(struct soap *soap, const char *tag, int id, const ns1__RecipientList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RecipientList), "ns1:RecipientList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Recipient(soap, "recipient", -1, &(((ns1__RecipientList*)a)->recipient), "ns1:Recipient");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__RecipientList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RecipientList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RecipientList * SOAP_FMAC4 soap_get_ns1__RecipientList(struct soap *soap, ns1__RecipientList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RecipientList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__RecipientList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RecipientList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RecipientList * SOAP_FMAC4 soap_in_ns1__RecipientList(struct soap *soap, const char *tag, ns1__RecipientList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__RecipientList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipientList, sizeof(ns1__RecipientList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__RecipientList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__RecipientList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__Recipient(soap, "recipient", &(((ns1__RecipientList*)a)->recipient), "ns1:Recipient"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__RecipientList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RecipientList, sizeof(ns1__RecipientList), soap->type, soap->arrayType), SOAP_TYPE_ns1__RecipientList, sizeof(ns1__RecipientList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__RecipientList * SOAP_FMAC6 soap_new_ns1__RecipientList(struct soap *soap, int n)
{	return soap_instantiate_ns1__RecipientList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__RecipientList(struct soap *soap, ns1__RecipientList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__RecipientList * SOAP_FMAC6 soap_instantiate_ns1__RecipientList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RecipientList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RecipientList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__RecipientList;
		if (size)
			*size = sizeof(ns1__RecipientList);
		((ns1__RecipientList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__RecipientList[n];
		if (size)
			*size = n * sizeof(ns1__RecipientList);
		for (int i = 0; i < n; i++)
			((ns1__RecipientList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__RecipientList*)cp->ptr;
}

void ns1__Recipient::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Recipient))
		this->soap_mark(soap);
}

void ns1__Recipient::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Recipient*)this)->distType, SOAP_TYPE_ns1__DistributionType);
	soap_embedded(soap, &((ns1__Recipient*)this)->recipType, SOAP_TYPE_ns1__RecipientType);
	soap_embedded(soap, &((ns1__Recipient*)this)->recipientStatus, SOAP_TYPE_PointerTons1__RecipientStatus);
	soap_mark_PointerTons1__RecipientStatus(soap, &((ns1__Recipient*)this)->recipientStatus);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->displayName, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->email, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ns1__Recipient::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__DistributionType(soap, &((ns1__Recipient*)this)->distType);
	soap_default_ns1__RecipientType(soap, &((ns1__Recipient*)this)->recipType);
	soap_default_PointerTons1__RecipientStatus(soap, &((ns1__Recipient*)this)->recipientStatus);
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_default_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

int ns1__Recipient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Recipient);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Recipient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Recipient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Recipient(struct soap *soap, const char *tag, int id, const ns1__Recipient *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Recipient), "ns1:Recipient");
	soap_out_std__string(soap, "displayName", -1, &(((ns1__NameAndEmail*)a)->displayName), "xsd:string");
	soap_out_std__string(soap, "email", -1, &(((ns1__NameAndEmail*)a)->email), "xsd:string");
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID");
	/* transient soap skipped */
	soap_out_ns1__DistributionType(soap, "distType", -1, &(((ns1__Recipient*)a)->distType), "ns1:DistributionType");
	soap_out_ns1__RecipientType(soap, "recipType", -1, &(((ns1__Recipient*)a)->recipType), "ns1:RecipientType");
	soap_out_PointerTons1__RecipientStatus(soap, "recipientStatus", -1, &(((ns1__Recipient*)a)->recipientStatus), "ns1:RecipientStatus");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Recipient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Recipient(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Recipient * SOAP_FMAC4 soap_get_ns1__Recipient(struct soap *soap, ns1__Recipient *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Recipient(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Recipient::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Recipient(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Recipient * SOAP_FMAC4 soap_in_ns1__Recipient(struct soap *soap, const char *tag, ns1__Recipient *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Recipient *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Recipient, sizeof(ns1__Recipient), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Recipient)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Recipient *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_displayName2 = 1, soap_flag_email2 = 1, soap_flag_uuid2 = 1, soap_flag_distType1 = 1, soap_flag_recipType1 = 1, soap_flag_recipientStatus1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_displayName2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "displayName", &(((ns1__NameAndEmail*)a)->displayName), "xsd:string"))
				{	soap_flag_displayName2 = 0;
					continue;
				}

			if (soap_flag_email2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "email", &(((ns1__NameAndEmail*)a)->email), "xsd:string"))
				{	soap_flag_email2 = 0;
					continue;
				}

			if (soap_flag_uuid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_distType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__DistributionType(soap, "distType", &(((ns1__Recipient*)a)->distType), "ns1:DistributionType"))
				{	soap_flag_distType1 = 0;
					continue;
				}

			if (soap_flag_recipType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__RecipientType(soap, "recipType", &(((ns1__Recipient*)a)->recipType), "ns1:RecipientType"))
				{	soap_flag_recipType1 = 0;
					continue;
				}

			if (soap_flag_recipientStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RecipientStatus(soap, "recipientStatus", &(((ns1__Recipient*)a)->recipientStatus), "ns1:RecipientStatus"))
				{	soap_flag_recipientStatus1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_distType1 || soap_flag_recipType1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__Recipient *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Recipient, sizeof(ns1__Recipient), soap->type, soap->arrayType), SOAP_TYPE_ns1__Recipient, sizeof(ns1__Recipient));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Recipient * SOAP_FMAC6 soap_new_ns1__Recipient(struct soap *soap, int n)
{	return soap_instantiate_ns1__Recipient(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Recipient(struct soap *soap, ns1__Recipient *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Recipient * SOAP_FMAC6 soap_instantiate_ns1__Recipient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Recipient(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Recipient, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Recipient;
		if (size)
			*size = sizeof(ns1__Recipient);
		((ns1__Recipient*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Recipient[n];
		if (size)
			*size = n * sizeof(ns1__Recipient);
		for (int i = 0; i < n; i++)
			((ns1__Recipient*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Recipient*)cp->ptr;
}

void ns1__QueryTarget::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__QueryTarget))
		this->soap_mark(soap);
}

void ns1__QueryTarget::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__QueryTarget*)this)->source, SOAP_TYPE_PointerTons1__uid);
	soap_mark_PointerTons1__uid(soap, &((ns1__QueryTarget*)this)->source);
	soap_embedded(soap, &((ns1__QueryTarget*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfns1__uid);
	soap_mark_PointerTostd__vectorTemplateOfns1__uid(soap, &((ns1__QueryTarget*)this)->container);
	/* transient soap skipped */
}

void ns1__QueryTarget::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__uid(soap, &((ns1__QueryTarget*)this)->source);
	soap_default_PointerTostd__vectorTemplateOfns1__uid(soap, &((ns1__QueryTarget*)this)->container);
	/* transient soap skipped */
}

int ns1__QueryTarget::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__QueryTarget);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__QueryTarget::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QueryTarget(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QueryTarget(struct soap *soap, const char *tag, int id, const ns1__QueryTarget *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QueryTarget), "ns1:QueryTarget");
	soap_out_PointerTons1__uid(soap, "source", -1, &(((ns1__QueryTarget*)a)->source), "ns1:uid");
	soap_out_PointerTostd__vectorTemplateOfns1__uid(soap, "container", -1, &(((ns1__QueryTarget*)a)->container), "ns1:uid");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__QueryTarget::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QueryTarget(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QueryTarget * SOAP_FMAC4 soap_get_ns1__QueryTarget(struct soap *soap, ns1__QueryTarget *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QueryTarget(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__QueryTarget::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__QueryTarget(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QueryTarget * SOAP_FMAC4 soap_in_ns1__QueryTarget(struct soap *soap, const char *tag, ns1__QueryTarget *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__QueryTarget *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QueryTarget, sizeof(ns1__QueryTarget), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__QueryTarget)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__QueryTarget *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_source1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__uid(soap, "source", &(((ns1__QueryTarget*)a)->source), "ns1:uid"))
				{	soap_flag_source1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfns1__uid(soap, "container", &(((ns1__QueryTarget*)a)->container), "ns1:uid"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__QueryTarget *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QueryTarget, sizeof(ns1__QueryTarget), soap->type, soap->arrayType), SOAP_TYPE_ns1__QueryTarget, sizeof(ns1__QueryTarget));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__QueryTarget * SOAP_FMAC6 soap_new_ns1__QueryTarget(struct soap *soap, int n)
{	return soap_instantiate_ns1__QueryTarget(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__QueryTarget(struct soap *soap, ns1__QueryTarget *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__QueryTarget * SOAP_FMAC6 soap_instantiate_ns1__QueryTarget(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QueryTarget(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__QueryTarget, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__QueryTarget;
		if (size)
			*size = sizeof(ns1__QueryTarget);
		((ns1__QueryTarget*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__QueryTarget[n];
		if (size)
			*size = n * sizeof(ns1__QueryTarget);
		for (int i = 0; i < n; i++)
			((ns1__QueryTarget*)cp->ptr)[i].soap = soap;
	}
	return (ns1__QueryTarget*)cp->ptr;
}

void ns1__QueryFolder::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__QueryFolder))
		this->soap_mark(soap);
}

void ns1__QueryFolder::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__QueryFolder*)this)->query, SOAP_TYPE_PointerTons1__Query);
	soap_mark_PointerTons1__Query(soap, &((ns1__QueryFolder*)this)->query);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Folder*)this)->parent, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Folder*)this)->parent);
	soap_embedded(soap, &((ns1__Folder*)this)->description, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Folder*)this)->description);
	soap_embedded(soap, &((ns1__Folder*)this)->count, SOAP_TYPE_PointerToint);
	soap_mark_PointerToint(soap, &((ns1__Folder*)this)->count);
	soap_embedded(soap, &((ns1__Folder*)this)->hasUnread, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Folder*)this)->hasUnread);
	soap_embedded(soap, &((ns1__Folder*)this)->unreadCount, SOAP_TYPE_PointerToint);
	soap_mark_PointerToint(soap, &((ns1__Folder*)this)->unreadCount);
	soap_embedded(soap, &((ns1__Folder*)this)->sequence, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Folder*)this)->settings, SOAP_TYPE_PointerTons1__uid);
	soap_mark_PointerTons1__uid(soap, &((ns1__Folder*)this)->settings);
	soap_embedded(soap, &((ns1__Folder*)this)->hasSubfolders, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Folder*)this)->hasSubfolders);
	soap_embedded(soap, &((ns1__Folder*)this)->notification, SOAP_TYPE_PointerTons1__SharedFolderNotification);
	soap_mark_PointerTons1__SharedFolderNotification(soap, &((ns1__Folder*)this)->notification);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__QueryFolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Query(soap, &((ns1__QueryFolder*)this)->query);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Folder*)this)->parent);
	soap_default_std__string(soap, &((ns1__Folder*)this)->description);
	soap_default_PointerToint(soap, &((ns1__Folder*)this)->count);
	soap_default_PointerTobool(soap, &((ns1__Folder*)this)->hasUnread);
	soap_default_PointerToint(soap, &((ns1__Folder*)this)->unreadCount);
	soap_default_unsignedLong(soap, &((ns1__Folder*)this)->sequence);
	soap_default_PointerTons1__uid(soap, &((ns1__Folder*)this)->settings);
	soap_default_PointerTobool(soap, &((ns1__Folder*)this)->hasSubfolders);
	soap_default_PointerTons1__SharedFolderNotification(soap, &((ns1__Folder*)this)->notification);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__QueryFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__QueryFolder);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__QueryFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QueryFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QueryFolder(struct soap *soap, const char *tag, int id, const ns1__QueryFolder *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QueryFolder), "ns1:QueryFolder");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_ns1__uid(soap, "parent", -1, &(((ns1__Folder*)a)->parent), "ns1:uid");
	soap_out_std__string(soap, "description", -1, &(((ns1__Folder*)a)->description), "xsd:string");
	soap_out_PointerToint(soap, "count", -1, &(((ns1__Folder*)a)->count), "");
	soap_out_PointerTobool(soap, "hasUnread", -1, &(((ns1__Folder*)a)->hasUnread), "");
	soap_out_PointerToint(soap, "unreadCount", -1, &(((ns1__Folder*)a)->unreadCount), "");
	soap_out_unsignedLong(soap, "sequence", -1, &(((ns1__Folder*)a)->sequence), "");
	soap_out_PointerTons1__uid(soap, "settings", -1, &(((ns1__Folder*)a)->settings), "ns1:uid");
	soap_out_PointerTobool(soap, "hasSubfolders", -1, &(((ns1__Folder*)a)->hasSubfolders), "");
	soap_out_PointerTons1__SharedFolderNotification(soap, "notification", -1, &(((ns1__Folder*)a)->notification), "ns1:SharedFolderNotification");
	/* transient soap skipped */
	soap_out_PointerTons1__Query(soap, "query", -1, &(((ns1__QueryFolder*)a)->query), "ns1:Query");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__QueryFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QueryFolder(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QueryFolder * SOAP_FMAC4 soap_get_ns1__QueryFolder(struct soap *soap, ns1__QueryFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QueryFolder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__QueryFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__QueryFolder(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QueryFolder * SOAP_FMAC4 soap_in_ns1__QueryFolder(struct soap *soap, const char *tag, ns1__QueryFolder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__QueryFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QueryFolder, sizeof(ns1__QueryFolder), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__QueryFolder)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__QueryFolder *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_type3 = 1, soap_flag_parent2 = 1, soap_flag_description2 = 1, soap_flag_count2 = 1, soap_flag_hasUnread2 = 1, soap_flag_unreadCount2 = 1, soap_flag_sequence2 = 1, soap_flag_settings2 = 1, soap_flag_hasSubfolders2 = 1, soap_flag_notification2 = 1, soap_flag_query1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}

			if (soap_flag_name3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name3 = 0;
					continue;
				}

			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}

			if (soap_flag_modified3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}

			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}

			if (soap_flag_type3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_parent2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "parent", &(((ns1__Folder*)a)->parent), "ns1:uid"))
				{	soap_flag_parent2 = 0;
					continue;
				}

			if (soap_flag_description2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "description", &(((ns1__Folder*)a)->description), "xsd:string"))
				{	soap_flag_description2 = 0;
					continue;
				}

			if (soap_flag_count2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "count", &(((ns1__Folder*)a)->count), ""))
				{	soap_flag_count2 = 0;
					continue;
				}

			if (soap_flag_hasUnread2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasUnread", &(((ns1__Folder*)a)->hasUnread), ""))
				{	soap_flag_hasUnread2 = 0;
					continue;
				}

			if (soap_flag_unreadCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "unreadCount", &(((ns1__Folder*)a)->unreadCount), ""))
				{	soap_flag_unreadCount2 = 0;
					continue;
				}

			if (soap_flag_sequence2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "sequence", &(((ns1__Folder*)a)->sequence), ""))
				{	soap_flag_sequence2 = 0;
					continue;
				}

			if (soap_flag_settings2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__uid(soap, "settings", &(((ns1__Folder*)a)->settings), "ns1:uid"))
				{	soap_flag_settings2 = 0;
					continue;
				}

			if (soap_flag_hasSubfolders2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasSubfolders", &(((ns1__Folder*)a)->hasSubfolders), ""))
				{	soap_flag_hasSubfolders2 = 0;
					continue;
				}

			if (soap_flag_notification2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SharedFolderNotification(soap, "notification", &(((ns1__Folder*)a)->notification), "ns1:SharedFolderNotification"))
				{	soap_flag_notification2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_query1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Query(soap, "query", &(((ns1__QueryFolder*)a)->query), "ns1:Query"))
				{	soap_flag_query1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__QueryFolder *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QueryFolder, sizeof(ns1__QueryFolder), soap->type, soap->arrayType), SOAP_TYPE_ns1__QueryFolder, sizeof(ns1__QueryFolder));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__QueryFolder * SOAP_FMAC6 soap_new_ns1__QueryFolder(struct soap *soap, int n)
{	return soap_instantiate_ns1__QueryFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__QueryFolder(struct soap *soap, ns1__QueryFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__QueryFolder * SOAP_FMAC6 soap_instantiate_ns1__QueryFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QueryFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__QueryFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__QueryFolder;
		if (size)
			*size = sizeof(ns1__QueryFolder);
		((ns1__QueryFolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__QueryFolder[n];
		if (size)
			*size = n * sizeof(ns1__QueryFolder);
		for (int i = 0; i < n; i++)
			((ns1__QueryFolder*)cp->ptr)[i].soap = soap;
	}
	return (ns1__QueryFolder*)cp->ptr;
}

void ns1__Query::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Query))
		this->soap_mark(soap);
}

void ns1__Query::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Query*)this)->target, SOAP_TYPE_PointerTons1__QueryTarget);
	soap_mark_PointerTons1__QueryTarget(soap, &((ns1__Query*)this)->target);
	soap_embedded(soap, &((ns1__Query*)this)->filter, SOAP_TYPE_PointerTons1__Filter);
	soap_mark_PointerTons1__Filter(soap, &((ns1__Query*)this)->filter);
	/* transient soap skipped */
}

void ns1__Query::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__QueryTarget(soap, &((ns1__Query*)this)->target);
	soap_default_PointerTons1__Filter(soap, &((ns1__Query*)this)->filter);
	/* transient soap skipped */
}

int ns1__Query::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Query);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Query::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Query(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Query(struct soap *soap, const char *tag, int id, const ns1__Query *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Query), "ns1:Query");
	soap_out_PointerTons1__QueryTarget(soap, "target", -1, &(((ns1__Query*)a)->target), "ns1:QueryTarget");
	soap_out_PointerTons1__Filter(soap, "filter", -1, &(((ns1__Query*)a)->filter), "ns1:Filter");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Query::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Query(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Query * SOAP_FMAC4 soap_get_ns1__Query(struct soap *soap, ns1__Query *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Query(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Query::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Query(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Query * SOAP_FMAC4 soap_in_ns1__Query(struct soap *soap, const char *tag, ns1__Query *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Query *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Query, sizeof(ns1__Query), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Query)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Query *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_target1 = 1, soap_flag_filter1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_target1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__QueryTarget(soap, "target", &(((ns1__Query*)a)->target), "ns1:QueryTarget"))
				{	soap_flag_target1 = 0;
					continue;
				}

			if (soap_flag_filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Filter(soap, "filter", &(((ns1__Query*)a)->filter), "ns1:Filter"))
				{	soap_flag_filter1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Query *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Query, sizeof(ns1__Query), soap->type, soap->arrayType), SOAP_TYPE_ns1__Query, sizeof(ns1__Query));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Query * SOAP_FMAC6 soap_new_ns1__Query(struct soap *soap, int n)
{	return soap_instantiate_ns1__Query(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Query(struct soap *soap, ns1__Query *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Query * SOAP_FMAC6 soap_instantiate_ns1__Query(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Query(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Query, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Query;
		if (size)
			*size = sizeof(ns1__Query);
		((ns1__Query*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Query[n];
		if (size)
			*size = n * sizeof(ns1__Query);
		for (int i = 0; i < n; i++)
			((ns1__Query*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Query*)cp->ptr;
}

void ns1__ProxyList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ProxyList))
		this->soap_mark(soap);
}

void ns1__ProxyList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ProxyList*)this)->proxy, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(soap, &((ns1__ProxyList*)this)->proxy);
	/* transient soap skipped */
}

void ns1__ProxyList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(soap, &((ns1__ProxyList*)this)->proxy);
	/* transient soap skipped */
}

int ns1__ProxyList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ProxyList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ProxyList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ProxyList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProxyList(struct soap *soap, const char *tag, int id, const ns1__ProxyList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProxyList), "ns1:ProxyList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(soap, "proxy", -1, &(((ns1__ProxyList*)a)->proxy), "ns1:NameAndEmail");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ProxyList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ProxyList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ProxyList * SOAP_FMAC4 soap_get_ns1__ProxyList(struct soap *soap, ns1__ProxyList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProxyList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ProxyList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ProxyList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ProxyList * SOAP_FMAC4 soap_in_ns1__ProxyList(struct soap *soap, const char *tag, ns1__ProxyList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ProxyList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProxyList, sizeof(ns1__ProxyList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ProxyList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ProxyList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(soap, "proxy", &(((ns1__ProxyList*)a)->proxy), "ns1:NameAndEmail"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__ProxyList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProxyList, sizeof(ns1__ProxyList), soap->type, soap->arrayType), SOAP_TYPE_ns1__ProxyList, sizeof(ns1__ProxyList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ProxyList * SOAP_FMAC6 soap_new_ns1__ProxyList(struct soap *soap, int n)
{	return soap_instantiate_ns1__ProxyList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ProxyList(struct soap *soap, ns1__ProxyList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ProxyList * SOAP_FMAC6 soap_instantiate_ns1__ProxyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ProxyList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ProxyList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ProxyList;
		if (size)
			*size = sizeof(ns1__ProxyList);
		((ns1__ProxyList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ProxyList[n];
		if (size)
			*size = n * sizeof(ns1__ProxyList);
		for (int i = 0; i < n; i++)
			((ns1__ProxyList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ProxyList*)cp->ptr;
}

void ns1__Proxy::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Proxy))
		this->soap_mark(soap);
}

void ns1__Proxy::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Proxy*)this)->username, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Proxy*)this)->username);
	soap_embedded(soap, &((ns1__Proxy*)this)->proxy, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Proxy*)this)->proxy);
	/* transient soap skipped */
	/* transient soap skipped */
}

void ns1__Proxy::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__Proxy*)this)->username);
	soap_default_std__string(soap, &((ns1__Proxy*)this)->proxy);
	/* transient soap skipped */
	/* transient soap skipped */
}

int ns1__Proxy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Proxy);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Proxy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Proxy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Proxy(struct soap *soap, const char *tag, int id, const ns1__Proxy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Proxy), "ns1:Proxy");
	/* transient soap skipped */
	soap_out_std__string(soap, "username", -1, &(((ns1__Proxy*)a)->username), "xsd:string");
	soap_out_std__string(soap, "proxy", -1, &(((ns1__Proxy*)a)->proxy), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Proxy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Proxy(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Proxy * SOAP_FMAC4 soap_get_ns1__Proxy(struct soap *soap, ns1__Proxy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Proxy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Proxy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Proxy(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Proxy * SOAP_FMAC4 soap_in_ns1__Proxy(struct soap *soap, const char *tag, ns1__Proxy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Proxy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Proxy, sizeof(ns1__Proxy), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Proxy)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Proxy *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_username1 = 1, soap_flag_proxy1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			/* transient soap skipped */
			if (soap_flag_username1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "username", &(((ns1__Proxy*)a)->username), "xsd:string"))
				{	soap_flag_username1 = 0;
					continue;
				}

			if (soap_flag_proxy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "proxy", &(((ns1__Proxy*)a)->proxy), "xsd:string"))
				{	soap_flag_proxy1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_username1 || soap_flag_proxy1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__Proxy *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Proxy, sizeof(ns1__Proxy), soap->type, soap->arrayType), SOAP_TYPE_ns1__Proxy, sizeof(ns1__Proxy));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Proxy * SOAP_FMAC6 soap_new_ns1__Proxy(struct soap *soap, int n)
{	return soap_instantiate_ns1__Proxy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Proxy(struct soap *soap, ns1__Proxy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Proxy * SOAP_FMAC6 soap_instantiate_ns1__Proxy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Proxy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Proxy, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Proxy;
		if (size)
			*size = sizeof(ns1__Proxy);
		((ns1__Proxy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Proxy[n];
		if (size)
			*size = n * sizeof(ns1__Proxy);
		for (int i = 0; i < n; i++)
			((ns1__Proxy*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Proxy*)cp->ptr;
}

void ns1__ProblemList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ProblemList))
		this->soap_mark(soap);
}

void ns1__ProblemList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ProblemList*)this)->entry, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(soap, &((ns1__ProblemList*)this)->entry);
	/* transient soap skipped */
}

void ns1__ProblemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(soap, &((ns1__ProblemList*)this)->entry);
	/* transient soap skipped */
}

int ns1__ProblemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ProblemList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ProblemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ProblemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProblemList(struct soap *soap, const char *tag, int id, const ns1__ProblemList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProblemList), "ns1:ProblemList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(soap, "entry", -1, &(((ns1__ProblemList*)a)->entry), "ns1:ProblemEntry");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ProblemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ProblemList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ProblemList * SOAP_FMAC4 soap_get_ns1__ProblemList(struct soap *soap, ns1__ProblemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProblemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ProblemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ProblemList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ProblemList * SOAP_FMAC4 soap_in_ns1__ProblemList(struct soap *soap, const char *tag, ns1__ProblemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ProblemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProblemList, sizeof(ns1__ProblemList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ProblemList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ProblemList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(soap, "entry", &(((ns1__ProblemList*)a)->entry), "ns1:ProblemEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__ProblemList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProblemList, sizeof(ns1__ProblemList), soap->type, soap->arrayType), SOAP_TYPE_ns1__ProblemList, sizeof(ns1__ProblemList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ProblemList * SOAP_FMAC6 soap_new_ns1__ProblemList(struct soap *soap, int n)
{	return soap_instantiate_ns1__ProblemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ProblemList(struct soap *soap, ns1__ProblemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ProblemList * SOAP_FMAC6 soap_instantiate_ns1__ProblemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ProblemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ProblemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ProblemList;
		if (size)
			*size = sizeof(ns1__ProblemList);
		((ns1__ProblemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ProblemList[n];
		if (size)
			*size = n * sizeof(ns1__ProblemList);
		for (int i = 0; i < n; i++)
			((ns1__ProblemList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ProblemList*)cp->ptr;
}

void ns1__ProblemEntry::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ProblemEntry))
		this->soap_mark(soap);
}

void ns1__ProblemEntry::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ProblemEntry*)this)->element, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__ProblemEntry*)this)->element);
	soap_embedded(soap, &((ns1__ProblemEntry*)this)->code, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__ProblemEntry*)this)->description, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__ProblemEntry*)this)->description);
	/* transient soap skipped */
}

void ns1__ProblemEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__string(soap, &((ns1__ProblemEntry*)this)->element);
	soap_default_int(soap, &((ns1__ProblemEntry*)this)->code);
	soap_default_std__string(soap, &((ns1__ProblemEntry*)this)->description);
	/* transient soap skipped */
}

int ns1__ProblemEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ProblemEntry);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ProblemEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ProblemEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProblemEntry(struct soap *soap, const char *tag, int id, const ns1__ProblemEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProblemEntry), "ns1:ProblemEntry");
	soap_out_PointerTostd__string(soap, "element", -1, &(((ns1__ProblemEntry*)a)->element), "xsd:string");
	soap_out_int(soap, "code", -1, &(((ns1__ProblemEntry*)a)->code), "");
	soap_out_std__string(soap, "description", -1, &(((ns1__ProblemEntry*)a)->description), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ProblemEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ProblemEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ProblemEntry * SOAP_FMAC4 soap_get_ns1__ProblemEntry(struct soap *soap, ns1__ProblemEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProblemEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ProblemEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ProblemEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ProblemEntry * SOAP_FMAC4 soap_in_ns1__ProblemEntry(struct soap *soap, const char *tag, ns1__ProblemEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ProblemEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProblemEntry, sizeof(ns1__ProblemEntry), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ProblemEntry)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ProblemEntry *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_element1 = 1, soap_flag_code1 = 1, soap_flag_description1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_element1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "element", &(((ns1__ProblemEntry*)a)->element), "xsd:string"))
				{	soap_flag_element1 = 0;
					continue;
				}

			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "code", &(((ns1__ProblemEntry*)a)->code), ""))
				{	soap_flag_code1 = 0;
					continue;
				}

			if (soap_flag_description1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "description", &(((ns1__ProblemEntry*)a)->description), "xsd:string"))
				{	soap_flag_description1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__ProblemEntry *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProblemEntry, sizeof(ns1__ProblemEntry), soap->type, soap->arrayType), SOAP_TYPE_ns1__ProblemEntry, sizeof(ns1__ProblemEntry));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ProblemEntry * SOAP_FMAC6 soap_new_ns1__ProblemEntry(struct soap *soap, int n)
{	return soap_instantiate_ns1__ProblemEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ProblemEntry(struct soap *soap, ns1__ProblemEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ProblemEntry * SOAP_FMAC6 soap_instantiate_ns1__ProblemEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ProblemEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ProblemEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ProblemEntry;
		if (size)
			*size = sizeof(ns1__ProblemEntry);
		((ns1__ProblemEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ProblemEntry[n];
		if (size)
			*size = n * sizeof(ns1__ProblemEntry);
		for (int i = 0; i < n; i++)
			((ns1__ProblemEntry*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ProblemEntry*)cp->ptr;
}

void ns1__PostalAddressList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__PostalAddressList))
		this->soap_mark(soap);
}

void ns1__PostalAddressList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__PostalAddressList*)this)->address, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(soap, &((ns1__PostalAddressList*)this)->address);
	/* transient soap skipped */
}

void ns1__PostalAddressList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(soap, &((ns1__PostalAddressList*)this)->address);
	/* transient soap skipped */
}

int ns1__PostalAddressList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__PostalAddressList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__PostalAddressList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PostalAddressList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PostalAddressList(struct soap *soap, const char *tag, int id, const ns1__PostalAddressList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PostalAddressList), "ns1:PostalAddressList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(soap, "address", -1, &(((ns1__PostalAddressList*)a)->address), "ns1:PostalAddress");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__PostalAddressList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PostalAddressList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PostalAddressList * SOAP_FMAC4 soap_get_ns1__PostalAddressList(struct soap *soap, ns1__PostalAddressList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PostalAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__PostalAddressList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PostalAddressList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PostalAddressList * SOAP_FMAC4 soap_in_ns1__PostalAddressList(struct soap *soap, const char *tag, ns1__PostalAddressList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__PostalAddressList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PostalAddressList, sizeof(ns1__PostalAddressList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__PostalAddressList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__PostalAddressList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(soap, "address", &(((ns1__PostalAddressList*)a)->address), "ns1:PostalAddress"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__PostalAddressList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PostalAddressList, sizeof(ns1__PostalAddressList), soap->type, soap->arrayType), SOAP_TYPE_ns1__PostalAddressList, sizeof(ns1__PostalAddressList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PostalAddressList * SOAP_FMAC6 soap_new_ns1__PostalAddressList(struct soap *soap, int n)
{	return soap_instantiate_ns1__PostalAddressList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PostalAddressList(struct soap *soap, ns1__PostalAddressList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__PostalAddressList * SOAP_FMAC6 soap_instantiate_ns1__PostalAddressList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PostalAddressList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PostalAddressList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PostalAddressList;
		if (size)
			*size = sizeof(ns1__PostalAddressList);
		((ns1__PostalAddressList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PostalAddressList[n];
		if (size)
			*size = n * sizeof(ns1__PostalAddressList);
		for (int i = 0; i < n; i++)
			((ns1__PostalAddressList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__PostalAddressList*)cp->ptr;
}

void ns1__PostalAddress::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__PostalAddress))
		this->soap_mark(soap);
}

void ns1__PostalAddress::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__PostalAddress*)this)->description, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__PostalAddress*)this)->description);
	soap_embedded(soap, &((ns1__PostalAddress*)this)->streetAddress, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->streetAddress);
	soap_embedded(soap, &((ns1__PostalAddress*)this)->location, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->location);
	soap_embedded(soap, &((ns1__PostalAddress*)this)->city, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->city);
	soap_embedded(soap, &((ns1__PostalAddress*)this)->state, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->state);
	soap_embedded(soap, &((ns1__PostalAddress*)this)->postalCode, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->postalCode);
	soap_embedded(soap, &((ns1__PostalAddress*)this)->country, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->country);
	/* transient soap skipped */
}

void ns1__PostalAddress::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__PostalAddress*)this)->description);
	soap_default_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->streetAddress);
	soap_default_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->location);
	soap_default_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->city);
	soap_default_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->state);
	soap_default_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->postalCode);
	soap_default_PointerTostd__string(soap, &((ns1__PostalAddress*)this)->country);
	soap_default_ns1__PostalAddressType(soap, &((ns1__PostalAddress*)this)->type);
	/* transient soap skipped */
}

int ns1__PostalAddress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__PostalAddress);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__PostalAddress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PostalAddress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PostalAddress(struct soap *soap, const char *tag, int id, const ns1__PostalAddress *a, const char *type)
{
	soap_set_attr(soap, "type", soap_ns1__PostalAddressType2s(soap, ((ns1__PostalAddress *)a)->type));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PostalAddress), "ns1:PostalAddress");
	soap_out_std__string(soap, "description", -1, &(((ns1__PostalAddress*)a)->description), "xsd:string");
	soap_out_PointerTostd__string(soap, "streetAddress", -1, &(((ns1__PostalAddress*)a)->streetAddress), "xsd:string");
	soap_out_PointerTostd__string(soap, "location", -1, &(((ns1__PostalAddress*)a)->location), "xsd:string");
	soap_out_PointerTostd__string(soap, "city", -1, &(((ns1__PostalAddress*)a)->city), "xsd:string");
	soap_out_PointerTostd__string(soap, "state", -1, &(((ns1__PostalAddress*)a)->state), "xsd:string");
	soap_out_PointerTostd__string(soap, "postalCode", -1, &(((ns1__PostalAddress*)a)->postalCode), "xsd:string");
	soap_out_PointerTostd__string(soap, "country", -1, &(((ns1__PostalAddress*)a)->country), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__PostalAddress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PostalAddress(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PostalAddress * SOAP_FMAC4 soap_get_ns1__PostalAddress(struct soap *soap, ns1__PostalAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PostalAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__PostalAddress::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PostalAddress(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PostalAddress * SOAP_FMAC4 soap_in_ns1__PostalAddress(struct soap *soap, const char *tag, ns1__PostalAddress *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__PostalAddress *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PostalAddress, sizeof(ns1__PostalAddress), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__PostalAddress)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__PostalAddress *)a->soap_in(soap, tag, type);
			}
		}
		if (soap_s2ns1__PostalAddressType(soap, soap_attr_value(soap, "type"), &((ns1__PostalAddress *)a)->type))
			return NULL;
		else if (soap->mode & SOAP_XML_STRICT)
		{	soap->error = SOAP_REQUIRED;
			return NULL;
		}
		short soap_flag_description1 = 1, soap_flag_streetAddress1 = 1, soap_flag_location1 = 1, soap_flag_city1 = 1, soap_flag_state1 = 1, soap_flag_postalCode1 = 1, soap_flag_country1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_description1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "description", &(((ns1__PostalAddress*)a)->description), "xsd:string"))
				{	soap_flag_description1 = 0;
					continue;
				}

			if (soap_flag_streetAddress1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "streetAddress", &(((ns1__PostalAddress*)a)->streetAddress), "xsd:string"))
				{	soap_flag_streetAddress1 = 0;
					continue;
				}

			if (soap_flag_location1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "location", &(((ns1__PostalAddress*)a)->location), "xsd:string"))
				{	soap_flag_location1 = 0;
					continue;
				}

			if (soap_flag_city1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "city", &(((ns1__PostalAddress*)a)->city), "xsd:string"))
				{	soap_flag_city1 = 0;
					continue;
				}

			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "state", &(((ns1__PostalAddress*)a)->state), "xsd:string"))
				{	soap_flag_state1 = 0;
					continue;
				}

			if (soap_flag_postalCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "postalCode", &(((ns1__PostalAddress*)a)->postalCode), "xsd:string"))
				{	soap_flag_postalCode1 = 0;
					continue;
				}

			if (soap_flag_country1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "country", &(((ns1__PostalAddress*)a)->country), "xsd:string"))
				{	soap_flag_country1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__PostalAddress *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PostalAddress, sizeof(ns1__PostalAddress), soap->type, soap->arrayType), SOAP_TYPE_ns1__PostalAddress, sizeof(ns1__PostalAddress));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PostalAddress * SOAP_FMAC6 soap_new_ns1__PostalAddress(struct soap *soap, int n)
{	return soap_instantiate_ns1__PostalAddress(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PostalAddress(struct soap *soap, ns1__PostalAddress *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__PostalAddress * SOAP_FMAC6 soap_instantiate_ns1__PostalAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PostalAddress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PostalAddress, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PostalAddress;
		if (size)
			*size = sizeof(ns1__PostalAddress);
		((ns1__PostalAddress*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PostalAddress[n];
		if (size)
			*size = n * sizeof(ns1__PostalAddress);
		for (int i = 0; i < n; i++)
			((ns1__PostalAddress*)cp->ptr)[i].soap = soap;
	}
	return (ns1__PostalAddress*)cp->ptr;
}

void ns1__PlainText::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__PlainText))
		this->soap_mark(soap);
}

void ns1__PlainText::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__PlainText*)this)->username, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__PlainText*)this)->username);
	soap_embedded(soap, &((ns1__PlainText*)this)->password, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__PlainText*)this)->password);
	/* transient soap skipped */
	/* transient soap skipped */
}

void ns1__PlainText::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__PlainText*)this)->username);
	soap_default_PointerTostd__string(soap, &((ns1__PlainText*)this)->password);
	/* transient soap skipped */
	/* transient soap skipped */
}

int ns1__PlainText::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__PlainText);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__PlainText::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PlainText(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PlainText(struct soap *soap, const char *tag, int id, const ns1__PlainText *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PlainText), "ns1:PlainText");
	/* transient soap skipped */
	soap_out_std__string(soap, "username", -1, &(((ns1__PlainText*)a)->username), "xsd:string");
	soap_out_PointerTostd__string(soap, "password", -1, &(((ns1__PlainText*)a)->password), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__PlainText::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PlainText(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PlainText * SOAP_FMAC4 soap_get_ns1__PlainText(struct soap *soap, ns1__PlainText *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PlainText(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__PlainText::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PlainText(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PlainText * SOAP_FMAC4 soap_in_ns1__PlainText(struct soap *soap, const char *tag, ns1__PlainText *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__PlainText *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PlainText, sizeof(ns1__PlainText), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__PlainText)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__PlainText *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_username1 = 1, soap_flag_password1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			/* transient soap skipped */
			if (soap_flag_username1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "username", &(((ns1__PlainText*)a)->username), "xsd:string"))
				{	soap_flag_username1 = 0;
					continue;
				}

			if (soap_flag_password1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "password", &(((ns1__PlainText*)a)->password), "xsd:string"))
				{	soap_flag_password1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_username1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__PlainText *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PlainText, sizeof(ns1__PlainText), soap->type, soap->arrayType), SOAP_TYPE_ns1__PlainText, sizeof(ns1__PlainText));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PlainText * SOAP_FMAC6 soap_new_ns1__PlainText(struct soap *soap, int n)
{	return soap_instantiate_ns1__PlainText(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PlainText(struct soap *soap, ns1__PlainText *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__PlainText * SOAP_FMAC6 soap_instantiate_ns1__PlainText(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PlainText(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PlainText, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PlainText;
		if (size)
			*size = sizeof(ns1__PlainText);
		((ns1__PlainText*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PlainText[n];
		if (size)
			*size = n * sizeof(ns1__PlainText);
		for (int i = 0; i < n; i++)
			((ns1__PlainText*)cp->ptr)[i].soap = soap;
	}
	return (ns1__PlainText*)cp->ptr;
}

void ns1__PhoneMessage::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__PhoneMessage))
		this->soap_mark(soap);
}

void ns1__PhoneMessage::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__PhoneMessage*)this)->caller, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__PhoneMessage*)this)->caller);
	soap_embedded(soap, &((ns1__PhoneMessage*)this)->company, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__PhoneMessage*)this)->company);
	soap_embedded(soap, &((ns1__PhoneMessage*)this)->phone, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__PhoneMessage*)this)->phone);
	soap_embedded(soap, &((ns1__PhoneMessage*)this)->flags, SOAP_TYPE_PointerTons1__PhoneFlags);
	soap_mark_PointerTons1__PhoneFlags(soap, &((ns1__PhoneMessage*)this)->flags);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Mail*)this)->subject, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_embedded(soap, &((ns1__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ns1__Mail*)this)->distribution, SOAP_TYPE_PointerTons1__Distribution);
	soap_mark_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_embedded(soap, &((ns1__Mail*)this)->message, SOAP_TYPE_PointerTons1__MessageBody);
	soap_mark_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_embedded(soap, &((ns1__Mail*)this)->attachments, SOAP_TYPE_PointerTons1__AttachmentInfo);
	soap_mark_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_embedded(soap, &((ns1__Mail*)this)->options, SOAP_TYPE_PointerTons1__ItemOptions);
	soap_mark_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__BoxEntry*)this)->status, SOAP_TYPE_PointerTons1__ItemStatus);
	soap_mark_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->msgid, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->source, SOAP_TYPE_PointerTons1__ItemSource);
	soap_mark_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->class_, SOAP_TYPE_PointerTons1__ItemClass);
	soap_mark_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__PhoneMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__string(soap, &((ns1__PhoneMessage*)this)->caller);
	soap_default_PointerTostd__string(soap, &((ns1__PhoneMessage*)this)->company);
	soap_default_PointerTostd__string(soap, &((ns1__PhoneMessage*)this)->phone);
	soap_default_PointerTons1__PhoneFlags(soap, &((ns1__PhoneMessage*)this)->flags);
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_default_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_default_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_default_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_default_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_default_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_default_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_default_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_default_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_default_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__PhoneMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__PhoneMessage);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__PhoneMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PhoneMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PhoneMessage(struct soap *soap, const char *tag, int id, const ns1__PhoneMessage *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PhoneMessage), "ns1:PhoneMessage");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_PointerTons1__ItemStatus(soap, "status", -1, &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus");
	soap_out_PointerTostd__string(soap, "thread", -1, &(((ns1__BoxEntry*)a)->thread), "xsd:string");
	soap_out_PointerTostd__string(soap, "msgid", -1, &(((ns1__BoxEntry*)a)->msgid), "xsd:string");
	soap_out_PointerTons1__ItemSource(soap, "source", -1, &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource");
	soap_out_string(soap, "delivered", -1, &(((ns1__BoxEntry*)a)->delivered), "");
	soap_out_PointerTons1__ItemClass(soap, "class", -1, &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass");
	/* transient soap skipped */
	soap_out_std__string(soap, "subject", -1, &(((ns1__Mail*)a)->subject), "xsd:string");
	soap_out_PointerTostd__string(soap, "originalSubject", -1, &(((ns1__Mail*)a)->originalSubject), "xsd:string");
	soap_out_PointerTons1__Distribution(soap, "distribution", -1, &(((ns1__Mail*)a)->distribution), "ns1:Distribution");
	soap_out_PointerTons1__MessageBody(soap, "message", -1, &(((ns1__Mail*)a)->message), "ns1:MessageBody");
	soap_out_PointerTons1__AttachmentInfo(soap, "attachments", -1, &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo");
	soap_out_PointerTons1__ItemOptions(soap, "options", -1, &(((ns1__Mail*)a)->options), "ns1:ItemOptions");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "caller", -1, &(((ns1__PhoneMessage*)a)->caller), "xsd:string");
	soap_out_PointerTostd__string(soap, "company", -1, &(((ns1__PhoneMessage*)a)->company), "xsd:string");
	soap_out_PointerTostd__string(soap, "phone", -1, &(((ns1__PhoneMessage*)a)->phone), "xsd:string");
	soap_out_PointerTons1__PhoneFlags(soap, "flags", -1, &(((ns1__PhoneMessage*)a)->flags), "ns1:PhoneFlags");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__PhoneMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PhoneMessage(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PhoneMessage * SOAP_FMAC4 soap_get_ns1__PhoneMessage(struct soap *soap, ns1__PhoneMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PhoneMessage(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__PhoneMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PhoneMessage(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PhoneMessage * SOAP_FMAC4 soap_in_ns1__PhoneMessage(struct soap *soap, const char *tag, ns1__PhoneMessage *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__PhoneMessage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PhoneMessage, sizeof(ns1__PhoneMessage), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__PhoneMessage)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__PhoneMessage *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id5 = 1, soap_flag_name5 = 1, soap_flag_version5 = 1, soap_flag_modified5 = 1, soap_flag_changes5 = 1, soap_flag_type5 = 1, soap_flag_categories4 = 1, soap_flag_created4 = 1, soap_flag_customs4 = 1, soap_flag_status3 = 1, soap_flag_thread3 = 1, soap_flag_msgid3 = 1, soap_flag_source3 = 1, soap_flag_delivered3 = 1, soap_flag_class_3 = 1, soap_flag_subject2 = 1, soap_flag_originalSubject2 = 1, soap_flag_distribution2 = 1, soap_flag_message2 = 1, soap_flag_attachments2 = 1, soap_flag_options2 = 1, soap_flag_caller1 = 1, soap_flag_company1 = 1, soap_flag_phone1 = 1, soap_flag_flags1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id5 = 0;
					continue;
				}

			if (soap_flag_name5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name5 = 0;
					continue;
				}

			if (soap_flag_version5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version5 = 0;
					continue;
				}

			if (soap_flag_modified5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified5 = 0;
					continue;
				}

			if (soap_flag_changes5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes5 = 0;
					continue;
				}

			if (soap_flag_type5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type5 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories4 = 0;
					continue;
				}

			if (soap_flag_created4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created4 = 0;
					continue;
				}

			if (soap_flag_customs4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemStatus(soap, "status", &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus"))
				{	soap_flag_status3 = 0;
					continue;
				}

			if (soap_flag_thread3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "thread", &(((ns1__BoxEntry*)a)->thread), "xsd:string"))
				{	soap_flag_thread3 = 0;
					continue;
				}

			if (soap_flag_msgid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "msgid", &(((ns1__BoxEntry*)a)->msgid), "xsd:string"))
				{	soap_flag_msgid3 = 0;
					continue;
				}

			if (soap_flag_source3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemSource(soap, "source", &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource"))
				{	soap_flag_source3 = 0;
					continue;
				}

			if (soap_flag_delivered3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "delivered", &(((ns1__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered3 = 0;
					continue;
				}

			if (soap_flag_class_3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemClass(soap, "class", &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass"))
				{	soap_flag_class_3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_subject2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "subject", &(((ns1__Mail*)a)->subject), "xsd:string"))
				{	soap_flag_subject2 = 0;
					continue;
				}

			if (soap_flag_originalSubject2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "originalSubject", &(((ns1__Mail*)a)->originalSubject), "xsd:string"))
				{	soap_flag_originalSubject2 = 0;
					continue;
				}

			if (soap_flag_distribution2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Distribution(soap, "distribution", &(((ns1__Mail*)a)->distribution), "ns1:Distribution"))
				{	soap_flag_distribution2 = 0;
					continue;
				}

			if (soap_flag_message2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MessageBody(soap, "message", &(((ns1__Mail*)a)->message), "ns1:MessageBody"))
				{	soap_flag_message2 = 0;
					continue;
				}

			if (soap_flag_attachments2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AttachmentInfo(soap, "attachments", &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo"))
				{	soap_flag_attachments2 = 0;
					continue;
				}

			if (soap_flag_options2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemOptions(soap, "options", &(((ns1__Mail*)a)->options), "ns1:ItemOptions"))
				{	soap_flag_options2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_caller1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "caller", &(((ns1__PhoneMessage*)a)->caller), "xsd:string"))
				{	soap_flag_caller1 = 0;
					continue;
				}

			if (soap_flag_company1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "company", &(((ns1__PhoneMessage*)a)->company), "xsd:string"))
				{	soap_flag_company1 = 0;
					continue;
				}

			if (soap_flag_phone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "phone", &(((ns1__PhoneMessage*)a)->phone), "xsd:string"))
				{	soap_flag_phone1 = 0;
					continue;
				}

			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PhoneFlags(soap, "flags", &(((ns1__PhoneMessage*)a)->flags), "ns1:PhoneFlags"))
				{	soap_flag_flags1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_subject2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__PhoneMessage *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PhoneMessage, sizeof(ns1__PhoneMessage), soap->type, soap->arrayType), SOAP_TYPE_ns1__PhoneMessage, sizeof(ns1__PhoneMessage));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PhoneMessage * SOAP_FMAC6 soap_new_ns1__PhoneMessage(struct soap *soap, int n)
{	return soap_instantiate_ns1__PhoneMessage(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PhoneMessage(struct soap *soap, ns1__PhoneMessage *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__PhoneMessage * SOAP_FMAC6 soap_instantiate_ns1__PhoneMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PhoneMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PhoneMessage, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PhoneMessage;
		if (size)
			*size = sizeof(ns1__PhoneMessage);
		((ns1__PhoneMessage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PhoneMessage[n];
		if (size)
			*size = n * sizeof(ns1__PhoneMessage);
		for (int i = 0; i < n; i++)
			((ns1__PhoneMessage*)cp->ptr)[i].soap = soap;
	}
	return (ns1__PhoneMessage*)cp->ptr;
}

void ns1__PhoneFlags::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__PhoneFlags))
		this->soap_mark(soap);
}

void ns1__PhoneFlags::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__PhoneFlags*)this)->called, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__PhoneFlags*)this)->called);
	soap_embedded(soap, &((ns1__PhoneFlags*)this)->pleaseCall, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__PhoneFlags*)this)->pleaseCall);
	soap_embedded(soap, &((ns1__PhoneFlags*)this)->willCall, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__PhoneFlags*)this)->willCall);
	soap_embedded(soap, &((ns1__PhoneFlags*)this)->returnedYourCall, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__PhoneFlags*)this)->returnedYourCall);
	soap_embedded(soap, &((ns1__PhoneFlags*)this)->wantsToSeeYou, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__PhoneFlags*)this)->wantsToSeeYou);
	soap_embedded(soap, &((ns1__PhoneFlags*)this)->cameToSeeYou, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__PhoneFlags*)this)->cameToSeeYou);
	soap_embedded(soap, &((ns1__PhoneFlags*)this)->urgent, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__PhoneFlags*)this)->urgent);
	/* transient soap skipped */
}

void ns1__PhoneFlags::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTobool(soap, &((ns1__PhoneFlags*)this)->called);
	soap_default_PointerTobool(soap, &((ns1__PhoneFlags*)this)->pleaseCall);
	soap_default_PointerTobool(soap, &((ns1__PhoneFlags*)this)->willCall);
	soap_default_PointerTobool(soap, &((ns1__PhoneFlags*)this)->returnedYourCall);
	soap_default_PointerTobool(soap, &((ns1__PhoneFlags*)this)->wantsToSeeYou);
	soap_default_PointerTobool(soap, &((ns1__PhoneFlags*)this)->cameToSeeYou);
	soap_default_PointerTobool(soap, &((ns1__PhoneFlags*)this)->urgent);
	/* transient soap skipped */
}

int ns1__PhoneFlags::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__PhoneFlags);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__PhoneFlags::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PhoneFlags(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PhoneFlags(struct soap *soap, const char *tag, int id, const ns1__PhoneFlags *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PhoneFlags), "ns1:PhoneFlags");
	soap_out_PointerTobool(soap, "called", -1, &(((ns1__PhoneFlags*)a)->called), "");
	soap_out_PointerTobool(soap, "pleaseCall", -1, &(((ns1__PhoneFlags*)a)->pleaseCall), "");
	soap_out_PointerTobool(soap, "willCall", -1, &(((ns1__PhoneFlags*)a)->willCall), "");
	soap_out_PointerTobool(soap, "returnedYourCall", -1, &(((ns1__PhoneFlags*)a)->returnedYourCall), "");
	soap_out_PointerTobool(soap, "wantsToSeeYou", -1, &(((ns1__PhoneFlags*)a)->wantsToSeeYou), "");
	soap_out_PointerTobool(soap, "cameToSeeYou", -1, &(((ns1__PhoneFlags*)a)->cameToSeeYou), "");
	soap_out_PointerTobool(soap, "urgent", -1, &(((ns1__PhoneFlags*)a)->urgent), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__PhoneFlags::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PhoneFlags(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PhoneFlags * SOAP_FMAC4 soap_get_ns1__PhoneFlags(struct soap *soap, ns1__PhoneFlags *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PhoneFlags(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__PhoneFlags::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PhoneFlags(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PhoneFlags * SOAP_FMAC4 soap_in_ns1__PhoneFlags(struct soap *soap, const char *tag, ns1__PhoneFlags *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__PhoneFlags *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PhoneFlags, sizeof(ns1__PhoneFlags), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__PhoneFlags)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__PhoneFlags *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_called1 = 1, soap_flag_pleaseCall1 = 1, soap_flag_willCall1 = 1, soap_flag_returnedYourCall1 = 1, soap_flag_wantsToSeeYou1 = 1, soap_flag_cameToSeeYou1 = 1, soap_flag_urgent1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_called1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "called", &(((ns1__PhoneFlags*)a)->called), ""))
				{	soap_flag_called1 = 0;
					continue;
				}

			if (soap_flag_pleaseCall1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "pleaseCall", &(((ns1__PhoneFlags*)a)->pleaseCall), ""))
				{	soap_flag_pleaseCall1 = 0;
					continue;
				}

			if (soap_flag_willCall1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "willCall", &(((ns1__PhoneFlags*)a)->willCall), ""))
				{	soap_flag_willCall1 = 0;
					continue;
				}

			if (soap_flag_returnedYourCall1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "returnedYourCall", &(((ns1__PhoneFlags*)a)->returnedYourCall), ""))
				{	soap_flag_returnedYourCall1 = 0;
					continue;
				}

			if (soap_flag_wantsToSeeYou1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "wantsToSeeYou", &(((ns1__PhoneFlags*)a)->wantsToSeeYou), ""))
				{	soap_flag_wantsToSeeYou1 = 0;
					continue;
				}

			if (soap_flag_cameToSeeYou1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "cameToSeeYou", &(((ns1__PhoneFlags*)a)->cameToSeeYou), ""))
				{	soap_flag_cameToSeeYou1 = 0;
					continue;
				}

			if (soap_flag_urgent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "urgent", &(((ns1__PhoneFlags*)a)->urgent), ""))
				{	soap_flag_urgent1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__PhoneFlags *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PhoneFlags, sizeof(ns1__PhoneFlags), soap->type, soap->arrayType), SOAP_TYPE_ns1__PhoneFlags, sizeof(ns1__PhoneFlags));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PhoneFlags * SOAP_FMAC6 soap_new_ns1__PhoneFlags(struct soap *soap, int n)
{	return soap_instantiate_ns1__PhoneFlags(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PhoneFlags(struct soap *soap, ns1__PhoneFlags *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__PhoneFlags * SOAP_FMAC6 soap_instantiate_ns1__PhoneFlags(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PhoneFlags(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PhoneFlags, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PhoneFlags;
		if (size)
			*size = sizeof(ns1__PhoneFlags);
		((ns1__PhoneFlags*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PhoneFlags[n];
		if (size)
			*size = n * sizeof(ns1__PhoneFlags);
		for (int i = 0; i < n; i++)
			((ns1__PhoneFlags*)cp->ptr)[i].soap = soap;
	}
	return (ns1__PhoneFlags*)cp->ptr;
}

void ns1__PersonalInfo::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__PersonalInfo))
		this->soap_mark(soap);
}

void ns1__PersonalInfo::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__PersonalInfo*)this)->birthday, SOAP_TYPE_xsd__date);
	soap_mark_xsd__date(soap, &((ns1__PersonalInfo*)this)->birthday);
	soap_embedded(soap, &((ns1__PersonalInfo*)this)->website, SOAP_TYPE_xsd__anyURI);
	soap_mark_xsd__anyURI(soap, &((ns1__PersonalInfo*)this)->website);
	/* transient soap skipped */
}

void ns1__PersonalInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__date(soap, &((ns1__PersonalInfo*)this)->birthday);
	soap_default_xsd__anyURI(soap, &((ns1__PersonalInfo*)this)->website);
	/* transient soap skipped */
}

int ns1__PersonalInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__PersonalInfo);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__PersonalInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PersonalInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PersonalInfo(struct soap *soap, const char *tag, int id, const ns1__PersonalInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PersonalInfo), "ns1:PersonalInfo");
	soap_out_xsd__date(soap, "birthday", -1, &(((ns1__PersonalInfo*)a)->birthday), "xsd:date");
	soap_out_xsd__anyURI(soap, "website", -1, &(((ns1__PersonalInfo*)a)->website), "xsd:anyURI");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__PersonalInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PersonalInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PersonalInfo * SOAP_FMAC4 soap_get_ns1__PersonalInfo(struct soap *soap, ns1__PersonalInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PersonalInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__PersonalInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PersonalInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PersonalInfo * SOAP_FMAC4 soap_in_ns1__PersonalInfo(struct soap *soap, const char *tag, ns1__PersonalInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__PersonalInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PersonalInfo, sizeof(ns1__PersonalInfo), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__PersonalInfo)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__PersonalInfo *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_birthday1 = 1, soap_flag_website1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_birthday1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__date(soap, "birthday", &(((ns1__PersonalInfo*)a)->birthday), "xsd:date"))
				{	soap_flag_birthday1 = 0;
					continue;
				}

			if (soap_flag_website1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyURI(soap, "website", &(((ns1__PersonalInfo*)a)->website), "xsd:anyURI"))
				{	soap_flag_website1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__PersonalInfo *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PersonalInfo, sizeof(ns1__PersonalInfo), soap->type, soap->arrayType), SOAP_TYPE_ns1__PersonalInfo, sizeof(ns1__PersonalInfo));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PersonalInfo * SOAP_FMAC6 soap_new_ns1__PersonalInfo(struct soap *soap, int n)
{	return soap_instantiate_ns1__PersonalInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PersonalInfo(struct soap *soap, ns1__PersonalInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__PersonalInfo * SOAP_FMAC6 soap_instantiate_ns1__PersonalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PersonalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PersonalInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PersonalInfo;
		if (size)
			*size = sizeof(ns1__PersonalInfo);
		((ns1__PersonalInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PersonalInfo[n];
		if (size)
			*size = n * sizeof(ns1__PersonalInfo);
		for (int i = 0; i < n; i++)
			((ns1__PersonalInfo*)cp->ptr)[i].soap = soap;
	}
	return (ns1__PersonalInfo*)cp->ptr;
}

void ns1__Organization::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Organization))
		this->soap_mark(soap);
}

void ns1__Organization::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Organization*)this)->contact, SOAP_TYPE_PointerTons1__ItemRef);
	soap_mark_PointerTons1__ItemRef(soap, &((ns1__Organization*)this)->contact);
	soap_embedded(soap, &((ns1__Organization*)this)->phone, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Organization*)this)->phone);
	soap_embedded(soap, &((ns1__Organization*)this)->fax, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Organization*)this)->fax);
	soap_embedded(soap, &((ns1__Organization*)this)->address, SOAP_TYPE_PointerTons1__PostalAddress);
	soap_mark_PointerTons1__PostalAddress(soap, &((ns1__Organization*)this)->address);
	soap_embedded(soap, &((ns1__Organization*)this)->website, SOAP_TYPE_xsd__anyURI);
	soap_mark_xsd__anyURI(soap, &((ns1__Organization*)this)->website);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__AddressBookItem*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__AddressBookItem*)this)->uuid);
	soap_embedded(soap, &((ns1__AddressBookItem*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__AddressBookItem*)this)->comment);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__Organization::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ItemRef(soap, &((ns1__Organization*)this)->contact);
	soap_default_PointerTostd__string(soap, &((ns1__Organization*)this)->phone);
	soap_default_PointerTostd__string(soap, &((ns1__Organization*)this)->fax);
	soap_default_PointerTons1__PostalAddress(soap, &((ns1__Organization*)this)->address);
	soap_default_xsd__anyURI(soap, &((ns1__Organization*)this)->website);
	/* transient soap skipped */
	soap_default_ns1__UUID(soap, &((ns1__AddressBookItem*)this)->uuid);
	soap_default_PointerTostd__string(soap, &((ns1__AddressBookItem*)this)->comment);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__Organization::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Organization);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Organization::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Organization(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Organization(struct soap *soap, const char *tag, int id, const ns1__Organization *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Organization), "ns1:Organization");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__AddressBookItem*)a)->uuid), "ns1:UUID");
	soap_out_PointerTostd__string(soap, "comment", -1, &(((ns1__AddressBookItem*)a)->comment), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTons1__ItemRef(soap, "contact", -1, &(((ns1__Organization*)a)->contact), "ns1:ItemRef");
	soap_out_PointerTostd__string(soap, "phone", -1, &(((ns1__Organization*)a)->phone), "xsd:string");
	soap_out_PointerTostd__string(soap, "fax", -1, &(((ns1__Organization*)a)->fax), "xsd:string");
	soap_out_PointerTons1__PostalAddress(soap, "address", -1, &(((ns1__Organization*)a)->address), "ns1:PostalAddress");
	soap_out_xsd__anyURI(soap, "website", -1, &(((ns1__Organization*)a)->website), "xsd:anyURI");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Organization::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Organization(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Organization * SOAP_FMAC4 soap_get_ns1__Organization(struct soap *soap, ns1__Organization *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Organization(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Organization::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Organization(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Organization * SOAP_FMAC4 soap_in_ns1__Organization(struct soap *soap, const char *tag, ns1__Organization *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Organization *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Organization, sizeof(ns1__Organization), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Organization)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Organization *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_type4 = 1, soap_flag_categories3 = 1, soap_flag_created3 = 1, soap_flag_customs3 = 1, soap_flag_uuid2 = 1, soap_flag_comment2 = 1, soap_flag_contact1 = 1, soap_flag_phone1 = 1, soap_flag_fax1 = 1, soap_flag_address1 = 1, soap_flag_website1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}

			if (soap_flag_name4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name4 = 0;
					continue;
				}

			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}

			if (soap_flag_modified4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}

			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}

			if (soap_flag_type4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories3 = 0;
					continue;
				}

			if (soap_flag_created3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created3 = 0;
					continue;
				}

			if (soap_flag_customs3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_uuid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__AddressBookItem*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}

			if (soap_flag_comment2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "comment", &(((ns1__AddressBookItem*)a)->comment), "xsd:string"))
				{	soap_flag_comment2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_contact1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRef(soap, "contact", &(((ns1__Organization*)a)->contact), "ns1:ItemRef"))
				{	soap_flag_contact1 = 0;
					continue;
				}

			if (soap_flag_phone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "phone", &(((ns1__Organization*)a)->phone), "xsd:string"))
				{	soap_flag_phone1 = 0;
					continue;
				}

			if (soap_flag_fax1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "fax", &(((ns1__Organization*)a)->fax), "xsd:string"))
				{	soap_flag_fax1 = 0;
					continue;
				}

			if (soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PostalAddress(soap, "address", &(((ns1__Organization*)a)->address), "ns1:PostalAddress"))
				{	soap_flag_address1 = 0;
					continue;
				}

			if (soap_flag_website1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyURI(soap, "website", &(((ns1__Organization*)a)->website), "xsd:anyURI"))
				{	soap_flag_website1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Organization *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Organization, sizeof(ns1__Organization), soap->type, soap->arrayType), SOAP_TYPE_ns1__Organization, sizeof(ns1__Organization));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Organization * SOAP_FMAC6 soap_new_ns1__Organization(struct soap *soap, int n)
{	return soap_instantiate_ns1__Organization(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Organization(struct soap *soap, ns1__Organization *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Organization * SOAP_FMAC6 soap_instantiate_ns1__Organization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Organization(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Organization, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Organization;
		if (size)
			*size = sizeof(ns1__Organization);
		((ns1__Organization*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Organization[n];
		if (size)
			*size = n * sizeof(ns1__Organization);
		for (int i = 0; i < n; i++)
			((ns1__Organization*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Organization*)cp->ptr;
}

void ns1__OfficeInfo::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__OfficeInfo))
		this->soap_mark(soap);
}

void ns1__OfficeInfo::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__OfficeInfo*)this)->organization, SOAP_TYPE_PointerTons1__ItemRef);
	soap_mark_PointerTons1__ItemRef(soap, &((ns1__OfficeInfo*)this)->organization);
	soap_embedded(soap, &((ns1__OfficeInfo*)this)->department, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__OfficeInfo*)this)->department);
	soap_embedded(soap, &((ns1__OfficeInfo*)this)->title, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__OfficeInfo*)this)->title);
	soap_embedded(soap, &((ns1__OfficeInfo*)this)->website, SOAP_TYPE_xsd__anyURI);
	soap_mark_xsd__anyURI(soap, &((ns1__OfficeInfo*)this)->website);
	/* transient soap skipped */
}

void ns1__OfficeInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ItemRef(soap, &((ns1__OfficeInfo*)this)->organization);
	soap_default_PointerTostd__string(soap, &((ns1__OfficeInfo*)this)->department);
	soap_default_PointerTostd__string(soap, &((ns1__OfficeInfo*)this)->title);
	soap_default_xsd__anyURI(soap, &((ns1__OfficeInfo*)this)->website);
	/* transient soap skipped */
}

int ns1__OfficeInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__OfficeInfo);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__OfficeInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OfficeInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OfficeInfo(struct soap *soap, const char *tag, int id, const ns1__OfficeInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OfficeInfo), "ns1:OfficeInfo");
	soap_out_PointerTons1__ItemRef(soap, "organization", -1, &(((ns1__OfficeInfo*)a)->organization), "ns1:ItemRef");
	soap_out_PointerTostd__string(soap, "department", -1, &(((ns1__OfficeInfo*)a)->department), "xsd:string");
	soap_out_PointerTostd__string(soap, "title", -1, &(((ns1__OfficeInfo*)a)->title), "xsd:string");
	soap_out_xsd__anyURI(soap, "website", -1, &(((ns1__OfficeInfo*)a)->website), "xsd:anyURI");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__OfficeInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OfficeInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OfficeInfo * SOAP_FMAC4 soap_get_ns1__OfficeInfo(struct soap *soap, ns1__OfficeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OfficeInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__OfficeInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OfficeInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OfficeInfo * SOAP_FMAC4 soap_in_ns1__OfficeInfo(struct soap *soap, const char *tag, ns1__OfficeInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__OfficeInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OfficeInfo, sizeof(ns1__OfficeInfo), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__OfficeInfo)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__OfficeInfo *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_organization1 = 1, soap_flag_department1 = 1, soap_flag_title1 = 1, soap_flag_website1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_organization1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemRef(soap, "organization", &(((ns1__OfficeInfo*)a)->organization), "ns1:ItemRef"))
				{	soap_flag_organization1 = 0;
					continue;
				}

			if (soap_flag_department1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "department", &(((ns1__OfficeInfo*)a)->department), "xsd:string"))
				{	soap_flag_department1 = 0;
					continue;
				}

			if (soap_flag_title1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "title", &(((ns1__OfficeInfo*)a)->title), "xsd:string"))
				{	soap_flag_title1 = 0;
					continue;
				}

			if (soap_flag_website1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyURI(soap, "website", &(((ns1__OfficeInfo*)a)->website), "xsd:anyURI"))
				{	soap_flag_website1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__OfficeInfo *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OfficeInfo, sizeof(ns1__OfficeInfo), soap->type, soap->arrayType), SOAP_TYPE_ns1__OfficeInfo, sizeof(ns1__OfficeInfo));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__OfficeInfo * SOAP_FMAC6 soap_new_ns1__OfficeInfo(struct soap *soap, int n)
{	return soap_instantiate_ns1__OfficeInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__OfficeInfo(struct soap *soap, ns1__OfficeInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__OfficeInfo * SOAP_FMAC6 soap_instantiate_ns1__OfficeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OfficeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OfficeInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__OfficeInfo;
		if (size)
			*size = sizeof(ns1__OfficeInfo);
		((ns1__OfficeInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__OfficeInfo[n];
		if (size)
			*size = n * sizeof(ns1__OfficeInfo);
		for (int i = 0; i < n; i++)
			((ns1__OfficeInfo*)cp->ptr)[i].soap = soap;
	}
	return (ns1__OfficeInfo*)cp->ptr;
}

void ns1__Note::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Note))
		this->soap_mark(soap);
}

void ns1__Note::soap_mark(struct soap *soap) const
{
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__CalendarItem*)this)->startDate, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__CalendarItem*)this)->startDate);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->rdate, SOAP_TYPE_PointerTons1__RecurrenceDateType);
	soap_mark_PointerTons1__RecurrenceDateType(soap, &((ns1__CalendarItem*)this)->rdate);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->isRecurring, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__CalendarItem*)this)->isRecurring);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->iCalId, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__CalendarItem*)this)->iCalId);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Mail*)this)->subject, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_embedded(soap, &((ns1__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ns1__Mail*)this)->distribution, SOAP_TYPE_PointerTons1__Distribution);
	soap_mark_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_embedded(soap, &((ns1__Mail*)this)->message, SOAP_TYPE_PointerTons1__MessageBody);
	soap_mark_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_embedded(soap, &((ns1__Mail*)this)->attachments, SOAP_TYPE_PointerTons1__AttachmentInfo);
	soap_mark_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_embedded(soap, &((ns1__Mail*)this)->options, SOAP_TYPE_PointerTons1__ItemOptions);
	soap_mark_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__BoxEntry*)this)->status, SOAP_TYPE_PointerTons1__ItemStatus);
	soap_mark_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->msgid, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->source, SOAP_TYPE_PointerTons1__ItemSource);
	soap_mark_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->class_, SOAP_TYPE_PointerTons1__ItemClass);
	soap_mark_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__Note::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
	soap_default_string(soap, &((ns1__CalendarItem*)this)->startDate);
	soap_default_PointerTons1__RecurrenceDateType(soap, &((ns1__CalendarItem*)this)->rdate);
	soap_default_PointerTobool(soap, &((ns1__CalendarItem*)this)->isRecurring);
	soap_default_PointerTostd__string(soap, &((ns1__CalendarItem*)this)->iCalId);
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_default_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_default_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_default_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_default_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_default_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_default_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_default_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_default_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_default_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__Note::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Note);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Note::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Note(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Note(struct soap *soap, const char *tag, int id, const ns1__Note *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Note), "ns1:Note");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_PointerTons1__ItemStatus(soap, "status", -1, &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus");
	soap_out_PointerTostd__string(soap, "thread", -1, &(((ns1__BoxEntry*)a)->thread), "xsd:string");
	soap_out_PointerTostd__string(soap, "msgid", -1, &(((ns1__BoxEntry*)a)->msgid), "xsd:string");
	soap_out_PointerTons1__ItemSource(soap, "source", -1, &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource");
	soap_out_string(soap, "delivered", -1, &(((ns1__BoxEntry*)a)->delivered), "");
	soap_out_PointerTons1__ItemClass(soap, "class", -1, &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass");
	/* transient soap skipped */
	soap_out_std__string(soap, "subject", -1, &(((ns1__Mail*)a)->subject), "xsd:string");
	soap_out_PointerTostd__string(soap, "originalSubject", -1, &(((ns1__Mail*)a)->originalSubject), "xsd:string");
	soap_out_PointerTons1__Distribution(soap, "distribution", -1, &(((ns1__Mail*)a)->distribution), "ns1:Distribution");
	soap_out_PointerTons1__MessageBody(soap, "message", -1, &(((ns1__Mail*)a)->message), "ns1:MessageBody");
	soap_out_PointerTons1__AttachmentInfo(soap, "attachments", -1, &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo");
	soap_out_PointerTons1__ItemOptions(soap, "options", -1, &(((ns1__Mail*)a)->options), "ns1:ItemOptions");
	/* transient soap skipped */
	soap_out_string(soap, "startDate", -1, &(((ns1__CalendarItem*)a)->startDate), "");
	soap_out_PointerTons1__RecurrenceDateType(soap, "rdate", -1, &(((ns1__CalendarItem*)a)->rdate), "ns1:RecurrenceDateType");
	soap_out_PointerTobool(soap, "isRecurring", -1, &(((ns1__CalendarItem*)a)->isRecurring), "");
	soap_out_PointerTostd__string(soap, "iCalId", -1, &(((ns1__CalendarItem*)a)->iCalId), "xsd:string");
	/* transient soap skipped */
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Note::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Note(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Note * SOAP_FMAC4 soap_get_ns1__Note(struct soap *soap, ns1__Note *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Note(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Note::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Note(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Note * SOAP_FMAC4 soap_in_ns1__Note(struct soap *soap, const char *tag, ns1__Note *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Note *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Note, sizeof(ns1__Note), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Note)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Note *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id6 = 1, soap_flag_name6 = 1, soap_flag_version6 = 1, soap_flag_modified6 = 1, soap_flag_changes6 = 1, soap_flag_type6 = 1, soap_flag_categories5 = 1, soap_flag_created5 = 1, soap_flag_customs5 = 1, soap_flag_status4 = 1, soap_flag_thread4 = 1, soap_flag_msgid4 = 1, soap_flag_source4 = 1, soap_flag_delivered4 = 1, soap_flag_class_4 = 1, soap_flag_subject3 = 1, soap_flag_originalSubject3 = 1, soap_flag_distribution3 = 1, soap_flag_message3 = 1, soap_flag_attachments3 = 1, soap_flag_options3 = 1, soap_flag_startDate2 = 1, soap_flag_rdate2 = 1, soap_flag_isRecurring2 = 1, soap_flag_iCalId2 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id6 = 0;
					continue;
				}

			if (soap_flag_name6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name6 = 0;
					continue;
				}

			if (soap_flag_version6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version6 = 0;
					continue;
				}

			if (soap_flag_modified6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified6 = 0;
					continue;
				}

			if (soap_flag_changes6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes6 = 0;
					continue;
				}

			if (soap_flag_type6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type6 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories5 = 0;
					continue;
				}

			if (soap_flag_created5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created5 = 0;
					continue;
				}

			if (soap_flag_customs5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs5 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_status4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemStatus(soap, "status", &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus"))
				{	soap_flag_status4 = 0;
					continue;
				}

			if (soap_flag_thread4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "thread", &(((ns1__BoxEntry*)a)->thread), "xsd:string"))
				{	soap_flag_thread4 = 0;
					continue;
				}

			if (soap_flag_msgid4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "msgid", &(((ns1__BoxEntry*)a)->msgid), "xsd:string"))
				{	soap_flag_msgid4 = 0;
					continue;
				}

			if (soap_flag_source4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemSource(soap, "source", &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource"))
				{	soap_flag_source4 = 0;
					continue;
				}

			if (soap_flag_delivered4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "delivered", &(((ns1__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered4 = 0;
					continue;
				}

			if (soap_flag_class_4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemClass(soap, "class", &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass"))
				{	soap_flag_class_4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_subject3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "subject", &(((ns1__Mail*)a)->subject), "xsd:string"))
				{	soap_flag_subject3 = 0;
					continue;
				}

			if (soap_flag_originalSubject3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "originalSubject", &(((ns1__Mail*)a)->originalSubject), "xsd:string"))
				{	soap_flag_originalSubject3 = 0;
					continue;
				}

			if (soap_flag_distribution3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Distribution(soap, "distribution", &(((ns1__Mail*)a)->distribution), "ns1:Distribution"))
				{	soap_flag_distribution3 = 0;
					continue;
				}

			if (soap_flag_message3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MessageBody(soap, "message", &(((ns1__Mail*)a)->message), "ns1:MessageBody"))
				{	soap_flag_message3 = 0;
					continue;
				}

			if (soap_flag_attachments3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AttachmentInfo(soap, "attachments", &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo"))
				{	soap_flag_attachments3 = 0;
					continue;
				}

			if (soap_flag_options3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemOptions(soap, "options", &(((ns1__Mail*)a)->options), "ns1:ItemOptions"))
				{	soap_flag_options3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_startDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "startDate", &(((ns1__CalendarItem*)a)->startDate), ""))
				{	soap_flag_startDate2 = 0;
					continue;
				}

			if (soap_flag_rdate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RecurrenceDateType(soap, "rdate", &(((ns1__CalendarItem*)a)->rdate), "ns1:RecurrenceDateType"))
				{	soap_flag_rdate2 = 0;
					continue;
				}

			if (soap_flag_isRecurring2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isRecurring", &(((ns1__CalendarItem*)a)->isRecurring), ""))
				{	soap_flag_isRecurring2 = 0;
					continue;
				}

			if (soap_flag_iCalId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "iCalId", &(((ns1__CalendarItem*)a)->iCalId), "xsd:string"))
				{	soap_flag_iCalId2 = 0;
					continue;
				}

			/* transient soap skipped */
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_subject3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__Note *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Note, sizeof(ns1__Note), soap->type, soap->arrayType), SOAP_TYPE_ns1__Note, sizeof(ns1__Note));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Note * SOAP_FMAC6 soap_new_ns1__Note(struct soap *soap, int n)
{	return soap_instantiate_ns1__Note(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Note(struct soap *soap, ns1__Note *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Note * SOAP_FMAC6 soap_instantiate_ns1__Note(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Note(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Note, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Note;
		if (size)
			*size = sizeof(ns1__Note);
		((ns1__Note*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Note[n];
		if (size)
			*size = n * sizeof(ns1__Note);
		for (int i = 0; i < n; i++)
			((ns1__Note*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Note*)cp->ptr;
}

void ns1__NameAndEmail::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__NameAndEmail))
		this->soap_mark(soap);
}

void ns1__NameAndEmail::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->displayName, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->email, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ns1__NameAndEmail::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_default_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

int ns1__NameAndEmail::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__NameAndEmail);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__NameAndEmail::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NameAndEmail(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NameAndEmail(struct soap *soap, const char *tag, int id, const ns1__NameAndEmail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NameAndEmail), "ns1:NameAndEmail");
	soap_out_std__string(soap, "displayName", -1, &(((ns1__NameAndEmail*)a)->displayName), "xsd:string");
	soap_out_std__string(soap, "email", -1, &(((ns1__NameAndEmail*)a)->email), "xsd:string");
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__NameAndEmail::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NameAndEmail(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NameAndEmail * SOAP_FMAC4 soap_get_ns1__NameAndEmail(struct soap *soap, ns1__NameAndEmail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NameAndEmail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__NameAndEmail::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__NameAndEmail(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NameAndEmail * SOAP_FMAC4 soap_in_ns1__NameAndEmail(struct soap *soap, const char *tag, ns1__NameAndEmail *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__NameAndEmail *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NameAndEmail, sizeof(ns1__NameAndEmail), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__NameAndEmail)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__NameAndEmail *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_displayName1 = 1, soap_flag_email1 = 1, soap_flag_uuid1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_displayName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "displayName", &(((ns1__NameAndEmail*)a)->displayName), "xsd:string"))
				{	soap_flag_displayName1 = 0;
					continue;
				}

			if (soap_flag_email1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "email", &(((ns1__NameAndEmail*)a)->email), "xsd:string"))
				{	soap_flag_email1 = 0;
					continue;
				}

			if (soap_flag_uuid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__NameAndEmail *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NameAndEmail, sizeof(ns1__NameAndEmail), soap->type, soap->arrayType), SOAP_TYPE_ns1__NameAndEmail, sizeof(ns1__NameAndEmail));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__NameAndEmail * SOAP_FMAC6 soap_new_ns1__NameAndEmail(struct soap *soap, int n)
{	return soap_instantiate_ns1__NameAndEmail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__NameAndEmail(struct soap *soap, ns1__NameAndEmail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__NameAndEmail * SOAP_FMAC6 soap_instantiate_ns1__NameAndEmail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NameAndEmail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__NameAndEmail, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:AccessControlListEntry"))
	{	cp->type = SOAP_TYPE_ns1__AccessControlListEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__AccessControlListEntry;
			if (size)
				*size = sizeof(ns1__AccessControlListEntry);
			((ns1__AccessControlListEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__AccessControlListEntry[n];
			if (size)
				*size = n * sizeof(ns1__AccessControlListEntry);
			for (int i = 0; i < n; i++)
				((ns1__AccessControlListEntry*)cp->ptr)[i].soap = soap;
		}
		return (ns1__AccessControlListEntry*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:AccessRightEntry"))
	{	cp->type = SOAP_TYPE_ns1__AccessRightEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__AccessRightEntry;
			if (size)
				*size = sizeof(ns1__AccessRightEntry);
			((ns1__AccessRightEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__AccessRightEntry[n];
			if (size)
				*size = n * sizeof(ns1__AccessRightEntry);
			for (int i = 0; i < n; i++)
				((ns1__AccessRightEntry*)cp->ptr)[i].soap = soap;
		}
		return (ns1__AccessRightEntry*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:FreeBusyUser"))
	{	cp->type = SOAP_TYPE_ns1__FreeBusyUser;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__FreeBusyUser;
			if (size)
				*size = sizeof(ns1__FreeBusyUser);
			((ns1__FreeBusyUser*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__FreeBusyUser[n];
			if (size)
				*size = n * sizeof(ns1__FreeBusyUser);
			for (int i = 0; i < n; i++)
				((ns1__FreeBusyUser*)cp->ptr)[i].soap = soap;
		}
		return (ns1__FreeBusyUser*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:From"))
	{	cp->type = SOAP_TYPE_ns1__From;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__From;
			if (size)
				*size = sizeof(ns1__From);
			((ns1__From*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__From[n];
			if (size)
				*size = n * sizeof(ns1__From);
			for (int i = 0; i < n; i++)
				((ns1__From*)cp->ptr)[i].soap = soap;
		}
		return (ns1__From*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Recipient"))
	{	cp->type = SOAP_TYPE_ns1__Recipient;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Recipient;
			if (size)
				*size = sizeof(ns1__Recipient);
			((ns1__Recipient*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Recipient[n];
			if (size)
				*size = n * sizeof(ns1__Recipient);
			for (int i = 0; i < n; i++)
				((ns1__Recipient*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Recipient*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:FolderACLEntry"))
	{	cp->type = SOAP_TYPE_ns1__FolderACLEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__FolderACLEntry;
			if (size)
				*size = sizeof(ns1__FolderACLEntry);
			((ns1__FolderACLEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__FolderACLEntry[n];
			if (size)
				*size = n * sizeof(ns1__FolderACLEntry);
			for (int i = 0; i < n; i++)
				((ns1__FolderACLEntry*)cp->ptr)[i].soap = soap;
		}
		return (ns1__FolderACLEntry*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:FreeBusyInfo"))
	{	cp->type = SOAP_TYPE_ns1__FreeBusyInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__FreeBusyInfo;
			if (size)
				*size = sizeof(ns1__FreeBusyInfo);
			((ns1__FreeBusyInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__FreeBusyInfo[n];
			if (size)
				*size = n * sizeof(ns1__FreeBusyInfo);
			for (int i = 0; i < n; i++)
				((ns1__FreeBusyInfo*)cp->ptr)[i].soap = soap;
		}
		return (ns1__FreeBusyInfo*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__NameAndEmail;
		if (size)
			*size = sizeof(ns1__NameAndEmail);
		((ns1__NameAndEmail*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__NameAndEmail[n];
		if (size)
			*size = n * sizeof(ns1__NameAndEmail);
		for (int i = 0; i < n; i++)
			((ns1__NameAndEmail*)cp->ptr)[i].soap = soap;
	}
	return (ns1__NameAndEmail*)cp->ptr;
}

void ns1__MessagePart::soap_serialize(struct soap *soap) const
{
		this->soap_mark(soap);
}

void ns1__MessagePart::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__MessagePart*)this)->__item, SOAP_TYPE_xsd__base64Binary);
	((ns1__MessagePart*)this)->__item.soap_mark(soap);
	/* transient soap skipped */
}

void ns1__MessagePart::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MessagePart*)this)->__item.xsd__base64Binary::soap_default(soap);
	soap_default_std__string(soap, &((ns1__MessagePart*)this)->contentId);
	soap_default_std__string(soap, &((ns1__MessagePart*)this)->contentType);
	soap_default_int(soap, &((ns1__MessagePart*)this)->length);
	/* transient soap skipped */
}

int ns1__MessagePart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__MessagePart);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__MessagePart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MessagePart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MessagePart(struct soap *soap, const char *tag, int id, const ns1__MessagePart *a, const char *type)
{
	if (!((ns1__MessagePart *)a)->contentId.empty())
		soap_set_attr(soap, "contentId", ((ns1__MessagePart *)a)->contentId.c_str());
	if (!((ns1__MessagePart *)a)->contentType.empty())
		soap_set_attr(soap, "contentType", ((ns1__MessagePart *)a)->contentType.c_str());
	soap_set_attr(soap, "length", soap_int2s(soap, ((ns1__MessagePart *)a)->length));
	(((ns1__MessagePart*)a)->__item).soap_out(soap, tag, id, "ns1:MessagePart");
	return SOAP_OK;
}

void *ns1__MessagePart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MessagePart(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MessagePart * SOAP_FMAC4 soap_get_ns1__MessagePart(struct soap *soap, ns1__MessagePart *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MessagePart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MessagePart::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MessagePart(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MessagePart * SOAP_FMAC4 soap_in_ns1__MessagePart(struct soap *soap, const char *tag, ns1__MessagePart *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ns1__MessagePart *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MessagePart, sizeof(ns1__MessagePart), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MessagePart)
			return (ns1__MessagePart *)a->soap_in(soap, tag, type);
	}
		{	const char *t = soap_attr_value(soap, "contentId");
			if (t)
			{	char *s;
				if (soap_s2string(soap, t, &s))
					return NULL;
				((ns1__MessagePart *)a)->contentId.assign(s);
			}
		}
		{	const char *t = soap_attr_value(soap, "contentType");
			if (t)
			{	char *s;
				if (soap_s2string(soap, t, &s))
					return NULL;
				((ns1__MessagePart *)a)->contentType.assign(s);
			}
		}
		if (soap_s2int(soap, soap_attr_value(soap, "length"), &((ns1__MessagePart *)a)->length))
			return NULL;
	if (!(((ns1__MessagePart*)a)->__item).soap_in(soap, tag, "ns1:MessagePart"))
		return NULL;
	return a;
}

SOAP_FMAC5 ns1__MessagePart * SOAP_FMAC6 soap_new_ns1__MessagePart(struct soap *soap, int n)
{	return soap_instantiate_ns1__MessagePart(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MessagePart(struct soap *soap, ns1__MessagePart *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__MessagePart * SOAP_FMAC6 soap_instantiate_ns1__MessagePart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MessagePart(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MessagePart, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MessagePart;
		if (size)
			*size = sizeof(ns1__MessagePart);
		((ns1__MessagePart*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MessagePart[n];
		if (size)
			*size = n * sizeof(ns1__MessagePart);
		for (int i = 0; i < n; i++)
			((ns1__MessagePart*)cp->ptr)[i].soap = soap;
	}
	return (ns1__MessagePart*)cp->ptr;
}

void ns1__MessageBody::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__MessageBody))
		this->soap_mark(soap);
}

void ns1__MessageBody::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__MessageBody*)this)->part, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__MessagePart);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(soap, &((ns1__MessageBody*)this)->part);
	/* transient soap skipped */
}

void ns1__MessageBody::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(soap, &((ns1__MessageBody*)this)->part);
	soap_default_std__string(soap, &((ns1__MessageBody*)this)->defaultPart);
	/* transient soap skipped */
}

int ns1__MessageBody::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__MessageBody);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__MessageBody::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MessageBody(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MessageBody(struct soap *soap, const char *tag, int id, const ns1__MessageBody *a, const char *type)
{
	if (!((ns1__MessageBody *)a)->defaultPart.empty())
		soap_set_attr(soap, "defaultPart", ((ns1__MessageBody *)a)->defaultPart.c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MessageBody), "ns1:MessageBody");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(soap, "part", -1, &(((ns1__MessageBody*)a)->part), "ns1:MessagePart");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MessageBody::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MessageBody(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MessageBody * SOAP_FMAC4 soap_get_ns1__MessageBody(struct soap *soap, ns1__MessageBody *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MessageBody(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MessageBody::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MessageBody(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MessageBody * SOAP_FMAC4 soap_in_ns1__MessageBody(struct soap *soap, const char *tag, ns1__MessageBody *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__MessageBody *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MessageBody, sizeof(ns1__MessageBody), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__MessageBody)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__MessageBody *)a->soap_in(soap, tag, type);
			}
		}
		{	const char *t = soap_attr_value(soap, "defaultPart");
			if (t)
			{	char *s;
				if (soap_s2string(soap, t, &s))
					return NULL;
				((ns1__MessageBody *)a)->defaultPart.assign(s);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(soap, "part", &(((ns1__MessageBody*)a)->part), "ns1:MessagePart"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__MessageBody *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MessageBody, sizeof(ns1__MessageBody), soap->type, soap->arrayType), SOAP_TYPE_ns1__MessageBody, sizeof(ns1__MessageBody));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MessageBody * SOAP_FMAC6 soap_new_ns1__MessageBody(struct soap *soap, int n)
{	return soap_instantiate_ns1__MessageBody(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MessageBody(struct soap *soap, ns1__MessageBody *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__MessageBody * SOAP_FMAC6 soap_instantiate_ns1__MessageBody(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MessageBody(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MessageBody, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MessageBody;
		if (size)
			*size = sizeof(ns1__MessageBody);
		((ns1__MessageBody*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MessageBody[n];
		if (size)
			*size = n * sizeof(ns1__MessageBody);
		for (int i = 0; i < n; i++)
			((ns1__MessageBody*)cp->ptr)[i].soap = soap;
	}
	return (ns1__MessageBody*)cp->ptr;
}

void ns1__Mail::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Mail))
		this->soap_mark(soap);
}

void ns1__Mail::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Mail*)this)->subject, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_embedded(soap, &((ns1__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ns1__Mail*)this)->distribution, SOAP_TYPE_PointerTons1__Distribution);
	soap_mark_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_embedded(soap, &((ns1__Mail*)this)->message, SOAP_TYPE_PointerTons1__MessageBody);
	soap_mark_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_embedded(soap, &((ns1__Mail*)this)->attachments, SOAP_TYPE_PointerTons1__AttachmentInfo);
	soap_mark_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_embedded(soap, &((ns1__Mail*)this)->options, SOAP_TYPE_PointerTons1__ItemOptions);
	soap_mark_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__BoxEntry*)this)->status, SOAP_TYPE_PointerTons1__ItemStatus);
	soap_mark_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->msgid, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->source, SOAP_TYPE_PointerTons1__ItemSource);
	soap_mark_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->class_, SOAP_TYPE_PointerTons1__ItemClass);
	soap_mark_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__Mail::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_default_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_default_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_default_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_default_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_default_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_default_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_default_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_default_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_default_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__Mail::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Mail);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Mail::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Mail(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Mail(struct soap *soap, const char *tag, int id, const ns1__Mail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Mail), "ns1:Mail");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_PointerTons1__ItemStatus(soap, "status", -1, &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus");
	soap_out_PointerTostd__string(soap, "thread", -1, &(((ns1__BoxEntry*)a)->thread), "xsd:string");
	soap_out_PointerTostd__string(soap, "msgid", -1, &(((ns1__BoxEntry*)a)->msgid), "xsd:string");
	soap_out_PointerTons1__ItemSource(soap, "source", -1, &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource");
	soap_out_string(soap, "delivered", -1, &(((ns1__BoxEntry*)a)->delivered), "");
	soap_out_PointerTons1__ItemClass(soap, "class", -1, &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass");
	/* transient soap skipped */
	soap_out_std__string(soap, "subject", -1, &(((ns1__Mail*)a)->subject), "xsd:string");
	soap_out_PointerTostd__string(soap, "originalSubject", -1, &(((ns1__Mail*)a)->originalSubject), "xsd:string");
	soap_out_PointerTons1__Distribution(soap, "distribution", -1, &(((ns1__Mail*)a)->distribution), "ns1:Distribution");
	soap_out_PointerTons1__MessageBody(soap, "message", -1, &(((ns1__Mail*)a)->message), "ns1:MessageBody");
	soap_out_PointerTons1__AttachmentInfo(soap, "attachments", -1, &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo");
	soap_out_PointerTons1__ItemOptions(soap, "options", -1, &(((ns1__Mail*)a)->options), "ns1:ItemOptions");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Mail::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Mail(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Mail * SOAP_FMAC4 soap_get_ns1__Mail(struct soap *soap, ns1__Mail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Mail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Mail::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Mail(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Mail * SOAP_FMAC4 soap_in_ns1__Mail(struct soap *soap, const char *tag, ns1__Mail *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Mail *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Mail, sizeof(ns1__Mail), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Mail)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Mail *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_type4 = 1, soap_flag_categories3 = 1, soap_flag_created3 = 1, soap_flag_customs3 = 1, soap_flag_status2 = 1, soap_flag_thread2 = 1, soap_flag_msgid2 = 1, soap_flag_source2 = 1, soap_flag_delivered2 = 1, soap_flag_class_2 = 1, soap_flag_subject1 = 1, soap_flag_originalSubject1 = 1, soap_flag_distribution1 = 1, soap_flag_message1 = 1, soap_flag_attachments1 = 1, soap_flag_options1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}

			if (soap_flag_name4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name4 = 0;
					continue;
				}

			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}

			if (soap_flag_modified4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}

			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}

			if (soap_flag_type4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories3 = 0;
					continue;
				}

			if (soap_flag_created3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created3 = 0;
					continue;
				}

			if (soap_flag_customs3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemStatus(soap, "status", &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus"))
				{	soap_flag_status2 = 0;
					continue;
				}

			if (soap_flag_thread2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "thread", &(((ns1__BoxEntry*)a)->thread), "xsd:string"))
				{	soap_flag_thread2 = 0;
					continue;
				}

			if (soap_flag_msgid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "msgid", &(((ns1__BoxEntry*)a)->msgid), "xsd:string"))
				{	soap_flag_msgid2 = 0;
					continue;
				}

			if (soap_flag_source2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemSource(soap, "source", &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource"))
				{	soap_flag_source2 = 0;
					continue;
				}

			if (soap_flag_delivered2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "delivered", &(((ns1__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered2 = 0;
					continue;
				}

			if (soap_flag_class_2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemClass(soap, "class", &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass"))
				{	soap_flag_class_2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_subject1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "subject", &(((ns1__Mail*)a)->subject), "xsd:string"))
				{	soap_flag_subject1 = 0;
					continue;
				}

			if (soap_flag_originalSubject1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "originalSubject", &(((ns1__Mail*)a)->originalSubject), "xsd:string"))
				{	soap_flag_originalSubject1 = 0;
					continue;
				}

			if (soap_flag_distribution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Distribution(soap, "distribution", &(((ns1__Mail*)a)->distribution), "ns1:Distribution"))
				{	soap_flag_distribution1 = 0;
					continue;
				}

			if (soap_flag_message1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MessageBody(soap, "message", &(((ns1__Mail*)a)->message), "ns1:MessageBody"))
				{	soap_flag_message1 = 0;
					continue;
				}

			if (soap_flag_attachments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AttachmentInfo(soap, "attachments", &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo"))
				{	soap_flag_attachments1 = 0;
					continue;
				}

			if (soap_flag_options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemOptions(soap, "options", &(((ns1__Mail*)a)->options), "ns1:ItemOptions"))
				{	soap_flag_options1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_subject1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__Mail *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Mail, sizeof(ns1__Mail), soap->type, soap->arrayType), SOAP_TYPE_ns1__Mail, sizeof(ns1__Mail));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Mail * SOAP_FMAC6 soap_new_ns1__Mail(struct soap *soap, int n)
{	return soap_instantiate_ns1__Mail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Mail(struct soap *soap, ns1__Mail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Mail * SOAP_FMAC6 soap_instantiate_ns1__Mail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Mail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Mail, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:CalendarItem"))
	{	cp->type = SOAP_TYPE_ns1__CalendarItem;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__CalendarItem;
			if (size)
				*size = sizeof(ns1__CalendarItem);
			((ns1__CalendarItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__CalendarItem[n];
			if (size)
				*size = n * sizeof(ns1__CalendarItem);
			for (int i = 0; i < n; i++)
				((ns1__CalendarItem*)cp->ptr)[i].soap = soap;
		}
		return (ns1__CalendarItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:DocumentRef"))
	{	cp->type = SOAP_TYPE_ns1__DocumentRef;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__DocumentRef;
			if (size)
				*size = sizeof(ns1__DocumentRef);
			((ns1__DocumentRef*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__DocumentRef[n];
			if (size)
				*size = n * sizeof(ns1__DocumentRef);
			for (int i = 0; i < n; i++)
				((ns1__DocumentRef*)cp->ptr)[i].soap = soap;
		}
		return (ns1__DocumentRef*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:PhoneMessage"))
	{	cp->type = SOAP_TYPE_ns1__PhoneMessage;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__PhoneMessage;
			if (size)
				*size = sizeof(ns1__PhoneMessage);
			((ns1__PhoneMessage*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__PhoneMessage[n];
			if (size)
				*size = n * sizeof(ns1__PhoneMessage);
			for (int i = 0; i < n; i++)
				((ns1__PhoneMessage*)cp->ptr)[i].soap = soap;
		}
		return (ns1__PhoneMessage*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Appointment"))
	{	cp->type = SOAP_TYPE_ns1__Appointment;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Appointment;
			if (size)
				*size = sizeof(ns1__Appointment);
			((ns1__Appointment*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Appointment[n];
			if (size)
				*size = n * sizeof(ns1__Appointment);
			for (int i = 0; i < n; i++)
				((ns1__Appointment*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Appointment*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Note"))
	{	cp->type = SOAP_TYPE_ns1__Note;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Note;
			if (size)
				*size = sizeof(ns1__Note);
			((ns1__Note*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Note[n];
			if (size)
				*size = n * sizeof(ns1__Note);
			for (int i = 0; i < n; i++)
				((ns1__Note*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Note*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Task"))
	{	cp->type = SOAP_TYPE_ns1__Task;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Task;
			if (size)
				*size = sizeof(ns1__Task);
			((ns1__Task*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Task[n];
			if (size)
				*size = n * sizeof(ns1__Task);
			for (int i = 0; i < n; i++)
				((ns1__Task*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Task*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Mail;
		if (size)
			*size = sizeof(ns1__Mail);
		((ns1__Mail*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Mail[n];
		if (size)
			*size = n * sizeof(ns1__Mail);
		for (int i = 0; i < n; i++)
			((ns1__Mail*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Mail*)cp->ptr;
}

void ns1__ItemStatus::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ItemStatus))
		this->soap_mark(soap);
}

void ns1__ItemStatus::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ItemStatus*)this)->accepted, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__ItemStatus*)this)->accepted);
	soap_embedded(soap, &((ns1__ItemStatus*)this)->completed, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__ItemStatus*)this)->completed);
	soap_embedded(soap, &((ns1__ItemStatus*)this)->delegated, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__ItemStatus*)this)->delegated);
	soap_embedded(soap, &((ns1__ItemStatus*)this)->deleted, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__ItemStatus*)this)->deleted);
	soap_embedded(soap, &((ns1__ItemStatus*)this)->forwarded, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__ItemStatus*)this)->forwarded);
	soap_embedded(soap, &((ns1__ItemStatus*)this)->opened, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__ItemStatus*)this)->opened);
	soap_embedded(soap, &((ns1__ItemStatus*)this)->read, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__ItemStatus*)this)->read);
	soap_embedded(soap, &((ns1__ItemStatus*)this)->replied, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__ItemStatus*)this)->replied);
	/* transient soap skipped */
}

void ns1__ItemStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTobool(soap, &((ns1__ItemStatus*)this)->accepted);
	soap_default_PointerTobool(soap, &((ns1__ItemStatus*)this)->completed);
	soap_default_PointerTobool(soap, &((ns1__ItemStatus*)this)->delegated);
	soap_default_PointerTobool(soap, &((ns1__ItemStatus*)this)->deleted);
	soap_default_PointerTobool(soap, &((ns1__ItemStatus*)this)->forwarded);
	soap_default_PointerTobool(soap, &((ns1__ItemStatus*)this)->opened);
	soap_default_PointerTobool(soap, &((ns1__ItemStatus*)this)->read);
	soap_default_PointerTobool(soap, &((ns1__ItemStatus*)this)->replied);
	/* transient soap skipped */
}

int ns1__ItemStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ItemStatus);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ItemStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ItemStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemStatus(struct soap *soap, const char *tag, int id, const ns1__ItemStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemStatus), "ns1:ItemStatus");
	soap_out_PointerTobool(soap, "accepted", -1, &(((ns1__ItemStatus*)a)->accepted), "");
	soap_out_PointerTobool(soap, "completed", -1, &(((ns1__ItemStatus*)a)->completed), "");
	soap_out_PointerTobool(soap, "delegated", -1, &(((ns1__ItemStatus*)a)->delegated), "");
	soap_out_PointerTobool(soap, "deleted", -1, &(((ns1__ItemStatus*)a)->deleted), "");
	soap_out_PointerTobool(soap, "forwarded", -1, &(((ns1__ItemStatus*)a)->forwarded), "");
	soap_out_PointerTobool(soap, "opened", -1, &(((ns1__ItemStatus*)a)->opened), "");
	soap_out_PointerTobool(soap, "read", -1, &(((ns1__ItemStatus*)a)->read), "");
	soap_out_PointerTobool(soap, "replied", -1, &(((ns1__ItemStatus*)a)->replied), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ItemStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ItemStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ItemStatus * SOAP_FMAC4 soap_get_ns1__ItemStatus(struct soap *soap, ns1__ItemStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ItemStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ItemStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ItemStatus * SOAP_FMAC4 soap_in_ns1__ItemStatus(struct soap *soap, const char *tag, ns1__ItemStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ItemStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemStatus, sizeof(ns1__ItemStatus), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ItemStatus)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ItemStatus *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_accepted1 = 1, soap_flag_completed1 = 1, soap_flag_delegated1 = 1, soap_flag_deleted1 = 1, soap_flag_forwarded1 = 1, soap_flag_opened1 = 1, soap_flag_read1 = 1, soap_flag_replied1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_accepted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "accepted", &(((ns1__ItemStatus*)a)->accepted), ""))
				{	soap_flag_accepted1 = 0;
					continue;
				}

			if (soap_flag_completed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "completed", &(((ns1__ItemStatus*)a)->completed), ""))
				{	soap_flag_completed1 = 0;
					continue;
				}

			if (soap_flag_delegated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "delegated", &(((ns1__ItemStatus*)a)->delegated), ""))
				{	soap_flag_delegated1 = 0;
					continue;
				}

			if (soap_flag_deleted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "deleted", &(((ns1__ItemStatus*)a)->deleted), ""))
				{	soap_flag_deleted1 = 0;
					continue;
				}

			if (soap_flag_forwarded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "forwarded", &(((ns1__ItemStatus*)a)->forwarded), ""))
				{	soap_flag_forwarded1 = 0;
					continue;
				}

			if (soap_flag_opened1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "opened", &(((ns1__ItemStatus*)a)->opened), ""))
				{	soap_flag_opened1 = 0;
					continue;
				}

			if (soap_flag_read1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "read", &(((ns1__ItemStatus*)a)->read), ""))
				{	soap_flag_read1 = 0;
					continue;
				}

			if (soap_flag_replied1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "replied", &(((ns1__ItemStatus*)a)->replied), ""))
				{	soap_flag_replied1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__ItemStatus *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemStatus, sizeof(ns1__ItemStatus), soap->type, soap->arrayType), SOAP_TYPE_ns1__ItemStatus, sizeof(ns1__ItemStatus));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ItemStatus * SOAP_FMAC6 soap_new_ns1__ItemStatus(struct soap *soap, int n)
{	return soap_instantiate_ns1__ItemStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ItemStatus(struct soap *soap, ns1__ItemStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ItemStatus * SOAP_FMAC6 soap_instantiate_ns1__ItemStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ItemStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ItemStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ItemStatus;
		if (size)
			*size = sizeof(ns1__ItemStatus);
		((ns1__ItemStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ItemStatus[n];
		if (size)
			*size = n * sizeof(ns1__ItemStatus);
		for (int i = 0; i < n; i++)
			((ns1__ItemStatus*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ItemStatus*)cp->ptr;
}

void ns1__Items::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Items))
		this->soap_mark(soap);
}

void ns1__Items::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Items*)this)->item, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Item);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Item(soap, &((ns1__Items*)this)->item);
	/* transient soap skipped */
}

void ns1__Items::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__Item(soap, &((ns1__Items*)this)->item);
	/* transient soap skipped */
}

int ns1__Items::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Items);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Items::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Items(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Items(struct soap *soap, const char *tag, int id, const ns1__Items *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Items), "ns1:Items");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Item(soap, "item", -1, &(((ns1__Items*)a)->item), "ns1:Item");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Items::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Items(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Items * SOAP_FMAC4 soap_get_ns1__Items(struct soap *soap, ns1__Items *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Items(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Items::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Items(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Items * SOAP_FMAC4 soap_in_ns1__Items(struct soap *soap, const char *tag, ns1__Items *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Items *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Items, sizeof(ns1__Items), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Items)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Items *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__Item(soap, "item", &(((ns1__Items*)a)->item), "ns1:Item"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Items *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Items, sizeof(ns1__Items), soap->type, soap->arrayType), SOAP_TYPE_ns1__Items, sizeof(ns1__Items));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Items * SOAP_FMAC6 soap_new_ns1__Items(struct soap *soap, int n)
{	return soap_instantiate_ns1__Items(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Items(struct soap *soap, ns1__Items *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Items * SOAP_FMAC6 soap_instantiate_ns1__Items(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Items(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Items, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:ItemList"))
	{	cp->type = SOAP_TYPE_ns1__ItemList;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ItemList;
			if (size)
				*size = sizeof(ns1__ItemList);
			((ns1__ItemList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ItemList[n];
			if (size)
				*size = n * sizeof(ns1__ItemList);
			for (int i = 0; i < n; i++)
				((ns1__ItemList*)cp->ptr)[i].soap = soap;
		}
		return (ns1__ItemList*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Items;
		if (size)
			*size = sizeof(ns1__Items);
		((ns1__Items*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Items[n];
		if (size)
			*size = n * sizeof(ns1__Items);
		for (int i = 0; i < n; i++)
			((ns1__Items*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Items*)cp->ptr;
}

void ns1__ItemRefList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ItemRefList))
		this->soap_mark(soap);
}

void ns1__ItemRefList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ItemRefList*)this)->item, SOAP_TYPE_PointerTostd__vectorTemplateOfns1__uid);
	soap_mark_PointerTostd__vectorTemplateOfns1__uid(soap, &((ns1__ItemRefList*)this)->item);
	/* transient soap skipped */
}

void ns1__ItemRefList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfns1__uid(soap, &((ns1__ItemRefList*)this)->item);
	/* transient soap skipped */
}

int ns1__ItemRefList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ItemRefList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ItemRefList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ItemRefList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemRefList(struct soap *soap, const char *tag, int id, const ns1__ItemRefList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemRefList), "ns1:ItemRefList");
	soap_out_PointerTostd__vectorTemplateOfns1__uid(soap, "item", -1, &(((ns1__ItemRefList*)a)->item), "ns1:uid");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ItemRefList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ItemRefList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ItemRefList * SOAP_FMAC4 soap_get_ns1__ItemRefList(struct soap *soap, ns1__ItemRefList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemRefList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ItemRefList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ItemRefList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ItemRefList * SOAP_FMAC4 soap_in_ns1__ItemRefList(struct soap *soap, const char *tag, ns1__ItemRefList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ItemRefList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemRefList, sizeof(ns1__ItemRefList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ItemRefList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ItemRefList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfns1__uid(soap, "item", &(((ns1__ItemRefList*)a)->item), "ns1:uid"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__ItemRefList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemRefList, sizeof(ns1__ItemRefList), soap->type, soap->arrayType), SOAP_TYPE_ns1__ItemRefList, sizeof(ns1__ItemRefList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ItemRefList * SOAP_FMAC6 soap_new_ns1__ItemRefList(struct soap *soap, int n)
{	return soap_instantiate_ns1__ItemRefList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ItemRefList(struct soap *soap, ns1__ItemRefList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ItemRefList * SOAP_FMAC6 soap_instantiate_ns1__ItemRefList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ItemRefList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ItemRefList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ItemRefList;
		if (size)
			*size = sizeof(ns1__ItemRefList);
		((ns1__ItemRefList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ItemRefList[n];
		if (size)
			*size = n * sizeof(ns1__ItemRefList);
		for (int i = 0; i < n; i++)
			((ns1__ItemRefList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ItemRefList*)cp->ptr;
}

void ns1__ItemRef::soap_serialize(struct soap *soap) const
{
		this->soap_mark(soap);
}

void ns1__ItemRef::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ItemRef*)this)->__item, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__ItemRef*)this)->__item);
	/* transient soap skipped */
}

void ns1__ItemRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__ItemRef*)this)->__item);
	soap_default_ns1__uid(soap, &((ns1__ItemRef*)this)->uid);
	/* transient soap skipped */
}

int ns1__ItemRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ItemRef);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ItemRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ItemRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemRef(struct soap *soap, const char *tag, int id, const ns1__ItemRef *a, const char *type)
{
	if (!((ns1__ItemRef *)a)->uid.empty())
		soap_set_attr(soap, "uid", ((ns1__ItemRef *)a)->uid.c_str());
	soap_out_std__string(soap, tag, id, &(((ns1__ItemRef*)a)->__item), "ns1:ItemRef");
	return SOAP_OK;
}

void *ns1__ItemRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ItemRef(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ItemRef * SOAP_FMAC4 soap_get_ns1__ItemRef(struct soap *soap, ns1__ItemRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ItemRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ItemRef(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ItemRef * SOAP_FMAC4 soap_in_ns1__ItemRef(struct soap *soap, const char *tag, ns1__ItemRef *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ns1__ItemRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemRef, sizeof(ns1__ItemRef), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ItemRef)
			return (ns1__ItemRef *)a->soap_in(soap, tag, type);
	}
		{	const char *t = soap_attr_value(soap, "uid");
			if (t)
			{	char *s;
				if (soap_s2string(soap, t, &s))
					return NULL;
				((ns1__ItemRef *)a)->uid.assign(s);
			}
		}
	if (!soap_in_std__string(soap, tag, &(((ns1__ItemRef*)a)->__item), "ns1:ItemRef"))
		return NULL;
	return a;
}

SOAP_FMAC5 ns1__ItemRef * SOAP_FMAC6 soap_new_ns1__ItemRef(struct soap *soap, int n)
{	return soap_instantiate_ns1__ItemRef(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ItemRef(struct soap *soap, ns1__ItemRef *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ItemRef * SOAP_FMAC6 soap_instantiate_ns1__ItemRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ItemRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ItemRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ItemRef;
		if (size)
			*size = sizeof(ns1__ItemRef);
		((ns1__ItemRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ItemRef[n];
		if (size)
			*size = n * sizeof(ns1__ItemRef);
		for (int i = 0; i < n; i++)
			((ns1__ItemRef*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ItemRef*)cp->ptr;
}

void ns1__ItemOptions::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ItemOptions))
		this->soap_mark(soap);
}

void ns1__ItemOptions::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ItemOptions*)this)->priority, SOAP_TYPE_ns1__ItemOptionsPriority);
	soap_embedded(soap, &((ns1__ItemOptions*)this)->expires, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ItemOptions*)this)->expires);
	soap_embedded(soap, &((ns1__ItemOptions*)this)->delayDeliveryUntil, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ItemOptions*)this)->delayDeliveryUntil);
	soap_embedded(soap, &((ns1__ItemOptions*)this)->concealSubject, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__ItemOptions*)this)->concealSubject);
	/* transient soap skipped */
}

void ns1__ItemOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ItemOptions*)this)->priority = (enum ns1__ItemOptionsPriority)1;
	soap_default_string(soap, &((ns1__ItemOptions*)this)->expires);
	soap_default_string(soap, &((ns1__ItemOptions*)this)->delayDeliveryUntil);
	soap_default_PointerTobool(soap, &((ns1__ItemOptions*)this)->concealSubject);
	/* transient soap skipped */
}

int ns1__ItemOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ItemOptions);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ItemOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ItemOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemOptions(struct soap *soap, const char *tag, int id, const ns1__ItemOptions *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemOptions), "ns1:ItemOptions");
	soap_out_ns1__ItemOptionsPriority(soap, "priority", -1, &(((ns1__ItemOptions*)a)->priority), "ns1:ItemOptionsPriority");
	soap_out_string(soap, "expires", -1, &(((ns1__ItemOptions*)a)->expires), "");
	soap_out_string(soap, "delayDeliveryUntil", -1, &(((ns1__ItemOptions*)a)->delayDeliveryUntil), "");
	soap_out_PointerTobool(soap, "concealSubject", -1, &(((ns1__ItemOptions*)a)->concealSubject), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ItemOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ItemOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ItemOptions * SOAP_FMAC4 soap_get_ns1__ItemOptions(struct soap *soap, ns1__ItemOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ItemOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ItemOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ItemOptions * SOAP_FMAC4 soap_in_ns1__ItemOptions(struct soap *soap, const char *tag, ns1__ItemOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ItemOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemOptions, sizeof(ns1__ItemOptions), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ItemOptions)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ItemOptions *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_priority1 = 1, soap_flag_expires1 = 1, soap_flag_delayDeliveryUntil1 = 1, soap_flag_concealSubject1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__ItemOptionsPriority(soap, "priority", &(((ns1__ItemOptions*)a)->priority), "ns1:ItemOptionsPriority"))
				{	soap_flag_priority1 = 0;
					continue;
				}

			if (soap_flag_expires1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "expires", &(((ns1__ItemOptions*)a)->expires), ""))
				{	soap_flag_expires1 = 0;
					continue;
				}

			if (soap_flag_delayDeliveryUntil1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "delayDeliveryUntil", &(((ns1__ItemOptions*)a)->delayDeliveryUntil), ""))
				{	soap_flag_delayDeliveryUntil1 = 0;
					continue;
				}

			if (soap_flag_concealSubject1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "concealSubject", &(((ns1__ItemOptions*)a)->concealSubject), ""))
				{	soap_flag_concealSubject1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__ItemOptions *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemOptions, sizeof(ns1__ItemOptions), soap->type, soap->arrayType), SOAP_TYPE_ns1__ItemOptions, sizeof(ns1__ItemOptions));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ItemOptions * SOAP_FMAC6 soap_new_ns1__ItemOptions(struct soap *soap, int n)
{	return soap_instantiate_ns1__ItemOptions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ItemOptions(struct soap *soap, ns1__ItemOptions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ItemOptions * SOAP_FMAC6 soap_instantiate_ns1__ItemOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ItemOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ItemOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ItemOptions;
		if (size)
			*size = sizeof(ns1__ItemOptions);
		((ns1__ItemOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ItemOptions[n];
		if (size)
			*size = n * sizeof(ns1__ItemOptions);
		for (int i = 0; i < n; i++)
			((ns1__ItemOptions*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ItemOptions*)cp->ptr;
}

void ns1__ItemList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ItemList))
		this->soap_mark(soap);
}

void ns1__ItemList::soap_mark(struct soap *soap) const
{
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Items*)this)->item, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Item);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Item(soap, &((ns1__Items*)this)->item);
	/* transient soap skipped */
}

void ns1__ItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ns1__ItemList*)this)->offset);
	soap_default_int(soap, &((ns1__ItemList*)this)->count);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__Item(soap, &((ns1__Items*)this)->item);
	/* transient soap skipped */
}

int ns1__ItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ItemList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemList(struct soap *soap, const char *tag, int id, const ns1__ItemList *a, const char *type)
{
	soap_set_attr(soap, "offset", soap_int2s(soap, ((ns1__ItemList *)a)->offset));
	soap_set_attr(soap, "count", soap_int2s(soap, ((ns1__ItemList *)a)->count));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemList), "ns1:ItemList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Item(soap, "item", -1, &(((ns1__Items*)a)->item), "ns1:Item");
	/* transient soap skipped */
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ItemList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ItemList * SOAP_FMAC4 soap_get_ns1__ItemList(struct soap *soap, ns1__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ItemList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ItemList * SOAP_FMAC4 soap_in_ns1__ItemList(struct soap *soap, const char *tag, ns1__ItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemList, sizeof(ns1__ItemList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ItemList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ItemList *)a->soap_in(soap, tag, type);
			}
		}
		if (soap_s2int(soap, soap_attr_value(soap, "offset"), &((ns1__ItemList *)a)->offset))
			return NULL;
		if (soap_s2int(soap, soap_attr_value(soap, "count"), &((ns1__ItemList *)a)->count))
			return NULL;;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__Item(soap, "item", &(((ns1__Items*)a)->item), "ns1:Item"))
					continue;
			/* transient soap skipped */
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__ItemList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemList, sizeof(ns1__ItemList), soap->type, soap->arrayType), SOAP_TYPE_ns1__ItemList, sizeof(ns1__ItemList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ItemList * SOAP_FMAC6 soap_new_ns1__ItemList(struct soap *soap, int n)
{	return soap_instantiate_ns1__ItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ItemList(struct soap *soap, ns1__ItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ItemList * SOAP_FMAC6 soap_instantiate_ns1__ItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ItemList;
		if (size)
			*size = sizeof(ns1__ItemList);
		((ns1__ItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ItemList[n];
		if (size)
			*size = n * sizeof(ns1__ItemList);
		for (int i = 0; i < n; i++)
			((ns1__ItemList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ItemList*)cp->ptr;
}

void ns1__ItemChanges::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ItemChanges))
		this->soap_mark(soap);
}

void ns1__ItemChanges::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ItemChanges*)this)->add, SOAP_TYPE_PointerTons1__Item);
	soap_mark_PointerTons1__Item(soap, &((ns1__ItemChanges*)this)->add);
	soap_embedded(soap, &((ns1__ItemChanges*)this)->_delete, SOAP_TYPE_PointerTons1__Item);
	soap_mark_PointerTons1__Item(soap, &((ns1__ItemChanges*)this)->_delete);
	soap_embedded(soap, &((ns1__ItemChanges*)this)->update, SOAP_TYPE_PointerTons1__Item);
	soap_mark_PointerTons1__Item(soap, &((ns1__ItemChanges*)this)->update);
	/* transient soap skipped */
}

void ns1__ItemChanges::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Item(soap, &((ns1__ItemChanges*)this)->add);
	soap_default_PointerTons1__Item(soap, &((ns1__ItemChanges*)this)->_delete);
	soap_default_PointerTons1__Item(soap, &((ns1__ItemChanges*)this)->update);
	/* transient soap skipped */
}

int ns1__ItemChanges::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ItemChanges);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ItemChanges::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ItemChanges(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemChanges(struct soap *soap, const char *tag, int id, const ns1__ItemChanges *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemChanges), "ns1:ItemChanges");
	soap_out_PointerTons1__Item(soap, "add", -1, &(((ns1__ItemChanges*)a)->add), "ns1:Item");
	soap_out_PointerTons1__Item(soap, "delete", -1, &(((ns1__ItemChanges*)a)->_delete), "ns1:Item");
	soap_out_PointerTons1__Item(soap, "update", -1, &(((ns1__ItemChanges*)a)->update), "ns1:Item");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ItemChanges::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ItemChanges(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ItemChanges * SOAP_FMAC4 soap_get_ns1__ItemChanges(struct soap *soap, ns1__ItemChanges *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemChanges(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ItemChanges::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ItemChanges(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ItemChanges * SOAP_FMAC4 soap_in_ns1__ItemChanges(struct soap *soap, const char *tag, ns1__ItemChanges *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ItemChanges *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemChanges, sizeof(ns1__ItemChanges), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ItemChanges)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ItemChanges *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_add1 = 1, soap_flag_delete1 = 1, soap_flag_update1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_add1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Item(soap, "add", &(((ns1__ItemChanges*)a)->add), "ns1:Item"))
				{	soap_flag_add1 = 0;
					continue;
				}

			if (soap_flag_delete1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Item(soap, "delete", &(((ns1__ItemChanges*)a)->_delete), "ns1:Item"))
				{	soap_flag_delete1 = 0;
					continue;
				}

			if (soap_flag_update1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Item(soap, "update", &(((ns1__ItemChanges*)a)->update), "ns1:Item"))
				{	soap_flag_update1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__ItemChanges *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemChanges, sizeof(ns1__ItemChanges), soap->type, soap->arrayType), SOAP_TYPE_ns1__ItemChanges, sizeof(ns1__ItemChanges));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ItemChanges * SOAP_FMAC6 soap_new_ns1__ItemChanges(struct soap *soap, int n)
{	return soap_instantiate_ns1__ItemChanges(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ItemChanges(struct soap *soap, ns1__ItemChanges *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ItemChanges * SOAP_FMAC6 soap_instantiate_ns1__ItemChanges(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ItemChanges(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ItemChanges, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ItemChanges;
		if (size)
			*size = sizeof(ns1__ItemChanges);
		((ns1__ItemChanges*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ItemChanges[n];
		if (size)
			*size = n * sizeof(ns1__ItemChanges);
		for (int i = 0; i < n; i++)
			((ns1__ItemChanges*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ItemChanges*)cp->ptr;
}

void ns1__Item::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Item))
		this->soap_mark(soap);
}

void ns1__Item::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__Item::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__Item::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Item);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Item::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Item(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Item(struct soap *soap, const char *tag, int id, const ns1__Item *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Item), "ns1:Item");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Item::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Item(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Item * SOAP_FMAC4 soap_get_ns1__Item(struct soap *soap, ns1__Item *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Item(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Item::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Item(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Item * SOAP_FMAC4 soap_in_ns1__Item(struct soap *soap, const char *tag, ns1__Item *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Item *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Item, sizeof(ns1__Item), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Item)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Item *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_name1 = 1, soap_flag_version1 = 1, soap_flag_modified1 = 1, soap_flag_changes1 = 1, soap_flag_type1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name1 = 0;
					continue;
				}

			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version1 = 0;
					continue;
				}

			if (soap_flag_modified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified1 = 0;
					continue;
				}

			if (soap_flag_changes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes1 = 0;
					continue;
				}

			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Item *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Item, sizeof(ns1__Item), soap->type, soap->arrayType), SOAP_TYPE_ns1__Item, sizeof(ns1__Item));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Item * SOAP_FMAC6 soap_new_ns1__Item(struct soap *soap, int n)
{	return soap_instantiate_ns1__Item(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Item(struct soap *soap, ns1__Item *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Item * SOAP_FMAC6 soap_instantiate_ns1__Item(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Item(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Item, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:AddressBook"))
	{	cp->type = SOAP_TYPE_ns1__AddressBook;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__AddressBook;
			if (size)
				*size = sizeof(ns1__AddressBook);
			((ns1__AddressBook*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__AddressBook[n];
			if (size)
				*size = n * sizeof(ns1__AddressBook);
			for (int i = 0; i < n; i++)
				((ns1__AddressBook*)cp->ptr)[i].soap = soap;
		}
		return (ns1__AddressBook*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Category"))
	{	cp->type = SOAP_TYPE_ns1__Category;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Category;
			if (size)
				*size = sizeof(ns1__Category);
			((ns1__Category*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Category[n];
			if (size)
				*size = n * sizeof(ns1__Category);
			for (int i = 0; i < n; i++)
				((ns1__Category*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Category*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ContainerItem"))
	{	cp->type = SOAP_TYPE_ns1__ContainerItem;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ContainerItem;
			if (size)
				*size = sizeof(ns1__ContainerItem);
			((ns1__ContainerItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ContainerItem[n];
			if (size)
				*size = n * sizeof(ns1__ContainerItem);
			for (int i = 0; i < n; i++)
				((ns1__ContainerItem*)cp->ptr)[i].soap = soap;
		}
		return (ns1__ContainerItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Folder"))
	{	cp->type = SOAP_TYPE_ns1__Folder;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Folder;
			if (size)
				*size = sizeof(ns1__Folder);
			((ns1__Folder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Folder[n];
			if (size)
				*size = n * sizeof(ns1__Folder);
			for (int i = 0; i < n; i++)
				((ns1__Folder*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Folder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:AddressBookItem"))
	{	cp->type = SOAP_TYPE_ns1__AddressBookItem;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__AddressBookItem;
			if (size)
				*size = sizeof(ns1__AddressBookItem);
			((ns1__AddressBookItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__AddressBookItem[n];
			if (size)
				*size = n * sizeof(ns1__AddressBookItem);
			for (int i = 0; i < n; i++)
				((ns1__AddressBookItem*)cp->ptr)[i].soap = soap;
		}
		return (ns1__AddressBookItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:BoxEntry"))
	{	cp->type = SOAP_TYPE_ns1__BoxEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__BoxEntry;
			if (size)
				*size = sizeof(ns1__BoxEntry);
			((ns1__BoxEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__BoxEntry[n];
			if (size)
				*size = n * sizeof(ns1__BoxEntry);
			for (int i = 0; i < n; i++)
				((ns1__BoxEntry*)cp->ptr)[i].soap = soap;
		}
		return (ns1__BoxEntry*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:QueryFolder"))
	{	cp->type = SOAP_TYPE_ns1__QueryFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__QueryFolder;
			if (size)
				*size = sizeof(ns1__QueryFolder);
			((ns1__QueryFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__QueryFolder[n];
			if (size)
				*size = n * sizeof(ns1__QueryFolder);
			for (int i = 0; i < n; i++)
				((ns1__QueryFolder*)cp->ptr)[i].soap = soap;
		}
		return (ns1__QueryFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SharedFolder"))
	{	cp->type = SOAP_TYPE_ns1__SharedFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__SharedFolder;
			if (size)
				*size = sizeof(ns1__SharedFolder);
			((ns1__SharedFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__SharedFolder[n];
			if (size)
				*size = n * sizeof(ns1__SharedFolder);
			for (int i = 0; i < n; i++)
				((ns1__SharedFolder*)cp->ptr)[i].soap = soap;
		}
		return (ns1__SharedFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SystemFolder"))
	{	cp->type = SOAP_TYPE_ns1__SystemFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__SystemFolder;
			if (size)
				*size = sizeof(ns1__SystemFolder);
			((ns1__SystemFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__SystemFolder[n];
			if (size)
				*size = n * sizeof(ns1__SystemFolder);
			for (int i = 0; i < n; i++)
				((ns1__SystemFolder*)cp->ptr)[i].soap = soap;
		}
		return (ns1__SystemFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Contact"))
	{	cp->type = SOAP_TYPE_ns1__Contact;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Contact;
			if (size)
				*size = sizeof(ns1__Contact);
			((ns1__Contact*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Contact[n];
			if (size)
				*size = n * sizeof(ns1__Contact);
			for (int i = 0; i < n; i++)
				((ns1__Contact*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Contact*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ContactFolder"))
	{	cp->type = SOAP_TYPE_ns1__ContactFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ContactFolder;
			if (size)
				*size = sizeof(ns1__ContactFolder);
			((ns1__ContactFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ContactFolder[n];
			if (size)
				*size = n * sizeof(ns1__ContactFolder);
			for (int i = 0; i < n; i++)
				((ns1__ContactFolder*)cp->ptr)[i].soap = soap;
		}
		return (ns1__ContactFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Group"))
	{	cp->type = SOAP_TYPE_ns1__Group;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Group;
			if (size)
				*size = sizeof(ns1__Group);
			((ns1__Group*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Group[n];
			if (size)
				*size = n * sizeof(ns1__Group);
			for (int i = 0; i < n; i++)
				((ns1__Group*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Group*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Mail"))
	{	cp->type = SOAP_TYPE_ns1__Mail;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Mail;
			if (size)
				*size = sizeof(ns1__Mail);
			((ns1__Mail*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Mail[n];
			if (size)
				*size = n * sizeof(ns1__Mail);
			for (int i = 0; i < n; i++)
				((ns1__Mail*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Mail*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Organization"))
	{	cp->type = SOAP_TYPE_ns1__Organization;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Organization;
			if (size)
				*size = sizeof(ns1__Organization);
			((ns1__Organization*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Organization[n];
			if (size)
				*size = n * sizeof(ns1__Organization);
			for (int i = 0; i < n; i++)
				((ns1__Organization*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Organization*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Resource"))
	{	cp->type = SOAP_TYPE_ns1__Resource;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Resource;
			if (size)
				*size = sizeof(ns1__Resource);
			((ns1__Resource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Resource[n];
			if (size)
				*size = n * sizeof(ns1__Resource);
			for (int i = 0; i < n; i++)
				((ns1__Resource*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Resource*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:CalendarItem"))
	{	cp->type = SOAP_TYPE_ns1__CalendarItem;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__CalendarItem;
			if (size)
				*size = sizeof(ns1__CalendarItem);
			((ns1__CalendarItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__CalendarItem[n];
			if (size)
				*size = n * sizeof(ns1__CalendarItem);
			for (int i = 0; i < n; i++)
				((ns1__CalendarItem*)cp->ptr)[i].soap = soap;
		}
		return (ns1__CalendarItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:DocumentRef"))
	{	cp->type = SOAP_TYPE_ns1__DocumentRef;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__DocumentRef;
			if (size)
				*size = sizeof(ns1__DocumentRef);
			((ns1__DocumentRef*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__DocumentRef[n];
			if (size)
				*size = n * sizeof(ns1__DocumentRef);
			for (int i = 0; i < n; i++)
				((ns1__DocumentRef*)cp->ptr)[i].soap = soap;
		}
		return (ns1__DocumentRef*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:PhoneMessage"))
	{	cp->type = SOAP_TYPE_ns1__PhoneMessage;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__PhoneMessage;
			if (size)
				*size = sizeof(ns1__PhoneMessage);
			((ns1__PhoneMessage*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__PhoneMessage[n];
			if (size)
				*size = n * sizeof(ns1__PhoneMessage);
			for (int i = 0; i < n; i++)
				((ns1__PhoneMessage*)cp->ptr)[i].soap = soap;
		}
		return (ns1__PhoneMessage*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Appointment"))
	{	cp->type = SOAP_TYPE_ns1__Appointment;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Appointment;
			if (size)
				*size = sizeof(ns1__Appointment);
			((ns1__Appointment*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Appointment[n];
			if (size)
				*size = n * sizeof(ns1__Appointment);
			for (int i = 0; i < n; i++)
				((ns1__Appointment*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Appointment*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Note"))
	{	cp->type = SOAP_TYPE_ns1__Note;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Note;
			if (size)
				*size = sizeof(ns1__Note);
			((ns1__Note*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Note[n];
			if (size)
				*size = n * sizeof(ns1__Note);
			for (int i = 0; i < n; i++)
				((ns1__Note*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Note*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Task"))
	{	cp->type = SOAP_TYPE_ns1__Task;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Task;
			if (size)
				*size = sizeof(ns1__Task);
			((ns1__Task*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Task[n];
			if (size)
				*size = n * sizeof(ns1__Task);
			for (int i = 0; i < n; i++)
				((ns1__Task*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Task*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Item;
		if (size)
			*size = sizeof(ns1__Item);
		((ns1__Item*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Item[n];
		if (size)
			*size = n * sizeof(ns1__Item);
		for (int i = 0; i < n; i++)
			((ns1__Item*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Item*)cp->ptr;
}

void ns1__ImAddressList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ImAddressList))
		this->soap_mark(soap);
}

void ns1__ImAddressList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ImAddressList*)this)->im, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ImAddress);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(soap, &((ns1__ImAddressList*)this)->im);
	/* transient soap skipped */
}

void ns1__ImAddressList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(soap, &((ns1__ImAddressList*)this)->im);
	/* transient soap skipped */
}

int ns1__ImAddressList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ImAddressList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ImAddressList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ImAddressList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ImAddressList(struct soap *soap, const char *tag, int id, const ns1__ImAddressList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ImAddressList), "ns1:ImAddressList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(soap, "im", -1, &(((ns1__ImAddressList*)a)->im), "ns1:ImAddress");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ImAddressList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ImAddressList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ImAddressList * SOAP_FMAC4 soap_get_ns1__ImAddressList(struct soap *soap, ns1__ImAddressList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ImAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ImAddressList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ImAddressList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ImAddressList * SOAP_FMAC4 soap_in_ns1__ImAddressList(struct soap *soap, const char *tag, ns1__ImAddressList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ImAddressList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ImAddressList, sizeof(ns1__ImAddressList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ImAddressList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ImAddressList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(soap, "im", &(((ns1__ImAddressList*)a)->im), "ns1:ImAddress"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__ImAddressList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ImAddressList, sizeof(ns1__ImAddressList), soap->type, soap->arrayType), SOAP_TYPE_ns1__ImAddressList, sizeof(ns1__ImAddressList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ImAddressList * SOAP_FMAC6 soap_new_ns1__ImAddressList(struct soap *soap, int n)
{	return soap_instantiate_ns1__ImAddressList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ImAddressList(struct soap *soap, ns1__ImAddressList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ImAddressList * SOAP_FMAC6 soap_instantiate_ns1__ImAddressList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ImAddressList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ImAddressList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ImAddressList;
		if (size)
			*size = sizeof(ns1__ImAddressList);
		((ns1__ImAddressList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ImAddressList[n];
		if (size)
			*size = n * sizeof(ns1__ImAddressList);
		for (int i = 0; i < n; i++)
			((ns1__ImAddressList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ImAddressList*)cp->ptr;
}

void ns1__ImAddress::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ImAddress))
		this->soap_mark(soap);
}

void ns1__ImAddress::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ImAddress*)this)->service, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__ImAddress*)this)->service);
	soap_embedded(soap, &((ns1__ImAddress*)this)->address, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__ImAddress*)this)->address);
	soap_embedded(soap, &((ns1__ImAddress*)this)->type, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__ImAddress*)this)->type);
	/* transient soap skipped */
}

void ns1__ImAddress::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__ImAddress*)this)->service);
	soap_default_std__string(soap, &((ns1__ImAddress*)this)->address);
	soap_default_std__string(soap, &((ns1__ImAddress*)this)->type);
	/* transient soap skipped */
}

int ns1__ImAddress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ImAddress);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ImAddress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ImAddress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ImAddress(struct soap *soap, const char *tag, int id, const ns1__ImAddress *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ImAddress), "ns1:ImAddress");
	soap_out_std__string(soap, "service", -1, &(((ns1__ImAddress*)a)->service), "xsd:string");
	soap_out_std__string(soap, "address", -1, &(((ns1__ImAddress*)a)->address), "xsd:string");
	soap_out_std__string(soap, "type", -1, &(((ns1__ImAddress*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ImAddress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ImAddress(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ImAddress * SOAP_FMAC4 soap_get_ns1__ImAddress(struct soap *soap, ns1__ImAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ImAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ImAddress::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ImAddress(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ImAddress * SOAP_FMAC4 soap_in_ns1__ImAddress(struct soap *soap, const char *tag, ns1__ImAddress *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ImAddress *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ImAddress, sizeof(ns1__ImAddress), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ImAddress)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ImAddress *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_service1 = 1, soap_flag_address1 = 1, soap_flag_type1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_service1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "service", &(((ns1__ImAddress*)a)->service), "xsd:string"))
				{	soap_flag_service1 = 0;
					continue;
				}

			if (soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "address", &(((ns1__ImAddress*)a)->address), "xsd:string"))
				{	soap_flag_address1 = 0;
					continue;
				}

			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "type", &(((ns1__ImAddress*)a)->type), "xsd:string"))
				{	soap_flag_type1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_service1 || soap_flag_address1 || soap_flag_type1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__ImAddress *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ImAddress, sizeof(ns1__ImAddress), soap->type, soap->arrayType), SOAP_TYPE_ns1__ImAddress, sizeof(ns1__ImAddress));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ImAddress * SOAP_FMAC6 soap_new_ns1__ImAddress(struct soap *soap, int n)
{	return soap_instantiate_ns1__ImAddress(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ImAddress(struct soap *soap, ns1__ImAddress *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ImAddress * SOAP_FMAC6 soap_instantiate_ns1__ImAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ImAddress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ImAddress, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ImAddress;
		if (size)
			*size = sizeof(ns1__ImAddress);
		((ns1__ImAddress*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ImAddress[n];
		if (size)
			*size = n * sizeof(ns1__ImAddress);
		for (int i = 0; i < n; i++)
			((ns1__ImAddress*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ImAddress*)cp->ptr;
}

void ns1__GroupMemberList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__GroupMemberList))
		this->soap_mark(soap);
}

void ns1__GroupMemberList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__GroupMemberList*)this)->member, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__GroupMember);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(soap, &((ns1__GroupMemberList*)this)->member);
	/* transient soap skipped */
}

void ns1__GroupMemberList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(soap, &((ns1__GroupMemberList*)this)->member);
	/* transient soap skipped */
}

int ns1__GroupMemberList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__GroupMemberList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__GroupMemberList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GroupMemberList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GroupMemberList(struct soap *soap, const char *tag, int id, const ns1__GroupMemberList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GroupMemberList), "ns1:GroupMemberList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(soap, "member", -1, &(((ns1__GroupMemberList*)a)->member), "ns1:GroupMember");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__GroupMemberList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GroupMemberList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GroupMemberList * SOAP_FMAC4 soap_get_ns1__GroupMemberList(struct soap *soap, ns1__GroupMemberList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GroupMemberList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__GroupMemberList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GroupMemberList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GroupMemberList * SOAP_FMAC4 soap_in_ns1__GroupMemberList(struct soap *soap, const char *tag, ns1__GroupMemberList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__GroupMemberList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GroupMemberList, sizeof(ns1__GroupMemberList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__GroupMemberList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__GroupMemberList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(soap, "member", &(((ns1__GroupMemberList*)a)->member), "ns1:GroupMember"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__GroupMemberList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GroupMemberList, sizeof(ns1__GroupMemberList), soap->type, soap->arrayType), SOAP_TYPE_ns1__GroupMemberList, sizeof(ns1__GroupMemberList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__GroupMemberList * SOAP_FMAC6 soap_new_ns1__GroupMemberList(struct soap *soap, int n)
{	return soap_instantiate_ns1__GroupMemberList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__GroupMemberList(struct soap *soap, ns1__GroupMemberList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__GroupMemberList * SOAP_FMAC6 soap_instantiate_ns1__GroupMemberList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GroupMemberList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GroupMemberList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__GroupMemberList;
		if (size)
			*size = sizeof(ns1__GroupMemberList);
		((ns1__GroupMemberList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__GroupMemberList[n];
		if (size)
			*size = n * sizeof(ns1__GroupMemberList);
		for (int i = 0; i < n; i++)
			((ns1__GroupMemberList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__GroupMemberList*)cp->ptr;
}

void ns1__GroupMember::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__GroupMember))
		this->soap_mark(soap);
}

void ns1__GroupMember::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__GroupMember*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__GroupMember*)this)->id);
	soap_embedded(soap, &((ns1__GroupMember*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__GroupMember*)this)->name);
	soap_embedded(soap, &((ns1__GroupMember*)this)->email, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__GroupMember*)this)->email);
	soap_embedded(soap, &((ns1__GroupMember*)this)->distType, SOAP_TYPE_ns1__DistributionType);
	soap_embedded(soap, &((ns1__GroupMember*)this)->itemType, SOAP_TYPE_ns1__ContactType);
	/* transient soap skipped */
}

void ns1__GroupMember::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((ns1__GroupMember*)this)->id);
	soap_default_std__string(soap, &((ns1__GroupMember*)this)->name);
	soap_default_std__string(soap, &((ns1__GroupMember*)this)->email);
	((ns1__GroupMember*)this)->distType = (enum ns1__DistributionType)0;
	((ns1__GroupMember*)this)->itemType = (enum ns1__ContactType)0;
	/* transient soap skipped */
}

int ns1__GroupMember::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__GroupMember);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__GroupMember::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GroupMember(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GroupMember(struct soap *soap, const char *tag, int id, const ns1__GroupMember *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GroupMember), "ns1:GroupMember");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__GroupMember*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__GroupMember*)a)->name), "xsd:string");
	soap_out_std__string(soap, "email", -1, &(((ns1__GroupMember*)a)->email), "xsd:string");
	soap_out_ns1__DistributionType(soap, "distType", -1, &(((ns1__GroupMember*)a)->distType), "ns1:DistributionType");
	soap_out_ns1__ContactType(soap, "itemType", -1, &(((ns1__GroupMember*)a)->itemType), "ns1:ContactType");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__GroupMember::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GroupMember(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GroupMember * SOAP_FMAC4 soap_get_ns1__GroupMember(struct soap *soap, ns1__GroupMember *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GroupMember(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__GroupMember::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GroupMember(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GroupMember * SOAP_FMAC4 soap_in_ns1__GroupMember(struct soap *soap, const char *tag, ns1__GroupMember *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__GroupMember *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GroupMember, sizeof(ns1__GroupMember), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__GroupMember)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__GroupMember *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_name1 = 1, soap_flag_email1 = 1, soap_flag_distType1 = 1, soap_flag_itemType1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__GroupMember*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__GroupMember*)a)->name), "xsd:string"))
				{	soap_flag_name1 = 0;
					continue;
				}

			if (soap_flag_email1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "email", &(((ns1__GroupMember*)a)->email), "xsd:string"))
				{	soap_flag_email1 = 0;
					continue;
				}

			if (soap_flag_distType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__DistributionType(soap, "distType", &(((ns1__GroupMember*)a)->distType), "ns1:DistributionType"))
				{	soap_flag_distType1 = 0;
					continue;
				}

			if (soap_flag_itemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__ContactType(soap, "itemType", &(((ns1__GroupMember*)a)->itemType), "ns1:ContactType"))
				{	soap_flag_itemType1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_email1 || soap_flag_distType1 || soap_flag_itemType1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__GroupMember *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GroupMember, sizeof(ns1__GroupMember), soap->type, soap->arrayType), SOAP_TYPE_ns1__GroupMember, sizeof(ns1__GroupMember));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__GroupMember * SOAP_FMAC6 soap_new_ns1__GroupMember(struct soap *soap, int n)
{	return soap_instantiate_ns1__GroupMember(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__GroupMember(struct soap *soap, ns1__GroupMember *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__GroupMember * SOAP_FMAC6 soap_instantiate_ns1__GroupMember(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GroupMember(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GroupMember, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__GroupMember;
		if (size)
			*size = sizeof(ns1__GroupMember);
		((ns1__GroupMember*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__GroupMember[n];
		if (size)
			*size = n * sizeof(ns1__GroupMember);
		for (int i = 0; i < n; i++)
			((ns1__GroupMember*)cp->ptr)[i].soap = soap;
	}
	return (ns1__GroupMember*)cp->ptr;
}

void ns1__Group::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Group))
		this->soap_mark(soap);
}

void ns1__Group::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Group*)this)->members, SOAP_TYPE_PointerTons1__GroupMemberList);
	soap_mark_PointerTons1__GroupMemberList(soap, &((ns1__Group*)this)->members);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__AddressBookItem*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__AddressBookItem*)this)->uuid);
	soap_embedded(soap, &((ns1__AddressBookItem*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__AddressBookItem*)this)->comment);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__Group::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__GroupMemberList(soap, &((ns1__Group*)this)->members);
	/* transient soap skipped */
	soap_default_ns1__UUID(soap, &((ns1__AddressBookItem*)this)->uuid);
	soap_default_PointerTostd__string(soap, &((ns1__AddressBookItem*)this)->comment);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__Group::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Group);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Group::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Group(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Group(struct soap *soap, const char *tag, int id, const ns1__Group *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Group), "ns1:Group");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__AddressBookItem*)a)->uuid), "ns1:UUID");
	soap_out_PointerTostd__string(soap, "comment", -1, &(((ns1__AddressBookItem*)a)->comment), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTons1__GroupMemberList(soap, "members", -1, &(((ns1__Group*)a)->members), "ns1:GroupMemberList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Group::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Group(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Group * SOAP_FMAC4 soap_get_ns1__Group(struct soap *soap, ns1__Group *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Group(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Group::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Group(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Group * SOAP_FMAC4 soap_in_ns1__Group(struct soap *soap, const char *tag, ns1__Group *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Group *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Group, sizeof(ns1__Group), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Group)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Group *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_type4 = 1, soap_flag_categories3 = 1, soap_flag_created3 = 1, soap_flag_customs3 = 1, soap_flag_uuid2 = 1, soap_flag_comment2 = 1, soap_flag_members1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}

			if (soap_flag_name4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name4 = 0;
					continue;
				}

			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}

			if (soap_flag_modified4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}

			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}

			if (soap_flag_type4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories3 = 0;
					continue;
				}

			if (soap_flag_created3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created3 = 0;
					continue;
				}

			if (soap_flag_customs3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_uuid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__AddressBookItem*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}

			if (soap_flag_comment2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "comment", &(((ns1__AddressBookItem*)a)->comment), "xsd:string"))
				{	soap_flag_comment2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_members1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GroupMemberList(soap, "members", &(((ns1__Group*)a)->members), "ns1:GroupMemberList"))
				{	soap_flag_members1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Group *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Group, sizeof(ns1__Group), soap->type, soap->arrayType), SOAP_TYPE_ns1__Group, sizeof(ns1__Group));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Group * SOAP_FMAC6 soap_new_ns1__Group(struct soap *soap, int n)
{	return soap_instantiate_ns1__Group(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Group(struct soap *soap, ns1__Group *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Group * SOAP_FMAC6 soap_instantiate_ns1__Group(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Group(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Group, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Group;
		if (size)
			*size = sizeof(ns1__Group);
		((ns1__Group*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Group[n];
		if (size)
			*size = n * sizeof(ns1__Group);
		for (int i = 0; i < n; i++)
			((ns1__Group*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Group*)cp->ptr;
}

void ns1__FullName::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FullName))
		this->soap_mark(soap);
}

void ns1__FullName::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FullName*)this)->displayName, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__FullName*)this)->displayName);
	soap_embedded(soap, &((ns1__FullName*)this)->namePrefix, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__FullName*)this)->namePrefix);
	soap_embedded(soap, &((ns1__FullName*)this)->firstName, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__FullName*)this)->firstName);
	soap_embedded(soap, &((ns1__FullName*)this)->middleName, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__FullName*)this)->middleName);
	soap_embedded(soap, &((ns1__FullName*)this)->lastName, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__FullName*)this)->lastName);
	soap_embedded(soap, &((ns1__FullName*)this)->nameSuffix, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__FullName*)this)->nameSuffix);
	/* transient soap skipped */
}

void ns1__FullName::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__FullName*)this)->displayName);
	soap_default_PointerTostd__string(soap, &((ns1__FullName*)this)->namePrefix);
	soap_default_PointerTostd__string(soap, &((ns1__FullName*)this)->firstName);
	soap_default_PointerTostd__string(soap, &((ns1__FullName*)this)->middleName);
	soap_default_PointerTostd__string(soap, &((ns1__FullName*)this)->lastName);
	soap_default_PointerTostd__string(soap, &((ns1__FullName*)this)->nameSuffix);
	/* transient soap skipped */
}

int ns1__FullName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FullName);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FullName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FullName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FullName(struct soap *soap, const char *tag, int id, const ns1__FullName *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FullName), "ns1:FullName");
	soap_out_std__string(soap, "displayName", -1, &(((ns1__FullName*)a)->displayName), "xsd:string");
	soap_out_PointerTostd__string(soap, "namePrefix", -1, &(((ns1__FullName*)a)->namePrefix), "xsd:string");
	soap_out_PointerTostd__string(soap, "firstName", -1, &(((ns1__FullName*)a)->firstName), "xsd:string");
	soap_out_PointerTostd__string(soap, "middleName", -1, &(((ns1__FullName*)a)->middleName), "xsd:string");
	soap_out_PointerTostd__string(soap, "lastName", -1, &(((ns1__FullName*)a)->lastName), "xsd:string");
	soap_out_PointerTostd__string(soap, "nameSuffix", -1, &(((ns1__FullName*)a)->nameSuffix), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FullName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FullName(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FullName * SOAP_FMAC4 soap_get_ns1__FullName(struct soap *soap, ns1__FullName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FullName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FullName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FullName(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FullName * SOAP_FMAC4 soap_in_ns1__FullName(struct soap *soap, const char *tag, ns1__FullName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FullName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FullName, sizeof(ns1__FullName), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FullName)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FullName *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_displayName1 = 1, soap_flag_namePrefix1 = 1, soap_flag_firstName1 = 1, soap_flag_middleName1 = 1, soap_flag_lastName1 = 1, soap_flag_nameSuffix1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_displayName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "displayName", &(((ns1__FullName*)a)->displayName), "xsd:string"))
				{	soap_flag_displayName1 = 0;
					continue;
				}

			if (soap_flag_namePrefix1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "namePrefix", &(((ns1__FullName*)a)->namePrefix), "xsd:string"))
				{	soap_flag_namePrefix1 = 0;
					continue;
				}

			if (soap_flag_firstName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "firstName", &(((ns1__FullName*)a)->firstName), "xsd:string"))
				{	soap_flag_firstName1 = 0;
					continue;
				}

			if (soap_flag_middleName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "middleName", &(((ns1__FullName*)a)->middleName), "xsd:string"))
				{	soap_flag_middleName1 = 0;
					continue;
				}

			if (soap_flag_lastName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "lastName", &(((ns1__FullName*)a)->lastName), "xsd:string"))
				{	soap_flag_lastName1 = 0;
					continue;
				}

			if (soap_flag_nameSuffix1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "nameSuffix", &(((ns1__FullName*)a)->nameSuffix), "xsd:string"))
				{	soap_flag_nameSuffix1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__FullName *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FullName, sizeof(ns1__FullName), soap->type, soap->arrayType), SOAP_TYPE_ns1__FullName, sizeof(ns1__FullName));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FullName * SOAP_FMAC6 soap_new_ns1__FullName(struct soap *soap, int n)
{	return soap_instantiate_ns1__FullName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FullName(struct soap *soap, ns1__FullName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FullName * SOAP_FMAC6 soap_instantiate_ns1__FullName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FullName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FullName, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FullName;
		if (size)
			*size = sizeof(ns1__FullName);
		((ns1__FullName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FullName[n];
		if (size)
			*size = n * sizeof(ns1__FullName);
		for (int i = 0; i < n; i++)
			((ns1__FullName*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FullName*)cp->ptr;
}

void ns1__From::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__From))
		this->soap_mark(soap);
}

void ns1__From::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__From*)this)->replyTo, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__From*)this)->replyTo);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->displayName, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->email, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ns1__From::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__string(soap, &((ns1__From*)this)->replyTo);
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_default_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

int ns1__From::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__From);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__From::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__From(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__From(struct soap *soap, const char *tag, int id, const ns1__From *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__From), "ns1:From");
	soap_out_std__string(soap, "displayName", -1, &(((ns1__NameAndEmail*)a)->displayName), "xsd:string");
	soap_out_std__string(soap, "email", -1, &(((ns1__NameAndEmail*)a)->email), "xsd:string");
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "replyTo", -1, &(((ns1__From*)a)->replyTo), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__From::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__From(soap, this, tag, type);
}

SOAP_FMAC3 ns1__From * SOAP_FMAC4 soap_get_ns1__From(struct soap *soap, ns1__From *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__From(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__From::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__From(soap, tag, this, type);
}

SOAP_FMAC3 ns1__From * SOAP_FMAC4 soap_in_ns1__From(struct soap *soap, const char *tag, ns1__From *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__From *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__From, sizeof(ns1__From), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__From)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__From *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_displayName2 = 1, soap_flag_email2 = 1, soap_flag_uuid2 = 1, soap_flag_replyTo1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_displayName2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "displayName", &(((ns1__NameAndEmail*)a)->displayName), "xsd:string"))
				{	soap_flag_displayName2 = 0;
					continue;
				}

			if (soap_flag_email2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "email", &(((ns1__NameAndEmail*)a)->email), "xsd:string"))
				{	soap_flag_email2 = 0;
					continue;
				}

			if (soap_flag_uuid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_replyTo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "replyTo", &(((ns1__From*)a)->replyTo), "xsd:string"))
				{	soap_flag_replyTo1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__From *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__From, sizeof(ns1__From), soap->type, soap->arrayType), SOAP_TYPE_ns1__From, sizeof(ns1__From));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__From * SOAP_FMAC6 soap_new_ns1__From(struct soap *soap, int n)
{	return soap_instantiate_ns1__From(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__From(struct soap *soap, ns1__From *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__From * SOAP_FMAC6 soap_instantiate_ns1__From(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__From(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__From, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__From;
		if (size)
			*size = sizeof(ns1__From);
		((ns1__From*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__From[n];
		if (size)
			*size = n * sizeof(ns1__From);
		for (int i = 0; i < n; i++)
			((ns1__From*)cp->ptr)[i].soap = soap;
	}
	return (ns1__From*)cp->ptr;
}

void ns1__FreeBusyUser::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FreeBusyUser))
		this->soap_mark(soap);
}

void ns1__FreeBusyUser::soap_mark(struct soap *soap) const
{
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->displayName, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->email, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ns1__FreeBusyUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_default_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

int ns1__FreeBusyUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FreeBusyUser);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FreeBusyUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FreeBusyUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FreeBusyUser(struct soap *soap, const char *tag, int id, const ns1__FreeBusyUser *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FreeBusyUser), "ns1:FreeBusyUser");
	soap_out_std__string(soap, "displayName", -1, &(((ns1__NameAndEmail*)a)->displayName), "xsd:string");
	soap_out_std__string(soap, "email", -1, &(((ns1__NameAndEmail*)a)->email), "xsd:string");
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID");
	/* transient soap skipped */
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FreeBusyUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FreeBusyUser(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FreeBusyUser * SOAP_FMAC4 soap_get_ns1__FreeBusyUser(struct soap *soap, ns1__FreeBusyUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FreeBusyUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FreeBusyUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FreeBusyUser(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FreeBusyUser * SOAP_FMAC4 soap_in_ns1__FreeBusyUser(struct soap *soap, const char *tag, ns1__FreeBusyUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FreeBusyUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyUser, sizeof(ns1__FreeBusyUser), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FreeBusyUser)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FreeBusyUser *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_displayName2 = 1, soap_flag_email2 = 1, soap_flag_uuid2 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_displayName2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "displayName", &(((ns1__NameAndEmail*)a)->displayName), "xsd:string"))
				{	soap_flag_displayName2 = 0;
					continue;
				}

			if (soap_flag_email2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "email", &(((ns1__NameAndEmail*)a)->email), "xsd:string"))
				{	soap_flag_email2 = 0;
					continue;
				}

			if (soap_flag_uuid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}

			/* transient soap skipped */
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__FreeBusyUser *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyUser, sizeof(ns1__FreeBusyUser), soap->type, soap->arrayType), SOAP_TYPE_ns1__FreeBusyUser, sizeof(ns1__FreeBusyUser));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FreeBusyUser * SOAP_FMAC6 soap_new_ns1__FreeBusyUser(struct soap *soap, int n)
{	return soap_instantiate_ns1__FreeBusyUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FreeBusyUser(struct soap *soap, ns1__FreeBusyUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FreeBusyUser * SOAP_FMAC6 soap_instantiate_ns1__FreeBusyUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FreeBusyUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FreeBusyUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:FreeBusyInfo"))
	{	cp->type = SOAP_TYPE_ns1__FreeBusyInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__FreeBusyInfo;
			if (size)
				*size = sizeof(ns1__FreeBusyInfo);
			((ns1__FreeBusyInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__FreeBusyInfo[n];
			if (size)
				*size = n * sizeof(ns1__FreeBusyInfo);
			for (int i = 0; i < n; i++)
				((ns1__FreeBusyInfo*)cp->ptr)[i].soap = soap;
		}
		return (ns1__FreeBusyInfo*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FreeBusyUser;
		if (size)
			*size = sizeof(ns1__FreeBusyUser);
		((ns1__FreeBusyUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FreeBusyUser[n];
		if (size)
			*size = n * sizeof(ns1__FreeBusyUser);
		for (int i = 0; i < n; i++)
			((ns1__FreeBusyUser*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FreeBusyUser*)cp->ptr;
}

void ns1__FreeBusyStats::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FreeBusyStats))
		this->soap_mark(soap);
}

void ns1__FreeBusyStats::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FreeBusyStats*)this)->responded, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__FreeBusyStats*)this)->outstanding, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__FreeBusyStats*)this)->total, SOAP_TYPE_int);
	/* transient soap skipped */
}

void ns1__FreeBusyStats::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ns1__FreeBusyStats*)this)->responded);
	soap_default_int(soap, &((ns1__FreeBusyStats*)this)->outstanding);
	soap_default_int(soap, &((ns1__FreeBusyStats*)this)->total);
	/* transient soap skipped */
}

int ns1__FreeBusyStats::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FreeBusyStats);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FreeBusyStats::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FreeBusyStats(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FreeBusyStats(struct soap *soap, const char *tag, int id, const ns1__FreeBusyStats *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FreeBusyStats), "ns1:FreeBusyStats");
	soap_out_int(soap, "responded", -1, &(((ns1__FreeBusyStats*)a)->responded), "");
	soap_out_int(soap, "outstanding", -1, &(((ns1__FreeBusyStats*)a)->outstanding), "");
	soap_out_int(soap, "total", -1, &(((ns1__FreeBusyStats*)a)->total), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FreeBusyStats::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FreeBusyStats(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FreeBusyStats * SOAP_FMAC4 soap_get_ns1__FreeBusyStats(struct soap *soap, ns1__FreeBusyStats *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FreeBusyStats(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FreeBusyStats::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FreeBusyStats(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FreeBusyStats * SOAP_FMAC4 soap_in_ns1__FreeBusyStats(struct soap *soap, const char *tag, ns1__FreeBusyStats *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FreeBusyStats *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyStats, sizeof(ns1__FreeBusyStats), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FreeBusyStats)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FreeBusyStats *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_responded1 = 1, soap_flag_outstanding1 = 1, soap_flag_total1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_responded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "responded", &(((ns1__FreeBusyStats*)a)->responded), ""))
				{	soap_flag_responded1 = 0;
					continue;
				}

			if (soap_flag_outstanding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "outstanding", &(((ns1__FreeBusyStats*)a)->outstanding), ""))
				{	soap_flag_outstanding1 = 0;
					continue;
				}

			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "total", &(((ns1__FreeBusyStats*)a)->total), ""))
				{	soap_flag_total1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responded1 || soap_flag_outstanding1 || soap_flag_total1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__FreeBusyStats *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyStats, sizeof(ns1__FreeBusyStats), soap->type, soap->arrayType), SOAP_TYPE_ns1__FreeBusyStats, sizeof(ns1__FreeBusyStats));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FreeBusyStats * SOAP_FMAC6 soap_new_ns1__FreeBusyStats(struct soap *soap, int n)
{	return soap_instantiate_ns1__FreeBusyStats(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FreeBusyStats(struct soap *soap, ns1__FreeBusyStats *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FreeBusyStats * SOAP_FMAC6 soap_instantiate_ns1__FreeBusyStats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FreeBusyStats(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FreeBusyStats, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FreeBusyStats;
		if (size)
			*size = sizeof(ns1__FreeBusyStats);
		((ns1__FreeBusyStats*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FreeBusyStats[n];
		if (size)
			*size = n * sizeof(ns1__FreeBusyStats);
		for (int i = 0; i < n; i++)
			((ns1__FreeBusyStats*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FreeBusyStats*)cp->ptr;
}

void ns1__FreeBusyInfoList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FreeBusyInfoList))
		this->soap_mark(soap);
}

void ns1__FreeBusyInfoList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FreeBusyInfoList*)this)->user, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, &((ns1__FreeBusyInfoList*)this)->user);
	/* transient soap skipped */
}

void ns1__FreeBusyInfoList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, &((ns1__FreeBusyInfoList*)this)->user);
	/* transient soap skipped */
}

int ns1__FreeBusyInfoList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FreeBusyInfoList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FreeBusyInfoList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FreeBusyInfoList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FreeBusyInfoList(struct soap *soap, const char *tag, int id, const ns1__FreeBusyInfoList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FreeBusyInfoList), "ns1:FreeBusyInfoList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, "user", -1, &(((ns1__FreeBusyInfoList*)a)->user), "ns1:FreeBusyInfo");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FreeBusyInfoList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FreeBusyInfoList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FreeBusyInfoList * SOAP_FMAC4 soap_get_ns1__FreeBusyInfoList(struct soap *soap, ns1__FreeBusyInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FreeBusyInfoList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FreeBusyInfoList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FreeBusyInfoList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FreeBusyInfoList * SOAP_FMAC4 soap_in_ns1__FreeBusyInfoList(struct soap *soap, const char *tag, ns1__FreeBusyInfoList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FreeBusyInfoList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyInfoList, sizeof(ns1__FreeBusyInfoList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FreeBusyInfoList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FreeBusyInfoList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, "user", &(((ns1__FreeBusyInfoList*)a)->user), "ns1:FreeBusyInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__FreeBusyInfoList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyInfoList, sizeof(ns1__FreeBusyInfoList), soap->type, soap->arrayType), SOAP_TYPE_ns1__FreeBusyInfoList, sizeof(ns1__FreeBusyInfoList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FreeBusyInfoList * SOAP_FMAC6 soap_new_ns1__FreeBusyInfoList(struct soap *soap, int n)
{	return soap_instantiate_ns1__FreeBusyInfoList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FreeBusyInfoList(struct soap *soap, ns1__FreeBusyInfoList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FreeBusyInfoList * SOAP_FMAC6 soap_instantiate_ns1__FreeBusyInfoList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FreeBusyInfoList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FreeBusyInfoList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FreeBusyInfoList;
		if (size)
			*size = sizeof(ns1__FreeBusyInfoList);
		((ns1__FreeBusyInfoList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FreeBusyInfoList[n];
		if (size)
			*size = n * sizeof(ns1__FreeBusyInfoList);
		for (int i = 0; i < n; i++)
			((ns1__FreeBusyInfoList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FreeBusyInfoList*)cp->ptr;
}

void ns1__FreeBusyUserList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FreeBusyUserList))
		this->soap_mark(soap);
}

void ns1__FreeBusyUserList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FreeBusyUserList*)this)->user, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(soap, &((ns1__FreeBusyUserList*)this)->user);
	/* transient soap skipped */
}

void ns1__FreeBusyUserList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(soap, &((ns1__FreeBusyUserList*)this)->user);
	/* transient soap skipped */
}

int ns1__FreeBusyUserList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FreeBusyUserList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FreeBusyUserList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FreeBusyUserList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FreeBusyUserList(struct soap *soap, const char *tag, int id, const ns1__FreeBusyUserList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FreeBusyUserList), "ns1:FreeBusyUserList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(soap, "user", -1, &(((ns1__FreeBusyUserList*)a)->user), "ns1:FreeBusyUser");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FreeBusyUserList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FreeBusyUserList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FreeBusyUserList * SOAP_FMAC4 soap_get_ns1__FreeBusyUserList(struct soap *soap, ns1__FreeBusyUserList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FreeBusyUserList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FreeBusyUserList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FreeBusyUserList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FreeBusyUserList * SOAP_FMAC4 soap_in_ns1__FreeBusyUserList(struct soap *soap, const char *tag, ns1__FreeBusyUserList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FreeBusyUserList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyUserList, sizeof(ns1__FreeBusyUserList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FreeBusyUserList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FreeBusyUserList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(soap, "user", &(((ns1__FreeBusyUserList*)a)->user), "ns1:FreeBusyUser"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__FreeBusyUserList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyUserList, sizeof(ns1__FreeBusyUserList), soap->type, soap->arrayType), SOAP_TYPE_ns1__FreeBusyUserList, sizeof(ns1__FreeBusyUserList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FreeBusyUserList * SOAP_FMAC6 soap_new_ns1__FreeBusyUserList(struct soap *soap, int n)
{	return soap_instantiate_ns1__FreeBusyUserList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FreeBusyUserList(struct soap *soap, ns1__FreeBusyUserList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FreeBusyUserList * SOAP_FMAC6 soap_instantiate_ns1__FreeBusyUserList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FreeBusyUserList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FreeBusyUserList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FreeBusyUserList;
		if (size)
			*size = sizeof(ns1__FreeBusyUserList);
		((ns1__FreeBusyUserList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FreeBusyUserList[n];
		if (size)
			*size = n * sizeof(ns1__FreeBusyUserList);
		for (int i = 0; i < n; i++)
			((ns1__FreeBusyUserList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FreeBusyUserList*)cp->ptr;
}

void ns1__FreeBusyInfo::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FreeBusyInfo))
		this->soap_mark(soap);
}

void ns1__FreeBusyInfo::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FreeBusyInfo*)this)->blocks, SOAP_TYPE_PointerTons1__FreeBusyBlockList);
	soap_mark_PointerTons1__FreeBusyBlockList(soap, &((ns1__FreeBusyInfo*)this)->blocks);
	/* transient soap skipped */
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->displayName, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->email, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ns1__FreeBusyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__FreeBusyBlockList(soap, &((ns1__FreeBusyInfo*)this)->blocks);
	/* transient soap skipped */
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_default_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

int ns1__FreeBusyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FreeBusyInfo);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FreeBusyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FreeBusyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FreeBusyInfo(struct soap *soap, const char *tag, int id, const ns1__FreeBusyInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FreeBusyInfo), "ns1:FreeBusyInfo");
	soap_out_std__string(soap, "displayName", -1, &(((ns1__NameAndEmail*)a)->displayName), "xsd:string");
	soap_out_std__string(soap, "email", -1, &(((ns1__NameAndEmail*)a)->email), "xsd:string");
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID");
	/* transient soap skipped */
	/* transient soap skipped */
	soap_out_PointerTons1__FreeBusyBlockList(soap, "blocks", -1, &(((ns1__FreeBusyInfo*)a)->blocks), "ns1:FreeBusyBlockList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FreeBusyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FreeBusyInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FreeBusyInfo * SOAP_FMAC4 soap_get_ns1__FreeBusyInfo(struct soap *soap, ns1__FreeBusyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FreeBusyInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FreeBusyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FreeBusyInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FreeBusyInfo * SOAP_FMAC4 soap_in_ns1__FreeBusyInfo(struct soap *soap, const char *tag, ns1__FreeBusyInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FreeBusyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyInfo, sizeof(ns1__FreeBusyInfo), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FreeBusyInfo)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FreeBusyInfo *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_displayName3 = 1, soap_flag_email3 = 1, soap_flag_uuid3 = 1, soap_flag_blocks1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_displayName3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "displayName", &(((ns1__NameAndEmail*)a)->displayName), "xsd:string"))
				{	soap_flag_displayName3 = 0;
					continue;
				}

			if (soap_flag_email3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "email", &(((ns1__NameAndEmail*)a)->email), "xsd:string"))
				{	soap_flag_email3 = 0;
					continue;
				}

			if (soap_flag_uuid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid3 = 0;
					continue;
				}

			/* transient soap skipped */
			/* transient soap skipped */
			if (soap_flag_blocks1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FreeBusyBlockList(soap, "blocks", &(((ns1__FreeBusyInfo*)a)->blocks), "ns1:FreeBusyBlockList"))
				{	soap_flag_blocks1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__FreeBusyInfo *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyInfo, sizeof(ns1__FreeBusyInfo), soap->type, soap->arrayType), SOAP_TYPE_ns1__FreeBusyInfo, sizeof(ns1__FreeBusyInfo));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FreeBusyInfo * SOAP_FMAC6 soap_new_ns1__FreeBusyInfo(struct soap *soap, int n)
{	return soap_instantiate_ns1__FreeBusyInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FreeBusyInfo(struct soap *soap, ns1__FreeBusyInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FreeBusyInfo * SOAP_FMAC6 soap_instantiate_ns1__FreeBusyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FreeBusyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FreeBusyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FreeBusyInfo;
		if (size)
			*size = sizeof(ns1__FreeBusyInfo);
		((ns1__FreeBusyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FreeBusyInfo[n];
		if (size)
			*size = n * sizeof(ns1__FreeBusyInfo);
		for (int i = 0; i < n; i++)
			((ns1__FreeBusyInfo*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FreeBusyInfo*)cp->ptr;
}

void ns1__FreeBusyBlock::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FreeBusyBlock))
		this->soap_mark(soap);
}

void ns1__FreeBusyBlock::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FreeBusyBlock*)this)->startDate, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__FreeBusyBlock*)this)->startDate);
	soap_embedded(soap, &((ns1__FreeBusyBlock*)this)->endDate, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__FreeBusyBlock*)this)->endDate);
	soap_embedded(soap, &((ns1__FreeBusyBlock*)this)->acceptLevel, SOAP_TYPE_ns1__AcceptLevel);
	soap_embedded(soap, &((ns1__FreeBusyBlock*)this)->subject, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__FreeBusyBlock*)this)->subject);
	/* transient soap skipped */
}

void ns1__FreeBusyBlock::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns1__FreeBusyBlock*)this)->startDate);
	soap_default_string(soap, &((ns1__FreeBusyBlock*)this)->endDate);
	soap_default_ns1__AcceptLevel(soap, &((ns1__FreeBusyBlock*)this)->acceptLevel);
	soap_default_std__string(soap, &((ns1__FreeBusyBlock*)this)->subject);
	/* transient soap skipped */
}

int ns1__FreeBusyBlock::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FreeBusyBlock);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FreeBusyBlock::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FreeBusyBlock(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FreeBusyBlock(struct soap *soap, const char *tag, int id, const ns1__FreeBusyBlock *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FreeBusyBlock), "ns1:FreeBusyBlock");
	soap_out_string(soap, "startDate", -1, &(((ns1__FreeBusyBlock*)a)->startDate), "");
	soap_out_string(soap, "endDate", -1, &(((ns1__FreeBusyBlock*)a)->endDate), "");
	soap_out_ns1__AcceptLevel(soap, "acceptLevel", -1, &(((ns1__FreeBusyBlock*)a)->acceptLevel), "ns1:AcceptLevel");
	soap_out_std__string(soap, "subject", -1, &(((ns1__FreeBusyBlock*)a)->subject), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FreeBusyBlock::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FreeBusyBlock(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FreeBusyBlock * SOAP_FMAC4 soap_get_ns1__FreeBusyBlock(struct soap *soap, ns1__FreeBusyBlock *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FreeBusyBlock(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FreeBusyBlock::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FreeBusyBlock(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FreeBusyBlock * SOAP_FMAC4 soap_in_ns1__FreeBusyBlock(struct soap *soap, const char *tag, ns1__FreeBusyBlock *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FreeBusyBlock *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyBlock, sizeof(ns1__FreeBusyBlock), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FreeBusyBlock)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FreeBusyBlock *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_startDate1 = 1, soap_flag_endDate1 = 1, soap_flag_acceptLevel1 = 1, soap_flag_subject1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "startDate", &(((ns1__FreeBusyBlock*)a)->startDate), ""))
				{	soap_flag_startDate1 = 0;
					continue;
				}

			if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "endDate", &(((ns1__FreeBusyBlock*)a)->endDate), ""))
				{	soap_flag_endDate1 = 0;
					continue;
				}

			if (soap_flag_acceptLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__AcceptLevel(soap, "acceptLevel", &(((ns1__FreeBusyBlock*)a)->acceptLevel), "ns1:AcceptLevel"))
				{	soap_flag_acceptLevel1 = 0;
					continue;
				}

			if (soap_flag_subject1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "subject", &(((ns1__FreeBusyBlock*)a)->subject), "xsd:string"))
				{	soap_flag_subject1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_acceptLevel1 || soap_flag_subject1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__FreeBusyBlock *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyBlock, sizeof(ns1__FreeBusyBlock), soap->type, soap->arrayType), SOAP_TYPE_ns1__FreeBusyBlock, sizeof(ns1__FreeBusyBlock));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FreeBusyBlock * SOAP_FMAC6 soap_new_ns1__FreeBusyBlock(struct soap *soap, int n)
{	return soap_instantiate_ns1__FreeBusyBlock(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FreeBusyBlock(struct soap *soap, ns1__FreeBusyBlock *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FreeBusyBlock * SOAP_FMAC6 soap_instantiate_ns1__FreeBusyBlock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FreeBusyBlock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FreeBusyBlock, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FreeBusyBlock;
		if (size)
			*size = sizeof(ns1__FreeBusyBlock);
		((ns1__FreeBusyBlock*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FreeBusyBlock[n];
		if (size)
			*size = n * sizeof(ns1__FreeBusyBlock);
		for (int i = 0; i < n; i++)
			((ns1__FreeBusyBlock*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FreeBusyBlock*)cp->ptr;
}

void ns1__FreeBusyBlockList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FreeBusyBlockList))
		this->soap_mark(soap);
}

void ns1__FreeBusyBlockList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FreeBusyBlockList*)this)->block, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, &((ns1__FreeBusyBlockList*)this)->block);
	/* transient soap skipped */
}

void ns1__FreeBusyBlockList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, &((ns1__FreeBusyBlockList*)this)->block);
	/* transient soap skipped */
}

int ns1__FreeBusyBlockList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FreeBusyBlockList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FreeBusyBlockList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FreeBusyBlockList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FreeBusyBlockList(struct soap *soap, const char *tag, int id, const ns1__FreeBusyBlockList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FreeBusyBlockList), "ns1:FreeBusyBlockList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, "block", -1, &(((ns1__FreeBusyBlockList*)a)->block), "ns1:FreeBusyBlock");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FreeBusyBlockList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FreeBusyBlockList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FreeBusyBlockList * SOAP_FMAC4 soap_get_ns1__FreeBusyBlockList(struct soap *soap, ns1__FreeBusyBlockList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FreeBusyBlockList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FreeBusyBlockList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FreeBusyBlockList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FreeBusyBlockList * SOAP_FMAC4 soap_in_ns1__FreeBusyBlockList(struct soap *soap, const char *tag, ns1__FreeBusyBlockList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FreeBusyBlockList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyBlockList, sizeof(ns1__FreeBusyBlockList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FreeBusyBlockList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FreeBusyBlockList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, "block", &(((ns1__FreeBusyBlockList*)a)->block), "ns1:FreeBusyBlock"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__FreeBusyBlockList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FreeBusyBlockList, sizeof(ns1__FreeBusyBlockList), soap->type, soap->arrayType), SOAP_TYPE_ns1__FreeBusyBlockList, sizeof(ns1__FreeBusyBlockList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FreeBusyBlockList * SOAP_FMAC6 soap_new_ns1__FreeBusyBlockList(struct soap *soap, int n)
{	return soap_instantiate_ns1__FreeBusyBlockList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FreeBusyBlockList(struct soap *soap, ns1__FreeBusyBlockList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FreeBusyBlockList * SOAP_FMAC6 soap_instantiate_ns1__FreeBusyBlockList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FreeBusyBlockList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FreeBusyBlockList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FreeBusyBlockList;
		if (size)
			*size = sizeof(ns1__FreeBusyBlockList);
		((ns1__FreeBusyBlockList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FreeBusyBlockList[n];
		if (size)
			*size = n * sizeof(ns1__FreeBusyBlockList);
		for (int i = 0; i < n; i++)
			((ns1__FreeBusyBlockList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FreeBusyBlockList*)cp->ptr;
}

void ns1__FolderList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FolderList))
		this->soap_mark(soap);
}

void ns1__FolderList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FolderList*)this)->folder, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Folder);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Folder(soap, &((ns1__FolderList*)this)->folder);
	/* transient soap skipped */
}

void ns1__FolderList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__Folder(soap, &((ns1__FolderList*)this)->folder);
	/* transient soap skipped */
}

int ns1__FolderList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FolderList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FolderList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FolderList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FolderList(struct soap *soap, const char *tag, int id, const ns1__FolderList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FolderList), "ns1:FolderList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Folder(soap, "folder", -1, &(((ns1__FolderList*)a)->folder), "ns1:Folder");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FolderList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FolderList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FolderList * SOAP_FMAC4 soap_get_ns1__FolderList(struct soap *soap, ns1__FolderList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FolderList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FolderList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FolderList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FolderList * SOAP_FMAC4 soap_in_ns1__FolderList(struct soap *soap, const char *tag, ns1__FolderList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FolderList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FolderList, sizeof(ns1__FolderList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FolderList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FolderList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__Folder(soap, "folder", &(((ns1__FolderList*)a)->folder), "ns1:Folder"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__FolderList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FolderList, sizeof(ns1__FolderList), soap->type, soap->arrayType), SOAP_TYPE_ns1__FolderList, sizeof(ns1__FolderList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FolderList * SOAP_FMAC6 soap_new_ns1__FolderList(struct soap *soap, int n)
{	return soap_instantiate_ns1__FolderList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FolderList(struct soap *soap, ns1__FolderList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FolderList * SOAP_FMAC6 soap_instantiate_ns1__FolderList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FolderList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FolderList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FolderList;
		if (size)
			*size = sizeof(ns1__FolderList);
		((ns1__FolderList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FolderList[n];
		if (size)
			*size = n * sizeof(ns1__FolderList);
		for (int i = 0; i < n; i++)
			((ns1__FolderList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FolderList*)cp->ptr;
}

void ns1__FolderACLEntry::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FolderACLEntry))
		this->soap_mark(soap);
}

void ns1__FolderACLEntry::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FolderACLEntry*)this)->status, SOAP_TYPE_ns1__FolderACLStatus);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__AccessControlListEntry*)this)->rights, SOAP_TYPE_PointerTons1__Rights);
	soap_mark_PointerTons1__Rights(soap, &((ns1__AccessControlListEntry*)this)->rights);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->displayName, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->email, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ns1__FolderACLEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__FolderACLStatus(soap, &((ns1__FolderACLEntry*)this)->status);
	/* transient soap skipped */
	soap_default_PointerTons1__Rights(soap, &((ns1__AccessControlListEntry*)this)->rights);
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_default_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

int ns1__FolderACLEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FolderACLEntry);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FolderACLEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FolderACLEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FolderACLEntry(struct soap *soap, const char *tag, int id, const ns1__FolderACLEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FolderACLEntry), "ns1:FolderACLEntry");
	soap_out_std__string(soap, "displayName", -1, &(((ns1__NameAndEmail*)a)->displayName), "xsd:string");
	soap_out_std__string(soap, "email", -1, &(((ns1__NameAndEmail*)a)->email), "xsd:string");
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID");
	/* transient soap skipped */
	soap_out_PointerTons1__Rights(soap, "rights", -1, &(((ns1__AccessControlListEntry*)a)->rights), "ns1:Rights");
	/* transient soap skipped */
	soap_out_ns1__FolderACLStatus(soap, "status", -1, &(((ns1__FolderACLEntry*)a)->status), "ns1:FolderACLStatus");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FolderACLEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FolderACLEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FolderACLEntry * SOAP_FMAC4 soap_get_ns1__FolderACLEntry(struct soap *soap, ns1__FolderACLEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FolderACLEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FolderACLEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FolderACLEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FolderACLEntry * SOAP_FMAC4 soap_in_ns1__FolderACLEntry(struct soap *soap, const char *tag, ns1__FolderACLEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FolderACLEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FolderACLEntry, sizeof(ns1__FolderACLEntry), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FolderACLEntry)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FolderACLEntry *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_displayName3 = 1, soap_flag_email3 = 1, soap_flag_uuid3 = 1, soap_flag_rights2 = 1, soap_flag_status1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_displayName3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "displayName", &(((ns1__NameAndEmail*)a)->displayName), "xsd:string"))
				{	soap_flag_displayName3 = 0;
					continue;
				}

			if (soap_flag_email3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "email", &(((ns1__NameAndEmail*)a)->email), "xsd:string"))
				{	soap_flag_email3 = 0;
					continue;
				}

			if (soap_flag_uuid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_rights2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Rights(soap, "rights", &(((ns1__AccessControlListEntry*)a)->rights), "ns1:Rights"))
				{	soap_flag_rights2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__FolderACLStatus(soap, "status", &(((ns1__FolderACLEntry*)a)->status), "ns1:FolderACLStatus"))
				{	soap_flag_status1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__FolderACLEntry *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FolderACLEntry, sizeof(ns1__FolderACLEntry), soap->type, soap->arrayType), SOAP_TYPE_ns1__FolderACLEntry, sizeof(ns1__FolderACLEntry));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FolderACLEntry * SOAP_FMAC6 soap_new_ns1__FolderACLEntry(struct soap *soap, int n)
{	return soap_instantiate_ns1__FolderACLEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FolderACLEntry(struct soap *soap, ns1__FolderACLEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FolderACLEntry * SOAP_FMAC6 soap_instantiate_ns1__FolderACLEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FolderACLEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FolderACLEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FolderACLEntry;
		if (size)
			*size = sizeof(ns1__FolderACLEntry);
		((ns1__FolderACLEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FolderACLEntry[n];
		if (size)
			*size = n * sizeof(ns1__FolderACLEntry);
		for (int i = 0; i < n; i++)
			((ns1__FolderACLEntry*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FolderACLEntry*)cp->ptr;
}

void ns1__FolderACL::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FolderACL))
		this->soap_mark(soap);
}

void ns1__FolderACL::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FolderACL*)this)->entry, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(soap, &((ns1__FolderACL*)this)->entry);
	/* transient soap skipped */
}

void ns1__FolderACL::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(soap, &((ns1__FolderACL*)this)->entry);
	/* transient soap skipped */
}

int ns1__FolderACL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FolderACL);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FolderACL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FolderACL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FolderACL(struct soap *soap, const char *tag, int id, const ns1__FolderACL *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FolderACL), "ns1:FolderACL");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(soap, "entry", -1, &(((ns1__FolderACL*)a)->entry), "ns1:FolderACLEntry");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FolderACL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FolderACL(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FolderACL * SOAP_FMAC4 soap_get_ns1__FolderACL(struct soap *soap, ns1__FolderACL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FolderACL(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FolderACL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FolderACL(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FolderACL * SOAP_FMAC4 soap_in_ns1__FolderACL(struct soap *soap, const char *tag, ns1__FolderACL *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FolderACL *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FolderACL, sizeof(ns1__FolderACL), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FolderACL)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FolderACL *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(soap, "entry", &(((ns1__FolderACL*)a)->entry), "ns1:FolderACLEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__FolderACL *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FolderACL, sizeof(ns1__FolderACL), soap->type, soap->arrayType), SOAP_TYPE_ns1__FolderACL, sizeof(ns1__FolderACL));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FolderACL * SOAP_FMAC6 soap_new_ns1__FolderACL(struct soap *soap, int n)
{	return soap_instantiate_ns1__FolderACL(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FolderACL(struct soap *soap, ns1__FolderACL *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FolderACL * SOAP_FMAC6 soap_instantiate_ns1__FolderACL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FolderACL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FolderACL, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FolderACL;
		if (size)
			*size = sizeof(ns1__FolderACL);
		((ns1__FolderACL*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FolderACL[n];
		if (size)
			*size = n * sizeof(ns1__FolderACL);
		for (int i = 0; i < n; i++)
			((ns1__FolderACL*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FolderACL*)cp->ptr;
}

void ns1__Folder::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Folder))
		this->soap_mark(soap);
}

void ns1__Folder::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Folder*)this)->parent, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Folder*)this)->parent);
	soap_embedded(soap, &((ns1__Folder*)this)->description, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Folder*)this)->description);
	soap_embedded(soap, &((ns1__Folder*)this)->count, SOAP_TYPE_PointerToint);
	soap_mark_PointerToint(soap, &((ns1__Folder*)this)->count);
	soap_embedded(soap, &((ns1__Folder*)this)->hasUnread, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Folder*)this)->hasUnread);
	soap_embedded(soap, &((ns1__Folder*)this)->unreadCount, SOAP_TYPE_PointerToint);
	soap_mark_PointerToint(soap, &((ns1__Folder*)this)->unreadCount);
	soap_embedded(soap, &((ns1__Folder*)this)->sequence, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Folder*)this)->settings, SOAP_TYPE_PointerTons1__uid);
	soap_mark_PointerTons1__uid(soap, &((ns1__Folder*)this)->settings);
	soap_embedded(soap, &((ns1__Folder*)this)->hasSubfolders, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Folder*)this)->hasSubfolders);
	soap_embedded(soap, &((ns1__Folder*)this)->notification, SOAP_TYPE_PointerTons1__SharedFolderNotification);
	soap_mark_PointerTons1__SharedFolderNotification(soap, &((ns1__Folder*)this)->notification);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__Folder::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((ns1__Folder*)this)->parent);
	soap_default_std__string(soap, &((ns1__Folder*)this)->description);
	soap_default_PointerToint(soap, &((ns1__Folder*)this)->count);
	soap_default_PointerTobool(soap, &((ns1__Folder*)this)->hasUnread);
	soap_default_PointerToint(soap, &((ns1__Folder*)this)->unreadCount);
	soap_default_unsignedLong(soap, &((ns1__Folder*)this)->sequence);
	soap_default_PointerTons1__uid(soap, &((ns1__Folder*)this)->settings);
	soap_default_PointerTobool(soap, &((ns1__Folder*)this)->hasSubfolders);
	soap_default_PointerTons1__SharedFolderNotification(soap, &((ns1__Folder*)this)->notification);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__Folder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Folder);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Folder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Folder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Folder(struct soap *soap, const char *tag, int id, const ns1__Folder *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Folder), "ns1:Folder");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_ns1__uid(soap, "parent", -1, &(((ns1__Folder*)a)->parent), "ns1:uid");
	soap_out_std__string(soap, "description", -1, &(((ns1__Folder*)a)->description), "xsd:string");
	soap_out_PointerToint(soap, "count", -1, &(((ns1__Folder*)a)->count), "");
	soap_out_PointerTobool(soap, "hasUnread", -1, &(((ns1__Folder*)a)->hasUnread), "");
	soap_out_PointerToint(soap, "unreadCount", -1, &(((ns1__Folder*)a)->unreadCount), "");
	soap_out_unsignedLong(soap, "sequence", -1, &(((ns1__Folder*)a)->sequence), "");
	soap_out_PointerTons1__uid(soap, "settings", -1, &(((ns1__Folder*)a)->settings), "ns1:uid");
	soap_out_PointerTobool(soap, "hasSubfolders", -1, &(((ns1__Folder*)a)->hasSubfolders), "");
	soap_out_PointerTons1__SharedFolderNotification(soap, "notification", -1, &(((ns1__Folder*)a)->notification), "ns1:SharedFolderNotification");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Folder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Folder(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Folder * SOAP_FMAC4 soap_get_ns1__Folder(struct soap *soap, ns1__Folder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Folder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Folder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Folder(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Folder * SOAP_FMAC4 soap_in_ns1__Folder(struct soap *soap, const char *tag, ns1__Folder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Folder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Folder, sizeof(ns1__Folder), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Folder)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Folder *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id2 = 1, soap_flag_name2 = 1, soap_flag_version2 = 1, soap_flag_modified2 = 1, soap_flag_changes2 = 1, soap_flag_type2 = 1, soap_flag_parent1 = 1, soap_flag_description1 = 1, soap_flag_count1 = 1, soap_flag_hasUnread1 = 1, soap_flag_unreadCount1 = 1, soap_flag_sequence1 = 1, soap_flag_settings1 = 1, soap_flag_hasSubfolders1 = 1, soap_flag_notification1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id2 = 0;
					continue;
				}

			if (soap_flag_name2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name2 = 0;
					continue;
				}

			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version2 = 0;
					continue;
				}

			if (soap_flag_modified2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified2 = 0;
					continue;
				}

			if (soap_flag_changes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes2 = 0;
					continue;
				}

			if (soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_parent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "parent", &(((ns1__Folder*)a)->parent), "ns1:uid"))
				{	soap_flag_parent1 = 0;
					continue;
				}

			if (soap_flag_description1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "description", &(((ns1__Folder*)a)->description), "xsd:string"))
				{	soap_flag_description1 = 0;
					continue;
				}

			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "count", &(((ns1__Folder*)a)->count), ""))
				{	soap_flag_count1 = 0;
					continue;
				}

			if (soap_flag_hasUnread1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasUnread", &(((ns1__Folder*)a)->hasUnread), ""))
				{	soap_flag_hasUnread1 = 0;
					continue;
				}

			if (soap_flag_unreadCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "unreadCount", &(((ns1__Folder*)a)->unreadCount), ""))
				{	soap_flag_unreadCount1 = 0;
					continue;
				}

			if (soap_flag_sequence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "sequence", &(((ns1__Folder*)a)->sequence), ""))
				{	soap_flag_sequence1 = 0;
					continue;
				}

			if (soap_flag_settings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__uid(soap, "settings", &(((ns1__Folder*)a)->settings), "ns1:uid"))
				{	soap_flag_settings1 = 0;
					continue;
				}

			if (soap_flag_hasSubfolders1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasSubfolders", &(((ns1__Folder*)a)->hasSubfolders), ""))
				{	soap_flag_hasSubfolders1 = 0;
					continue;
				}

			if (soap_flag_notification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SharedFolderNotification(soap, "notification", &(((ns1__Folder*)a)->notification), "ns1:SharedFolderNotification"))
				{	soap_flag_notification1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__Folder *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Folder, sizeof(ns1__Folder), soap->type, soap->arrayType), SOAP_TYPE_ns1__Folder, sizeof(ns1__Folder));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Folder * SOAP_FMAC6 soap_new_ns1__Folder(struct soap *soap, int n)
{	return soap_instantiate_ns1__Folder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Folder(struct soap *soap, ns1__Folder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Folder * SOAP_FMAC6 soap_instantiate_ns1__Folder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Folder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Folder, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:QueryFolder"))
	{	cp->type = SOAP_TYPE_ns1__QueryFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__QueryFolder;
			if (size)
				*size = sizeof(ns1__QueryFolder);
			((ns1__QueryFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__QueryFolder[n];
			if (size)
				*size = n * sizeof(ns1__QueryFolder);
			for (int i = 0; i < n; i++)
				((ns1__QueryFolder*)cp->ptr)[i].soap = soap;
		}
		return (ns1__QueryFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SharedFolder"))
	{	cp->type = SOAP_TYPE_ns1__SharedFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__SharedFolder;
			if (size)
				*size = sizeof(ns1__SharedFolder);
			((ns1__SharedFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__SharedFolder[n];
			if (size)
				*size = n * sizeof(ns1__SharedFolder);
			for (int i = 0; i < n; i++)
				((ns1__SharedFolder*)cp->ptr)[i].soap = soap;
		}
		return (ns1__SharedFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:SystemFolder"))
	{	cp->type = SOAP_TYPE_ns1__SystemFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__SystemFolder;
			if (size)
				*size = sizeof(ns1__SystemFolder);
			((ns1__SystemFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__SystemFolder[n];
			if (size)
				*size = n * sizeof(ns1__SystemFolder);
			for (int i = 0; i < n; i++)
				((ns1__SystemFolder*)cp->ptr)[i].soap = soap;
		}
		return (ns1__SystemFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ContactFolder"))
	{	cp->type = SOAP_TYPE_ns1__ContactFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__ContactFolder;
			if (size)
				*size = sizeof(ns1__ContactFolder);
			((ns1__ContactFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__ContactFolder[n];
			if (size)
				*size = n * sizeof(ns1__ContactFolder);
			for (int i = 0; i < n; i++)
				((ns1__ContactFolder*)cp->ptr)[i].soap = soap;
		}
		return (ns1__ContactFolder*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Folder;
		if (size)
			*size = sizeof(ns1__Folder);
		((ns1__Folder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Folder[n];
		if (size)
			*size = n * sizeof(ns1__Folder);
		for (int i = 0; i < n; i++)
			((ns1__Folder*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Folder*)cp->ptr;
}

void ns1__FilterGroup::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FilterGroup))
		this->soap_mark(soap);
}

void ns1__FilterGroup::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FilterGroup*)this)->element, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FilterElement);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(soap, &((ns1__FilterGroup*)this)->element);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__FilterElement*)this)->op, SOAP_TYPE_ns1__FilterOp);
	/* transient soap skipped */
}

void ns1__FilterGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(soap, &((ns1__FilterGroup*)this)->element);
	/* transient soap skipped */
	soap_default_ns1__FilterOp(soap, &((ns1__FilterElement*)this)->op);
	/* transient soap skipped */
}

int ns1__FilterGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FilterGroup);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FilterGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FilterGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FilterGroup(struct soap *soap, const char *tag, int id, const ns1__FilterGroup *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FilterGroup), "ns1:FilterGroup");
	soap_out_ns1__FilterOp(soap, "op", -1, &(((ns1__FilterElement*)a)->op), "ns1:FilterOp");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(soap, "element", -1, &(((ns1__FilterGroup*)a)->element), "ns1:FilterElement");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FilterGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FilterGroup(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FilterGroup * SOAP_FMAC4 soap_get_ns1__FilterGroup(struct soap *soap, ns1__FilterGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FilterGroup(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FilterGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FilterGroup(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FilterGroup * SOAP_FMAC4 soap_in_ns1__FilterGroup(struct soap *soap, const char *tag, ns1__FilterGroup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FilterGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FilterGroup, sizeof(ns1__FilterGroup), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FilterGroup)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FilterGroup *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_op2 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_op2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__FilterOp(soap, "op", &(((ns1__FilterElement*)a)->op), "ns1:FilterOp"))
				{	soap_flag_op2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(soap, "element", &(((ns1__FilterGroup*)a)->element), "ns1:FilterElement"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_op2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__FilterGroup *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FilterGroup, sizeof(ns1__FilterGroup), soap->type, soap->arrayType), SOAP_TYPE_ns1__FilterGroup, sizeof(ns1__FilterGroup));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FilterGroup * SOAP_FMAC6 soap_new_ns1__FilterGroup(struct soap *soap, int n)
{	return soap_instantiate_ns1__FilterGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FilterGroup(struct soap *soap, ns1__FilterGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FilterGroup * SOAP_FMAC6 soap_instantiate_ns1__FilterGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FilterGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FilterGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FilterGroup;
		if (size)
			*size = sizeof(ns1__FilterGroup);
		((ns1__FilterGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FilterGroup[n];
		if (size)
			*size = n * sizeof(ns1__FilterGroup);
		for (int i = 0; i < n; i++)
			((ns1__FilterGroup*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FilterGroup*)cp->ptr;
}

void ns1__FilterEntry::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FilterEntry))
		this->soap_mark(soap);
}

void ns1__FilterEntry::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FilterEntry*)this)->field, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__FilterEntry*)this)->field);
	soap_embedded(soap, &((ns1__FilterEntry*)this)->value, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__FilterEntry*)this)->value);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__FilterElement*)this)->op, SOAP_TYPE_ns1__FilterOp);
	/* transient soap skipped */
}

void ns1__FilterEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__FilterEntry*)this)->field);
	soap_default_std__string(soap, &((ns1__FilterEntry*)this)->value);
	/* transient soap skipped */
	soap_default_ns1__FilterOp(soap, &((ns1__FilterElement*)this)->op);
	/* transient soap skipped */
}

int ns1__FilterEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FilterEntry);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FilterEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FilterEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FilterEntry(struct soap *soap, const char *tag, int id, const ns1__FilterEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FilterEntry), "ns1:FilterEntry");
	soap_out_ns1__FilterOp(soap, "op", -1, &(((ns1__FilterElement*)a)->op), "ns1:FilterOp");
	/* transient soap skipped */
	soap_out_std__string(soap, "field", -1, &(((ns1__FilterEntry*)a)->field), "xsd:string");
	soap_out_std__string(soap, "value", -1, &(((ns1__FilterEntry*)a)->value), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FilterEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FilterEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FilterEntry * SOAP_FMAC4 soap_get_ns1__FilterEntry(struct soap *soap, ns1__FilterEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FilterEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FilterEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FilterEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FilterEntry * SOAP_FMAC4 soap_in_ns1__FilterEntry(struct soap *soap, const char *tag, ns1__FilterEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FilterEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FilterEntry, sizeof(ns1__FilterEntry), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FilterEntry)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FilterEntry *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_op2 = 1, soap_flag_field1 = 1, soap_flag_value1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_op2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__FilterOp(soap, "op", &(((ns1__FilterElement*)a)->op), "ns1:FilterOp"))
				{	soap_flag_op2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_field1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "field", &(((ns1__FilterEntry*)a)->field), "xsd:string"))
				{	soap_flag_field1 = 0;
					continue;
				}

			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "value", &(((ns1__FilterEntry*)a)->value), "xsd:string"))
				{	soap_flag_value1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_op2 || soap_flag_field1 || soap_flag_value1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__FilterEntry *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FilterEntry, sizeof(ns1__FilterEntry), soap->type, soap->arrayType), SOAP_TYPE_ns1__FilterEntry, sizeof(ns1__FilterEntry));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FilterEntry * SOAP_FMAC6 soap_new_ns1__FilterEntry(struct soap *soap, int n)
{	return soap_instantiate_ns1__FilterEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FilterEntry(struct soap *soap, ns1__FilterEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FilterEntry * SOAP_FMAC6 soap_instantiate_ns1__FilterEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FilterEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FilterEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FilterEntry;
		if (size)
			*size = sizeof(ns1__FilterEntry);
		((ns1__FilterEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FilterEntry[n];
		if (size)
			*size = n * sizeof(ns1__FilterEntry);
		for (int i = 0; i < n; i++)
			((ns1__FilterEntry*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FilterEntry*)cp->ptr;
}

void ns1__FilterElement::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__FilterElement))
		this->soap_mark(soap);
}

void ns1__FilterElement::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__FilterElement*)this)->op, SOAP_TYPE_ns1__FilterOp);
	/* transient soap skipped */
}

void ns1__FilterElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__FilterOp(soap, &((ns1__FilterElement*)this)->op);
	/* transient soap skipped */
}

int ns1__FilterElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__FilterElement);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__FilterElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FilterElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FilterElement(struct soap *soap, const char *tag, int id, const ns1__FilterElement *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FilterElement), "ns1:FilterElement");
	soap_out_ns1__FilterOp(soap, "op", -1, &(((ns1__FilterElement*)a)->op), "ns1:FilterOp");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__FilterElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FilterElement(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FilterElement * SOAP_FMAC4 soap_get_ns1__FilterElement(struct soap *soap, ns1__FilterElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FilterElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__FilterElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FilterElement(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FilterElement * SOAP_FMAC4 soap_in_ns1__FilterElement(struct soap *soap, const char *tag, ns1__FilterElement *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__FilterElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FilterElement, sizeof(ns1__FilterElement), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__FilterElement)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__FilterElement *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_op1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_op1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__FilterOp(soap, "op", &(((ns1__FilterElement*)a)->op), "ns1:FilterOp"))
				{	soap_flag_op1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_op1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__FilterElement *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FilterElement, sizeof(ns1__FilterElement), soap->type, soap->arrayType), SOAP_TYPE_ns1__FilterElement, sizeof(ns1__FilterElement));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__FilterElement * SOAP_FMAC6 soap_new_ns1__FilterElement(struct soap *soap, int n)
{	return soap_instantiate_ns1__FilterElement(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__FilterElement(struct soap *soap, ns1__FilterElement *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__FilterElement * SOAP_FMAC6 soap_instantiate_ns1__FilterElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FilterElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__FilterElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:FilterEntry"))
	{	cp->type = SOAP_TYPE_ns1__FilterEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__FilterEntry;
			if (size)
				*size = sizeof(ns1__FilterEntry);
			((ns1__FilterEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__FilterEntry[n];
			if (size)
				*size = n * sizeof(ns1__FilterEntry);
			for (int i = 0; i < n; i++)
				((ns1__FilterEntry*)cp->ptr)[i].soap = soap;
		}
		return (ns1__FilterEntry*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:FilterGroup"))
	{	cp->type = SOAP_TYPE_ns1__FilterGroup;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__FilterGroup;
			if (size)
				*size = sizeof(ns1__FilterGroup);
			((ns1__FilterGroup*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__FilterGroup[n];
			if (size)
				*size = n * sizeof(ns1__FilterGroup);
			for (int i = 0; i < n; i++)
				((ns1__FilterGroup*)cp->ptr)[i].soap = soap;
		}
		return (ns1__FilterGroup*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__FilterElement;
		if (size)
			*size = sizeof(ns1__FilterElement);
		((ns1__FilterElement*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__FilterElement[n];
		if (size)
			*size = n * sizeof(ns1__FilterElement);
		for (int i = 0; i < n; i++)
			((ns1__FilterElement*)cp->ptr)[i].soap = soap;
	}
	return (ns1__FilterElement*)cp->ptr;
}

void ns1__Filter::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Filter))
		this->soap_mark(soap);
}

void ns1__Filter::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Filter*)this)->element, SOAP_TYPE_PointerTons1__FilterElement);
	soap_mark_PointerTons1__FilterElement(soap, &((ns1__Filter*)this)->element);
	/* transient soap skipped */
}

void ns1__Filter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__FilterElement(soap, &((ns1__Filter*)this)->element);
	/* transient soap skipped */
}

int ns1__Filter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Filter);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Filter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Filter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Filter(struct soap *soap, const char *tag, int id, const ns1__Filter *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Filter), "ns1:Filter");
	soap_out_PointerTons1__FilterElement(soap, "element", -1, &(((ns1__Filter*)a)->element), "ns1:FilterElement");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Filter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Filter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Filter * SOAP_FMAC4 soap_get_ns1__Filter(struct soap *soap, ns1__Filter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Filter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Filter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Filter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Filter * SOAP_FMAC4 soap_in_ns1__Filter(struct soap *soap, const char *tag, ns1__Filter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Filter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Filter, sizeof(ns1__Filter), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Filter)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Filter *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_element1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_element1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FilterElement(soap, "element", &(((ns1__Filter*)a)->element), "ns1:FilterElement"))
				{	soap_flag_element1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Filter *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Filter, sizeof(ns1__Filter), soap->type, soap->arrayType), SOAP_TYPE_ns1__Filter, sizeof(ns1__Filter));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Filter * SOAP_FMAC6 soap_new_ns1__Filter(struct soap *soap, int n)
{	return soap_instantiate_ns1__Filter(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Filter(struct soap *soap, ns1__Filter *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Filter * SOAP_FMAC6 soap_instantiate_ns1__Filter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Filter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Filter, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Filter;
		if (size)
			*size = sizeof(ns1__Filter);
		((ns1__Filter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Filter[n];
		if (size)
			*size = n * sizeof(ns1__Filter);
		for (int i = 0; i < n; i++)
			((ns1__Filter*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Filter*)cp->ptr;
}

void ns1__EmailAddressList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__EmailAddressList))
		this->soap_mark(soap);
}

void ns1__EmailAddressList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__EmailAddressList*)this)->email, SOAP_TYPE_PointerTostd__vectorTemplateOfstd__string);
	soap_mark_PointerTostd__vectorTemplateOfstd__string(soap, &((ns1__EmailAddressList*)this)->email);
	/* transient soap skipped */
}

void ns1__EmailAddressList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfstd__string(soap, &((ns1__EmailAddressList*)this)->email);
	soap_default_std__string(soap, &((ns1__EmailAddressList*)this)->primary);
	/* transient soap skipped */
}

int ns1__EmailAddressList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__EmailAddressList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__EmailAddressList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EmailAddressList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EmailAddressList(struct soap *soap, const char *tag, int id, const ns1__EmailAddressList *a, const char *type)
{
	if (!((ns1__EmailAddressList *)a)->primary.empty())
		soap_set_attr(soap, "primary", ((ns1__EmailAddressList *)a)->primary.c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EmailAddressList), "ns1:EmailAddressList");
	soap_out_PointerTostd__vectorTemplateOfstd__string(soap, "email", -1, &(((ns1__EmailAddressList*)a)->email), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__EmailAddressList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EmailAddressList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EmailAddressList * SOAP_FMAC4 soap_get_ns1__EmailAddressList(struct soap *soap, ns1__EmailAddressList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EmailAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__EmailAddressList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EmailAddressList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EmailAddressList * SOAP_FMAC4 soap_in_ns1__EmailAddressList(struct soap *soap, const char *tag, ns1__EmailAddressList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__EmailAddressList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EmailAddressList, sizeof(ns1__EmailAddressList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__EmailAddressList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__EmailAddressList *)a->soap_in(soap, tag, type);
			}
		}
		{	const char *t = soap_attr_value(soap, "primary");
			if (t)
			{	char *s;
				if (soap_s2string(soap, t, &s))
					return NULL;
				((ns1__EmailAddressList *)a)->primary.assign(s);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfstd__string(soap, "email", &(((ns1__EmailAddressList*)a)->email), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__EmailAddressList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EmailAddressList, sizeof(ns1__EmailAddressList), soap->type, soap->arrayType), SOAP_TYPE_ns1__EmailAddressList, sizeof(ns1__EmailAddressList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__EmailAddressList * SOAP_FMAC6 soap_new_ns1__EmailAddressList(struct soap *soap, int n)
{	return soap_instantiate_ns1__EmailAddressList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__EmailAddressList(struct soap *soap, ns1__EmailAddressList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__EmailAddressList * SOAP_FMAC6 soap_instantiate_ns1__EmailAddressList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EmailAddressList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EmailAddressList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__EmailAddressList;
		if (size)
			*size = sizeof(ns1__EmailAddressList);
		((ns1__EmailAddressList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__EmailAddressList[n];
		if (size)
			*size = n * sizeof(ns1__EmailAddressList);
		for (int i = 0; i < n; i++)
			((ns1__EmailAddressList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__EmailAddressList*)cp->ptr;
}

void ns1__DocumentRef::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__DocumentRef))
		this->soap_mark(soap);
}

void ns1__DocumentRef::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__DocumentRef*)this)->library, SOAP_TYPE_PointerTons1__NameAndEmail);
	soap_mark_PointerTons1__NameAndEmail(soap, &((ns1__DocumentRef*)this)->library);
	soap_embedded(soap, &((ns1__DocumentRef*)this)->number, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__DocumentRef*)this)->filename, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__DocumentRef*)this)->filename);
	soap_embedded(soap, &((ns1__DocumentRef*)this)->docType, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__DocumentRef*)this)->docType);
	soap_embedded(soap, &((ns1__DocumentRef*)this)->author, SOAP_TYPE_PointerTons1__NameAndEmail);
	soap_mark_PointerTons1__NameAndEmail(soap, &((ns1__DocumentRef*)this)->author);
	soap_embedded(soap, &((ns1__DocumentRef*)this)->creator, SOAP_TYPE_PointerTons1__NameAndEmail);
	soap_mark_PointerTons1__NameAndEmail(soap, &((ns1__DocumentRef*)this)->creator);
	soap_embedded(soap, &((ns1__DocumentRef*)this)->officialVersion, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__DocumentRef*)this)->currentVersion, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__DocumentRef*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__DocumentRef*)this)->versionDescription, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__DocumentRef*)this)->versionDescription);
	soap_embedded(soap, &((ns1__DocumentRef*)this)->fileSize, SOAP_TYPE_PointerTounsignedLong);
	soap_mark_PointerTounsignedLong(soap, &((ns1__DocumentRef*)this)->fileSize);
	soap_embedded(soap, &((ns1__DocumentRef*)this)->acl, SOAP_TYPE_PointerTons1__AccessControlList);
	soap_mark_PointerTons1__AccessControlList(soap, &((ns1__DocumentRef*)this)->acl);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Mail*)this)->subject, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_embedded(soap, &((ns1__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ns1__Mail*)this)->distribution, SOAP_TYPE_PointerTons1__Distribution);
	soap_mark_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_embedded(soap, &((ns1__Mail*)this)->message, SOAP_TYPE_PointerTons1__MessageBody);
	soap_mark_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_embedded(soap, &((ns1__Mail*)this)->attachments, SOAP_TYPE_PointerTons1__AttachmentInfo);
	soap_mark_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_embedded(soap, &((ns1__Mail*)this)->options, SOAP_TYPE_PointerTons1__ItemOptions);
	soap_mark_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__BoxEntry*)this)->status, SOAP_TYPE_PointerTons1__ItemStatus);
	soap_mark_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->msgid, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->source, SOAP_TYPE_PointerTons1__ItemSource);
	soap_mark_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->class_, SOAP_TYPE_PointerTons1__ItemClass);
	soap_mark_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__DocumentRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__NameAndEmail(soap, &((ns1__DocumentRef*)this)->library);
	soap_default_unsignedLong(soap, &((ns1__DocumentRef*)this)->number);
	soap_default_PointerTostd__string(soap, &((ns1__DocumentRef*)this)->filename);
	soap_default_std__string(soap, &((ns1__DocumentRef*)this)->docType);
	soap_default_PointerTons1__NameAndEmail(soap, &((ns1__DocumentRef*)this)->author);
	soap_default_PointerTons1__NameAndEmail(soap, &((ns1__DocumentRef*)this)->creator);
	soap_default_unsignedLong(soap, &((ns1__DocumentRef*)this)->officialVersion);
	soap_default_unsignedLong(soap, &((ns1__DocumentRef*)this)->currentVersion);
	soap_default_unsignedLong(soap, &((ns1__DocumentRef*)this)->version);
	soap_default_std__string(soap, &((ns1__DocumentRef*)this)->versionDescription);
	soap_default_PointerTounsignedLong(soap, &((ns1__DocumentRef*)this)->fileSize);
	soap_default_PointerTons1__AccessControlList(soap, &((ns1__DocumentRef*)this)->acl);
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_default_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_default_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_default_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_default_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_default_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_default_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_default_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_default_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_default_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__DocumentRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__DocumentRef);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__DocumentRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DocumentRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DocumentRef(struct soap *soap, const char *tag, int id, const ns1__DocumentRef *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DocumentRef), "ns1:DocumentRef");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_PointerTons1__ItemStatus(soap, "status", -1, &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus");
	soap_out_PointerTostd__string(soap, "thread", -1, &(((ns1__BoxEntry*)a)->thread), "xsd:string");
	soap_out_PointerTostd__string(soap, "msgid", -1, &(((ns1__BoxEntry*)a)->msgid), "xsd:string");
	soap_out_PointerTons1__ItemSource(soap, "source", -1, &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource");
	soap_out_string(soap, "delivered", -1, &(((ns1__BoxEntry*)a)->delivered), "");
	soap_out_PointerTons1__ItemClass(soap, "class", -1, &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass");
	/* transient soap skipped */
	soap_out_std__string(soap, "subject", -1, &(((ns1__Mail*)a)->subject), "xsd:string");
	soap_out_PointerTostd__string(soap, "originalSubject", -1, &(((ns1__Mail*)a)->originalSubject), "xsd:string");
	soap_out_PointerTons1__Distribution(soap, "distribution", -1, &(((ns1__Mail*)a)->distribution), "ns1:Distribution");
	soap_out_PointerTons1__MessageBody(soap, "message", -1, &(((ns1__Mail*)a)->message), "ns1:MessageBody");
	soap_out_PointerTons1__AttachmentInfo(soap, "attachments", -1, &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo");
	soap_out_PointerTons1__ItemOptions(soap, "options", -1, &(((ns1__Mail*)a)->options), "ns1:ItemOptions");
	/* transient soap skipped */
	soap_out_PointerTons1__NameAndEmail(soap, "library", -1, &(((ns1__DocumentRef*)a)->library), "ns1:NameAndEmail");
	soap_out_unsignedLong(soap, "number", -1, &(((ns1__DocumentRef*)a)->number), "");
	soap_out_PointerTostd__string(soap, "filename", -1, &(((ns1__DocumentRef*)a)->filename), "xsd:string");
	soap_out_std__string(soap, "docType", -1, &(((ns1__DocumentRef*)a)->docType), "xsd:string");
	soap_out_PointerTons1__NameAndEmail(soap, "author", -1, &(((ns1__DocumentRef*)a)->author), "ns1:NameAndEmail");
	soap_out_PointerTons1__NameAndEmail(soap, "creator", -1, &(((ns1__DocumentRef*)a)->creator), "ns1:NameAndEmail");
	soap_out_unsignedLong(soap, "officialVersion", -1, &(((ns1__DocumentRef*)a)->officialVersion), "");
	soap_out_unsignedLong(soap, "currentVersion", -1, &(((ns1__DocumentRef*)a)->currentVersion), "");
	soap_out_unsignedLong(soap, "ns1:DocumentRef.version", -1, &(((ns1__DocumentRef*)a)->version), "");
	soap_out_std__string(soap, "versionDescription", -1, &(((ns1__DocumentRef*)a)->versionDescription), "xsd:string");
	soap_out_PointerTounsignedLong(soap, "fileSize", -1, &(((ns1__DocumentRef*)a)->fileSize), "");
	soap_out_PointerTons1__AccessControlList(soap, "acl", -1, &(((ns1__DocumentRef*)a)->acl), "ns1:AccessControlList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__DocumentRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DocumentRef(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DocumentRef * SOAP_FMAC4 soap_get_ns1__DocumentRef(struct soap *soap, ns1__DocumentRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DocumentRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__DocumentRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DocumentRef(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DocumentRef * SOAP_FMAC4 soap_in_ns1__DocumentRef(struct soap *soap, const char *tag, ns1__DocumentRef *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__DocumentRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DocumentRef, sizeof(ns1__DocumentRef), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__DocumentRef)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__DocumentRef *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id5 = 1, soap_flag_name5 = 1, soap_flag_version5 = 1, soap_flag_modified5 = 1, soap_flag_changes5 = 1, soap_flag_type5 = 1, soap_flag_categories4 = 1, soap_flag_created4 = 1, soap_flag_customs4 = 1, soap_flag_status3 = 1, soap_flag_thread3 = 1, soap_flag_msgid3 = 1, soap_flag_source3 = 1, soap_flag_delivered3 = 1, soap_flag_class_3 = 1, soap_flag_subject2 = 1, soap_flag_originalSubject2 = 1, soap_flag_distribution2 = 1, soap_flag_message2 = 1, soap_flag_attachments2 = 1, soap_flag_options2 = 1, soap_flag_library1 = 1, soap_flag_number1 = 1, soap_flag_filename1 = 1, soap_flag_docType1 = 1, soap_flag_author1 = 1, soap_flag_creator1 = 1, soap_flag_officialVersion1 = 1, soap_flag_currentVersion1 = 1, soap_flag_version1 = 1, soap_flag_versionDescription1 = 1, soap_flag_fileSize1 = 1, soap_flag_acl1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id5 = 0;
					continue;
				}

			if (soap_flag_name5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name5 = 0;
					continue;
				}

			if (soap_flag_version5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version5 = 0;
					continue;
				}

			if (soap_flag_modified5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified5 = 0;
					continue;
				}

			if (soap_flag_changes5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes5 = 0;
					continue;
				}

			if (soap_flag_type5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type5 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories4 = 0;
					continue;
				}

			if (soap_flag_created4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created4 = 0;
					continue;
				}

			if (soap_flag_customs4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemStatus(soap, "status", &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus"))
				{	soap_flag_status3 = 0;
					continue;
				}

			if (soap_flag_thread3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "thread", &(((ns1__BoxEntry*)a)->thread), "xsd:string"))
				{	soap_flag_thread3 = 0;
					continue;
				}

			if (soap_flag_msgid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "msgid", &(((ns1__BoxEntry*)a)->msgid), "xsd:string"))
				{	soap_flag_msgid3 = 0;
					continue;
				}

			if (soap_flag_source3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemSource(soap, "source", &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource"))
				{	soap_flag_source3 = 0;
					continue;
				}

			if (soap_flag_delivered3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "delivered", &(((ns1__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered3 = 0;
					continue;
				}

			if (soap_flag_class_3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemClass(soap, "class", &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass"))
				{	soap_flag_class_3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_subject2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "subject", &(((ns1__Mail*)a)->subject), "xsd:string"))
				{	soap_flag_subject2 = 0;
					continue;
				}

			if (soap_flag_originalSubject2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "originalSubject", &(((ns1__Mail*)a)->originalSubject), "xsd:string"))
				{	soap_flag_originalSubject2 = 0;
					continue;
				}

			if (soap_flag_distribution2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Distribution(soap, "distribution", &(((ns1__Mail*)a)->distribution), "ns1:Distribution"))
				{	soap_flag_distribution2 = 0;
					continue;
				}

			if (soap_flag_message2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MessageBody(soap, "message", &(((ns1__Mail*)a)->message), "ns1:MessageBody"))
				{	soap_flag_message2 = 0;
					continue;
				}

			if (soap_flag_attachments2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AttachmentInfo(soap, "attachments", &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo"))
				{	soap_flag_attachments2 = 0;
					continue;
				}

			if (soap_flag_options2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemOptions(soap, "options", &(((ns1__Mail*)a)->options), "ns1:ItemOptions"))
				{	soap_flag_options2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_library1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__NameAndEmail(soap, "library", &(((ns1__DocumentRef*)a)->library), "ns1:NameAndEmail"))
				{	soap_flag_library1 = 0;
					continue;
				}

			if (soap_flag_number1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "number", &(((ns1__DocumentRef*)a)->number), ""))
				{	soap_flag_number1 = 0;
					continue;
				}

			if (soap_flag_filename1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "filename", &(((ns1__DocumentRef*)a)->filename), "xsd:string"))
				{	soap_flag_filename1 = 0;
					continue;
				}

			if (soap_flag_docType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "docType", &(((ns1__DocumentRef*)a)->docType), "xsd:string"))
				{	soap_flag_docType1 = 0;
					continue;
				}

			if (soap_flag_author1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__NameAndEmail(soap, "author", &(((ns1__DocumentRef*)a)->author), "ns1:NameAndEmail"))
				{	soap_flag_author1 = 0;
					continue;
				}

			if (soap_flag_creator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__NameAndEmail(soap, "creator", &(((ns1__DocumentRef*)a)->creator), "ns1:NameAndEmail"))
				{	soap_flag_creator1 = 0;
					continue;
				}

			if (soap_flag_officialVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "officialVersion", &(((ns1__DocumentRef*)a)->officialVersion), ""))
				{	soap_flag_officialVersion1 = 0;
					continue;
				}

			if (soap_flag_currentVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "currentVersion", &(((ns1__DocumentRef*)a)->currentVersion), ""))
				{	soap_flag_currentVersion1 = 0;
					continue;
				}

			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "ns1:DocumentRef.version", &(((ns1__DocumentRef*)a)->version), ""))
				{	soap_flag_version1 = 0;
					continue;
				}

			if (soap_flag_versionDescription1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "versionDescription", &(((ns1__DocumentRef*)a)->versionDescription), "xsd:string"))
				{	soap_flag_versionDescription1 = 0;
					continue;
				}

			if (soap_flag_fileSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "fileSize", &(((ns1__DocumentRef*)a)->fileSize), ""))
				{	soap_flag_fileSize1 = 0;
					continue;
				}

			if (soap_flag_acl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessControlList(soap, "acl", &(((ns1__DocumentRef*)a)->acl), "ns1:AccessControlList"))
				{	soap_flag_acl1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_subject2 || soap_flag_number1 || soap_flag_docType1 || soap_flag_officialVersion1 || soap_flag_currentVersion1 || soap_flag_version1 || soap_flag_versionDescription1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__DocumentRef *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DocumentRef, sizeof(ns1__DocumentRef), soap->type, soap->arrayType), SOAP_TYPE_ns1__DocumentRef, sizeof(ns1__DocumentRef));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__DocumentRef * SOAP_FMAC6 soap_new_ns1__DocumentRef(struct soap *soap, int n)
{	return soap_instantiate_ns1__DocumentRef(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__DocumentRef(struct soap *soap, ns1__DocumentRef *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__DocumentRef * SOAP_FMAC6 soap_instantiate_ns1__DocumentRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DocumentRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DocumentRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DocumentRef;
		if (size)
			*size = sizeof(ns1__DocumentRef);
		((ns1__DocumentRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DocumentRef[n];
		if (size)
			*size = n * sizeof(ns1__DocumentRef);
		for (int i = 0; i < n; i++)
			((ns1__DocumentRef*)cp->ptr)[i].soap = soap;
	}
	return (ns1__DocumentRef*)cp->ptr;
}

void ns1__Distribution::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Distribution))
		this->soap_mark(soap);
}

void ns1__Distribution::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Distribution*)this)->from, SOAP_TYPE_PointerTons1__From);
	soap_mark_PointerTons1__From(soap, &((ns1__Distribution*)this)->from);
	soap_embedded(soap, &((ns1__Distribution*)this)->to, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Distribution*)this)->to);
	soap_embedded(soap, &((ns1__Distribution*)this)->cc, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Distribution*)this)->cc);
	soap_embedded(soap, &((ns1__Distribution*)this)->bc, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Distribution*)this)->bc);
	soap_embedded(soap, &((ns1__Distribution*)this)->recipients, SOAP_TYPE_PointerTons1__RecipientList);
	soap_mark_PointerTons1__RecipientList(soap, &((ns1__Distribution*)this)->recipients);
	soap_embedded(soap, &((ns1__Distribution*)this)->sendoptions, SOAP_TYPE_PointerTons1__SendOptions);
	soap_mark_PointerTons1__SendOptions(soap, &((ns1__Distribution*)this)->sendoptions);
	/* transient soap skipped */
}

void ns1__Distribution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__From(soap, &((ns1__Distribution*)this)->from);
	soap_default_PointerTostd__string(soap, &((ns1__Distribution*)this)->to);
	soap_default_PointerTostd__string(soap, &((ns1__Distribution*)this)->cc);
	soap_default_PointerTostd__string(soap, &((ns1__Distribution*)this)->bc);
	soap_default_PointerTons1__RecipientList(soap, &((ns1__Distribution*)this)->recipients);
	soap_default_PointerTons1__SendOptions(soap, &((ns1__Distribution*)this)->sendoptions);
	/* transient soap skipped */
}

int ns1__Distribution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Distribution);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Distribution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Distribution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Distribution(struct soap *soap, const char *tag, int id, const ns1__Distribution *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Distribution), "ns1:Distribution");
	soap_out_PointerTons1__From(soap, "from", -1, &(((ns1__Distribution*)a)->from), "ns1:From");
	soap_out_PointerTostd__string(soap, "to", -1, &(((ns1__Distribution*)a)->to), "xsd:string");
	soap_out_PointerTostd__string(soap, "cc", -1, &(((ns1__Distribution*)a)->cc), "xsd:string");
	soap_out_PointerTostd__string(soap, "bc", -1, &(((ns1__Distribution*)a)->bc), "xsd:string");
	soap_out_PointerTons1__RecipientList(soap, "recipients", -1, &(((ns1__Distribution*)a)->recipients), "ns1:RecipientList");
	soap_out_PointerTons1__SendOptions(soap, "sendoptions", -1, &(((ns1__Distribution*)a)->sendoptions), "ns1:SendOptions");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Distribution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Distribution(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Distribution * SOAP_FMAC4 soap_get_ns1__Distribution(struct soap *soap, ns1__Distribution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Distribution(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Distribution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Distribution(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Distribution * SOAP_FMAC4 soap_in_ns1__Distribution(struct soap *soap, const char *tag, ns1__Distribution *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Distribution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Distribution, sizeof(ns1__Distribution), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Distribution)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Distribution *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_from1 = 1, soap_flag_to1 = 1, soap_flag_cc1 = 1, soap_flag_bc1 = 1, soap_flag_recipients1 = 1, soap_flag_sendoptions1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_from1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__From(soap, "from", &(((ns1__Distribution*)a)->from), "ns1:From"))
				{	soap_flag_from1 = 0;
					continue;
				}

			if (soap_flag_to1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "to", &(((ns1__Distribution*)a)->to), "xsd:string"))
				{	soap_flag_to1 = 0;
					continue;
				}

			if (soap_flag_cc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "cc", &(((ns1__Distribution*)a)->cc), "xsd:string"))
				{	soap_flag_cc1 = 0;
					continue;
				}

			if (soap_flag_bc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "bc", &(((ns1__Distribution*)a)->bc), "xsd:string"))
				{	soap_flag_bc1 = 0;
					continue;
				}

			if (soap_flag_recipients1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RecipientList(soap, "recipients", &(((ns1__Distribution*)a)->recipients), "ns1:RecipientList"))
				{	soap_flag_recipients1 = 0;
					continue;
				}

			if (soap_flag_sendoptions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SendOptions(soap, "sendoptions", &(((ns1__Distribution*)a)->sendoptions), "ns1:SendOptions"))
				{	soap_flag_sendoptions1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Distribution *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Distribution, sizeof(ns1__Distribution), soap->type, soap->arrayType), SOAP_TYPE_ns1__Distribution, sizeof(ns1__Distribution));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Distribution * SOAP_FMAC6 soap_new_ns1__Distribution(struct soap *soap, int n)
{	return soap_instantiate_ns1__Distribution(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Distribution(struct soap *soap, ns1__Distribution *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Distribution * SOAP_FMAC6 soap_instantiate_ns1__Distribution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Distribution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Distribution, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Distribution;
		if (size)
			*size = sizeof(ns1__Distribution);
		((ns1__Distribution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Distribution[n];
		if (size)
			*size = n * sizeof(ns1__Distribution);
		for (int i = 0; i < n; i++)
			((ns1__Distribution*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Distribution*)cp->ptr;
}

void ns1__DeltaList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__DeltaList))
		this->soap_mark(soap);
}

void ns1__DeltaList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__DeltaList*)this)->add, SOAP_TYPE_PointerTons1__Items);
	soap_mark_PointerTons1__Items(soap, &((ns1__DeltaList*)this)->add);
	soap_embedded(soap, &((ns1__DeltaList*)this)->_delete, SOAP_TYPE_PointerTons1__Items);
	soap_mark_PointerTons1__Items(soap, &((ns1__DeltaList*)this)->_delete);
	soap_embedded(soap, &((ns1__DeltaList*)this)->update, SOAP_TYPE_PointerTons1__Items);
	soap_mark_PointerTons1__Items(soap, &((ns1__DeltaList*)this)->update);
	/* transient soap skipped */
}

void ns1__DeltaList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Items(soap, &((ns1__DeltaList*)this)->add);
	soap_default_PointerTons1__Items(soap, &((ns1__DeltaList*)this)->_delete);
	soap_default_PointerTons1__Items(soap, &((ns1__DeltaList*)this)->update);
	/* transient soap skipped */
}

int ns1__DeltaList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__DeltaList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__DeltaList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DeltaList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeltaList(struct soap *soap, const char *tag, int id, const ns1__DeltaList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeltaList), "ns1:DeltaList");
	soap_out_PointerTons1__Items(soap, "add", -1, &(((ns1__DeltaList*)a)->add), "ns1:Items");
	soap_out_PointerTons1__Items(soap, "delete", -1, &(((ns1__DeltaList*)a)->_delete), "ns1:Items");
	soap_out_PointerTons1__Items(soap, "update", -1, &(((ns1__DeltaList*)a)->update), "ns1:Items");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__DeltaList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DeltaList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DeltaList * SOAP_FMAC4 soap_get_ns1__DeltaList(struct soap *soap, ns1__DeltaList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeltaList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__DeltaList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DeltaList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DeltaList * SOAP_FMAC4 soap_in_ns1__DeltaList(struct soap *soap, const char *tag, ns1__DeltaList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__DeltaList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeltaList, sizeof(ns1__DeltaList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__DeltaList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__DeltaList *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_add1 = 1, soap_flag_delete1 = 1, soap_flag_update1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_add1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Items(soap, "add", &(((ns1__DeltaList*)a)->add), "ns1:Items"))
				{	soap_flag_add1 = 0;
					continue;
				}

			if (soap_flag_delete1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Items(soap, "delete", &(((ns1__DeltaList*)a)->_delete), "ns1:Items"))
				{	soap_flag_delete1 = 0;
					continue;
				}

			if (soap_flag_update1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Items(soap, "update", &(((ns1__DeltaList*)a)->update), "ns1:Items"))
				{	soap_flag_update1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__DeltaList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeltaList, sizeof(ns1__DeltaList), soap->type, soap->arrayType), SOAP_TYPE_ns1__DeltaList, sizeof(ns1__DeltaList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__DeltaList * SOAP_FMAC6 soap_new_ns1__DeltaList(struct soap *soap, int n)
{	return soap_instantiate_ns1__DeltaList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__DeltaList(struct soap *soap, ns1__DeltaList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__DeltaList * SOAP_FMAC6 soap_instantiate_ns1__DeltaList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeltaList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DeltaList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DeltaList;
		if (size)
			*size = sizeof(ns1__DeltaList);
		((ns1__DeltaList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DeltaList[n];
		if (size)
			*size = n * sizeof(ns1__DeltaList);
		for (int i = 0; i < n; i++)
			((ns1__DeltaList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__DeltaList*)cp->ptr;
}

void ns1__DelegateeStatus::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__DelegateeStatus))
		this->soap_mark(soap);
}

void ns1__DelegateeStatus::soap_mark(struct soap *soap) const
{
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->delivered, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->delivered);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->undeliverable, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->undeliverable);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->transferred, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->transferred);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->transferDelayed, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->transferDelayed);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->downloaded, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->downloaded);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->retractRequested, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->retractRequested);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->retracted, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->retracted);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->opened, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->opened);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->deleted, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->deleted);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->undeleted, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->undeleted);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->purged, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->purged);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->accepted, SOAP_TYPE_PointerTons1__CommentStatus);
	soap_mark_PointerTons1__CommentStatus(soap, &((ns1__RecipientStatus*)this)->accepted);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->declined, SOAP_TYPE_PointerTons1__CommentStatus);
	soap_mark_PointerTons1__CommentStatus(soap, &((ns1__RecipientStatus*)this)->declined);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->replied, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->replied);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->forwarded, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->forwarded);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->shared, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->shared);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->started, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->started);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->completed, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->completed);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->incomplete, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__RecipientStatus*)this)->incomplete);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->delegated, SOAP_TYPE_PointerTons1__DelegatedStatus);
	soap_mark_PointerTons1__DelegatedStatus(soap, &((ns1__RecipientStatus*)this)->delegated);
	soap_embedded(soap, &((ns1__RecipientStatus*)this)->delegateeStatus, SOAP_TYPE_PointerTons1__DelegateeStatus);
	soap_mark_PointerTons1__DelegateeStatus(soap, &((ns1__RecipientStatus*)this)->delegateeStatus);
	/* transient soap skipped */
}

void ns1__DelegateeStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__DelegateeStatus*)this)->userid);
	/* transient soap skipped */
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->delivered);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->undeliverable);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->transferred);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->transferDelayed);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->downloaded);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->retractRequested);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->retracted);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->opened);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->deleted);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->undeleted);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->purged);
	soap_default_PointerTons1__CommentStatus(soap, &((ns1__RecipientStatus*)this)->accepted);
	soap_default_PointerTons1__CommentStatus(soap, &((ns1__RecipientStatus*)this)->declined);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->replied);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->forwarded);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->shared);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->started);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->completed);
	soap_default_string(soap, &((ns1__RecipientStatus*)this)->incomplete);
	soap_default_PointerTons1__DelegatedStatus(soap, &((ns1__RecipientStatus*)this)->delegated);
	soap_default_PointerTons1__DelegateeStatus(soap, &((ns1__RecipientStatus*)this)->delegateeStatus);
	/* transient soap skipped */
}

int ns1__DelegateeStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__DelegateeStatus);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__DelegateeStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DelegateeStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DelegateeStatus(struct soap *soap, const char *tag, int id, const ns1__DelegateeStatus *a, const char *type)
{
	if (!((ns1__DelegateeStatus *)a)->userid.empty())
		soap_set_attr(soap, "userid", ((ns1__DelegateeStatus *)a)->userid.c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DelegateeStatus), "ns1:DelegateeStatus");
	soap_out_string(soap, "delivered", -1, &(((ns1__RecipientStatus*)a)->delivered), "");
	soap_out_string(soap, "undeliverable", -1, &(((ns1__RecipientStatus*)a)->undeliverable), "");
	soap_out_string(soap, "transferred", -1, &(((ns1__RecipientStatus*)a)->transferred), "");
	soap_out_string(soap, "transferDelayed", -1, &(((ns1__RecipientStatus*)a)->transferDelayed), "");
	soap_out_string(soap, "downloaded", -1, &(((ns1__RecipientStatus*)a)->downloaded), "");
	soap_out_string(soap, "retractRequested", -1, &(((ns1__RecipientStatus*)a)->retractRequested), "");
	soap_out_string(soap, "retracted", -1, &(((ns1__RecipientStatus*)a)->retracted), "");
	soap_out_string(soap, "opened", -1, &(((ns1__RecipientStatus*)a)->opened), "");
	soap_out_string(soap, "deleted", -1, &(((ns1__RecipientStatus*)a)->deleted), "");
	soap_out_string(soap, "undeleted", -1, &(((ns1__RecipientStatus*)a)->undeleted), "");
	soap_out_string(soap, "purged", -1, &(((ns1__RecipientStatus*)a)->purged), "");
	soap_out_PointerTons1__CommentStatus(soap, "accepted", -1, &(((ns1__RecipientStatus*)a)->accepted), "ns1:CommentStatus");
	soap_out_PointerTons1__CommentStatus(soap, "declined", -1, &(((ns1__RecipientStatus*)a)->declined), "ns1:CommentStatus");
	soap_out_string(soap, "replied", -1, &(((ns1__RecipientStatus*)a)->replied), "");
	soap_out_string(soap, "forwarded", -1, &(((ns1__RecipientStatus*)a)->forwarded), "");
	soap_out_string(soap, "shared", -1, &(((ns1__RecipientStatus*)a)->shared), "");
	soap_out_string(soap, "started", -1, &(((ns1__RecipientStatus*)a)->started), "");
	soap_out_string(soap, "completed", -1, &(((ns1__RecipientStatus*)a)->completed), "");
	soap_out_string(soap, "incomplete", -1, &(((ns1__RecipientStatus*)a)->incomplete), "");
	soap_out_PointerTons1__DelegatedStatus(soap, "delegated", -1, &(((ns1__RecipientStatus*)a)->delegated), "ns1:DelegatedStatus");
	soap_out_PointerTons1__DelegateeStatus(soap, "delegateeStatus", -1, &(((ns1__RecipientStatus*)a)->delegateeStatus), "ns1:DelegateeStatus");
	/* transient soap skipped */
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__DelegateeStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DelegateeStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DelegateeStatus * SOAP_FMAC4 soap_get_ns1__DelegateeStatus(struct soap *soap, ns1__DelegateeStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DelegateeStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__DelegateeStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DelegateeStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DelegateeStatus * SOAP_FMAC4 soap_in_ns1__DelegateeStatus(struct soap *soap, const char *tag, ns1__DelegateeStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__DelegateeStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DelegateeStatus, sizeof(ns1__DelegateeStatus), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__DelegateeStatus)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__DelegateeStatus *)a->soap_in(soap, tag, type);
			}
		}
		{	const char *t = soap_attr_value(soap, "userid");
			if (t)
			{	char *s;
				if (soap_s2string(soap, t, &s))
					return NULL;
				((ns1__DelegateeStatus *)a)->userid.assign(s);
			}
		}
		short soap_flag_delivered2 = 1, soap_flag_undeliverable2 = 1, soap_flag_transferred2 = 1, soap_flag_transferDelayed2 = 1, soap_flag_downloaded2 = 1, soap_flag_retractRequested2 = 1, soap_flag_retracted2 = 1, soap_flag_opened2 = 1, soap_flag_deleted2 = 1, soap_flag_undeleted2 = 1, soap_flag_purged2 = 1, soap_flag_accepted2 = 1, soap_flag_declined2 = 1, soap_flag_replied2 = 1, soap_flag_forwarded2 = 1, soap_flag_shared2 = 1, soap_flag_started2 = 1, soap_flag_completed2 = 1, soap_flag_incomplete2 = 1, soap_flag_delegated2 = 1, soap_flag_delegateeStatus2 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_delivered2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "delivered", &(((ns1__RecipientStatus*)a)->delivered), ""))
				{	soap_flag_delivered2 = 0;
					continue;
				}

			if (soap_flag_undeliverable2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "undeliverable", &(((ns1__RecipientStatus*)a)->undeliverable), ""))
				{	soap_flag_undeliverable2 = 0;
					continue;
				}

			if (soap_flag_transferred2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "transferred", &(((ns1__RecipientStatus*)a)->transferred), ""))
				{	soap_flag_transferred2 = 0;
					continue;
				}

			if (soap_flag_transferDelayed2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "transferDelayed", &(((ns1__RecipientStatus*)a)->transferDelayed), ""))
				{	soap_flag_transferDelayed2 = 0;
					continue;
				}

			if (soap_flag_downloaded2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "downloaded", &(((ns1__RecipientStatus*)a)->downloaded), ""))
				{	soap_flag_downloaded2 = 0;
					continue;
				}

			if (soap_flag_retractRequested2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "retractRequested", &(((ns1__RecipientStatus*)a)->retractRequested), ""))
				{	soap_flag_retractRequested2 = 0;
					continue;
				}

			if (soap_flag_retracted2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "retracted", &(((ns1__RecipientStatus*)a)->retracted), ""))
				{	soap_flag_retracted2 = 0;
					continue;
				}

			if (soap_flag_opened2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "opened", &(((ns1__RecipientStatus*)a)->opened), ""))
				{	soap_flag_opened2 = 0;
					continue;
				}

			if (soap_flag_deleted2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "deleted", &(((ns1__RecipientStatus*)a)->deleted), ""))
				{	soap_flag_deleted2 = 0;
					continue;
				}

			if (soap_flag_undeleted2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "undeleted", &(((ns1__RecipientStatus*)a)->undeleted), ""))
				{	soap_flag_undeleted2 = 0;
					continue;
				}

			if (soap_flag_purged2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "purged", &(((ns1__RecipientStatus*)a)->purged), ""))
				{	soap_flag_purged2 = 0;
					continue;
				}

			if (soap_flag_accepted2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CommentStatus(soap, "accepted", &(((ns1__RecipientStatus*)a)->accepted), "ns1:CommentStatus"))
				{	soap_flag_accepted2 = 0;
					continue;
				}

			if (soap_flag_declined2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CommentStatus(soap, "declined", &(((ns1__RecipientStatus*)a)->declined), "ns1:CommentStatus"))
				{	soap_flag_declined2 = 0;
					continue;
				}

			if (soap_flag_replied2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "replied", &(((ns1__RecipientStatus*)a)->replied), ""))
				{	soap_flag_replied2 = 0;
					continue;
				}

			if (soap_flag_forwarded2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "forwarded", &(((ns1__RecipientStatus*)a)->forwarded), ""))
				{	soap_flag_forwarded2 = 0;
					continue;
				}

			if (soap_flag_shared2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "shared", &(((ns1__RecipientStatus*)a)->shared), ""))
				{	soap_flag_shared2 = 0;
					continue;
				}

			if (soap_flag_started2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "started", &(((ns1__RecipientStatus*)a)->started), ""))
				{	soap_flag_started2 = 0;
					continue;
				}

			if (soap_flag_completed2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "completed", &(((ns1__RecipientStatus*)a)->completed), ""))
				{	soap_flag_completed2 = 0;
					continue;
				}

			if (soap_flag_incomplete2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "incomplete", &(((ns1__RecipientStatus*)a)->incomplete), ""))
				{	soap_flag_incomplete2 = 0;
					continue;
				}

			if (soap_flag_delegated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DelegatedStatus(soap, "delegated", &(((ns1__RecipientStatus*)a)->delegated), "ns1:DelegatedStatus"))
				{	soap_flag_delegated2 = 0;
					continue;
				}

			if (soap_flag_delegateeStatus2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DelegateeStatus(soap, "delegateeStatus", &(((ns1__RecipientStatus*)a)->delegateeStatus), "ns1:DelegateeStatus"))
				{	soap_flag_delegateeStatus2 = 0;
					continue;
				}

			/* transient soap skipped */
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__DelegateeStatus *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DelegateeStatus, sizeof(ns1__DelegateeStatus), soap->type, soap->arrayType), SOAP_TYPE_ns1__DelegateeStatus, sizeof(ns1__DelegateeStatus));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__DelegateeStatus * SOAP_FMAC6 soap_new_ns1__DelegateeStatus(struct soap *soap, int n)
{	return soap_instantiate_ns1__DelegateeStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__DelegateeStatus(struct soap *soap, ns1__DelegateeStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__DelegateeStatus * SOAP_FMAC6 soap_instantiate_ns1__DelegateeStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DelegateeStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DelegateeStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DelegateeStatus;
		if (size)
			*size = sizeof(ns1__DelegateeStatus);
		((ns1__DelegateeStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DelegateeStatus[n];
		if (size)
			*size = n * sizeof(ns1__DelegateeStatus);
		for (int i = 0; i < n; i++)
			((ns1__DelegateeStatus*)cp->ptr)[i].soap = soap;
	}
	return (ns1__DelegateeStatus*)cp->ptr;
}

void ns1__DelegatedStatus::soap_serialize(struct soap *soap) const
{
		this->soap_mark(soap);
}

void ns1__DelegatedStatus::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__DelegatedStatus*)this)->__item, SOAP_TYPE_PointerTons1__CommentStatus);
	soap_mark_PointerTons1__CommentStatus(soap, &((ns1__DelegatedStatus*)this)->__item);
	/* transient soap skipped */
}

void ns1__DelegatedStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__CommentStatus(soap, &((ns1__DelegatedStatus*)this)->__item);
	soap_default_std__string(soap, &((ns1__DelegatedStatus*)this)->userid);
	/* transient soap skipped */
}

int ns1__DelegatedStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__DelegatedStatus);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__DelegatedStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DelegatedStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DelegatedStatus(struct soap *soap, const char *tag, int id, const ns1__DelegatedStatus *a, const char *type)
{
	if (!((ns1__DelegatedStatus *)a)->userid.empty())
		soap_set_attr(soap, "userid", ((ns1__DelegatedStatus *)a)->userid.c_str());
	soap_out_PointerTons1__CommentStatus(soap, tag, id, &(((ns1__DelegatedStatus*)a)->__item), "ns1:DelegatedStatus");
	return SOAP_OK;
}

void *ns1__DelegatedStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DelegatedStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DelegatedStatus * SOAP_FMAC4 soap_get_ns1__DelegatedStatus(struct soap *soap, ns1__DelegatedStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DelegatedStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__DelegatedStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DelegatedStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DelegatedStatus * SOAP_FMAC4 soap_in_ns1__DelegatedStatus(struct soap *soap, const char *tag, ns1__DelegatedStatus *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ns1__DelegatedStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DelegatedStatus, sizeof(ns1__DelegatedStatus), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DelegatedStatus)
			return (ns1__DelegatedStatus *)a->soap_in(soap, tag, type);
	}
		{	const char *t = soap_attr_value(soap, "userid");
			if (t)
			{	char *s;
				if (soap_s2string(soap, t, &s))
					return NULL;
				((ns1__DelegatedStatus *)a)->userid.assign(s);
			}
		}
	if (!soap_in_PointerTons1__CommentStatus(soap, tag, &(((ns1__DelegatedStatus*)a)->__item), "ns1:DelegatedStatus"))
		return NULL;
	return a;
}

SOAP_FMAC5 ns1__DelegatedStatus * SOAP_FMAC6 soap_new_ns1__DelegatedStatus(struct soap *soap, int n)
{	return soap_instantiate_ns1__DelegatedStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__DelegatedStatus(struct soap *soap, ns1__DelegatedStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__DelegatedStatus * SOAP_FMAC6 soap_instantiate_ns1__DelegatedStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DelegatedStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DelegatedStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DelegatedStatus;
		if (size)
			*size = sizeof(ns1__DelegatedStatus);
		((ns1__DelegatedStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DelegatedStatus[n];
		if (size)
			*size = n * sizeof(ns1__DelegatedStatus);
		for (int i = 0; i < n; i++)
			((ns1__DelegatedStatus*)cp->ptr)[i].soap = soap;
	}
	return (ns1__DelegatedStatus*)cp->ptr;
}

void ns1__DayOfWeek::soap_serialize(struct soap *soap) const
{
		this->soap_mark(soap);
}

void ns1__DayOfWeek::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__DayOfWeek*)this)->__item, SOAP_TYPE_ns1__WeekDay);
	/* transient soap skipped */
}

void ns1__DayOfWeek::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__WeekDay(soap, &((ns1__DayOfWeek*)this)->__item);
	soap_default_ns1__OccurrenceType(soap, &((ns1__DayOfWeek*)this)->occurrence);
	/* transient soap skipped */
}

int ns1__DayOfWeek::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__DayOfWeek);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__DayOfWeek::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DayOfWeek(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DayOfWeek(struct soap *soap, const char *tag, int id, const ns1__DayOfWeek *a, const char *type)
{
	soap_set_attr(soap, "occurrence", soap_ns1__OccurrenceType2s(soap, ((ns1__DayOfWeek *)a)->occurrence));
	soap_out_ns1__WeekDay(soap, tag, id, &(((ns1__DayOfWeek*)a)->__item), "ns1:DayOfWeek");
	return SOAP_OK;
}

void *ns1__DayOfWeek::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DayOfWeek(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DayOfWeek * SOAP_FMAC4 soap_get_ns1__DayOfWeek(struct soap *soap, ns1__DayOfWeek *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DayOfWeek(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__DayOfWeek::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DayOfWeek(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DayOfWeek * SOAP_FMAC4 soap_in_ns1__DayOfWeek(struct soap *soap, const char *tag, ns1__DayOfWeek *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ns1__DayOfWeek *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DayOfWeek, sizeof(ns1__DayOfWeek), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DayOfWeek)
			return (ns1__DayOfWeek *)a->soap_in(soap, tag, type);
	}
		if (soap_s2ns1__OccurrenceType(soap, soap_attr_value(soap, "occurrence"), &((ns1__DayOfWeek *)a)->occurrence))
			return NULL;
	if (!soap_in_ns1__WeekDay(soap, tag, &(((ns1__DayOfWeek*)a)->__item), "ns1:DayOfWeek"))
		return NULL;
	return a;
}

SOAP_FMAC5 ns1__DayOfWeek * SOAP_FMAC6 soap_new_ns1__DayOfWeek(struct soap *soap, int n)
{	return soap_instantiate_ns1__DayOfWeek(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__DayOfWeek(struct soap *soap, ns1__DayOfWeek *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__DayOfWeek * SOAP_FMAC6 soap_instantiate_ns1__DayOfWeek(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DayOfWeek(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DayOfWeek, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DayOfWeek;
		if (size)
			*size = sizeof(ns1__DayOfWeek);
		((ns1__DayOfWeek*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DayOfWeek[n];
		if (size)
			*size = n * sizeof(ns1__DayOfWeek);
		for (int i = 0; i < n; i++)
			((ns1__DayOfWeek*)cp->ptr)[i].soap = soap;
	}
	return (ns1__DayOfWeek*)cp->ptr;
}

void ns1__CustomList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__CustomList))
		this->soap_mark(soap);
}

void ns1__CustomList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__CustomList*)this)->custom, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Custom);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, &((ns1__CustomList*)this)->custom);
	/* transient soap skipped */
}

void ns1__CustomList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, &((ns1__CustomList*)this)->custom);
	/* transient soap skipped */
}

int ns1__CustomList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__CustomList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__CustomList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CustomList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CustomList(struct soap *soap, const char *tag, int id, const ns1__CustomList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CustomList), "ns1:CustomList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, "custom", -1, &(((ns1__CustomList*)a)->custom), "ns1:Custom");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CustomList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CustomList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CustomList * SOAP_FMAC4 soap_get_ns1__CustomList(struct soap *soap, ns1__CustomList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CustomList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CustomList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CustomList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CustomList * SOAP_FMAC4 soap_in_ns1__CustomList(struct soap *soap, const char *tag, ns1__CustomList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__CustomList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CustomList, sizeof(ns1__CustomList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__CustomList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__CustomList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, "custom", &(((ns1__CustomList*)a)->custom), "ns1:Custom"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__CustomList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CustomList, sizeof(ns1__CustomList), soap->type, soap->arrayType), SOAP_TYPE_ns1__CustomList, sizeof(ns1__CustomList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CustomList * SOAP_FMAC6 soap_new_ns1__CustomList(struct soap *soap, int n)
{	return soap_instantiate_ns1__CustomList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CustomList(struct soap *soap, ns1__CustomList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__CustomList * SOAP_FMAC6 soap_instantiate_ns1__CustomList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CustomList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CustomList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CustomList;
		if (size)
			*size = sizeof(ns1__CustomList);
		((ns1__CustomList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CustomList[n];
		if (size)
			*size = n * sizeof(ns1__CustomList);
		for (int i = 0; i < n; i++)
			((ns1__CustomList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__CustomList*)cp->ptr;
}

void ns1__Custom::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Custom))
		this->soap_mark(soap);
}

void ns1__Custom::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Custom*)this)->field, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Custom*)this)->field);
	soap_embedded(soap, &((ns1__Custom*)this)->value, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Custom*)this)->value);
	/* transient soap skipped */
}

void ns1__Custom::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__Custom*)this)->field);
	soap_default_PointerTostd__string(soap, &((ns1__Custom*)this)->value);
	/* transient soap skipped */
}

int ns1__Custom::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Custom);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Custom::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Custom(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Custom(struct soap *soap, const char *tag, int id, const ns1__Custom *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Custom), "ns1:Custom");
	soap_out_std__string(soap, "field", -1, &(((ns1__Custom*)a)->field), "xsd:string");
	soap_out_PointerTostd__string(soap, "value", -1, &(((ns1__Custom*)a)->value), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Custom::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Custom(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Custom * SOAP_FMAC4 soap_get_ns1__Custom(struct soap *soap, ns1__Custom *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Custom(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Custom::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Custom(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Custom * SOAP_FMAC4 soap_in_ns1__Custom(struct soap *soap, const char *tag, ns1__Custom *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Custom *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Custom, sizeof(ns1__Custom), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Custom)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Custom *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_field1 = 1, soap_flag_value1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_field1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "field", &(((ns1__Custom*)a)->field), "xsd:string"))
				{	soap_flag_field1 = 0;
					continue;
				}

			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "value", &(((ns1__Custom*)a)->value), "xsd:string"))
				{	soap_flag_value1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_field1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__Custom *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Custom, sizeof(ns1__Custom), soap->type, soap->arrayType), SOAP_TYPE_ns1__Custom, sizeof(ns1__Custom));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Custom * SOAP_FMAC6 soap_new_ns1__Custom(struct soap *soap, int n)
{	return soap_instantiate_ns1__Custom(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Custom(struct soap *soap, ns1__Custom *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Custom * SOAP_FMAC6 soap_instantiate_ns1__Custom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Custom(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Custom, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Custom;
		if (size)
			*size = sizeof(ns1__Custom);
		((ns1__Custom*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Custom[n];
		if (size)
			*size = n * sizeof(ns1__Custom);
		for (int i = 0; i < n; i++)
			((ns1__Custom*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Custom*)cp->ptr;
}

void ns1__ContactFolder::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ContactFolder))
		this->soap_mark(soap);
}

void ns1__ContactFolder::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ContactFolder*)this)->addressBook, SOAP_TYPE_PointerTons1__uid);
	soap_mark_PointerTons1__uid(soap, &((ns1__ContactFolder*)this)->addressBook);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__SystemFolder*)this)->isSystemFolder, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__SystemFolder*)this)->isSystemFolder);
	soap_embedded(soap, &((ns1__SystemFolder*)this)->folder_USCOREtype, SOAP_TYPE_ns1__FolderType);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Folder*)this)->parent, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Folder*)this)->parent);
	soap_embedded(soap, &((ns1__Folder*)this)->description, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Folder*)this)->description);
	soap_embedded(soap, &((ns1__Folder*)this)->count, SOAP_TYPE_PointerToint);
	soap_mark_PointerToint(soap, &((ns1__Folder*)this)->count);
	soap_embedded(soap, &((ns1__Folder*)this)->hasUnread, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Folder*)this)->hasUnread);
	soap_embedded(soap, &((ns1__Folder*)this)->unreadCount, SOAP_TYPE_PointerToint);
	soap_mark_PointerToint(soap, &((ns1__Folder*)this)->unreadCount);
	soap_embedded(soap, &((ns1__Folder*)this)->sequence, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Folder*)this)->settings, SOAP_TYPE_PointerTons1__uid);
	soap_mark_PointerTons1__uid(soap, &((ns1__Folder*)this)->settings);
	soap_embedded(soap, &((ns1__Folder*)this)->hasSubfolders, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Folder*)this)->hasSubfolders);
	soap_embedded(soap, &((ns1__Folder*)this)->notification, SOAP_TYPE_PointerTons1__SharedFolderNotification);
	soap_mark_PointerTons1__SharedFolderNotification(soap, &((ns1__Folder*)this)->notification);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__ContactFolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__uid(soap, &((ns1__ContactFolder*)this)->addressBook);
	/* transient soap skipped */
	soap_default_PointerTobool(soap, &((ns1__SystemFolder*)this)->isSystemFolder);
	soap_default_ns1__FolderType(soap, &((ns1__SystemFolder*)this)->folder_USCOREtype);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Folder*)this)->parent);
	soap_default_std__string(soap, &((ns1__Folder*)this)->description);
	soap_default_PointerToint(soap, &((ns1__Folder*)this)->count);
	soap_default_PointerTobool(soap, &((ns1__Folder*)this)->hasUnread);
	soap_default_PointerToint(soap, &((ns1__Folder*)this)->unreadCount);
	soap_default_unsignedLong(soap, &((ns1__Folder*)this)->sequence);
	soap_default_PointerTons1__uid(soap, &((ns1__Folder*)this)->settings);
	soap_default_PointerTobool(soap, &((ns1__Folder*)this)->hasSubfolders);
	soap_default_PointerTons1__SharedFolderNotification(soap, &((ns1__Folder*)this)->notification);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__ContactFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ContactFolder);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ContactFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ContactFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ContactFolder(struct soap *soap, const char *tag, int id, const ns1__ContactFolder *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ContactFolder), "ns1:ContactFolder");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_ns1__uid(soap, "parent", -1, &(((ns1__Folder*)a)->parent), "ns1:uid");
	soap_out_std__string(soap, "description", -1, &(((ns1__Folder*)a)->description), "xsd:string");
	soap_out_PointerToint(soap, "count", -1, &(((ns1__Folder*)a)->count), "");
	soap_out_PointerTobool(soap, "hasUnread", -1, &(((ns1__Folder*)a)->hasUnread), "");
	soap_out_PointerToint(soap, "unreadCount", -1, &(((ns1__Folder*)a)->unreadCount), "");
	soap_out_unsignedLong(soap, "sequence", -1, &(((ns1__Folder*)a)->sequence), "");
	soap_out_PointerTons1__uid(soap, "settings", -1, &(((ns1__Folder*)a)->settings), "ns1:uid");
	soap_out_PointerTobool(soap, "hasSubfolders", -1, &(((ns1__Folder*)a)->hasSubfolders), "");
	soap_out_PointerTons1__SharedFolderNotification(soap, "notification", -1, &(((ns1__Folder*)a)->notification), "ns1:SharedFolderNotification");
	/* transient soap skipped */
	soap_out_PointerTobool(soap, "isSystemFolder", -1, &(((ns1__SystemFolder*)a)->isSystemFolder), "");
	soap_out_ns1__FolderType(soap, "folder_type", -1, &(((ns1__SystemFolder*)a)->folder_USCOREtype), "ns1:FolderType");
	/* transient soap skipped */
	soap_out_PointerTons1__uid(soap, "addressBook", -1, &(((ns1__ContactFolder*)a)->addressBook), "ns1:uid");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ContactFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ContactFolder(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ContactFolder * SOAP_FMAC4 soap_get_ns1__ContactFolder(struct soap *soap, ns1__ContactFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ContactFolder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ContactFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ContactFolder(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ContactFolder * SOAP_FMAC4 soap_in_ns1__ContactFolder(struct soap *soap, const char *tag, ns1__ContactFolder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ContactFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ContactFolder, sizeof(ns1__ContactFolder), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ContactFolder)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ContactFolder *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_type4 = 1, soap_flag_parent3 = 1, soap_flag_description3 = 1, soap_flag_count3 = 1, soap_flag_hasUnread3 = 1, soap_flag_unreadCount3 = 1, soap_flag_sequence3 = 1, soap_flag_settings3 = 1, soap_flag_hasSubfolders3 = 1, soap_flag_notification3 = 1, soap_flag_isSystemFolder2 = 1, soap_flag_folder_USCOREtype2 = 1, soap_flag_addressBook1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}

			if (soap_flag_name4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name4 = 0;
					continue;
				}

			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}

			if (soap_flag_modified4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}

			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}

			if (soap_flag_type4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_parent3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "parent", &(((ns1__Folder*)a)->parent), "ns1:uid"))
				{	soap_flag_parent3 = 0;
					continue;
				}

			if (soap_flag_description3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "description", &(((ns1__Folder*)a)->description), "xsd:string"))
				{	soap_flag_description3 = 0;
					continue;
				}

			if (soap_flag_count3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "count", &(((ns1__Folder*)a)->count), ""))
				{	soap_flag_count3 = 0;
					continue;
				}

			if (soap_flag_hasUnread3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasUnread", &(((ns1__Folder*)a)->hasUnread), ""))
				{	soap_flag_hasUnread3 = 0;
					continue;
				}

			if (soap_flag_unreadCount3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "unreadCount", &(((ns1__Folder*)a)->unreadCount), ""))
				{	soap_flag_unreadCount3 = 0;
					continue;
				}

			if (soap_flag_sequence3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "sequence", &(((ns1__Folder*)a)->sequence), ""))
				{	soap_flag_sequence3 = 0;
					continue;
				}

			if (soap_flag_settings3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__uid(soap, "settings", &(((ns1__Folder*)a)->settings), "ns1:uid"))
				{	soap_flag_settings3 = 0;
					continue;
				}

			if (soap_flag_hasSubfolders3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasSubfolders", &(((ns1__Folder*)a)->hasSubfolders), ""))
				{	soap_flag_hasSubfolders3 = 0;
					continue;
				}

			if (soap_flag_notification3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SharedFolderNotification(soap, "notification", &(((ns1__Folder*)a)->notification), "ns1:SharedFolderNotification"))
				{	soap_flag_notification3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_isSystemFolder2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isSystemFolder", &(((ns1__SystemFolder*)a)->isSystemFolder), ""))
				{	soap_flag_isSystemFolder2 = 0;
					continue;
				}

			if (soap_flag_folder_USCOREtype2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__FolderType(soap, "folder_type", &(((ns1__SystemFolder*)a)->folder_USCOREtype), "ns1:FolderType"))
				{	soap_flag_folder_USCOREtype2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_addressBook1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__uid(soap, "addressBook", &(((ns1__ContactFolder*)a)->addressBook), "ns1:uid"))
				{	soap_flag_addressBook1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent3 || soap_flag_folder_USCOREtype2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__ContactFolder *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ContactFolder, sizeof(ns1__ContactFolder), soap->type, soap->arrayType), SOAP_TYPE_ns1__ContactFolder, sizeof(ns1__ContactFolder));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ContactFolder * SOAP_FMAC6 soap_new_ns1__ContactFolder(struct soap *soap, int n)
{	return soap_instantiate_ns1__ContactFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ContactFolder(struct soap *soap, ns1__ContactFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ContactFolder * SOAP_FMAC6 soap_instantiate_ns1__ContactFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ContactFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ContactFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ContactFolder;
		if (size)
			*size = sizeof(ns1__ContactFolder);
		((ns1__ContactFolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ContactFolder[n];
		if (size)
			*size = n * sizeof(ns1__ContactFolder);
		for (int i = 0; i < n; i++)
			((ns1__ContactFolder*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ContactFolder*)cp->ptr;
}

void ns1__ContainerRef::soap_serialize(struct soap *soap) const
{
		this->soap_mark(soap);
}

void ns1__ContainerRef::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ContainerRef*)this)->__item, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__ContainerRef*)this)->__item);
	/* transient soap skipped */
}

void ns1__ContainerRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__ContainerRef*)this)->__item);
	soap_default_string(soap, &((ns1__ContainerRef*)this)->deleted);
	/* transient soap skipped */
}

int ns1__ContainerRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ContainerRef);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ContainerRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ContainerRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ContainerRef(struct soap *soap, const char *tag, int id, const ns1__ContainerRef *a, const char *type)
{
	if (((ns1__ContainerRef *)a)->deleted)
		soap_set_attr(soap, "deleted", ((ns1__ContainerRef *)a)->deleted);
	soap_out_std__string(soap, tag, id, &(((ns1__ContainerRef*)a)->__item), "ns1:ContainerRef");
	return SOAP_OK;
}

void *ns1__ContainerRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ContainerRef(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ContainerRef * SOAP_FMAC4 soap_get_ns1__ContainerRef(struct soap *soap, ns1__ContainerRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ContainerRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ContainerRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ContainerRef(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ContainerRef * SOAP_FMAC4 soap_in_ns1__ContainerRef(struct soap *soap, const char *tag, ns1__ContainerRef *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ns1__ContainerRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ContainerRef, sizeof(ns1__ContainerRef), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ContainerRef)
			return (ns1__ContainerRef *)a->soap_in(soap, tag, type);
	}
		if (soap_s2string(soap, soap_attr_value(soap, "deleted"), &((ns1__ContainerRef *)a)->deleted))
			return NULL;
	if (!soap_in_std__string(soap, tag, &(((ns1__ContainerRef*)a)->__item), "ns1:ContainerRef"))
		return NULL;
	return a;
}

SOAP_FMAC5 ns1__ContainerRef * SOAP_FMAC6 soap_new_ns1__ContainerRef(struct soap *soap, int n)
{	return soap_instantiate_ns1__ContainerRef(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ContainerRef(struct soap *soap, ns1__ContainerRef *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ContainerRef * SOAP_FMAC6 soap_instantiate_ns1__ContainerRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ContainerRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ContainerRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ContainerRef;
		if (size)
			*size = sizeof(ns1__ContainerRef);
		((ns1__ContainerRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ContainerRef[n];
		if (size)
			*size = n * sizeof(ns1__ContainerRef);
		for (int i = 0; i < n; i++)
			((ns1__ContainerRef*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ContainerRef*)cp->ptr;
}

void ns1__ContainerItem::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__ContainerItem))
		this->soap_mark(soap);
}

void ns1__ContainerItem::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__ContainerItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__ContainerItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__ContainerItem);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__ContainerItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ContainerItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ContainerItem(struct soap *soap, const char *tag, int id, const ns1__ContainerItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ContainerItem), "ns1:ContainerItem");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ContainerItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ContainerItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ContainerItem * SOAP_FMAC4 soap_get_ns1__ContainerItem(struct soap *soap, ns1__ContainerItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ContainerItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ContainerItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ContainerItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ContainerItem * SOAP_FMAC4 soap_in_ns1__ContainerItem(struct soap *soap, const char *tag, ns1__ContainerItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__ContainerItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ContainerItem, sizeof(ns1__ContainerItem), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__ContainerItem)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__ContainerItem *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id2 = 1, soap_flag_name2 = 1, soap_flag_version2 = 1, soap_flag_modified2 = 1, soap_flag_changes2 = 1, soap_flag_type2 = 1, soap_flag_categories1 = 1, soap_flag_created1 = 1, soap_flag_customs1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id2 = 0;
					continue;
				}

			if (soap_flag_name2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name2 = 0;
					continue;
				}

			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version2 = 0;
					continue;
				}

			if (soap_flag_modified2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified2 = 0;
					continue;
				}

			if (soap_flag_changes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes2 = 0;
					continue;
				}

			if (soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories1 = 0;
					continue;
				}

			if (soap_flag_created1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created1 = 0;
					continue;
				}

			if (soap_flag_customs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__ContainerItem *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ContainerItem, sizeof(ns1__ContainerItem), soap->type, soap->arrayType), SOAP_TYPE_ns1__ContainerItem, sizeof(ns1__ContainerItem));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ContainerItem * SOAP_FMAC6 soap_new_ns1__ContainerItem(struct soap *soap, int n)
{	return soap_instantiate_ns1__ContainerItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ContainerItem(struct soap *soap, ns1__ContainerItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__ContainerItem * SOAP_FMAC6 soap_instantiate_ns1__ContainerItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ContainerItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ContainerItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:AddressBookItem"))
	{	cp->type = SOAP_TYPE_ns1__AddressBookItem;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__AddressBookItem;
			if (size)
				*size = sizeof(ns1__AddressBookItem);
			((ns1__AddressBookItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__AddressBookItem[n];
			if (size)
				*size = n * sizeof(ns1__AddressBookItem);
			for (int i = 0; i < n; i++)
				((ns1__AddressBookItem*)cp->ptr)[i].soap = soap;
		}
		return (ns1__AddressBookItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:BoxEntry"))
	{	cp->type = SOAP_TYPE_ns1__BoxEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__BoxEntry;
			if (size)
				*size = sizeof(ns1__BoxEntry);
			((ns1__BoxEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__BoxEntry[n];
			if (size)
				*size = n * sizeof(ns1__BoxEntry);
			for (int i = 0; i < n; i++)
				((ns1__BoxEntry*)cp->ptr)[i].soap = soap;
		}
		return (ns1__BoxEntry*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Contact"))
	{	cp->type = SOAP_TYPE_ns1__Contact;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Contact;
			if (size)
				*size = sizeof(ns1__Contact);
			((ns1__Contact*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Contact[n];
			if (size)
				*size = n * sizeof(ns1__Contact);
			for (int i = 0; i < n; i++)
				((ns1__Contact*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Contact*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Group"))
	{	cp->type = SOAP_TYPE_ns1__Group;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Group;
			if (size)
				*size = sizeof(ns1__Group);
			((ns1__Group*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Group[n];
			if (size)
				*size = n * sizeof(ns1__Group);
			for (int i = 0; i < n; i++)
				((ns1__Group*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Group*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Mail"))
	{	cp->type = SOAP_TYPE_ns1__Mail;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Mail;
			if (size)
				*size = sizeof(ns1__Mail);
			((ns1__Mail*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Mail[n];
			if (size)
				*size = n * sizeof(ns1__Mail);
			for (int i = 0; i < n; i++)
				((ns1__Mail*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Mail*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Organization"))
	{	cp->type = SOAP_TYPE_ns1__Organization;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Organization;
			if (size)
				*size = sizeof(ns1__Organization);
			((ns1__Organization*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Organization[n];
			if (size)
				*size = n * sizeof(ns1__Organization);
			for (int i = 0; i < n; i++)
				((ns1__Organization*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Organization*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Resource"))
	{	cp->type = SOAP_TYPE_ns1__Resource;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Resource;
			if (size)
				*size = sizeof(ns1__Resource);
			((ns1__Resource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Resource[n];
			if (size)
				*size = n * sizeof(ns1__Resource);
			for (int i = 0; i < n; i++)
				((ns1__Resource*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Resource*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:CalendarItem"))
	{	cp->type = SOAP_TYPE_ns1__CalendarItem;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__CalendarItem;
			if (size)
				*size = sizeof(ns1__CalendarItem);
			((ns1__CalendarItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__CalendarItem[n];
			if (size)
				*size = n * sizeof(ns1__CalendarItem);
			for (int i = 0; i < n; i++)
				((ns1__CalendarItem*)cp->ptr)[i].soap = soap;
		}
		return (ns1__CalendarItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:DocumentRef"))
	{	cp->type = SOAP_TYPE_ns1__DocumentRef;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__DocumentRef;
			if (size)
				*size = sizeof(ns1__DocumentRef);
			((ns1__DocumentRef*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__DocumentRef[n];
			if (size)
				*size = n * sizeof(ns1__DocumentRef);
			for (int i = 0; i < n; i++)
				((ns1__DocumentRef*)cp->ptr)[i].soap = soap;
		}
		return (ns1__DocumentRef*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:PhoneMessage"))
	{	cp->type = SOAP_TYPE_ns1__PhoneMessage;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__PhoneMessage;
			if (size)
				*size = sizeof(ns1__PhoneMessage);
			((ns1__PhoneMessage*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__PhoneMessage[n];
			if (size)
				*size = n * sizeof(ns1__PhoneMessage);
			for (int i = 0; i < n; i++)
				((ns1__PhoneMessage*)cp->ptr)[i].soap = soap;
		}
		return (ns1__PhoneMessage*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Appointment"))
	{	cp->type = SOAP_TYPE_ns1__Appointment;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Appointment;
			if (size)
				*size = sizeof(ns1__Appointment);
			((ns1__Appointment*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Appointment[n];
			if (size)
				*size = n * sizeof(ns1__Appointment);
			for (int i = 0; i < n; i++)
				((ns1__Appointment*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Appointment*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Note"))
	{	cp->type = SOAP_TYPE_ns1__Note;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Note;
			if (size)
				*size = sizeof(ns1__Note);
			((ns1__Note*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Note[n];
			if (size)
				*size = n * sizeof(ns1__Note);
			for (int i = 0; i < n; i++)
				((ns1__Note*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Note*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Task"))
	{	cp->type = SOAP_TYPE_ns1__Task;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Task;
			if (size)
				*size = sizeof(ns1__Task);
			((ns1__Task*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Task[n];
			if (size)
				*size = n * sizeof(ns1__Task);
			for (int i = 0; i < n; i++)
				((ns1__Task*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Task*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ContainerItem;
		if (size)
			*size = sizeof(ns1__ContainerItem);
		((ns1__ContainerItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ContainerItem[n];
		if (size)
			*size = n * sizeof(ns1__ContainerItem);
		for (int i = 0; i < n; i++)
			((ns1__ContainerItem*)cp->ptr)[i].soap = soap;
	}
	return (ns1__ContainerItem*)cp->ptr;
}

void ns1__Contact::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Contact))
		this->soap_mark(soap);
}

void ns1__Contact::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Contact*)this)->fullName, SOAP_TYPE_PointerTons1__FullName);
	soap_mark_PointerTons1__FullName(soap, &((ns1__Contact*)this)->fullName);
	soap_embedded(soap, &((ns1__Contact*)this)->emailList, SOAP_TYPE_PointerTons1__EmailAddressList);
	soap_mark_PointerTons1__EmailAddressList(soap, &((ns1__Contact*)this)->emailList);
	soap_embedded(soap, &((ns1__Contact*)this)->imList, SOAP_TYPE_PointerTons1__ImAddressList);
	soap_mark_PointerTons1__ImAddressList(soap, &((ns1__Contact*)this)->imList);
	soap_embedded(soap, &((ns1__Contact*)this)->addressList, SOAP_TYPE_PointerTons1__PostalAddressList);
	soap_mark_PointerTons1__PostalAddressList(soap, &((ns1__Contact*)this)->addressList);
	soap_embedded(soap, &((ns1__Contact*)this)->officeInfo, SOAP_TYPE_PointerTons1__OfficeInfo);
	soap_mark_PointerTons1__OfficeInfo(soap, &((ns1__Contact*)this)->officeInfo);
	soap_embedded(soap, &((ns1__Contact*)this)->personalInfo, SOAP_TYPE_PointerTons1__PersonalInfo);
	soap_mark_PointerTons1__PersonalInfo(soap, &((ns1__Contact*)this)->personalInfo);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__AddressBookItem*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__AddressBookItem*)this)->uuid);
	soap_embedded(soap, &((ns1__AddressBookItem*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__AddressBookItem*)this)->comment);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__Contact::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__FullName(soap, &((ns1__Contact*)this)->fullName);
	soap_default_PointerTons1__EmailAddressList(soap, &((ns1__Contact*)this)->emailList);
	soap_default_PointerTons1__ImAddressList(soap, &((ns1__Contact*)this)->imList);
	soap_default_PointerTons1__PostalAddressList(soap, &((ns1__Contact*)this)->addressList);
	soap_default_PointerTons1__OfficeInfo(soap, &((ns1__Contact*)this)->officeInfo);
	soap_default_PointerTons1__PersonalInfo(soap, &((ns1__Contact*)this)->personalInfo);
	/* transient soap skipped */
	soap_default_ns1__UUID(soap, &((ns1__AddressBookItem*)this)->uuid);
	soap_default_PointerTostd__string(soap, &((ns1__AddressBookItem*)this)->comment);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__Contact::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Contact);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Contact::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Contact(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Contact(struct soap *soap, const char *tag, int id, const ns1__Contact *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Contact), "ns1:Contact");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__AddressBookItem*)a)->uuid), "ns1:UUID");
	soap_out_PointerTostd__string(soap, "comment", -1, &(((ns1__AddressBookItem*)a)->comment), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTons1__FullName(soap, "fullName", -1, &(((ns1__Contact*)a)->fullName), "ns1:FullName");
	soap_out_PointerTons1__EmailAddressList(soap, "emailList", -1, &(((ns1__Contact*)a)->emailList), "ns1:EmailAddressList");
	soap_out_PointerTons1__ImAddressList(soap, "imList", -1, &(((ns1__Contact*)a)->imList), "ns1:ImAddressList");
	soap_out_PointerTons1__PostalAddressList(soap, "addressList", -1, &(((ns1__Contact*)a)->addressList), "ns1:PostalAddressList");
	soap_out_PointerTons1__OfficeInfo(soap, "officeInfo", -1, &(((ns1__Contact*)a)->officeInfo), "ns1:OfficeInfo");
	soap_out_PointerTons1__PersonalInfo(soap, "personalInfo", -1, &(((ns1__Contact*)a)->personalInfo), "ns1:PersonalInfo");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Contact::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Contact(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Contact * SOAP_FMAC4 soap_get_ns1__Contact(struct soap *soap, ns1__Contact *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Contact(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Contact::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Contact(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Contact * SOAP_FMAC4 soap_in_ns1__Contact(struct soap *soap, const char *tag, ns1__Contact *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Contact *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Contact, sizeof(ns1__Contact), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Contact)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Contact *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_type4 = 1, soap_flag_categories3 = 1, soap_flag_created3 = 1, soap_flag_customs3 = 1, soap_flag_uuid2 = 1, soap_flag_comment2 = 1, soap_flag_fullName1 = 1, soap_flag_emailList1 = 1, soap_flag_imList1 = 1, soap_flag_addressList1 = 1, soap_flag_officeInfo1 = 1, soap_flag_personalInfo1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}

			if (soap_flag_name4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name4 = 0;
					continue;
				}

			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}

			if (soap_flag_modified4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}

			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}

			if (soap_flag_type4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories3 = 0;
					continue;
				}

			if (soap_flag_created3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created3 = 0;
					continue;
				}

			if (soap_flag_customs3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_uuid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__AddressBookItem*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}

			if (soap_flag_comment2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "comment", &(((ns1__AddressBookItem*)a)->comment), "xsd:string"))
				{	soap_flag_comment2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_fullName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FullName(soap, "fullName", &(((ns1__Contact*)a)->fullName), "ns1:FullName"))
				{	soap_flag_fullName1 = 0;
					continue;
				}

			if (soap_flag_emailList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__EmailAddressList(soap, "emailList", &(((ns1__Contact*)a)->emailList), "ns1:EmailAddressList"))
				{	soap_flag_emailList1 = 0;
					continue;
				}

			if (soap_flag_imList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ImAddressList(soap, "imList", &(((ns1__Contact*)a)->imList), "ns1:ImAddressList"))
				{	soap_flag_imList1 = 0;
					continue;
				}

			if (soap_flag_addressList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PostalAddressList(soap, "addressList", &(((ns1__Contact*)a)->addressList), "ns1:PostalAddressList"))
				{	soap_flag_addressList1 = 0;
					continue;
				}

			if (soap_flag_officeInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__OfficeInfo(soap, "officeInfo", &(((ns1__Contact*)a)->officeInfo), "ns1:OfficeInfo"))
				{	soap_flag_officeInfo1 = 0;
					continue;
				}

			if (soap_flag_personalInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PersonalInfo(soap, "personalInfo", &(((ns1__Contact*)a)->personalInfo), "ns1:PersonalInfo"))
				{	soap_flag_personalInfo1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Contact *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Contact, sizeof(ns1__Contact), soap->type, soap->arrayType), SOAP_TYPE_ns1__Contact, sizeof(ns1__Contact));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Contact * SOAP_FMAC6 soap_new_ns1__Contact(struct soap *soap, int n)
{	return soap_instantiate_ns1__Contact(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Contact(struct soap *soap, ns1__Contact *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Contact * SOAP_FMAC6 soap_instantiate_ns1__Contact(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Contact(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Contact, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Contact;
		if (size)
			*size = sizeof(ns1__Contact);
		((ns1__Contact*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Contact[n];
		if (size)
			*size = n * sizeof(ns1__Contact);
		for (int i = 0; i < n; i++)
			((ns1__Contact*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Contact*)cp->ptr;
}

void ns1__CommentStatus::soap_serialize(struct soap *soap) const
{
		this->soap_mark(soap);
}

void ns1__CommentStatus::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__CommentStatus*)this)->__item, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__CommentStatus*)this)->__item);
	/* transient soap skipped */
}

void ns1__CommentStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns1__CommentStatus*)this)->__item);
	soap_default_std__string(soap, &((ns1__CommentStatus*)this)->comment);
	/* transient soap skipped */
}

int ns1__CommentStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__CommentStatus);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__CommentStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CommentStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CommentStatus(struct soap *soap, const char *tag, int id, const ns1__CommentStatus *a, const char *type)
{
	if (!((ns1__CommentStatus *)a)->comment.empty())
		soap_set_attr(soap, "comment", ((ns1__CommentStatus *)a)->comment.c_str());
	soap_out_string(soap, tag, id, &(((ns1__CommentStatus*)a)->__item), "ns1:CommentStatus");
	return SOAP_OK;
}

void *ns1__CommentStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CommentStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CommentStatus * SOAP_FMAC4 soap_get_ns1__CommentStatus(struct soap *soap, ns1__CommentStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CommentStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CommentStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CommentStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CommentStatus * SOAP_FMAC4 soap_in_ns1__CommentStatus(struct soap *soap, const char *tag, ns1__CommentStatus *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ns1__CommentStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CommentStatus, sizeof(ns1__CommentStatus), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CommentStatus)
			return (ns1__CommentStatus *)a->soap_in(soap, tag, type);
	}
		{	const char *t = soap_attr_value(soap, "comment");
			if (t)
			{	char *s;
				if (soap_s2string(soap, t, &s))
					return NULL;
				((ns1__CommentStatus *)a)->comment.assign(s);
			}
		}
	if (!soap_in_string(soap, tag, &(((ns1__CommentStatus*)a)->__item), "ns1:CommentStatus"))
		return NULL;
	return a;
}

SOAP_FMAC5 ns1__CommentStatus * SOAP_FMAC6 soap_new_ns1__CommentStatus(struct soap *soap, int n)
{	return soap_instantiate_ns1__CommentStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CommentStatus(struct soap *soap, ns1__CommentStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__CommentStatus * SOAP_FMAC6 soap_instantiate_ns1__CommentStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CommentStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CommentStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CommentStatus;
		if (size)
			*size = sizeof(ns1__CommentStatus);
		((ns1__CommentStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CommentStatus[n];
		if (size)
			*size = n * sizeof(ns1__CommentStatus);
		for (int i = 0; i < n; i++)
			((ns1__CommentStatus*)cp->ptr)[i].soap = soap;
	}
	return (ns1__CommentStatus*)cp->ptr;
}

void ns1__CategoryRefList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__CategoryRefList))
		this->soap_mark(soap);
}

void ns1__CategoryRefList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__CategoryRefList*)this)->category, SOAP_TYPE_PointerTostd__vectorTemplateOfns1__uid);
	soap_mark_PointerTostd__vectorTemplateOfns1__uid(soap, &((ns1__CategoryRefList*)this)->category);
	/* transient soap skipped */
}

void ns1__CategoryRefList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfns1__uid(soap, &((ns1__CategoryRefList*)this)->category);
	soap_default_ns1__uid(soap, &((ns1__CategoryRefList*)this)->primary);
	/* transient soap skipped */
}

int ns1__CategoryRefList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__CategoryRefList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__CategoryRefList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CategoryRefList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CategoryRefList(struct soap *soap, const char *tag, int id, const ns1__CategoryRefList *a, const char *type)
{
	if (!((ns1__CategoryRefList *)a)->primary.empty())
		soap_set_attr(soap, "primary", ((ns1__CategoryRefList *)a)->primary.c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CategoryRefList), "ns1:CategoryRefList");
	soap_out_PointerTostd__vectorTemplateOfns1__uid(soap, "category", -1, &(((ns1__CategoryRefList*)a)->category), "ns1:uid");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CategoryRefList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CategoryRefList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CategoryRefList * SOAP_FMAC4 soap_get_ns1__CategoryRefList(struct soap *soap, ns1__CategoryRefList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CategoryRefList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CategoryRefList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CategoryRefList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CategoryRefList * SOAP_FMAC4 soap_in_ns1__CategoryRefList(struct soap *soap, const char *tag, ns1__CategoryRefList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__CategoryRefList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CategoryRefList, sizeof(ns1__CategoryRefList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__CategoryRefList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__CategoryRefList *)a->soap_in(soap, tag, type);
			}
		}
		{	const char *t = soap_attr_value(soap, "primary");
			if (t)
			{	char *s;
				if (soap_s2string(soap, t, &s))
					return NULL;
				((ns1__CategoryRefList *)a)->primary.assign(s);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfns1__uid(soap, "category", &(((ns1__CategoryRefList*)a)->category), "ns1:uid"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__CategoryRefList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CategoryRefList, sizeof(ns1__CategoryRefList), soap->type, soap->arrayType), SOAP_TYPE_ns1__CategoryRefList, sizeof(ns1__CategoryRefList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CategoryRefList * SOAP_FMAC6 soap_new_ns1__CategoryRefList(struct soap *soap, int n)
{	return soap_instantiate_ns1__CategoryRefList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CategoryRefList(struct soap *soap, ns1__CategoryRefList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__CategoryRefList * SOAP_FMAC6 soap_instantiate_ns1__CategoryRefList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CategoryRefList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CategoryRefList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CategoryRefList;
		if (size)
			*size = sizeof(ns1__CategoryRefList);
		((ns1__CategoryRefList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CategoryRefList[n];
		if (size)
			*size = n * sizeof(ns1__CategoryRefList);
		for (int i = 0; i < n; i++)
			((ns1__CategoryRefList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__CategoryRefList*)cp->ptr;
}

void ns1__CategoryList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__CategoryList))
		this->soap_mark(soap);
}

void ns1__CategoryList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__CategoryList*)this)->category, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Category);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Category(soap, &((ns1__CategoryList*)this)->category);
	/* transient soap skipped */
}

void ns1__CategoryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__Category(soap, &((ns1__CategoryList*)this)->category);
	/* transient soap skipped */
}

int ns1__CategoryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__CategoryList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__CategoryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CategoryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CategoryList(struct soap *soap, const char *tag, int id, const ns1__CategoryList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CategoryList), "ns1:CategoryList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Category(soap, "category", -1, &(((ns1__CategoryList*)a)->category), "ns1:Category");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CategoryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CategoryList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CategoryList * SOAP_FMAC4 soap_get_ns1__CategoryList(struct soap *soap, ns1__CategoryList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CategoryList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CategoryList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CategoryList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CategoryList * SOAP_FMAC4 soap_in_ns1__CategoryList(struct soap *soap, const char *tag, ns1__CategoryList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__CategoryList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CategoryList, sizeof(ns1__CategoryList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__CategoryList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__CategoryList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__Category(soap, "category", &(((ns1__CategoryList*)a)->category), "ns1:Category"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__CategoryList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CategoryList, sizeof(ns1__CategoryList), soap->type, soap->arrayType), SOAP_TYPE_ns1__CategoryList, sizeof(ns1__CategoryList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CategoryList * SOAP_FMAC6 soap_new_ns1__CategoryList(struct soap *soap, int n)
{	return soap_instantiate_ns1__CategoryList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CategoryList(struct soap *soap, ns1__CategoryList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__CategoryList * SOAP_FMAC6 soap_instantiate_ns1__CategoryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CategoryList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CategoryList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CategoryList;
		if (size)
			*size = sizeof(ns1__CategoryList);
		((ns1__CategoryList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CategoryList[n];
		if (size)
			*size = n * sizeof(ns1__CategoryList);
		for (int i = 0; i < n; i++)
			((ns1__CategoryList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__CategoryList*)cp->ptr;
}

void ns1__Category::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Category))
		this->soap_mark(soap);
}

void ns1__Category::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Category*)this)->categoryType, SOAP_TYPE_PointerTons1__CategoryType);
	soap_mark_PointerTons1__CategoryType(soap, &((ns1__Category*)this)->categoryType);
	soap_embedded(soap, &((ns1__Category*)this)->color, SOAP_TYPE_PointerTounsignedLong);
	soap_mark_PointerTounsignedLong(soap, &((ns1__Category*)this)->color);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__Category::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__CategoryType(soap, &((ns1__Category*)this)->categoryType);
	soap_default_PointerTounsignedLong(soap, &((ns1__Category*)this)->color);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__Category::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Category);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Category::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Category(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Category(struct soap *soap, const char *tag, int id, const ns1__Category *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Category), "ns1:Category");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTons1__CategoryType(soap, "categoryType", -1, &(((ns1__Category*)a)->categoryType), "ns1:CategoryType");
	soap_out_PointerTounsignedLong(soap, "color", -1, &(((ns1__Category*)a)->color), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Category::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Category(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Category * SOAP_FMAC4 soap_get_ns1__Category(struct soap *soap, ns1__Category *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Category(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Category::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Category(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Category * SOAP_FMAC4 soap_in_ns1__Category(struct soap *soap, const char *tag, ns1__Category *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Category *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Category, sizeof(ns1__Category), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Category)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Category *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id2 = 1, soap_flag_name2 = 1, soap_flag_version2 = 1, soap_flag_modified2 = 1, soap_flag_changes2 = 1, soap_flag_type2 = 1, soap_flag_categoryType1 = 1, soap_flag_color1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id2 = 0;
					continue;
				}

			if (soap_flag_name2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name2 = 0;
					continue;
				}

			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version2 = 0;
					continue;
				}

			if (soap_flag_modified2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified2 = 0;
					continue;
				}

			if (soap_flag_changes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes2 = 0;
					continue;
				}

			if (soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_categoryType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryType(soap, "categoryType", &(((ns1__Category*)a)->categoryType), "ns1:CategoryType"))
				{	soap_flag_categoryType1 = 0;
					continue;
				}

			if (soap_flag_color1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "color", &(((ns1__Category*)a)->color), ""))
				{	soap_flag_color1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Category *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Category, sizeof(ns1__Category), soap->type, soap->arrayType), SOAP_TYPE_ns1__Category, sizeof(ns1__Category));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Category * SOAP_FMAC6 soap_new_ns1__Category(struct soap *soap, int n)
{	return soap_instantiate_ns1__Category(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Category(struct soap *soap, ns1__Category *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Category * SOAP_FMAC6 soap_instantiate_ns1__Category(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Category(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Category, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Category;
		if (size)
			*size = sizeof(ns1__Category);
		((ns1__Category*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Category[n];
		if (size)
			*size = n * sizeof(ns1__Category);
		for (int i = 0; i < n; i++)
			((ns1__Category*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Category*)cp->ptr;
}

void ns1__CalendarItem::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__CalendarItem))
		this->soap_mark(soap);
}

void ns1__CalendarItem::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__CalendarItem*)this)->startDate, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__CalendarItem*)this)->startDate);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->rdate, SOAP_TYPE_PointerTons1__RecurrenceDateType);
	soap_mark_PointerTons1__RecurrenceDateType(soap, &((ns1__CalendarItem*)this)->rdate);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->isRecurring, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__CalendarItem*)this)->isRecurring);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->iCalId, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__CalendarItem*)this)->iCalId);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Mail*)this)->subject, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_embedded(soap, &((ns1__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ns1__Mail*)this)->distribution, SOAP_TYPE_PointerTons1__Distribution);
	soap_mark_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_embedded(soap, &((ns1__Mail*)this)->message, SOAP_TYPE_PointerTons1__MessageBody);
	soap_mark_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_embedded(soap, &((ns1__Mail*)this)->attachments, SOAP_TYPE_PointerTons1__AttachmentInfo);
	soap_mark_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_embedded(soap, &((ns1__Mail*)this)->options, SOAP_TYPE_PointerTons1__ItemOptions);
	soap_mark_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__BoxEntry*)this)->status, SOAP_TYPE_PointerTons1__ItemStatus);
	soap_mark_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->msgid, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->source, SOAP_TYPE_PointerTons1__ItemSource);
	soap_mark_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->class_, SOAP_TYPE_PointerTons1__ItemClass);
	soap_mark_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__CalendarItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns1__CalendarItem*)this)->startDate);
	soap_default_PointerTons1__RecurrenceDateType(soap, &((ns1__CalendarItem*)this)->rdate);
	soap_default_PointerTobool(soap, &((ns1__CalendarItem*)this)->isRecurring);
	soap_default_PointerTostd__string(soap, &((ns1__CalendarItem*)this)->iCalId);
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_default_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_default_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_default_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_default_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_default_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_default_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_default_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_default_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_default_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__CalendarItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__CalendarItem);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__CalendarItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CalendarItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CalendarItem(struct soap *soap, const char *tag, int id, const ns1__CalendarItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CalendarItem), "ns1:CalendarItem");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_PointerTons1__ItemStatus(soap, "status", -1, &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus");
	soap_out_PointerTostd__string(soap, "thread", -1, &(((ns1__BoxEntry*)a)->thread), "xsd:string");
	soap_out_PointerTostd__string(soap, "msgid", -1, &(((ns1__BoxEntry*)a)->msgid), "xsd:string");
	soap_out_PointerTons1__ItemSource(soap, "source", -1, &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource");
	soap_out_string(soap, "delivered", -1, &(((ns1__BoxEntry*)a)->delivered), "");
	soap_out_PointerTons1__ItemClass(soap, "class", -1, &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass");
	/* transient soap skipped */
	soap_out_std__string(soap, "subject", -1, &(((ns1__Mail*)a)->subject), "xsd:string");
	soap_out_PointerTostd__string(soap, "originalSubject", -1, &(((ns1__Mail*)a)->originalSubject), "xsd:string");
	soap_out_PointerTons1__Distribution(soap, "distribution", -1, &(((ns1__Mail*)a)->distribution), "ns1:Distribution");
	soap_out_PointerTons1__MessageBody(soap, "message", -1, &(((ns1__Mail*)a)->message), "ns1:MessageBody");
	soap_out_PointerTons1__AttachmentInfo(soap, "attachments", -1, &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo");
	soap_out_PointerTons1__ItemOptions(soap, "options", -1, &(((ns1__Mail*)a)->options), "ns1:ItemOptions");
	/* transient soap skipped */
	soap_out_string(soap, "startDate", -1, &(((ns1__CalendarItem*)a)->startDate), "");
	soap_out_PointerTons1__RecurrenceDateType(soap, "rdate", -1, &(((ns1__CalendarItem*)a)->rdate), "ns1:RecurrenceDateType");
	soap_out_PointerTobool(soap, "isRecurring", -1, &(((ns1__CalendarItem*)a)->isRecurring), "");
	soap_out_PointerTostd__string(soap, "iCalId", -1, &(((ns1__CalendarItem*)a)->iCalId), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CalendarItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CalendarItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CalendarItem * SOAP_FMAC4 soap_get_ns1__CalendarItem(struct soap *soap, ns1__CalendarItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CalendarItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CalendarItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CalendarItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CalendarItem * SOAP_FMAC4 soap_in_ns1__CalendarItem(struct soap *soap, const char *tag, ns1__CalendarItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__CalendarItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CalendarItem, sizeof(ns1__CalendarItem), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__CalendarItem)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__CalendarItem *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id5 = 1, soap_flag_name5 = 1, soap_flag_version5 = 1, soap_flag_modified5 = 1, soap_flag_changes5 = 1, soap_flag_type5 = 1, soap_flag_categories4 = 1, soap_flag_created4 = 1, soap_flag_customs4 = 1, soap_flag_status3 = 1, soap_flag_thread3 = 1, soap_flag_msgid3 = 1, soap_flag_source3 = 1, soap_flag_delivered3 = 1, soap_flag_class_3 = 1, soap_flag_subject2 = 1, soap_flag_originalSubject2 = 1, soap_flag_distribution2 = 1, soap_flag_message2 = 1, soap_flag_attachments2 = 1, soap_flag_options2 = 1, soap_flag_startDate1 = 1, soap_flag_rdate1 = 1, soap_flag_isRecurring1 = 1, soap_flag_iCalId1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id5 = 0;
					continue;
				}

			if (soap_flag_name5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name5 = 0;
					continue;
				}

			if (soap_flag_version5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version5 = 0;
					continue;
				}

			if (soap_flag_modified5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified5 = 0;
					continue;
				}

			if (soap_flag_changes5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes5 = 0;
					continue;
				}

			if (soap_flag_type5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type5 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories4 = 0;
					continue;
				}

			if (soap_flag_created4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created4 = 0;
					continue;
				}

			if (soap_flag_customs4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemStatus(soap, "status", &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus"))
				{	soap_flag_status3 = 0;
					continue;
				}

			if (soap_flag_thread3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "thread", &(((ns1__BoxEntry*)a)->thread), "xsd:string"))
				{	soap_flag_thread3 = 0;
					continue;
				}

			if (soap_flag_msgid3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "msgid", &(((ns1__BoxEntry*)a)->msgid), "xsd:string"))
				{	soap_flag_msgid3 = 0;
					continue;
				}

			if (soap_flag_source3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemSource(soap, "source", &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource"))
				{	soap_flag_source3 = 0;
					continue;
				}

			if (soap_flag_delivered3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "delivered", &(((ns1__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered3 = 0;
					continue;
				}

			if (soap_flag_class_3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemClass(soap, "class", &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass"))
				{	soap_flag_class_3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_subject2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "subject", &(((ns1__Mail*)a)->subject), "xsd:string"))
				{	soap_flag_subject2 = 0;
					continue;
				}

			if (soap_flag_originalSubject2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "originalSubject", &(((ns1__Mail*)a)->originalSubject), "xsd:string"))
				{	soap_flag_originalSubject2 = 0;
					continue;
				}

			if (soap_flag_distribution2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Distribution(soap, "distribution", &(((ns1__Mail*)a)->distribution), "ns1:Distribution"))
				{	soap_flag_distribution2 = 0;
					continue;
				}

			if (soap_flag_message2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MessageBody(soap, "message", &(((ns1__Mail*)a)->message), "ns1:MessageBody"))
				{	soap_flag_message2 = 0;
					continue;
				}

			if (soap_flag_attachments2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AttachmentInfo(soap, "attachments", &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo"))
				{	soap_flag_attachments2 = 0;
					continue;
				}

			if (soap_flag_options2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemOptions(soap, "options", &(((ns1__Mail*)a)->options), "ns1:ItemOptions"))
				{	soap_flag_options2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "startDate", &(((ns1__CalendarItem*)a)->startDate), ""))
				{	soap_flag_startDate1 = 0;
					continue;
				}

			if (soap_flag_rdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RecurrenceDateType(soap, "rdate", &(((ns1__CalendarItem*)a)->rdate), "ns1:RecurrenceDateType"))
				{	soap_flag_rdate1 = 0;
					continue;
				}

			if (soap_flag_isRecurring1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isRecurring", &(((ns1__CalendarItem*)a)->isRecurring), ""))
				{	soap_flag_isRecurring1 = 0;
					continue;
				}

			if (soap_flag_iCalId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "iCalId", &(((ns1__CalendarItem*)a)->iCalId), "xsd:string"))
				{	soap_flag_iCalId1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_subject2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__CalendarItem *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CalendarItem, sizeof(ns1__CalendarItem), soap->type, soap->arrayType), SOAP_TYPE_ns1__CalendarItem, sizeof(ns1__CalendarItem));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CalendarItem * SOAP_FMAC6 soap_new_ns1__CalendarItem(struct soap *soap, int n)
{	return soap_instantiate_ns1__CalendarItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CalendarItem(struct soap *soap, ns1__CalendarItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__CalendarItem * SOAP_FMAC6 soap_instantiate_ns1__CalendarItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CalendarItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CalendarItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:Appointment"))
	{	cp->type = SOAP_TYPE_ns1__Appointment;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Appointment;
			if (size)
				*size = sizeof(ns1__Appointment);
			((ns1__Appointment*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Appointment[n];
			if (size)
				*size = n * sizeof(ns1__Appointment);
			for (int i = 0; i < n; i++)
				((ns1__Appointment*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Appointment*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Note"))
	{	cp->type = SOAP_TYPE_ns1__Note;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Note;
			if (size)
				*size = sizeof(ns1__Note);
			((ns1__Note*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Note[n];
			if (size)
				*size = n * sizeof(ns1__Note);
			for (int i = 0; i < n; i++)
				((ns1__Note*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Note*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Task"))
	{	cp->type = SOAP_TYPE_ns1__Task;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Task;
			if (size)
				*size = sizeof(ns1__Task);
			((ns1__Task*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Task[n];
			if (size)
				*size = n * sizeof(ns1__Task);
			for (int i = 0; i < n; i++)
				((ns1__Task*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Task*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CalendarItem;
		if (size)
			*size = sizeof(ns1__CalendarItem);
		((ns1__CalendarItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CalendarItem[n];
		if (size)
			*size = n * sizeof(ns1__CalendarItem);
		for (int i = 0; i < n; i++)
			((ns1__CalendarItem*)cp->ptr)[i].soap = soap;
	}
	return (ns1__CalendarItem*)cp->ptr;
}

void ns1__BoxEntry::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__BoxEntry))
		this->soap_mark(soap);
}

void ns1__BoxEntry::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__BoxEntry*)this)->status, SOAP_TYPE_PointerTons1__ItemStatus);
	soap_mark_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->msgid, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->source, SOAP_TYPE_PointerTons1__ItemSource);
	soap_mark_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->class_, SOAP_TYPE_PointerTons1__ItemClass);
	soap_mark_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__BoxEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_default_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_default_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_default_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__BoxEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__BoxEntry);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__BoxEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BoxEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BoxEntry(struct soap *soap, const char *tag, int id, const ns1__BoxEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BoxEntry), "ns1:BoxEntry");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_PointerTons1__ItemStatus(soap, "status", -1, &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus");
	soap_out_PointerTostd__string(soap, "thread", -1, &(((ns1__BoxEntry*)a)->thread), "xsd:string");
	soap_out_PointerTostd__string(soap, "msgid", -1, &(((ns1__BoxEntry*)a)->msgid), "xsd:string");
	soap_out_PointerTons1__ItemSource(soap, "source", -1, &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource");
	soap_out_string(soap, "delivered", -1, &(((ns1__BoxEntry*)a)->delivered), "");
	soap_out_PointerTons1__ItemClass(soap, "class", -1, &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__BoxEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BoxEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BoxEntry * SOAP_FMAC4 soap_get_ns1__BoxEntry(struct soap *soap, ns1__BoxEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BoxEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__BoxEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BoxEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BoxEntry * SOAP_FMAC4 soap_in_ns1__BoxEntry(struct soap *soap, const char *tag, ns1__BoxEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__BoxEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BoxEntry, sizeof(ns1__BoxEntry), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__BoxEntry)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__BoxEntry *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_type3 = 1, soap_flag_categories2 = 1, soap_flag_created2 = 1, soap_flag_customs2 = 1, soap_flag_status1 = 1, soap_flag_thread1 = 1, soap_flag_msgid1 = 1, soap_flag_source1 = 1, soap_flag_delivered1 = 1, soap_flag_class_1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}

			if (soap_flag_name3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name3 = 0;
					continue;
				}

			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}

			if (soap_flag_modified3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}

			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}

			if (soap_flag_type3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories2 = 0;
					continue;
				}

			if (soap_flag_created2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created2 = 0;
					continue;
				}

			if (soap_flag_customs2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemStatus(soap, "status", &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus"))
				{	soap_flag_status1 = 0;
					continue;
				}

			if (soap_flag_thread1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "thread", &(((ns1__BoxEntry*)a)->thread), "xsd:string"))
				{	soap_flag_thread1 = 0;
					continue;
				}

			if (soap_flag_msgid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "msgid", &(((ns1__BoxEntry*)a)->msgid), "xsd:string"))
				{	soap_flag_msgid1 = 0;
					continue;
				}

			if (soap_flag_source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemSource(soap, "source", &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource"))
				{	soap_flag_source1 = 0;
					continue;
				}

			if (soap_flag_delivered1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "delivered", &(((ns1__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered1 = 0;
					continue;
				}

			if (soap_flag_class_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemClass(soap, "class", &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass"))
				{	soap_flag_class_1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__BoxEntry *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BoxEntry, sizeof(ns1__BoxEntry), soap->type, soap->arrayType), SOAP_TYPE_ns1__BoxEntry, sizeof(ns1__BoxEntry));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__BoxEntry * SOAP_FMAC6 soap_new_ns1__BoxEntry(struct soap *soap, int n)
{	return soap_instantiate_ns1__BoxEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__BoxEntry(struct soap *soap, ns1__BoxEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__BoxEntry * SOAP_FMAC6 soap_instantiate_ns1__BoxEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BoxEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BoxEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:Mail"))
	{	cp->type = SOAP_TYPE_ns1__Mail;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Mail;
			if (size)
				*size = sizeof(ns1__Mail);
			((ns1__Mail*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Mail[n];
			if (size)
				*size = n * sizeof(ns1__Mail);
			for (int i = 0; i < n; i++)
				((ns1__Mail*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Mail*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:CalendarItem"))
	{	cp->type = SOAP_TYPE_ns1__CalendarItem;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__CalendarItem;
			if (size)
				*size = sizeof(ns1__CalendarItem);
			((ns1__CalendarItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__CalendarItem[n];
			if (size)
				*size = n * sizeof(ns1__CalendarItem);
			for (int i = 0; i < n; i++)
				((ns1__CalendarItem*)cp->ptr)[i].soap = soap;
		}
		return (ns1__CalendarItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:DocumentRef"))
	{	cp->type = SOAP_TYPE_ns1__DocumentRef;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__DocumentRef;
			if (size)
				*size = sizeof(ns1__DocumentRef);
			((ns1__DocumentRef*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__DocumentRef[n];
			if (size)
				*size = n * sizeof(ns1__DocumentRef);
			for (int i = 0; i < n; i++)
				((ns1__DocumentRef*)cp->ptr)[i].soap = soap;
		}
		return (ns1__DocumentRef*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:PhoneMessage"))
	{	cp->type = SOAP_TYPE_ns1__PhoneMessage;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__PhoneMessage;
			if (size)
				*size = sizeof(ns1__PhoneMessage);
			((ns1__PhoneMessage*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__PhoneMessage[n];
			if (size)
				*size = n * sizeof(ns1__PhoneMessage);
			for (int i = 0; i < n; i++)
				((ns1__PhoneMessage*)cp->ptr)[i].soap = soap;
		}
		return (ns1__PhoneMessage*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Appointment"))
	{	cp->type = SOAP_TYPE_ns1__Appointment;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Appointment;
			if (size)
				*size = sizeof(ns1__Appointment);
			((ns1__Appointment*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Appointment[n];
			if (size)
				*size = n * sizeof(ns1__Appointment);
			for (int i = 0; i < n; i++)
				((ns1__Appointment*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Appointment*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Note"))
	{	cp->type = SOAP_TYPE_ns1__Note;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Note;
			if (size)
				*size = sizeof(ns1__Note);
			((ns1__Note*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Note[n];
			if (size)
				*size = n * sizeof(ns1__Note);
			for (int i = 0; i < n; i++)
				((ns1__Note*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Note*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Task"))
	{	cp->type = SOAP_TYPE_ns1__Task;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Task;
			if (size)
				*size = sizeof(ns1__Task);
			((ns1__Task*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Task[n];
			if (size)
				*size = n * sizeof(ns1__Task);
			for (int i = 0; i < n; i++)
				((ns1__Task*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Task*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__BoxEntry;
		if (size)
			*size = sizeof(ns1__BoxEntry);
		((ns1__BoxEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__BoxEntry[n];
		if (size)
			*size = n * sizeof(ns1__BoxEntry);
		for (int i = 0; i < n; i++)
			((ns1__BoxEntry*)cp->ptr)[i].soap = soap;
	}
	return (ns1__BoxEntry*)cp->ptr;
}

void ns1__Authentication::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Authentication))
		this->soap_mark(soap);
}

void ns1__Authentication::soap_mark(struct soap *soap) const
{
	/* transient soap skipped */
}

void ns1__Authentication::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int ns1__Authentication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Authentication);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Authentication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Authentication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Authentication(struct soap *soap, const char *tag, int id, const ns1__Authentication *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Authentication), "ns1:Authentication");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Authentication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Authentication(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Authentication * SOAP_FMAC4 soap_get_ns1__Authentication(struct soap *soap, ns1__Authentication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Authentication(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Authentication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Authentication(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Authentication * SOAP_FMAC4 soap_in_ns1__Authentication(struct soap *soap, const char *tag, ns1__Authentication *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Authentication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Authentication, sizeof(ns1__Authentication), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Authentication)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Authentication *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__Authentication *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Authentication, sizeof(ns1__Authentication), soap->type, soap->arrayType), SOAP_TYPE_ns1__Authentication, sizeof(ns1__Authentication));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Authentication * SOAP_FMAC6 soap_new_ns1__Authentication(struct soap *soap, int n)
{	return soap_instantiate_ns1__Authentication(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Authentication(struct soap *soap, ns1__Authentication *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Authentication * SOAP_FMAC6 soap_instantiate_ns1__Authentication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Authentication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Authentication, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:PlainText"))
	{	cp->type = SOAP_TYPE_ns1__PlainText;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__PlainText;
			if (size)
				*size = sizeof(ns1__PlainText);
			((ns1__PlainText*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__PlainText[n];
			if (size)
				*size = n * sizeof(ns1__PlainText);
			for (int i = 0; i < n; i++)
				((ns1__PlainText*)cp->ptr)[i].soap = soap;
		}
		return (ns1__PlainText*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Proxy"))
	{	cp->type = SOAP_TYPE_ns1__Proxy;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Proxy;
			if (size)
				*size = sizeof(ns1__Proxy);
			((ns1__Proxy*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Proxy[n];
			if (size)
				*size = n * sizeof(ns1__Proxy);
			for (int i = 0; i < n; i++)
				((ns1__Proxy*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Proxy*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:TrustedApplication"))
	{	cp->type = SOAP_TYPE_ns1__TrustedApplication;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__TrustedApplication;
			if (size)
				*size = sizeof(ns1__TrustedApplication);
			((ns1__TrustedApplication*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__TrustedApplication[n];
			if (size)
				*size = n * sizeof(ns1__TrustedApplication);
			for (int i = 0; i < n; i++)
				((ns1__TrustedApplication*)cp->ptr)[i].soap = soap;
		}
		return (ns1__TrustedApplication*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Authentication;
		if (size)
			*size = sizeof(ns1__Authentication);
		((ns1__Authentication*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Authentication[n];
		if (size)
			*size = n * sizeof(ns1__Authentication);
		for (int i = 0; i < n; i++)
			((ns1__Authentication*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Authentication*)cp->ptr;
}

void ns1__AttachmentItemInfo::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AttachmentItemInfo))
		this->soap_mark(soap);
}

void ns1__AttachmentItemInfo::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AttachmentItemInfo*)this)->id, SOAP_TYPE_PointerTons1__AttachmentID);
	soap_mark_PointerTons1__AttachmentID(soap, &((ns1__AttachmentItemInfo*)this)->id);
	soap_embedded(soap, &((ns1__AttachmentItemInfo*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__AttachmentItemInfo*)this)->name);
	soap_embedded(soap, &((ns1__AttachmentItemInfo*)this)->contentId, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__AttachmentItemInfo*)this)->contentId);
	soap_embedded(soap, &((ns1__AttachmentItemInfo*)this)->contentType, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__AttachmentItemInfo*)this)->contentType);
	soap_embedded(soap, &((ns1__AttachmentItemInfo*)this)->size, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__AttachmentItemInfo*)this)->date, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__AttachmentItemInfo*)this)->date);
	soap_embedded(soap, &((ns1__AttachmentItemInfo*)this)->data, SOAP_TYPE_PointerToxsd__base64Binary);
	soap_mark_PointerToxsd__base64Binary(soap, &((ns1__AttachmentItemInfo*)this)->data);
	/* transient soap skipped */
}

void ns1__AttachmentItemInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__AttachmentID(soap, &((ns1__AttachmentItemInfo*)this)->id);
	soap_default_std__string(soap, &((ns1__AttachmentItemInfo*)this)->name);
	soap_default_PointerTostd__string(soap, &((ns1__AttachmentItemInfo*)this)->contentId);
	soap_default_PointerTostd__string(soap, &((ns1__AttachmentItemInfo*)this)->contentType);
	soap_default_unsignedLong(soap, &((ns1__AttachmentItemInfo*)this)->size);
	soap_default_string(soap, &((ns1__AttachmentItemInfo*)this)->date);
	soap_default_PointerToxsd__base64Binary(soap, &((ns1__AttachmentItemInfo*)this)->data);
	/* transient soap skipped */
}

int ns1__AttachmentItemInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AttachmentItemInfo);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AttachmentItemInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AttachmentItemInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AttachmentItemInfo(struct soap *soap, const char *tag, int id, const ns1__AttachmentItemInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AttachmentItemInfo), "ns1:AttachmentItemInfo");
	soap_out_PointerTons1__AttachmentID(soap, "id", -1, &(((ns1__AttachmentItemInfo*)a)->id), "ns1:AttachmentID");
	soap_out_std__string(soap, "name", -1, &(((ns1__AttachmentItemInfo*)a)->name), "xsd:string");
	soap_out_PointerTostd__string(soap, "contentId", -1, &(((ns1__AttachmentItemInfo*)a)->contentId), "xsd:string");
	soap_out_PointerTostd__string(soap, "contentType", -1, &(((ns1__AttachmentItemInfo*)a)->contentType), "xsd:string");
	soap_out_unsignedLong(soap, "size", -1, &(((ns1__AttachmentItemInfo*)a)->size), "");
	soap_out_string(soap, "date", -1, &(((ns1__AttachmentItemInfo*)a)->date), "");
	soap_out_PointerToxsd__base64Binary(soap, "data", -1, &(((ns1__AttachmentItemInfo*)a)->data), "xsd:base64Binary");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AttachmentItemInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AttachmentItemInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AttachmentItemInfo * SOAP_FMAC4 soap_get_ns1__AttachmentItemInfo(struct soap *soap, ns1__AttachmentItemInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AttachmentItemInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AttachmentItemInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AttachmentItemInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AttachmentItemInfo * SOAP_FMAC4 soap_in_ns1__AttachmentItemInfo(struct soap *soap, const char *tag, ns1__AttachmentItemInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AttachmentItemInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AttachmentItemInfo, sizeof(ns1__AttachmentItemInfo), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AttachmentItemInfo)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AttachmentItemInfo *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_name1 = 1, soap_flag_contentId1 = 1, soap_flag_contentType1 = 1, soap_flag_size1 = 1, soap_flag_date1 = 1, soap_flag_data1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AttachmentID(soap, "id", &(((ns1__AttachmentItemInfo*)a)->id), "ns1:AttachmentID"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__AttachmentItemInfo*)a)->name), "xsd:string"))
				{	soap_flag_name1 = 0;
					continue;
				}

			if (soap_flag_contentId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "contentId", &(((ns1__AttachmentItemInfo*)a)->contentId), "xsd:string"))
				{	soap_flag_contentId1 = 0;
					continue;
				}

			if (soap_flag_contentType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "contentType", &(((ns1__AttachmentItemInfo*)a)->contentType), "xsd:string"))
				{	soap_flag_contentType1 = 0;
					continue;
				}

			if (soap_flag_size1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "size", &(((ns1__AttachmentItemInfo*)a)->size), ""))
				{	soap_flag_size1 = 0;
					continue;
				}

			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "date", &(((ns1__AttachmentItemInfo*)a)->date), ""))
				{	soap_flag_date1 = 0;
					continue;
				}

			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "data", &(((ns1__AttachmentItemInfo*)a)->data), "xsd:base64Binary"))
				{	soap_flag_data1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 || soap_flag_size1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__AttachmentItemInfo *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AttachmentItemInfo, sizeof(ns1__AttachmentItemInfo), soap->type, soap->arrayType), SOAP_TYPE_ns1__AttachmentItemInfo, sizeof(ns1__AttachmentItemInfo));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AttachmentItemInfo * SOAP_FMAC6 soap_new_ns1__AttachmentItemInfo(struct soap *soap, int n)
{	return soap_instantiate_ns1__AttachmentItemInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AttachmentItemInfo(struct soap *soap, ns1__AttachmentItemInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AttachmentItemInfo * SOAP_FMAC6 soap_instantiate_ns1__AttachmentItemInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AttachmentItemInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AttachmentItemInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AttachmentItemInfo;
		if (size)
			*size = sizeof(ns1__AttachmentItemInfo);
		((ns1__AttachmentItemInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AttachmentItemInfo[n];
		if (size)
			*size = n * sizeof(ns1__AttachmentItemInfo);
		for (int i = 0; i < n; i++)
			((ns1__AttachmentItemInfo*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AttachmentItemInfo*)cp->ptr;
}

void ns1__AttachmentInfo::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AttachmentInfo))
		this->soap_mark(soap);
}

void ns1__AttachmentInfo::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AttachmentInfo*)this)->attachment, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, &((ns1__AttachmentInfo*)this)->attachment);
	/* transient soap skipped */
}

void ns1__AttachmentInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, &((ns1__AttachmentInfo*)this)->attachment);
	/* transient soap skipped */
}

int ns1__AttachmentInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AttachmentInfo);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AttachmentInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AttachmentInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AttachmentInfo(struct soap *soap, const char *tag, int id, const ns1__AttachmentInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AttachmentInfo), "ns1:AttachmentInfo");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, "attachment", -1, &(((ns1__AttachmentInfo*)a)->attachment), "ns1:AttachmentItemInfo");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AttachmentInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AttachmentInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AttachmentInfo * SOAP_FMAC4 soap_get_ns1__AttachmentInfo(struct soap *soap, ns1__AttachmentInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AttachmentInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AttachmentInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AttachmentInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AttachmentInfo * SOAP_FMAC4 soap_in_ns1__AttachmentInfo(struct soap *soap, const char *tag, ns1__AttachmentInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AttachmentInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AttachmentInfo, sizeof(ns1__AttachmentInfo), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AttachmentInfo)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AttachmentInfo *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, "attachment", &(((ns1__AttachmentInfo*)a)->attachment), "ns1:AttachmentItemInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__AttachmentInfo *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AttachmentInfo, sizeof(ns1__AttachmentInfo), soap->type, soap->arrayType), SOAP_TYPE_ns1__AttachmentInfo, sizeof(ns1__AttachmentInfo));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AttachmentInfo * SOAP_FMAC6 soap_new_ns1__AttachmentInfo(struct soap *soap, int n)
{	return soap_instantiate_ns1__AttachmentInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AttachmentInfo(struct soap *soap, ns1__AttachmentInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AttachmentInfo * SOAP_FMAC6 soap_instantiate_ns1__AttachmentInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AttachmentInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AttachmentInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AttachmentInfo;
		if (size)
			*size = sizeof(ns1__AttachmentInfo);
		((ns1__AttachmentInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AttachmentInfo[n];
		if (size)
			*size = n * sizeof(ns1__AttachmentInfo);
		for (int i = 0; i < n; i++)
			((ns1__AttachmentInfo*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AttachmentInfo*)cp->ptr;
}

void ns1__AttachmentID::soap_serialize(struct soap *soap) const
{
		this->soap_mark(soap);
}

void ns1__AttachmentID::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AttachmentID*)this)->__item, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__AttachmentID*)this)->__item);
	/* transient soap skipped */
}

void ns1__AttachmentID::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((ns1__AttachmentID*)this)->__item);
	soap_default_bool(soap, &((ns1__AttachmentID*)this)->itemReference);
	/* transient soap skipped */
}

int ns1__AttachmentID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AttachmentID);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AttachmentID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AttachmentID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AttachmentID(struct soap *soap, const char *tag, int id, const ns1__AttachmentID *a, const char *type)
{
	soap_set_attr(soap, "itemReference", soap_bool2s(soap, ((ns1__AttachmentID *)a)->itemReference));
	soap_out_ns1__uid(soap, tag, id, &(((ns1__AttachmentID*)a)->__item), "ns1:AttachmentID");
	return SOAP_OK;
}

void *ns1__AttachmentID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AttachmentID(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AttachmentID * SOAP_FMAC4 soap_get_ns1__AttachmentID(struct soap *soap, ns1__AttachmentID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AttachmentID(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AttachmentID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AttachmentID(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AttachmentID * SOAP_FMAC4 soap_in_ns1__AttachmentID(struct soap *soap, const char *tag, ns1__AttachmentID *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ns1__AttachmentID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AttachmentID, sizeof(ns1__AttachmentID), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AttachmentID)
			return (ns1__AttachmentID *)a->soap_in(soap, tag, type);
	}
		if (soap_s2bool(soap, soap_attr_value(soap, "itemReference"), &((ns1__AttachmentID *)a)->itemReference))
			return NULL;
	if (!soap_in_ns1__uid(soap, tag, &(((ns1__AttachmentID*)a)->__item), "ns1:AttachmentID"))
		return NULL;
	return a;
}

SOAP_FMAC5 ns1__AttachmentID * SOAP_FMAC6 soap_new_ns1__AttachmentID(struct soap *soap, int n)
{	return soap_instantiate_ns1__AttachmentID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AttachmentID(struct soap *soap, ns1__AttachmentID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AttachmentID * SOAP_FMAC6 soap_instantiate_ns1__AttachmentID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AttachmentID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AttachmentID, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AttachmentID;
		if (size)
			*size = sizeof(ns1__AttachmentID);
		((ns1__AttachmentID*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AttachmentID[n];
		if (size)
			*size = n * sizeof(ns1__AttachmentID);
		for (int i = 0; i < n; i++)
			((ns1__AttachmentID*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AttachmentID*)cp->ptr;
}

void ns1__Appointment::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__Appointment))
		this->soap_mark(soap);
}

void ns1__Appointment::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Appointment*)this)->endDate, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Appointment*)this)->endDate);
	soap_embedded(soap, &((ns1__Appointment*)this)->acceptLevel, SOAP_TYPE_ns1__AcceptLevel);
	soap_embedded(soap, &((ns1__Appointment*)this)->alarm, SOAP_TYPE_PointerTons1__Alarm);
	soap_mark_PointerTons1__Alarm(soap, &((ns1__Appointment*)this)->alarm);
	soap_embedded(soap, &((ns1__Appointment*)this)->allDayEvent, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__Appointment*)this)->allDayEvent);
	soap_embedded(soap, &((ns1__Appointment*)this)->place, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Appointment*)this)->place);
	soap_embedded(soap, &((ns1__Appointment*)this)->timezone, SOAP_TYPE_PointerTons1__Timezone);
	soap_mark_PointerTons1__Timezone(soap, &((ns1__Appointment*)this)->timezone);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__CalendarItem*)this)->startDate, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__CalendarItem*)this)->startDate);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->rdate, SOAP_TYPE_PointerTons1__RecurrenceDateType);
	soap_mark_PointerTons1__RecurrenceDateType(soap, &((ns1__CalendarItem*)this)->rdate);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->isRecurring, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__CalendarItem*)this)->isRecurring);
	soap_embedded(soap, &((ns1__CalendarItem*)this)->iCalId, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__CalendarItem*)this)->iCalId);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Mail*)this)->subject, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_embedded(soap, &((ns1__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ns1__Mail*)this)->distribution, SOAP_TYPE_PointerTons1__Distribution);
	soap_mark_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_embedded(soap, &((ns1__Mail*)this)->message, SOAP_TYPE_PointerTons1__MessageBody);
	soap_mark_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_embedded(soap, &((ns1__Mail*)this)->attachments, SOAP_TYPE_PointerTons1__AttachmentInfo);
	soap_mark_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_embedded(soap, &((ns1__Mail*)this)->options, SOAP_TYPE_PointerTons1__ItemOptions);
	soap_mark_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__BoxEntry*)this)->status, SOAP_TYPE_PointerTons1__ItemStatus);
	soap_mark_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->msgid, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->source, SOAP_TYPE_PointerTons1__ItemSource);
	soap_mark_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ns1__BoxEntry*)this)->class_, SOAP_TYPE_PointerTons1__ItemClass);
	soap_mark_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__Appointment::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns1__Appointment*)this)->endDate);
	soap_default_ns1__AcceptLevel(soap, &((ns1__Appointment*)this)->acceptLevel);
	soap_default_PointerTons1__Alarm(soap, &((ns1__Appointment*)this)->alarm);
	soap_default_PointerTobool(soap, &((ns1__Appointment*)this)->allDayEvent);
	soap_default_PointerTostd__string(soap, &((ns1__Appointment*)this)->place);
	soap_default_PointerTons1__Timezone(soap, &((ns1__Appointment*)this)->timezone);
	/* transient soap skipped */
	soap_default_string(soap, &((ns1__CalendarItem*)this)->startDate);
	soap_default_PointerTons1__RecurrenceDateType(soap, &((ns1__CalendarItem*)this)->rdate);
	soap_default_PointerTobool(soap, &((ns1__CalendarItem*)this)->isRecurring);
	soap_default_PointerTostd__string(soap, &((ns1__CalendarItem*)this)->iCalId);
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__Mail*)this)->subject);
	soap_default_PointerTostd__string(soap, &((ns1__Mail*)this)->originalSubject);
	soap_default_PointerTons1__Distribution(soap, &((ns1__Mail*)this)->distribution);
	soap_default_PointerTons1__MessageBody(soap, &((ns1__Mail*)this)->message);
	soap_default_PointerTons1__AttachmentInfo(soap, &((ns1__Mail*)this)->attachments);
	soap_default_PointerTons1__ItemOptions(soap, &((ns1__Mail*)this)->options);
	/* transient soap skipped */
	soap_default_PointerTons1__ItemStatus(soap, &((ns1__BoxEntry*)this)->status);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->thread);
	soap_default_PointerTostd__string(soap, &((ns1__BoxEntry*)this)->msgid);
	soap_default_PointerTons1__ItemSource(soap, &((ns1__BoxEntry*)this)->source);
	soap_default_string(soap, &((ns1__BoxEntry*)this)->delivered);
	soap_default_PointerTons1__ItemClass(soap, &((ns1__BoxEntry*)this)->class_);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__Appointment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Appointment);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Appointment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Appointment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Appointment(struct soap *soap, const char *tag, int id, const ns1__Appointment *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Appointment), "ns1:Appointment");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_PointerTons1__ItemStatus(soap, "status", -1, &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus");
	soap_out_PointerTostd__string(soap, "thread", -1, &(((ns1__BoxEntry*)a)->thread), "xsd:string");
	soap_out_PointerTostd__string(soap, "msgid", -1, &(((ns1__BoxEntry*)a)->msgid), "xsd:string");
	soap_out_PointerTons1__ItemSource(soap, "source", -1, &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource");
	soap_out_string(soap, "delivered", -1, &(((ns1__BoxEntry*)a)->delivered), "");
	soap_out_PointerTons1__ItemClass(soap, "class", -1, &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass");
	/* transient soap skipped */
	soap_out_std__string(soap, "subject", -1, &(((ns1__Mail*)a)->subject), "xsd:string");
	soap_out_PointerTostd__string(soap, "originalSubject", -1, &(((ns1__Mail*)a)->originalSubject), "xsd:string");
	soap_out_PointerTons1__Distribution(soap, "distribution", -1, &(((ns1__Mail*)a)->distribution), "ns1:Distribution");
	soap_out_PointerTons1__MessageBody(soap, "message", -1, &(((ns1__Mail*)a)->message), "ns1:MessageBody");
	soap_out_PointerTons1__AttachmentInfo(soap, "attachments", -1, &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo");
	soap_out_PointerTons1__ItemOptions(soap, "options", -1, &(((ns1__Mail*)a)->options), "ns1:ItemOptions");
	/* transient soap skipped */
	soap_out_string(soap, "startDate", -1, &(((ns1__CalendarItem*)a)->startDate), "");
	soap_out_PointerTons1__RecurrenceDateType(soap, "rdate", -1, &(((ns1__CalendarItem*)a)->rdate), "ns1:RecurrenceDateType");
	soap_out_PointerTobool(soap, "isRecurring", -1, &(((ns1__CalendarItem*)a)->isRecurring), "");
	soap_out_PointerTostd__string(soap, "iCalId", -1, &(((ns1__CalendarItem*)a)->iCalId), "xsd:string");
	/* transient soap skipped */
	soap_out_string(soap, "endDate", -1, &(((ns1__Appointment*)a)->endDate), "");
	soap_out_ns1__AcceptLevel(soap, "acceptLevel", -1, &(((ns1__Appointment*)a)->acceptLevel), "ns1:AcceptLevel");
	soap_out_PointerTons1__Alarm(soap, "alarm", -1, &(((ns1__Appointment*)a)->alarm), "ns1:Alarm");
	soap_out_PointerTobool(soap, "allDayEvent", -1, &(((ns1__Appointment*)a)->allDayEvent), "");
	soap_out_PointerTostd__string(soap, "place", -1, &(((ns1__Appointment*)a)->place), "xsd:string");
	soap_out_PointerTons1__Timezone(soap, "timezone", -1, &(((ns1__Appointment*)a)->timezone), "ns1:Timezone");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Appointment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Appointment(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Appointment * SOAP_FMAC4 soap_get_ns1__Appointment(struct soap *soap, ns1__Appointment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Appointment(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Appointment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Appointment(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Appointment * SOAP_FMAC4 soap_in_ns1__Appointment(struct soap *soap, const char *tag, ns1__Appointment *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__Appointment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Appointment, sizeof(ns1__Appointment), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__Appointment)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__Appointment *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id6 = 1, soap_flag_name6 = 1, soap_flag_version6 = 1, soap_flag_modified6 = 1, soap_flag_changes6 = 1, soap_flag_type6 = 1, soap_flag_categories5 = 1, soap_flag_created5 = 1, soap_flag_customs5 = 1, soap_flag_status4 = 1, soap_flag_thread4 = 1, soap_flag_msgid4 = 1, soap_flag_source4 = 1, soap_flag_delivered4 = 1, soap_flag_class_4 = 1, soap_flag_subject3 = 1, soap_flag_originalSubject3 = 1, soap_flag_distribution3 = 1, soap_flag_message3 = 1, soap_flag_attachments3 = 1, soap_flag_options3 = 1, soap_flag_startDate2 = 1, soap_flag_rdate2 = 1, soap_flag_isRecurring2 = 1, soap_flag_iCalId2 = 1, soap_flag_endDate1 = 1, soap_flag_acceptLevel1 = 1, soap_flag_alarm1 = 1, soap_flag_allDayEvent1 = 1, soap_flag_place1 = 1, soap_flag_timezone1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id6 = 0;
					continue;
				}

			if (soap_flag_name6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name6 = 0;
					continue;
				}

			if (soap_flag_version6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version6 = 0;
					continue;
				}

			if (soap_flag_modified6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified6 = 0;
					continue;
				}

			if (soap_flag_changes6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes6 = 0;
					continue;
				}

			if (soap_flag_type6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type6 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories5 = 0;
					continue;
				}

			if (soap_flag_created5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created5 = 0;
					continue;
				}

			if (soap_flag_customs5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs5 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_status4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemStatus(soap, "status", &(((ns1__BoxEntry*)a)->status), "ns1:ItemStatus"))
				{	soap_flag_status4 = 0;
					continue;
				}

			if (soap_flag_thread4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "thread", &(((ns1__BoxEntry*)a)->thread), "xsd:string"))
				{	soap_flag_thread4 = 0;
					continue;
				}

			if (soap_flag_msgid4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "msgid", &(((ns1__BoxEntry*)a)->msgid), "xsd:string"))
				{	soap_flag_msgid4 = 0;
					continue;
				}

			if (soap_flag_source4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemSource(soap, "source", &(((ns1__BoxEntry*)a)->source), "ns1:ItemSource"))
				{	soap_flag_source4 = 0;
					continue;
				}

			if (soap_flag_delivered4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "delivered", &(((ns1__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered4 = 0;
					continue;
				}

			if (soap_flag_class_4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemClass(soap, "class", &(((ns1__BoxEntry*)a)->class_), "ns1:ItemClass"))
				{	soap_flag_class_4 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_subject3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "subject", &(((ns1__Mail*)a)->subject), "xsd:string"))
				{	soap_flag_subject3 = 0;
					continue;
				}

			if (soap_flag_originalSubject3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "originalSubject", &(((ns1__Mail*)a)->originalSubject), "xsd:string"))
				{	soap_flag_originalSubject3 = 0;
					continue;
				}

			if (soap_flag_distribution3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Distribution(soap, "distribution", &(((ns1__Mail*)a)->distribution), "ns1:Distribution"))
				{	soap_flag_distribution3 = 0;
					continue;
				}

			if (soap_flag_message3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MessageBody(soap, "message", &(((ns1__Mail*)a)->message), "ns1:MessageBody"))
				{	soap_flag_message3 = 0;
					continue;
				}

			if (soap_flag_attachments3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AttachmentInfo(soap, "attachments", &(((ns1__Mail*)a)->attachments), "ns1:AttachmentInfo"))
				{	soap_flag_attachments3 = 0;
					continue;
				}

			if (soap_flag_options3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemOptions(soap, "options", &(((ns1__Mail*)a)->options), "ns1:ItemOptions"))
				{	soap_flag_options3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_startDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "startDate", &(((ns1__CalendarItem*)a)->startDate), ""))
				{	soap_flag_startDate2 = 0;
					continue;
				}

			if (soap_flag_rdate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RecurrenceDateType(soap, "rdate", &(((ns1__CalendarItem*)a)->rdate), "ns1:RecurrenceDateType"))
				{	soap_flag_rdate2 = 0;
					continue;
				}

			if (soap_flag_isRecurring2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isRecurring", &(((ns1__CalendarItem*)a)->isRecurring), ""))
				{	soap_flag_isRecurring2 = 0;
					continue;
				}

			if (soap_flag_iCalId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "iCalId", &(((ns1__CalendarItem*)a)->iCalId), "xsd:string"))
				{	soap_flag_iCalId2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "endDate", &(((ns1__Appointment*)a)->endDate), ""))
				{	soap_flag_endDate1 = 0;
					continue;
				}

			if (soap_flag_acceptLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__AcceptLevel(soap, "acceptLevel", &(((ns1__Appointment*)a)->acceptLevel), "ns1:AcceptLevel"))
				{	soap_flag_acceptLevel1 = 0;
					continue;
				}

			if (soap_flag_alarm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Alarm(soap, "alarm", &(((ns1__Appointment*)a)->alarm), "ns1:Alarm"))
				{	soap_flag_alarm1 = 0;
					continue;
				}

			if (soap_flag_allDayEvent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "allDayEvent", &(((ns1__Appointment*)a)->allDayEvent), ""))
				{	soap_flag_allDayEvent1 = 0;
					continue;
				}

			if (soap_flag_place1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "place", &(((ns1__Appointment*)a)->place), "xsd:string"))
				{	soap_flag_place1 = 0;
					continue;
				}

			if (soap_flag_timezone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Timezone(soap, "timezone", &(((ns1__Appointment*)a)->timezone), "ns1:Timezone"))
				{	soap_flag_timezone1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_subject3 || soap_flag_acceptLevel1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns1__Appointment *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Appointment, sizeof(ns1__Appointment), soap->type, soap->arrayType), SOAP_TYPE_ns1__Appointment, sizeof(ns1__Appointment));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Appointment * SOAP_FMAC6 soap_new_ns1__Appointment(struct soap *soap, int n)
{	return soap_instantiate_ns1__Appointment(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Appointment(struct soap *soap, ns1__Appointment *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Appointment * SOAP_FMAC6 soap_instantiate_ns1__Appointment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Appointment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Appointment, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Appointment;
		if (size)
			*size = sizeof(ns1__Appointment);
		((ns1__Appointment*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Appointment[n];
		if (size)
			*size = n * sizeof(ns1__Appointment);
		for (int i = 0; i < n; i++)
			((ns1__Appointment*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Appointment*)cp->ptr;
}

void ns1__Alarm::soap_serialize(struct soap *soap) const
{
		this->soap_mark(soap);
}

void ns1__Alarm::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__Alarm*)this)->__item, SOAP_TYPE_int);
	/* transient soap skipped */
}

void ns1__Alarm::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ns1__Alarm*)this)->__item);
	soap_default_bool(soap, &((ns1__Alarm*)this)->enabled);
	/* transient soap skipped */
}

int ns1__Alarm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__Alarm);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__Alarm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Alarm(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Alarm(struct soap *soap, const char *tag, int id, const ns1__Alarm *a, const char *type)
{
	soap_set_attr(soap, "enabled", soap_bool2s(soap, ((ns1__Alarm *)a)->enabled));
	soap_out_int(soap, tag, id, &(((ns1__Alarm*)a)->__item), "ns1:Alarm");
	return SOAP_OK;
}

void *ns1__Alarm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Alarm(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Alarm * SOAP_FMAC4 soap_get_ns1__Alarm(struct soap *soap, ns1__Alarm *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Alarm(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Alarm::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Alarm(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Alarm * SOAP_FMAC4 soap_in_ns1__Alarm(struct soap *soap, const char *tag, ns1__Alarm *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ns1__Alarm *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Alarm, sizeof(ns1__Alarm), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Alarm)
			return (ns1__Alarm *)a->soap_in(soap, tag, type);
	}
		if (soap_s2bool(soap, soap_attr_value(soap, "enabled"), &((ns1__Alarm *)a)->enabled))
			return NULL;
	if (!soap_in_int(soap, tag, &(((ns1__Alarm*)a)->__item), "ns1:Alarm"))
		return NULL;
	return a;
}

SOAP_FMAC5 ns1__Alarm * SOAP_FMAC6 soap_new_ns1__Alarm(struct soap *soap, int n)
{	return soap_instantiate_ns1__Alarm(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Alarm(struct soap *soap, ns1__Alarm *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__Alarm * SOAP_FMAC6 soap_instantiate_ns1__Alarm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Alarm(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Alarm, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Alarm;
		if (size)
			*size = sizeof(ns1__Alarm);
		((ns1__Alarm*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Alarm[n];
		if (size)
			*size = n * sizeof(ns1__Alarm);
		for (int i = 0; i < n; i++)
			((ns1__Alarm*)cp->ptr)[i].soap = soap;
	}
	return (ns1__Alarm*)cp->ptr;
}

void ns1__AddressBookList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AddressBookList))
		this->soap_mark(soap);
}

void ns1__AddressBookList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AddressBookList*)this)->book, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AddressBook);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(soap, &((ns1__AddressBookList*)this)->book);
	/* transient soap skipped */
}

void ns1__AddressBookList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(soap, &((ns1__AddressBookList*)this)->book);
	/* transient soap skipped */
}

int ns1__AddressBookList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AddressBookList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AddressBookList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AddressBookList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AddressBookList(struct soap *soap, const char *tag, int id, const ns1__AddressBookList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AddressBookList), "ns1:AddressBookList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(soap, "book", -1, &(((ns1__AddressBookList*)a)->book), "ns1:AddressBook");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AddressBookList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AddressBookList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AddressBookList * SOAP_FMAC4 soap_get_ns1__AddressBookList(struct soap *soap, ns1__AddressBookList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AddressBookList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AddressBookList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AddressBookList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AddressBookList * SOAP_FMAC4 soap_in_ns1__AddressBookList(struct soap *soap, const char *tag, ns1__AddressBookList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AddressBookList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddressBookList, sizeof(ns1__AddressBookList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AddressBookList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AddressBookList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(soap, "book", &(((ns1__AddressBookList*)a)->book), "ns1:AddressBook"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__AddressBookList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddressBookList, sizeof(ns1__AddressBookList), soap->type, soap->arrayType), SOAP_TYPE_ns1__AddressBookList, sizeof(ns1__AddressBookList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AddressBookList * SOAP_FMAC6 soap_new_ns1__AddressBookList(struct soap *soap, int n)
{	return soap_instantiate_ns1__AddressBookList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AddressBookList(struct soap *soap, ns1__AddressBookList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AddressBookList * SOAP_FMAC6 soap_instantiate_ns1__AddressBookList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AddressBookList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AddressBookList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AddressBookList;
		if (size)
			*size = sizeof(ns1__AddressBookList);
		((ns1__AddressBookList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AddressBookList[n];
		if (size)
			*size = n * sizeof(ns1__AddressBookList);
		for (int i = 0; i < n; i++)
			((ns1__AddressBookList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AddressBookList*)cp->ptr;
}

void ns1__AddressBookItem::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AddressBookItem))
		this->soap_mark(soap);
}

void ns1__AddressBookItem::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AddressBookItem*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__AddressBookItem*)this)->uuid);
	soap_embedded(soap, &((ns1__AddressBookItem*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__AddressBookItem*)this)->comment);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__ContainerItem*)this)->container, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->categories, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_mark_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_embedded(soap, &((ns1__ContainerItem*)this)->customs, SOAP_TYPE_PointerTons1__CustomList);
	soap_mark_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__AddressBookItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__UUID(soap, &((ns1__AddressBookItem*)this)->uuid);
	soap_default_PointerTostd__string(soap, &((ns1__AddressBookItem*)this)->comment);
	/* transient soap skipped */
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, &((ns1__ContainerItem*)this)->container);
	soap_default_PointerTons1__CategoryRefList(soap, &((ns1__ContainerItem*)this)->categories);
	soap_default_string(soap, &((ns1__ContainerItem*)this)->created);
	soap_default_PointerTons1__CustomList(soap, &((ns1__ContainerItem*)this)->customs);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__AddressBookItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AddressBookItem);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AddressBookItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AddressBookItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AddressBookItem(struct soap *soap, const char *tag, int id, const ns1__AddressBookItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AddressBookItem), "ns1:AddressBookItem");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", -1, &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef");
	soap_out_PointerTons1__CategoryRefList(soap, "categories", -1, &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList");
	soap_out_string(soap, "created", -1, &(((ns1__ContainerItem*)a)->created), "");
	soap_out_PointerTons1__CustomList(soap, "customs", -1, &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList");
	/* transient soap skipped */
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__AddressBookItem*)a)->uuid), "ns1:UUID");
	soap_out_PointerTostd__string(soap, "comment", -1, &(((ns1__AddressBookItem*)a)->comment), "xsd:string");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AddressBookItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AddressBookItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AddressBookItem * SOAP_FMAC4 soap_get_ns1__AddressBookItem(struct soap *soap, ns1__AddressBookItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AddressBookItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AddressBookItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AddressBookItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AddressBookItem * SOAP_FMAC4 soap_in_ns1__AddressBookItem(struct soap *soap, const char *tag, ns1__AddressBookItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AddressBookItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddressBookItem, sizeof(ns1__AddressBookItem), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AddressBookItem)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AddressBookItem *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_type3 = 1, soap_flag_categories2 = 1, soap_flag_created2 = 1, soap_flag_customs2 = 1, soap_flag_uuid1 = 1, soap_flag_comment1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}

			if (soap_flag_name3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name3 = 0;
					continue;
				}

			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}

			if (soap_flag_modified3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}

			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}

			if (soap_flag_type3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type3 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, "container", &(((ns1__ContainerItem*)a)->container), "ns1:ContainerRef"))
					continue;
			if (soap_flag_categories2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CategoryRefList(soap, "categories", &(((ns1__ContainerItem*)a)->categories), "ns1:CategoryRefList"))
				{	soap_flag_categories2 = 0;
					continue;
				}

			if (soap_flag_created2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "created", &(((ns1__ContainerItem*)a)->created), ""))
				{	soap_flag_created2 = 0;
					continue;
				}

			if (soap_flag_customs2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CustomList(soap, "customs", &(((ns1__ContainerItem*)a)->customs), "ns1:CustomList"))
				{	soap_flag_customs2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_uuid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__AddressBookItem*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid1 = 0;
					continue;
				}

			if (soap_flag_comment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "comment", &(((ns1__AddressBookItem*)a)->comment), "xsd:string"))
				{	soap_flag_comment1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__AddressBookItem *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddressBookItem, sizeof(ns1__AddressBookItem), soap->type, soap->arrayType), SOAP_TYPE_ns1__AddressBookItem, sizeof(ns1__AddressBookItem));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AddressBookItem * SOAP_FMAC6 soap_new_ns1__AddressBookItem(struct soap *soap, int n)
{	return soap_instantiate_ns1__AddressBookItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AddressBookItem(struct soap *soap, ns1__AddressBookItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AddressBookItem * SOAP_FMAC6 soap_instantiate_ns1__AddressBookItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AddressBookItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AddressBookItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:Contact"))
	{	cp->type = SOAP_TYPE_ns1__Contact;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Contact;
			if (size)
				*size = sizeof(ns1__Contact);
			((ns1__Contact*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Contact[n];
			if (size)
				*size = n * sizeof(ns1__Contact);
			for (int i = 0; i < n; i++)
				((ns1__Contact*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Contact*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Group"))
	{	cp->type = SOAP_TYPE_ns1__Group;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Group;
			if (size)
				*size = sizeof(ns1__Group);
			((ns1__Group*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Group[n];
			if (size)
				*size = n * sizeof(ns1__Group);
			for (int i = 0; i < n; i++)
				((ns1__Group*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Group*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Organization"))
	{	cp->type = SOAP_TYPE_ns1__Organization;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Organization;
			if (size)
				*size = sizeof(ns1__Organization);
			((ns1__Organization*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Organization[n];
			if (size)
				*size = n * sizeof(ns1__Organization);
			for (int i = 0; i < n; i++)
				((ns1__Organization*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Organization*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Resource"))
	{	cp->type = SOAP_TYPE_ns1__Resource;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__Resource;
			if (size)
				*size = sizeof(ns1__Resource);
			((ns1__Resource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__Resource[n];
			if (size)
				*size = n * sizeof(ns1__Resource);
			for (int i = 0; i < n; i++)
				((ns1__Resource*)cp->ptr)[i].soap = soap;
		}
		return (ns1__Resource*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AddressBookItem;
		if (size)
			*size = sizeof(ns1__AddressBookItem);
		((ns1__AddressBookItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AddressBookItem[n];
		if (size)
			*size = n * sizeof(ns1__AddressBookItem);
		for (int i = 0; i < n; i++)
			((ns1__AddressBookItem*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AddressBookItem*)cp->ptr;
}

void ns1__AddressBook::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AddressBook))
		this->soap_mark(soap);
}

void ns1__AddressBook::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AddressBook*)this)->description, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__AddressBook*)this)->description);
	soap_embedded(soap, &((ns1__AddressBook*)this)->isPersonal, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__AddressBook*)this)->isPersonal);
	soap_embedded(soap, &((ns1__AddressBook*)this)->isFrequentContacts, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__AddressBook*)this)->isFrequentContacts);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__Item*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_embedded(soap, &((ns1__Item*)this)->name, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__Item*)this)->name);
	soap_embedded(soap, &((ns1__Item*)this)->version, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ns1__Item*)this)->modified, SOAP_TYPE_string);
	soap_mark_string(soap, &((ns1__Item*)this)->modified);
	soap_embedded(soap, &((ns1__Item*)this)->changes, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_mark_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_embedded(soap, &((ns1__Item*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_mark_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

void ns1__AddressBook::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__AddressBook*)this)->description);
	soap_default_PointerTobool(soap, &((ns1__AddressBook*)this)->isPersonal);
	soap_default_PointerTobool(soap, &((ns1__AddressBook*)this)->isFrequentContacts);
	/* transient soap skipped */
	soap_default_ns1__uid(soap, &((ns1__Item*)this)->id);
	soap_default_std__string(soap, &((ns1__Item*)this)->name);
	soap_default_unsignedLong(soap, &((ns1__Item*)this)->version);
	soap_default_string(soap, &((ns1__Item*)this)->modified);
	soap_default_PointerTons1__ItemChanges(soap, &((ns1__Item*)this)->changes);
	soap_default_PointerTostd__string(soap, &((ns1__Item*)this)->type);
	/* transient soap skipped */
}

int ns1__AddressBook::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AddressBook);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AddressBook::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AddressBook(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AddressBook(struct soap *soap, const char *tag, int id, const ns1__AddressBook *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AddressBook), "ns1:AddressBook");
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__Item*)a)->id), "ns1:uid");
	soap_out_std__string(soap, "name", -1, &(((ns1__Item*)a)->name), "xsd:string");
	soap_out_unsignedLong(soap, "version", -1, &(((ns1__Item*)a)->version), "");
	soap_out_string(soap, "modified", -1, &(((ns1__Item*)a)->modified), "");
	soap_out_PointerTons1__ItemChanges(soap, "changes", -1, &(((ns1__Item*)a)->changes), "ns1:ItemChanges");
	soap_out_PointerTostd__string(soap, "type", -1, &(((ns1__Item*)a)->type), "xsd:string");
	/* transient soap skipped */
	soap_out_std__string(soap, "description", -1, &(((ns1__AddressBook*)a)->description), "xsd:string");
	soap_out_PointerTobool(soap, "isPersonal", -1, &(((ns1__AddressBook*)a)->isPersonal), "");
	soap_out_PointerTobool(soap, "isFrequentContacts", -1, &(((ns1__AddressBook*)a)->isFrequentContacts), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AddressBook::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AddressBook(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AddressBook * SOAP_FMAC4 soap_get_ns1__AddressBook(struct soap *soap, ns1__AddressBook *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AddressBook(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AddressBook::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AddressBook(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AddressBook * SOAP_FMAC4 soap_in_ns1__AddressBook(struct soap *soap, const char *tag, ns1__AddressBook *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AddressBook *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddressBook, sizeof(ns1__AddressBook), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AddressBook)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AddressBook *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id2 = 1, soap_flag_name2 = 1, soap_flag_version2 = 1, soap_flag_modified2 = 1, soap_flag_changes2 = 1, soap_flag_type2 = 1, soap_flag_description1 = 1, soap_flag_isPersonal1 = 1, soap_flag_isFrequentContacts1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__Item*)a)->id), "ns1:uid"))
				{	soap_flag_id2 = 0;
					continue;
				}

			if (soap_flag_name2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "name", &(((ns1__Item*)a)->name), "xsd:string"))
				{	soap_flag_name2 = 0;
					continue;
				}

			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "version", &(((ns1__Item*)a)->version), ""))
				{	soap_flag_version2 = 0;
					continue;
				}

			if (soap_flag_modified2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "modified", &(((ns1__Item*)a)->modified), ""))
				{	soap_flag_modified2 = 0;
					continue;
				}

			if (soap_flag_changes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemChanges(soap, "changes", &(((ns1__Item*)a)->changes), "ns1:ItemChanges"))
				{	soap_flag_changes2 = 0;
					continue;
				}

			if (soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__string(soap, "type", &(((ns1__Item*)a)->type), "xsd:string"))
				{	soap_flag_type2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_description1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "description", &(((ns1__AddressBook*)a)->description), "xsd:string"))
				{	soap_flag_description1 = 0;
					continue;
				}

			if (soap_flag_isPersonal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isPersonal", &(((ns1__AddressBook*)a)->isPersonal), ""))
				{	soap_flag_isPersonal1 = 0;
					continue;
				}

			if (soap_flag_isFrequentContacts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isFrequentContacts", &(((ns1__AddressBook*)a)->isFrequentContacts), ""))
				{	soap_flag_isFrequentContacts1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__AddressBook *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AddressBook, sizeof(ns1__AddressBook), soap->type, soap->arrayType), SOAP_TYPE_ns1__AddressBook, sizeof(ns1__AddressBook));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AddressBook * SOAP_FMAC6 soap_new_ns1__AddressBook(struct soap *soap, int n)
{	return soap_instantiate_ns1__AddressBook(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AddressBook(struct soap *soap, ns1__AddressBook *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AddressBook * SOAP_FMAC6 soap_instantiate_ns1__AddressBook(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AddressBook(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AddressBook, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AddressBook;
		if (size)
			*size = sizeof(ns1__AddressBook);
		((ns1__AddressBook*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AddressBook[n];
		if (size)
			*size = n * sizeof(ns1__AddressBook);
		for (int i = 0; i < n; i++)
			((ns1__AddressBook*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AddressBook*)cp->ptr;
}

void ns1__AccessRightList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AccessRightList))
		this->soap_mark(soap);
}

void ns1__AccessRightList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AccessRightList*)this)->entry, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(soap, &((ns1__AccessRightList*)this)->entry);
	/* transient soap skipped */
}

void ns1__AccessRightList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(soap, &((ns1__AccessRightList*)this)->entry);
	/* transient soap skipped */
}

int ns1__AccessRightList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AccessRightList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AccessRightList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccessRightList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessRightList(struct soap *soap, const char *tag, int id, const ns1__AccessRightList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessRightList), "ns1:AccessRightList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(soap, "entry", -1, &(((ns1__AccessRightList*)a)->entry), "ns1:AccessRightEntry");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AccessRightList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccessRightList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccessRightList * SOAP_FMAC4 soap_get_ns1__AccessRightList(struct soap *soap, ns1__AccessRightList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessRightList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AccessRightList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AccessRightList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccessRightList * SOAP_FMAC4 soap_in_ns1__AccessRightList(struct soap *soap, const char *tag, ns1__AccessRightList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AccessRightList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessRightList, sizeof(ns1__AccessRightList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AccessRightList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AccessRightList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(soap, "entry", &(((ns1__AccessRightList*)a)->entry), "ns1:AccessRightEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__AccessRightList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessRightList, sizeof(ns1__AccessRightList), soap->type, soap->arrayType), SOAP_TYPE_ns1__AccessRightList, sizeof(ns1__AccessRightList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AccessRightList * SOAP_FMAC6 soap_new_ns1__AccessRightList(struct soap *soap, int n)
{	return soap_instantiate_ns1__AccessRightList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AccessRightList(struct soap *soap, ns1__AccessRightList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AccessRightList * SOAP_FMAC6 soap_instantiate_ns1__AccessRightList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccessRightList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AccessRightList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AccessRightList;
		if (size)
			*size = sizeof(ns1__AccessRightList);
		((ns1__AccessRightList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AccessRightList[n];
		if (size)
			*size = n * sizeof(ns1__AccessRightList);
		for (int i = 0; i < n; i++)
			((ns1__AccessRightList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AccessRightList*)cp->ptr;
}

void ns1__AccessRightEntry::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AccessRightEntry))
		this->soap_mark(soap);
}

void ns1__AccessRightEntry::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AccessRightEntry*)this)->id, SOAP_TYPE_ns1__uid);
	soap_mark_ns1__uid(soap, &((ns1__AccessRightEntry*)this)->id);
	soap_embedded(soap, &((ns1__AccessRightEntry*)this)->appointment, SOAP_TYPE_PointerTons1__AccessRight);
	soap_mark_PointerTons1__AccessRight(soap, &((ns1__AccessRightEntry*)this)->appointment);
	soap_embedded(soap, &((ns1__AccessRightEntry*)this)->mail, SOAP_TYPE_PointerTons1__AccessRight);
	soap_mark_PointerTons1__AccessRight(soap, &((ns1__AccessRightEntry*)this)->mail);
	soap_embedded(soap, &((ns1__AccessRightEntry*)this)->misc, SOAP_TYPE_PointerTons1__AccessMiscRight);
	soap_mark_PointerTons1__AccessMiscRight(soap, &((ns1__AccessRightEntry*)this)->misc);
	soap_embedded(soap, &((ns1__AccessRightEntry*)this)->note, SOAP_TYPE_PointerTons1__AccessRight);
	soap_mark_PointerTons1__AccessRight(soap, &((ns1__AccessRightEntry*)this)->note);
	soap_embedded(soap, &((ns1__AccessRightEntry*)this)->task, SOAP_TYPE_PointerTons1__AccessRight);
	soap_mark_PointerTons1__AccessRight(soap, &((ns1__AccessRightEntry*)this)->task);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->displayName, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->email, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ns1__AccessRightEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__uid(soap, &((ns1__AccessRightEntry*)this)->id);
	soap_default_PointerTons1__AccessRight(soap, &((ns1__AccessRightEntry*)this)->appointment);
	soap_default_PointerTons1__AccessRight(soap, &((ns1__AccessRightEntry*)this)->mail);
	soap_default_PointerTons1__AccessMiscRight(soap, &((ns1__AccessRightEntry*)this)->misc);
	soap_default_PointerTons1__AccessRight(soap, &((ns1__AccessRightEntry*)this)->note);
	soap_default_PointerTons1__AccessRight(soap, &((ns1__AccessRightEntry*)this)->task);
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_default_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

int ns1__AccessRightEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AccessRightEntry);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AccessRightEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccessRightEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessRightEntry(struct soap *soap, const char *tag, int id, const ns1__AccessRightEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessRightEntry), "ns1:AccessRightEntry");
	soap_out_std__string(soap, "displayName", -1, &(((ns1__NameAndEmail*)a)->displayName), "xsd:string");
	soap_out_std__string(soap, "email", -1, &(((ns1__NameAndEmail*)a)->email), "xsd:string");
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID");
	/* transient soap skipped */
	soap_out_ns1__uid(soap, "id", -1, &(((ns1__AccessRightEntry*)a)->id), "ns1:uid");
	soap_out_PointerTons1__AccessRight(soap, "appointment", -1, &(((ns1__AccessRightEntry*)a)->appointment), "ns1:AccessRight");
	soap_out_PointerTons1__AccessRight(soap, "mail", -1, &(((ns1__AccessRightEntry*)a)->mail), "ns1:AccessRight");
	soap_out_PointerTons1__AccessMiscRight(soap, "misc", -1, &(((ns1__AccessRightEntry*)a)->misc), "ns1:AccessMiscRight");
	soap_out_PointerTons1__AccessRight(soap, "note", -1, &(((ns1__AccessRightEntry*)a)->note), "ns1:AccessRight");
	soap_out_PointerTons1__AccessRight(soap, "task", -1, &(((ns1__AccessRightEntry*)a)->task), "ns1:AccessRight");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AccessRightEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccessRightEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccessRightEntry * SOAP_FMAC4 soap_get_ns1__AccessRightEntry(struct soap *soap, ns1__AccessRightEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessRightEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AccessRightEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AccessRightEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccessRightEntry * SOAP_FMAC4 soap_in_ns1__AccessRightEntry(struct soap *soap, const char *tag, ns1__AccessRightEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AccessRightEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessRightEntry, sizeof(ns1__AccessRightEntry), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AccessRightEntry)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AccessRightEntry *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_displayName2 = 1, soap_flag_email2 = 1, soap_flag_uuid2 = 1, soap_flag_id1 = 1, soap_flag_appointment1 = 1, soap_flag_mail1 = 1, soap_flag_misc1 = 1, soap_flag_note1 = 1, soap_flag_task1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_displayName2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "displayName", &(((ns1__NameAndEmail*)a)->displayName), "xsd:string"))
				{	soap_flag_displayName2 = 0;
					continue;
				}

			if (soap_flag_email2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "email", &(((ns1__NameAndEmail*)a)->email), "xsd:string"))
				{	soap_flag_email2 = 0;
					continue;
				}

			if (soap_flag_uuid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__uid(soap, "id", &(((ns1__AccessRightEntry*)a)->id), "ns1:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_appointment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessRight(soap, "appointment", &(((ns1__AccessRightEntry*)a)->appointment), "ns1:AccessRight"))
				{	soap_flag_appointment1 = 0;
					continue;
				}

			if (soap_flag_mail1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessRight(soap, "mail", &(((ns1__AccessRightEntry*)a)->mail), "ns1:AccessRight"))
				{	soap_flag_mail1 = 0;
					continue;
				}

			if (soap_flag_misc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessMiscRight(soap, "misc", &(((ns1__AccessRightEntry*)a)->misc), "ns1:AccessMiscRight"))
				{	soap_flag_misc1 = 0;
					continue;
				}

			if (soap_flag_note1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessRight(soap, "note", &(((ns1__AccessRightEntry*)a)->note), "ns1:AccessRight"))
				{	soap_flag_note1 = 0;
					continue;
				}

			if (soap_flag_task1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessRight(soap, "task", &(((ns1__AccessRightEntry*)a)->task), "ns1:AccessRight"))
				{	soap_flag_task1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__AccessRightEntry *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessRightEntry, sizeof(ns1__AccessRightEntry), soap->type, soap->arrayType), SOAP_TYPE_ns1__AccessRightEntry, sizeof(ns1__AccessRightEntry));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AccessRightEntry * SOAP_FMAC6 soap_new_ns1__AccessRightEntry(struct soap *soap, int n)
{	return soap_instantiate_ns1__AccessRightEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AccessRightEntry(struct soap *soap, ns1__AccessRightEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AccessRightEntry * SOAP_FMAC6 soap_instantiate_ns1__AccessRightEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccessRightEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AccessRightEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AccessRightEntry;
		if (size)
			*size = sizeof(ns1__AccessRightEntry);
		((ns1__AccessRightEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AccessRightEntry[n];
		if (size)
			*size = n * sizeof(ns1__AccessRightEntry);
		for (int i = 0; i < n; i++)
			((ns1__AccessRightEntry*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AccessRightEntry*)cp->ptr;
}

void ns1__AccessRightChanges::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AccessRightChanges))
		this->soap_mark(soap);
}

void ns1__AccessRightChanges::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AccessRightChanges*)this)->add, SOAP_TYPE_PointerTons1__AccessRightEntry);
	soap_mark_PointerTons1__AccessRightEntry(soap, &((ns1__AccessRightChanges*)this)->add);
	soap_embedded(soap, &((ns1__AccessRightChanges*)this)->_delete, SOAP_TYPE_PointerTons1__AccessRightEntry);
	soap_mark_PointerTons1__AccessRightEntry(soap, &((ns1__AccessRightChanges*)this)->_delete);
	soap_embedded(soap, &((ns1__AccessRightChanges*)this)->update, SOAP_TYPE_PointerTons1__AccessRightEntry);
	soap_mark_PointerTons1__AccessRightEntry(soap, &((ns1__AccessRightChanges*)this)->update);
	/* transient soap skipped */
}

void ns1__AccessRightChanges::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__AccessRightEntry(soap, &((ns1__AccessRightChanges*)this)->add);
	soap_default_PointerTons1__AccessRightEntry(soap, &((ns1__AccessRightChanges*)this)->_delete);
	soap_default_PointerTons1__AccessRightEntry(soap, &((ns1__AccessRightChanges*)this)->update);
	/* transient soap skipped */
}

int ns1__AccessRightChanges::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AccessRightChanges);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AccessRightChanges::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccessRightChanges(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessRightChanges(struct soap *soap, const char *tag, int id, const ns1__AccessRightChanges *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessRightChanges), "ns1:AccessRightChanges");
	soap_out_PointerTons1__AccessRightEntry(soap, "add", -1, &(((ns1__AccessRightChanges*)a)->add), "ns1:AccessRightEntry");
	soap_out_PointerTons1__AccessRightEntry(soap, "delete", -1, &(((ns1__AccessRightChanges*)a)->_delete), "ns1:AccessRightEntry");
	soap_out_PointerTons1__AccessRightEntry(soap, "update", -1, &(((ns1__AccessRightChanges*)a)->update), "ns1:AccessRightEntry");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AccessRightChanges::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccessRightChanges(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccessRightChanges * SOAP_FMAC4 soap_get_ns1__AccessRightChanges(struct soap *soap, ns1__AccessRightChanges *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessRightChanges(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AccessRightChanges::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AccessRightChanges(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccessRightChanges * SOAP_FMAC4 soap_in_ns1__AccessRightChanges(struct soap *soap, const char *tag, ns1__AccessRightChanges *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AccessRightChanges *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessRightChanges, sizeof(ns1__AccessRightChanges), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AccessRightChanges)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AccessRightChanges *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_add1 = 1, soap_flag_delete1 = 1, soap_flag_update1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_add1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessRightEntry(soap, "add", &(((ns1__AccessRightChanges*)a)->add), "ns1:AccessRightEntry"))
				{	soap_flag_add1 = 0;
					continue;
				}

			if (soap_flag_delete1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessRightEntry(soap, "delete", &(((ns1__AccessRightChanges*)a)->_delete), "ns1:AccessRightEntry"))
				{	soap_flag_delete1 = 0;
					continue;
				}

			if (soap_flag_update1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessRightEntry(soap, "update", &(((ns1__AccessRightChanges*)a)->update), "ns1:AccessRightEntry"))
				{	soap_flag_update1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__AccessRightChanges *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessRightChanges, sizeof(ns1__AccessRightChanges), soap->type, soap->arrayType), SOAP_TYPE_ns1__AccessRightChanges, sizeof(ns1__AccessRightChanges));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AccessRightChanges * SOAP_FMAC6 soap_new_ns1__AccessRightChanges(struct soap *soap, int n)
{	return soap_instantiate_ns1__AccessRightChanges(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AccessRightChanges(struct soap *soap, ns1__AccessRightChanges *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AccessRightChanges * SOAP_FMAC6 soap_instantiate_ns1__AccessRightChanges(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccessRightChanges(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AccessRightChanges, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AccessRightChanges;
		if (size)
			*size = sizeof(ns1__AccessRightChanges);
		((ns1__AccessRightChanges*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AccessRightChanges[n];
		if (size)
			*size = n * sizeof(ns1__AccessRightChanges);
		for (int i = 0; i < n; i++)
			((ns1__AccessRightChanges*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AccessRightChanges*)cp->ptr;
}

void ns1__AccessRight::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AccessRight))
		this->soap_mark(soap);
}

void ns1__AccessRight::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AccessRight*)this)->read, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__AccessRight*)this)->read);
	soap_embedded(soap, &((ns1__AccessRight*)this)->write, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__AccessRight*)this)->write);
	/* transient soap skipped */
}

void ns1__AccessRight::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTobool(soap, &((ns1__AccessRight*)this)->read);
	soap_default_PointerTobool(soap, &((ns1__AccessRight*)this)->write);
	/* transient soap skipped */
}

int ns1__AccessRight::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AccessRight);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AccessRight::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccessRight(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessRight(struct soap *soap, const char *tag, int id, const ns1__AccessRight *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessRight), "ns1:AccessRight");
	soap_out_PointerTobool(soap, "read", -1, &(((ns1__AccessRight*)a)->read), "");
	soap_out_PointerTobool(soap, "write", -1, &(((ns1__AccessRight*)a)->write), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AccessRight::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccessRight(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccessRight * SOAP_FMAC4 soap_get_ns1__AccessRight(struct soap *soap, ns1__AccessRight *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessRight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AccessRight::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AccessRight(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccessRight * SOAP_FMAC4 soap_in_ns1__AccessRight(struct soap *soap, const char *tag, ns1__AccessRight *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AccessRight *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessRight, sizeof(ns1__AccessRight), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AccessRight)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AccessRight *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_read1 = 1, soap_flag_write1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_read1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "read", &(((ns1__AccessRight*)a)->read), ""))
				{	soap_flag_read1 = 0;
					continue;
				}

			if (soap_flag_write1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "write", &(((ns1__AccessRight*)a)->write), ""))
				{	soap_flag_write1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__AccessRight *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessRight, sizeof(ns1__AccessRight), soap->type, soap->arrayType), SOAP_TYPE_ns1__AccessRight, sizeof(ns1__AccessRight));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AccessRight * SOAP_FMAC6 soap_new_ns1__AccessRight(struct soap *soap, int n)
{	return soap_instantiate_ns1__AccessRight(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AccessRight(struct soap *soap, ns1__AccessRight *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AccessRight * SOAP_FMAC6 soap_instantiate_ns1__AccessRight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccessRight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AccessRight, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AccessRight;
		if (size)
			*size = sizeof(ns1__AccessRight);
		((ns1__AccessRight*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AccessRight[n];
		if (size)
			*size = n * sizeof(ns1__AccessRight);
		for (int i = 0; i < n; i++)
			((ns1__AccessRight*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AccessRight*)cp->ptr;
}

void ns1__AccessMiscRight::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AccessMiscRight))
		this->soap_mark(soap);
}

void ns1__AccessMiscRight::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AccessMiscRight*)this)->alarms, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__AccessMiscRight*)this)->alarms);
	soap_embedded(soap, &((ns1__AccessMiscRight*)this)->notify, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__AccessMiscRight*)this)->notify);
	soap_embedded(soap, &((ns1__AccessMiscRight*)this)->readHidden, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__AccessMiscRight*)this)->readHidden);
	soap_embedded(soap, &((ns1__AccessMiscRight*)this)->setup, SOAP_TYPE_PointerTobool);
	soap_mark_PointerTobool(soap, &((ns1__AccessMiscRight*)this)->setup);
	/* transient soap skipped */
}

void ns1__AccessMiscRight::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTobool(soap, &((ns1__AccessMiscRight*)this)->alarms);
	soap_default_PointerTobool(soap, &((ns1__AccessMiscRight*)this)->notify);
	soap_default_PointerTobool(soap, &((ns1__AccessMiscRight*)this)->readHidden);
	soap_default_PointerTobool(soap, &((ns1__AccessMiscRight*)this)->setup);
	/* transient soap skipped */
}

int ns1__AccessMiscRight::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AccessMiscRight);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AccessMiscRight::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccessMiscRight(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessMiscRight(struct soap *soap, const char *tag, int id, const ns1__AccessMiscRight *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessMiscRight), "ns1:AccessMiscRight");
	soap_out_PointerTobool(soap, "alarms", -1, &(((ns1__AccessMiscRight*)a)->alarms), "");
	soap_out_PointerTobool(soap, "notify", -1, &(((ns1__AccessMiscRight*)a)->notify), "");
	soap_out_PointerTobool(soap, "readHidden", -1, &(((ns1__AccessMiscRight*)a)->readHidden), "");
	soap_out_PointerTobool(soap, "setup", -1, &(((ns1__AccessMiscRight*)a)->setup), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AccessMiscRight::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccessMiscRight(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccessMiscRight * SOAP_FMAC4 soap_get_ns1__AccessMiscRight(struct soap *soap, ns1__AccessMiscRight *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessMiscRight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AccessMiscRight::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AccessMiscRight(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccessMiscRight * SOAP_FMAC4 soap_in_ns1__AccessMiscRight(struct soap *soap, const char *tag, ns1__AccessMiscRight *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AccessMiscRight *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessMiscRight, sizeof(ns1__AccessMiscRight), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AccessMiscRight)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AccessMiscRight *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_alarms1 = 1, soap_flag_notify1 = 1, soap_flag_readHidden1 = 1, soap_flag_setup1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_alarms1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "alarms", &(((ns1__AccessMiscRight*)a)->alarms), ""))
				{	soap_flag_alarms1 = 0;
					continue;
				}

			if (soap_flag_notify1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "notify", &(((ns1__AccessMiscRight*)a)->notify), ""))
				{	soap_flag_notify1 = 0;
					continue;
				}

			if (soap_flag_readHidden1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "readHidden", &(((ns1__AccessMiscRight*)a)->readHidden), ""))
				{	soap_flag_readHidden1 = 0;
					continue;
				}

			if (soap_flag_setup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "setup", &(((ns1__AccessMiscRight*)a)->setup), ""))
				{	soap_flag_setup1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__AccessMiscRight *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessMiscRight, sizeof(ns1__AccessMiscRight), soap->type, soap->arrayType), SOAP_TYPE_ns1__AccessMiscRight, sizeof(ns1__AccessMiscRight));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AccessMiscRight * SOAP_FMAC6 soap_new_ns1__AccessMiscRight(struct soap *soap, int n)
{	return soap_instantiate_ns1__AccessMiscRight(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AccessMiscRight(struct soap *soap, ns1__AccessMiscRight *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AccessMiscRight * SOAP_FMAC6 soap_instantiate_ns1__AccessMiscRight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccessMiscRight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AccessMiscRight, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AccessMiscRight;
		if (size)
			*size = sizeof(ns1__AccessMiscRight);
		((ns1__AccessMiscRight*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AccessMiscRight[n];
		if (size)
			*size = n * sizeof(ns1__AccessMiscRight);
		for (int i = 0; i < n; i++)
			((ns1__AccessMiscRight*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AccessMiscRight*)cp->ptr;
}

void ns1__AccessControlList::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AccessControlList))
		this->soap_mark(soap);
}

void ns1__AccessControlList::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AccessControlList*)this)->entry, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry);
	soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, &((ns1__AccessControlList*)this)->entry);
	/* transient soap skipped */
}

void ns1__AccessControlList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, &((ns1__AccessControlList*)this)->entry);
	/* transient soap skipped */
}

int ns1__AccessControlList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AccessControlList);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AccessControlList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccessControlList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessControlList(struct soap *soap, const char *tag, int id, const ns1__AccessControlList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessControlList), "ns1:AccessControlList");
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, "entry", -1, &(((ns1__AccessControlList*)a)->entry), "ns1:AccessControlListEntry");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AccessControlList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccessControlList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccessControlList * SOAP_FMAC4 soap_get_ns1__AccessControlList(struct soap *soap, ns1__AccessControlList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessControlList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AccessControlList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AccessControlList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccessControlList * SOAP_FMAC4 soap_in_ns1__AccessControlList(struct soap *soap, const char *tag, ns1__AccessControlList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AccessControlList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessControlList, sizeof(ns1__AccessControlList), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AccessControlList)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AccessControlList *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, "entry", &(((ns1__AccessControlList*)a)->entry), "ns1:AccessControlListEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__AccessControlList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessControlList, sizeof(ns1__AccessControlList), soap->type, soap->arrayType), SOAP_TYPE_ns1__AccessControlList, sizeof(ns1__AccessControlList));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AccessControlList * SOAP_FMAC6 soap_new_ns1__AccessControlList(struct soap *soap, int n)
{	return soap_instantiate_ns1__AccessControlList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AccessControlList(struct soap *soap, ns1__AccessControlList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AccessControlList * SOAP_FMAC6 soap_instantiate_ns1__AccessControlList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccessControlList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AccessControlList, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AccessControlList;
		if (size)
			*size = sizeof(ns1__AccessControlList);
		((ns1__AccessControlList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AccessControlList[n];
		if (size)
			*size = n * sizeof(ns1__AccessControlList);
		for (int i = 0; i < n; i++)
			((ns1__AccessControlList*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AccessControlList*)cp->ptr;
}

void ns1__AccessControlListEntry::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns1__AccessControlListEntry))
		this->soap_mark(soap);
}

void ns1__AccessControlListEntry::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns1__AccessControlListEntry*)this)->rights, SOAP_TYPE_PointerTons1__Rights);
	soap_mark_PointerTons1__Rights(soap, &((ns1__AccessControlListEntry*)this)->rights);
	/* transient soap skipped */
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->displayName, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->email, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ns1__NameAndEmail*)this)->uuid, SOAP_TYPE_ns1__UUID);
	soap_mark_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ns1__AccessControlListEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_PointerTons1__Rights(soap, &((ns1__AccessControlListEntry*)this)->rights);
	/* transient soap skipped */
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->displayName);
	soap_default_std__string(soap, &((ns1__NameAndEmail*)this)->email);
	soap_default_ns1__UUID(soap, &((ns1__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

int ns1__AccessControlListEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_ns1__AccessControlListEntry);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int ns1__AccessControlListEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccessControlListEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessControlListEntry(struct soap *soap, const char *tag, int id, const ns1__AccessControlListEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessControlListEntry), "ns1:AccessControlListEntry");
	soap_out_std__string(soap, "displayName", -1, &(((ns1__NameAndEmail*)a)->displayName), "xsd:string");
	soap_out_std__string(soap, "email", -1, &(((ns1__NameAndEmail*)a)->email), "xsd:string");
	soap_out_ns1__UUID(soap, "uuid", -1, &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID");
	/* transient soap skipped */
	soap_out_PointerTons1__Rights(soap, "rights", -1, &(((ns1__AccessControlListEntry*)a)->rights), "ns1:Rights");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AccessControlListEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccessControlListEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccessControlListEntry * SOAP_FMAC4 soap_get_ns1__AccessControlListEntry(struct soap *soap, ns1__AccessControlListEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessControlListEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AccessControlListEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AccessControlListEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccessControlListEntry * SOAP_FMAC4 soap_in_ns1__AccessControlListEntry(struct soap *soap, const char *tag, ns1__AccessControlListEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns1__AccessControlListEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessControlListEntry, sizeof(ns1__AccessControlListEntry), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns1__AccessControlListEntry)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns1__AccessControlListEntry *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_displayName2 = 1, soap_flag_email2 = 1, soap_flag_uuid2 = 1, soap_flag_rights1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_displayName2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "displayName", &(((ns1__NameAndEmail*)a)->displayName), "xsd:string"))
				{	soap_flag_displayName2 = 0;
					continue;
				}

			if (soap_flag_email2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "email", &(((ns1__NameAndEmail*)a)->email), "xsd:string"))
				{	soap_flag_email2 = 0;
					continue;
				}

			if (soap_flag_uuid2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UUID(soap, "uuid", &(((ns1__NameAndEmail*)a)->uuid), "ns1:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap_flag_rights1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Rights(soap, "rights", &(((ns1__AccessControlListEntry*)a)->rights), "ns1:Rights"))
				{	soap_flag_rights1 = 0;
					continue;
				}

			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns1__AccessControlListEntry *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessControlListEntry, sizeof(ns1__AccessControlListEntry), soap->type, soap->arrayType), SOAP_TYPE_ns1__AccessControlListEntry, sizeof(ns1__AccessControlListEntry));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AccessControlListEntry * SOAP_FMAC6 soap_new_ns1__AccessControlListEntry(struct soap *soap, int n)
{	return soap_instantiate_ns1__AccessControlListEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AccessControlListEntry(struct soap *soap, ns1__AccessControlListEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ns1__AccessControlListEntry * SOAP_FMAC6 soap_instantiate_ns1__AccessControlListEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccessControlListEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AccessControlListEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (type && !soap_match_tag(soap, type, "ns1:FolderACLEntry"))
	{	cp->type = SOAP_TYPE_ns1__FolderACLEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__FolderACLEntry;
			if (size)
				*size = sizeof(ns1__FolderACLEntry);
			((ns1__FolderACLEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__FolderACLEntry[n];
			if (size)
				*size = n * sizeof(ns1__FolderACLEntry);
			for (int i = 0; i < n; i++)
				((ns1__FolderACLEntry*)cp->ptr)[i].soap = soap;
		}
		return (ns1__FolderACLEntry*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AccessControlListEntry;
		if (size)
			*size = sizeof(ns1__AccessControlListEntry);
		((ns1__AccessControlListEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AccessControlListEntry[n];
		if (size)
			*size = n * sizeof(ns1__AccessControlListEntry);
		for (int i = 0; i < n; i++)
			((ns1__AccessControlListEntry*)cp->ptr)[i].soap = soap;
	}
	return (ns1__AccessControlListEntry*)cp->ptr;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void xsd__base64Binary::soap_mark(struct soap *soap) const
{
	if (this->__ptr)
		soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary);
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_array(soap, (void*)this, (struct soap_array*)&this->__ptr, this->__size, tag, SOAP_TYPE_xsd__base64Binary);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	i = soap_array_pointer_lookup(soap, a, (struct soap_array*)&a->__ptr, n, SOAP_TYPE_xsd__base64Binary, &pp);
	if (!a->__ptr)
	{	soap_element_null(soap, tag, i, type);
		return SOAP_OK;
	}
	if (id <= 0 && i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return SOAP_OK;
		}
		if (soap_is_single(soap, pp))
			i = 0;
	}
	else if (id > 0)
		i = id;
	soap_element_begin_out(soap, tag, i, "xsd:base64Binary");
	if (i > 0)
		soap_set_embedded(soap, pp);
	soap_putbase64(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "SOAP-ENC:base64") && soap_match_tag(soap, soap->type, "SOAP-ENC:base64Binary"))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType)))
			a->soap_default(soap);
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (!*soap->href)
	{	if (!(a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body)
		{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType), SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary));
		if (a && soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap *soap, int n)
{	return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary;
		if (size)
			*size = sizeof(xsd__base64Binary);
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary[n];
		if (size)
			*size = n * sizeof(xsd__base64Binary);
	}
	return (xsd__base64Binary*)cp->ptr;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Fault))
		soap_mark_SOAP_ENV__Fault(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_embedded(soap, &a->faultcode, SOAP_TYPE__QName);
	soap_mark__QName(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	soap_mark_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_embedded(soap, &a->SOAP_ENV__Code, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_mark_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_embedded(soap, &a->SOAP_ENV__Reason, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Reason);
	soap_embedded(soap, &a->SOAP_ENV__Detail, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	soap_mark_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	soap_default_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_default_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_default_string(soap, &a->SOAP_ENV__Reason);
	soap_default_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_SOAP_ENV__Fault);
	soap_out_SOAP_ENV__Fault(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_string(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0), SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault));
		if (a && soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_mark_SOAP_ENV__Detail(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	soap_markelement(soap, a->value, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	a->__type = 0;
	a->value = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_SOAP_ENV__Detail);
	soap_out_SOAP_ENV__Detail(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->value, "value", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_value = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Detail(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if ((a->value = soap_getelement(soap, &a->__type)))
				{	soap_flag_value = 0;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0), SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail));
		if (a && soap->alloced)
			soap_default_SOAP_ENV__Detail(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_embedded(soap, &a->SOAP_ENV__Value, SOAP_TYPE__QName);
	soap_mark__QName(soap, &a->SOAP_ENV__Value);
	soap_embedded(soap, &a->SOAP_ENV__Node, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Node);
	soap_embedded(soap, &a->SOAP_ENV__Role, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_SOAP_ENV__Code);
	soap_out_SOAP_ENV__Code(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, ""))
				{	soap_flag_SOAP_ENV__Node = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, ""))
				{	soap_flag_SOAP_ENV__Role = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code));
		if (a && soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__createItemRequest(struct soap *soap, struct __ns9__createItemRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns9__createItemRequest))
		soap_mark___ns9__createItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns9__createItemRequest(struct soap *soap, const struct __ns9__createItemRequest *a)
{
	soap_embedded(soap, &a->ns1__createItemRequest, SOAP_TYPE_PointerTo_ns1__createItemRequest);
	soap_mark_PointerTo_ns1__createItemRequest(soap, &a->ns1__createItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__createItemRequest(struct soap *soap, struct __ns9__createItemRequest *a)
{
	soap_default_PointerTo_ns1__createItemRequest(soap, &a->ns1__createItemRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__createItemRequest(struct soap *soap, const struct __ns9__createItemRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns9__createItemRequest);
	soap_out___ns9__createItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns9__createItemRequest(struct soap *soap, const char *tag, int id, const struct __ns9__createItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns9__createItemRequest), type);
	soap_out_PointerTo_ns1__createItemRequest(soap, "ns1:createItemRequest", -1, &a->ns1__createItemRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__createItemRequest * SOAP_FMAC4 soap_get___ns9__createItemRequest(struct soap *soap, struct __ns9__createItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns9__createItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns9__createItemRequest * SOAP_FMAC4 soap_in___ns9__createItemRequest(struct soap *soap, const char *tag, struct __ns9__createItemRequest *a, const char *type)
{
	short soap_flag_ns1__createItemRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns9__createItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns9__createItemRequest, sizeof(struct __ns9__createItemRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns9__createItemRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__createItemRequest(soap, "ns1:createItemRequest", &a->ns1__createItemRequest, ""))
				{	soap_flag_ns1__createItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__createItemRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns9__createItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns9__createItemRequest, sizeof(struct __ns9__createItemRequest), 0), SOAP_TYPE___ns9__createItemRequest, sizeof(struct __ns9__createItemRequest));
		if (a && soap->alloced)
			soap_default___ns9__createItemRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__getDeltaRequest(struct soap *soap, struct __ns8__getDeltaRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns8__getDeltaRequest))
		soap_mark___ns8__getDeltaRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns8__getDeltaRequest(struct soap *soap, const struct __ns8__getDeltaRequest *a)
{
	soap_embedded(soap, &a->ns1__getDeltaRequest, SOAP_TYPE_PointerTo_ns1__getDeltaRequest);
	soap_mark_PointerTo_ns1__getDeltaRequest(soap, &a->ns1__getDeltaRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__getDeltaRequest(struct soap *soap, struct __ns8__getDeltaRequest *a)
{
	soap_default_PointerTo_ns1__getDeltaRequest(soap, &a->ns1__getDeltaRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__getDeltaRequest(struct soap *soap, const struct __ns8__getDeltaRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns8__getDeltaRequest);
	soap_out___ns8__getDeltaRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__getDeltaRequest(struct soap *soap, const char *tag, int id, const struct __ns8__getDeltaRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns8__getDeltaRequest), type);
	soap_out_PointerTo_ns1__getDeltaRequest(soap, "ns1:getDeltaRequest", -1, &a->ns1__getDeltaRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__getDeltaRequest * SOAP_FMAC4 soap_get___ns8__getDeltaRequest(struct soap *soap, struct __ns8__getDeltaRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__getDeltaRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns8__getDeltaRequest * SOAP_FMAC4 soap_in___ns8__getDeltaRequest(struct soap *soap, const char *tag, struct __ns8__getDeltaRequest *a, const char *type)
{
	short soap_flag_ns1__getDeltaRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns8__getDeltaRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns8__getDeltaRequest, sizeof(struct __ns8__getDeltaRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns8__getDeltaRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDeltaRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getDeltaRequest(soap, "ns1:getDeltaRequest", &a->ns1__getDeltaRequest, ""))
				{	soap_flag_ns1__getDeltaRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__getDeltaRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns8__getDeltaRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns8__getDeltaRequest, sizeof(struct __ns8__getDeltaRequest), 0), SOAP_TYPE___ns8__getDeltaRequest, sizeof(struct __ns8__getDeltaRequest));
		if (a && soap->alloced)
			soap_default___ns8__getDeltaRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__getFolderListRequest(struct soap *soap, struct __ns7__getFolderListRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns7__getFolderListRequest))
		soap_mark___ns7__getFolderListRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns7__getFolderListRequest(struct soap *soap, const struct __ns7__getFolderListRequest *a)
{
	soap_embedded(soap, &a->ns1__getFolderListRequest, SOAP_TYPE_PointerTo_ns1__getFolderListRequest);
	soap_mark_PointerTo_ns1__getFolderListRequest(soap, &a->ns1__getFolderListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__getFolderListRequest(struct soap *soap, struct __ns7__getFolderListRequest *a)
{
	soap_default_PointerTo_ns1__getFolderListRequest(soap, &a->ns1__getFolderListRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__getFolderListRequest(struct soap *soap, const struct __ns7__getFolderListRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns7__getFolderListRequest);
	soap_out___ns7__getFolderListRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__getFolderListRequest(struct soap *soap, const char *tag, int id, const struct __ns7__getFolderListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns7__getFolderListRequest), type);
	soap_out_PointerTo_ns1__getFolderListRequest(soap, "ns1:getFolderListRequest", -1, &a->ns1__getFolderListRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getFolderListRequest * SOAP_FMAC4 soap_get___ns7__getFolderListRequest(struct soap *soap, struct __ns7__getFolderListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__getFolderListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns7__getFolderListRequest * SOAP_FMAC4 soap_in___ns7__getFolderListRequest(struct soap *soap, const char *tag, struct __ns7__getFolderListRequest *a, const char *type)
{
	short soap_flag_ns1__getFolderListRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns7__getFolderListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns7__getFolderListRequest, sizeof(struct __ns7__getFolderListRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns7__getFolderListRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getFolderListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getFolderListRequest(soap, "ns1:getFolderListRequest", &a->ns1__getFolderListRequest, ""))
				{	soap_flag_ns1__getFolderListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__getFolderListRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns7__getFolderListRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns7__getFolderListRequest, sizeof(struct __ns7__getFolderListRequest), 0), SOAP_TYPE___ns7__getFolderListRequest, sizeof(struct __ns7__getFolderListRequest));
		if (a && soap->alloced)
			soap_default___ns7__getFolderListRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__getItemsRequest(struct soap *soap, struct __ns6__getItemsRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns6__getItemsRequest))
		soap_mark___ns6__getItemsRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns6__getItemsRequest(struct soap *soap, const struct __ns6__getItemsRequest *a)
{
	soap_embedded(soap, &a->ns1__getItemsRequest, SOAP_TYPE_PointerTo_ns1__getItemsRequest);
	soap_mark_PointerTo_ns1__getItemsRequest(soap, &a->ns1__getItemsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__getItemsRequest(struct soap *soap, struct __ns6__getItemsRequest *a)
{
	soap_default_PointerTo_ns1__getItemsRequest(soap, &a->ns1__getItemsRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__getItemsRequest(struct soap *soap, const struct __ns6__getItemsRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns6__getItemsRequest);
	soap_out___ns6__getItemsRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__getItemsRequest(struct soap *soap, const char *tag, int id, const struct __ns6__getItemsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns6__getItemsRequest), type);
	soap_out_PointerTo_ns1__getItemsRequest(soap, "ns1:getItemsRequest", -1, &a->ns1__getItemsRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__getItemsRequest * SOAP_FMAC4 soap_get___ns6__getItemsRequest(struct soap *soap, struct __ns6__getItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__getItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns6__getItemsRequest * SOAP_FMAC4 soap_in___ns6__getItemsRequest(struct soap *soap, const char *tag, struct __ns6__getItemsRequest *a, const char *type)
{
	short soap_flag_ns1__getItemsRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns6__getItemsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns6__getItemsRequest, sizeof(struct __ns6__getItemsRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns6__getItemsRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getItemsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getItemsRequest(soap, "ns1:getItemsRequest", &a->ns1__getItemsRequest, ""))
				{	soap_flag_ns1__getItemsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__getItemsRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns6__getItemsRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns6__getItemsRequest, sizeof(struct __ns6__getItemsRequest), 0), SOAP_TYPE___ns6__getItemsRequest, sizeof(struct __ns6__getItemsRequest));
		if (a && soap->alloced)
			soap_default___ns6__getItemsRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__getItemRequest(struct soap *soap, struct __ns5__getItemRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns5__getItemRequest))
		soap_mark___ns5__getItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns5__getItemRequest(struct soap *soap, const struct __ns5__getItemRequest *a)
{
	soap_embedded(soap, &a->ns1__getItemRequest, SOAP_TYPE_PointerTo_ns1__getItemRequest);
	soap_mark_PointerTo_ns1__getItemRequest(soap, &a->ns1__getItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__getItemRequest(struct soap *soap, struct __ns5__getItemRequest *a)
{
	soap_default_PointerTo_ns1__getItemRequest(soap, &a->ns1__getItemRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__getItemRequest(struct soap *soap, const struct __ns5__getItemRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns5__getItemRequest);
	soap_out___ns5__getItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__getItemRequest(struct soap *soap, const char *tag, int id, const struct __ns5__getItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns5__getItemRequest), type);
	soap_out_PointerTo_ns1__getItemRequest(soap, "ns1:getItemRequest", -1, &a->ns1__getItemRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__getItemRequest * SOAP_FMAC4 soap_get___ns5__getItemRequest(struct soap *soap, struct __ns5__getItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__getItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns5__getItemRequest * SOAP_FMAC4 soap_in___ns5__getItemRequest(struct soap *soap, const char *tag, struct __ns5__getItemRequest *a, const char *type)
{
	short soap_flag_ns1__getItemRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns5__getItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns5__getItemRequest, sizeof(struct __ns5__getItemRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns5__getItemRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getItemRequest(soap, "ns1:getItemRequest", &a->ns1__getItemRequest, ""))
				{	soap_flag_ns1__getItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__getItemRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns5__getItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns5__getItemRequest, sizeof(struct __ns5__getItemRequest), 0), SOAP_TYPE___ns5__getItemRequest, sizeof(struct __ns5__getItemRequest));
		if (a && soap->alloced)
			soap_default___ns5__getItemRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getAddressBookListRequest(struct soap *soap, struct __ns4__getAddressBookListRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns4__getAddressBookListRequest))
		soap_mark___ns4__getAddressBookListRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns4__getAddressBookListRequest(struct soap *soap, const struct __ns4__getAddressBookListRequest *a)
{
	soap_embedded(soap, &a->ns1__getAddressBookListRequest, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &a->ns1__getAddressBookListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getAddressBookListRequest(struct soap *soap, struct __ns4__getAddressBookListRequest *a)
{
	soap_default_std__string(soap, &a->ns1__getAddressBookListRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getAddressBookListRequest(struct soap *soap, const struct __ns4__getAddressBookListRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns4__getAddressBookListRequest);
	soap_out___ns4__getAddressBookListRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__getAddressBookListRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getAddressBookListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns4__getAddressBookListRequest), type);
	soap_out_std__string(soap, "ns1:getAddressBookListRequest", -1, &a->ns1__getAddressBookListRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getAddressBookListRequest * SOAP_FMAC4 soap_get___ns4__getAddressBookListRequest(struct soap *soap, struct __ns4__getAddressBookListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__getAddressBookListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns4__getAddressBookListRequest * SOAP_FMAC4 soap_in___ns4__getAddressBookListRequest(struct soap *soap, const char *tag, struct __ns4__getAddressBookListRequest *a, const char *type)
{
	short soap_flag_ns1__getAddressBookListRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns4__getAddressBookListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE___ns4__getAddressBookListRequest, sizeof(struct __ns4__getAddressBookListRequest), soap->type, soap->arrayType);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns4__getAddressBookListRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAddressBookListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "ns1:getAddressBookListRequest", &a->ns1__getAddressBookListRequest, "xsd:string"))
				{	soap_flag_ns1__getAddressBookListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__getAddressBookListRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns4__getAddressBookListRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE___ns4__getAddressBookListRequest, sizeof(struct __ns4__getAddressBookListRequest), soap->type, soap->arrayType), SOAP_TYPE___ns4__getAddressBookListRequest, sizeof(struct __ns4__getAddressBookListRequest));
		if (a && soap->alloced)
			soap_default___ns4__getAddressBookListRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct __ns4__getAddressBookListRequest * SOAP_FMAC6 soap_new___ns4__getAddressBookListRequest(struct soap *soap, int n)
{	return soap_instantiate___ns4__getAddressBookListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns4__getAddressBookListRequest(struct soap *soap, struct __ns4__getAddressBookListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 struct __ns4__getAddressBookListRequest * SOAP_FMAC6 soap_instantiate___ns4__getAddressBookListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getAddressBookListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getAddressBookListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns4__getAddressBookListRequest;
		if (size)
			*size = sizeof(struct __ns4__getAddressBookListRequest);
	}
	else
	{	cp->ptr = (void*)new struct __ns4__getAddressBookListRequest[n];
		if (size)
			*size = n * sizeof(struct __ns4__getAddressBookListRequest);
	}
	return (struct __ns4__getAddressBookListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__getCategoryListRequest(struct soap *soap, struct __ns3__getCategoryListRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns3__getCategoryListRequest))
		soap_mark___ns3__getCategoryListRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns3__getCategoryListRequest(struct soap *soap, const struct __ns3__getCategoryListRequest *a)
{
	soap_embedded(soap, &a->ns1__getCategoryListRequest, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &a->ns1__getCategoryListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__getCategoryListRequest(struct soap *soap, struct __ns3__getCategoryListRequest *a)
{
	soap_default_std__string(soap, &a->ns1__getCategoryListRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__getCategoryListRequest(struct soap *soap, const struct __ns3__getCategoryListRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns3__getCategoryListRequest);
	soap_out___ns3__getCategoryListRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__getCategoryListRequest(struct soap *soap, const char *tag, int id, const struct __ns3__getCategoryListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns3__getCategoryListRequest), type);
	soap_out_std__string(soap, "ns1:getCategoryListRequest", -1, &a->ns1__getCategoryListRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__getCategoryListRequest * SOAP_FMAC4 soap_get___ns3__getCategoryListRequest(struct soap *soap, struct __ns3__getCategoryListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__getCategoryListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns3__getCategoryListRequest * SOAP_FMAC4 soap_in___ns3__getCategoryListRequest(struct soap *soap, const char *tag, struct __ns3__getCategoryListRequest *a, const char *type)
{
	short soap_flag_ns1__getCategoryListRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns3__getCategoryListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE___ns3__getCategoryListRequest, sizeof(struct __ns3__getCategoryListRequest), soap->type, soap->arrayType);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns3__getCategoryListRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCategoryListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "ns1:getCategoryListRequest", &a->ns1__getCategoryListRequest, "xsd:string"))
				{	soap_flag_ns1__getCategoryListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__getCategoryListRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns3__getCategoryListRequest *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE___ns3__getCategoryListRequest, sizeof(struct __ns3__getCategoryListRequest), soap->type, soap->arrayType), SOAP_TYPE___ns3__getCategoryListRequest, sizeof(struct __ns3__getCategoryListRequest));
		if (a && soap->alloced)
			soap_default___ns3__getCategoryListRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct __ns3__getCategoryListRequest * SOAP_FMAC6 soap_new___ns3__getCategoryListRequest(struct soap *soap, int n)
{	return soap_instantiate___ns3__getCategoryListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns3__getCategoryListRequest(struct soap *soap, struct __ns3__getCategoryListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 struct __ns3__getCategoryListRequest * SOAP_FMAC6 soap_instantiate___ns3__getCategoryListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__getCategoryListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__getCategoryListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__getCategoryListRequest;
		if (size)
			*size = sizeof(struct __ns3__getCategoryListRequest);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__getCategoryListRequest[n];
		if (size)
			*size = n * sizeof(struct __ns3__getCategoryListRequest);
	}
	return (struct __ns3__getCategoryListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__loginRequest(struct soap *soap, struct __ns2__loginRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns2__loginRequest))
		soap_mark___ns2__loginRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns2__loginRequest(struct soap *soap, const struct __ns2__loginRequest *a)
{
	soap_embedded(soap, &a->ns1__loginRequest, SOAP_TYPE_PointerTo_ns1__loginRequest);
	soap_mark_PointerTo_ns1__loginRequest(soap, &a->ns1__loginRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__loginRequest(struct soap *soap, struct __ns2__loginRequest *a)
{
	soap_default_PointerTo_ns1__loginRequest(soap, &a->ns1__loginRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__loginRequest(struct soap *soap, const struct __ns2__loginRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns2__loginRequest);
	soap_out___ns2__loginRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__loginRequest(struct soap *soap, const char *tag, int id, const struct __ns2__loginRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns2__loginRequest), type);
	soap_out_PointerTo_ns1__loginRequest(soap, "ns1:loginRequest", -1, &a->ns1__loginRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__loginRequest * SOAP_FMAC4 soap_get___ns2__loginRequest(struct soap *soap, struct __ns2__loginRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__loginRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns2__loginRequest * SOAP_FMAC4 soap_in___ns2__loginRequest(struct soap *soap, const char *tag, struct __ns2__loginRequest *a, const char *type)
{
	short soap_flag_ns1__loginRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns2__loginRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns2__loginRequest, sizeof(struct __ns2__loginRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns2__loginRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__loginRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__loginRequest(soap, "ns1:loginRequest", &a->ns1__loginRequest, ""))
				{	soap_flag_ns1__loginRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__loginRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns2__loginRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns2__loginRequest, sizeof(struct __ns2__loginRequest), 0), SOAP_TYPE___ns2__loginRequest, sizeof(struct __ns2__loginRequest));
		if (a && soap->alloced)
			soap_default___ns2__loginRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns16__sendItemRequest(struct soap *soap, struct __ns16__sendItemRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns16__sendItemRequest))
		soap_mark___ns16__sendItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns16__sendItemRequest(struct soap *soap, const struct __ns16__sendItemRequest *a)
{
	soap_embedded(soap, &a->ns1__sendItemRequest, SOAP_TYPE_PointerTo_ns1__sendItemRequest);
	soap_mark_PointerTo_ns1__sendItemRequest(soap, &a->ns1__sendItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns16__sendItemRequest(struct soap *soap, struct __ns16__sendItemRequest *a)
{
	soap_default_PointerTo_ns1__sendItemRequest(soap, &a->ns1__sendItemRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns16__sendItemRequest(struct soap *soap, const struct __ns16__sendItemRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns16__sendItemRequest);
	soap_out___ns16__sendItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns16__sendItemRequest(struct soap *soap, const char *tag, int id, const struct __ns16__sendItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns16__sendItemRequest), type);
	soap_out_PointerTo_ns1__sendItemRequest(soap, "ns1:sendItemRequest", -1, &a->ns1__sendItemRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns16__sendItemRequest * SOAP_FMAC4 soap_get___ns16__sendItemRequest(struct soap *soap, struct __ns16__sendItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns16__sendItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns16__sendItemRequest * SOAP_FMAC4 soap_in___ns16__sendItemRequest(struct soap *soap, const char *tag, struct __ns16__sendItemRequest *a, const char *type)
{
	short soap_flag_ns1__sendItemRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns16__sendItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns16__sendItemRequest, sizeof(struct __ns16__sendItemRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns16__sendItemRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__sendItemRequest(soap, "ns1:sendItemRequest", &a->ns1__sendItemRequest, ""))
				{	soap_flag_ns1__sendItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__sendItemRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns16__sendItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns16__sendItemRequest, sizeof(struct __ns16__sendItemRequest), 0), SOAP_TYPE___ns16__sendItemRequest, sizeof(struct __ns16__sendItemRequest));
		if (a && soap->alloced)
			soap_default___ns16__sendItemRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns15__getFreeBusyRequest(struct soap *soap, struct __ns15__getFreeBusyRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns15__getFreeBusyRequest))
		soap_mark___ns15__getFreeBusyRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns15__getFreeBusyRequest(struct soap *soap, const struct __ns15__getFreeBusyRequest *a)
{
	soap_embedded(soap, &a->ns1__getFreeBusyRequest, SOAP_TYPE_PointerTo_ns1__getFreeBusyRequest);
	soap_mark_PointerTo_ns1__getFreeBusyRequest(soap, &a->ns1__getFreeBusyRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns15__getFreeBusyRequest(struct soap *soap, struct __ns15__getFreeBusyRequest *a)
{
	soap_default_PointerTo_ns1__getFreeBusyRequest(soap, &a->ns1__getFreeBusyRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns15__getFreeBusyRequest(struct soap *soap, const struct __ns15__getFreeBusyRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns15__getFreeBusyRequest);
	soap_out___ns15__getFreeBusyRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns15__getFreeBusyRequest(struct soap *soap, const char *tag, int id, const struct __ns15__getFreeBusyRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns15__getFreeBusyRequest), type);
	soap_out_PointerTo_ns1__getFreeBusyRequest(soap, "ns1:getFreeBusyRequest", -1, &a->ns1__getFreeBusyRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns15__getFreeBusyRequest * SOAP_FMAC4 soap_get___ns15__getFreeBusyRequest(struct soap *soap, struct __ns15__getFreeBusyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns15__getFreeBusyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns15__getFreeBusyRequest * SOAP_FMAC4 soap_in___ns15__getFreeBusyRequest(struct soap *soap, const char *tag, struct __ns15__getFreeBusyRequest *a, const char *type)
{
	short soap_flag_ns1__getFreeBusyRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns15__getFreeBusyRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns15__getFreeBusyRequest, sizeof(struct __ns15__getFreeBusyRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns15__getFreeBusyRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getFreeBusyRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getFreeBusyRequest(soap, "ns1:getFreeBusyRequest", &a->ns1__getFreeBusyRequest, ""))
				{	soap_flag_ns1__getFreeBusyRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__getFreeBusyRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns15__getFreeBusyRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns15__getFreeBusyRequest, sizeof(struct __ns15__getFreeBusyRequest), 0), SOAP_TYPE___ns15__getFreeBusyRequest, sizeof(struct __ns15__getFreeBusyRequest));
		if (a && soap->alloced)
			soap_default___ns15__getFreeBusyRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns14__closeFreeBusySessionRequest(struct soap *soap, struct __ns14__closeFreeBusySessionRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns14__closeFreeBusySessionRequest))
		soap_mark___ns14__closeFreeBusySessionRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns14__closeFreeBusySessionRequest(struct soap *soap, const struct __ns14__closeFreeBusySessionRequest *a)
{
	soap_embedded(soap, &a->ns1__closeFreeBusySessionRequest, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionRequest);
	soap_mark_PointerTo_ns1__closeFreeBusySessionRequest(soap, &a->ns1__closeFreeBusySessionRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns14__closeFreeBusySessionRequest(struct soap *soap, struct __ns14__closeFreeBusySessionRequest *a)
{
	soap_default_PointerTo_ns1__closeFreeBusySessionRequest(soap, &a->ns1__closeFreeBusySessionRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns14__closeFreeBusySessionRequest(struct soap *soap, const struct __ns14__closeFreeBusySessionRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns14__closeFreeBusySessionRequest);
	soap_out___ns14__closeFreeBusySessionRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns14__closeFreeBusySessionRequest(struct soap *soap, const char *tag, int id, const struct __ns14__closeFreeBusySessionRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns14__closeFreeBusySessionRequest), type);
	soap_out_PointerTo_ns1__closeFreeBusySessionRequest(soap, "ns1:closeFreeBusySessionRequest", -1, &a->ns1__closeFreeBusySessionRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns14__closeFreeBusySessionRequest * SOAP_FMAC4 soap_get___ns14__closeFreeBusySessionRequest(struct soap *soap, struct __ns14__closeFreeBusySessionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns14__closeFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns14__closeFreeBusySessionRequest * SOAP_FMAC4 soap_in___ns14__closeFreeBusySessionRequest(struct soap *soap, const char *tag, struct __ns14__closeFreeBusySessionRequest *a, const char *type)
{
	short soap_flag_ns1__closeFreeBusySessionRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns14__closeFreeBusySessionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns14__closeFreeBusySessionRequest, sizeof(struct __ns14__closeFreeBusySessionRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns14__closeFreeBusySessionRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__closeFreeBusySessionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__closeFreeBusySessionRequest(soap, "ns1:closeFreeBusySessionRequest", &a->ns1__closeFreeBusySessionRequest, ""))
				{	soap_flag_ns1__closeFreeBusySessionRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__closeFreeBusySessionRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns14__closeFreeBusySessionRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns14__closeFreeBusySessionRequest, sizeof(struct __ns14__closeFreeBusySessionRequest), 0), SOAP_TYPE___ns14__closeFreeBusySessionRequest, sizeof(struct __ns14__closeFreeBusySessionRequest));
		if (a && soap->alloced)
			soap_default___ns14__closeFreeBusySessionRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns13__startFreeBusySessionRequest(struct soap *soap, struct __ns13__startFreeBusySessionRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns13__startFreeBusySessionRequest))
		soap_mark___ns13__startFreeBusySessionRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns13__startFreeBusySessionRequest(struct soap *soap, const struct __ns13__startFreeBusySessionRequest *a)
{
	soap_embedded(soap, &a->ns1__startFreeBusySessionRequest, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionRequest);
	soap_mark_PointerTo_ns1__startFreeBusySessionRequest(soap, &a->ns1__startFreeBusySessionRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns13__startFreeBusySessionRequest(struct soap *soap, struct __ns13__startFreeBusySessionRequest *a)
{
	soap_default_PointerTo_ns1__startFreeBusySessionRequest(soap, &a->ns1__startFreeBusySessionRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns13__startFreeBusySessionRequest(struct soap *soap, const struct __ns13__startFreeBusySessionRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns13__startFreeBusySessionRequest);
	soap_out___ns13__startFreeBusySessionRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns13__startFreeBusySessionRequest(struct soap *soap, const char *tag, int id, const struct __ns13__startFreeBusySessionRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns13__startFreeBusySessionRequest), type);
	soap_out_PointerTo_ns1__startFreeBusySessionRequest(soap, "ns1:startFreeBusySessionRequest", -1, &a->ns1__startFreeBusySessionRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns13__startFreeBusySessionRequest * SOAP_FMAC4 soap_get___ns13__startFreeBusySessionRequest(struct soap *soap, struct __ns13__startFreeBusySessionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns13__startFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns13__startFreeBusySessionRequest * SOAP_FMAC4 soap_in___ns13__startFreeBusySessionRequest(struct soap *soap, const char *tag, struct __ns13__startFreeBusySessionRequest *a, const char *type)
{
	short soap_flag_ns1__startFreeBusySessionRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns13__startFreeBusySessionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns13__startFreeBusySessionRequest, sizeof(struct __ns13__startFreeBusySessionRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns13__startFreeBusySessionRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__startFreeBusySessionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__startFreeBusySessionRequest(soap, "ns1:startFreeBusySessionRequest", &a->ns1__startFreeBusySessionRequest, ""))
				{	soap_flag_ns1__startFreeBusySessionRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__startFreeBusySessionRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns13__startFreeBusySessionRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns13__startFreeBusySessionRequest, sizeof(struct __ns13__startFreeBusySessionRequest), 0), SOAP_TYPE___ns13__startFreeBusySessionRequest, sizeof(struct __ns13__startFreeBusySessionRequest));
		if (a && soap->alloced)
			soap_default___ns13__startFreeBusySessionRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns12__removeItemRequest(struct soap *soap, struct __ns12__removeItemRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns12__removeItemRequest))
		soap_mark___ns12__removeItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns12__removeItemRequest(struct soap *soap, const struct __ns12__removeItemRequest *a)
{
	soap_embedded(soap, &a->ns1__removeItemRequest, SOAP_TYPE_PointerTo_ns1__removeItemRequest);
	soap_mark_PointerTo_ns1__removeItemRequest(soap, &a->ns1__removeItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns12__removeItemRequest(struct soap *soap, struct __ns12__removeItemRequest *a)
{
	soap_default_PointerTo_ns1__removeItemRequest(soap, &a->ns1__removeItemRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns12__removeItemRequest(struct soap *soap, const struct __ns12__removeItemRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns12__removeItemRequest);
	soap_out___ns12__removeItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns12__removeItemRequest(struct soap *soap, const char *tag, int id, const struct __ns12__removeItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns12__removeItemRequest), type);
	soap_out_PointerTo_ns1__removeItemRequest(soap, "ns1:removeItemRequest", -1, &a->ns1__removeItemRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns12__removeItemRequest * SOAP_FMAC4 soap_get___ns12__removeItemRequest(struct soap *soap, struct __ns12__removeItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns12__removeItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns12__removeItemRequest * SOAP_FMAC4 soap_in___ns12__removeItemRequest(struct soap *soap, const char *tag, struct __ns12__removeItemRequest *a, const char *type)
{
	short soap_flag_ns1__removeItemRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns12__removeItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns12__removeItemRequest, sizeof(struct __ns12__removeItemRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns12__removeItemRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeItemRequest(soap, "ns1:removeItemRequest", &a->ns1__removeItemRequest, ""))
				{	soap_flag_ns1__removeItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__removeItemRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns12__removeItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns12__removeItemRequest, sizeof(struct __ns12__removeItemRequest), 0), SOAP_TYPE___ns12__removeItemRequest, sizeof(struct __ns12__removeItemRequest));
		if (a && soap->alloced)
			soap_default___ns12__removeItemRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__purgeItemRequest(struct soap *soap, struct __ns11__purgeItemRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns11__purgeItemRequest))
		soap_mark___ns11__purgeItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns11__purgeItemRequest(struct soap *soap, const struct __ns11__purgeItemRequest *a)
{
	soap_embedded(soap, &a->ns1__purgeItemRequest, SOAP_TYPE_PointerTo_ns1__purgeItemRequest);
	soap_mark_PointerTo_ns1__purgeItemRequest(soap, &a->ns1__purgeItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__purgeItemRequest(struct soap *soap, struct __ns11__purgeItemRequest *a)
{
	soap_default_PointerTo_ns1__purgeItemRequest(soap, &a->ns1__purgeItemRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__purgeItemRequest(struct soap *soap, const struct __ns11__purgeItemRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns11__purgeItemRequest);
	soap_out___ns11__purgeItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns11__purgeItemRequest(struct soap *soap, const char *tag, int id, const struct __ns11__purgeItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns11__purgeItemRequest), type);
	soap_out_PointerTo_ns1__purgeItemRequest(soap, "ns1:purgeItemRequest", -1, &a->ns1__purgeItemRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__purgeItemRequest * SOAP_FMAC4 soap_get___ns11__purgeItemRequest(struct soap *soap, struct __ns11__purgeItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns11__purgeItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns11__purgeItemRequest * SOAP_FMAC4 soap_in___ns11__purgeItemRequest(struct soap *soap, const char *tag, struct __ns11__purgeItemRequest *a, const char *type)
{
	short soap_flag_ns1__purgeItemRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns11__purgeItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns11__purgeItemRequest, sizeof(struct __ns11__purgeItemRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns11__purgeItemRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__purgeItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__purgeItemRequest(soap, "ns1:purgeItemRequest", &a->ns1__purgeItemRequest, ""))
				{	soap_flag_ns1__purgeItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__purgeItemRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns11__purgeItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns11__purgeItemRequest, sizeof(struct __ns11__purgeItemRequest), 0), SOAP_TYPE___ns11__purgeItemRequest, sizeof(struct __ns11__purgeItemRequest));
		if (a && soap->alloced)
			soap_default___ns11__purgeItemRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns10__modifyItemRequest(struct soap *soap, struct __ns10__modifyItemRequest const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE___ns10__modifyItemRequest))
		soap_mark___ns10__modifyItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark___ns10__modifyItemRequest(struct soap *soap, const struct __ns10__modifyItemRequest *a)
{
	soap_embedded(soap, &a->ns1__modifyItemRequest, SOAP_TYPE_PointerTo_ns1__modifyItemRequest);
	soap_mark_PointerTo_ns1__modifyItemRequest(soap, &a->ns1__modifyItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns10__modifyItemRequest(struct soap *soap, struct __ns10__modifyItemRequest *a)
{
	soap_default_PointerTo_ns1__modifyItemRequest(soap, &a->ns1__modifyItemRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns10__modifyItemRequest(struct soap *soap, const struct __ns10__modifyItemRequest *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE___ns10__modifyItemRequest);
	soap_out___ns10__modifyItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns10__modifyItemRequest(struct soap *soap, const char *tag, int id, const struct __ns10__modifyItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE___ns10__modifyItemRequest), type);
	soap_out_PointerTo_ns1__modifyItemRequest(soap, "ns1:modifyItemRequest", -1, &a->ns1__modifyItemRequest, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns10__modifyItemRequest * SOAP_FMAC4 soap_get___ns10__modifyItemRequest(struct soap *soap, struct __ns10__modifyItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns10__modifyItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns10__modifyItemRequest * SOAP_FMAC4 soap_in___ns10__modifyItemRequest(struct soap *soap, const char *tag, struct __ns10__modifyItemRequest *a, const char *type)
{
	short soap_flag_ns1__modifyItemRequest = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct __ns10__modifyItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns10__modifyItemRequest, sizeof(struct __ns10__modifyItemRequest), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default___ns10__modifyItemRequest(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__modifyItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__modifyItemRequest(soap, "ns1:modifyItemRequest", &a->ns1__modifyItemRequest, ""))
				{	soap_flag_ns1__modifyItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__modifyItemRequest))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct __ns10__modifyItemRequest *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns10__modifyItemRequest, sizeof(struct __ns10__modifyItemRequest), 0), SOAP_TYPE___ns10__modifyItemRequest, sizeof(struct __ns10__modifyItemRequest));
		if (a && soap->alloced)
			soap_default___ns10__modifyItemRequest(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Header))
		soap_mark_SOAP_ENV__Header(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	soap_embedded(soap, &a->ns1__session, SOAP_TYPE_std__string);
	soap_mark_std__string(soap, &a->ns1__session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	soap_default_std__string(soap, &a->ns1__session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_SOAP_ENV__Header);
	soap_out_SOAP_ENV__Header(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	soap_out_std__string(soap, "ns1:session", -1, &a->ns1__session, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	short soap_flag_ns1__session = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Header *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), soap->type, soap->arrayType);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__session && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__string(soap, "ns1:session", &a->ns1__session, "xsd:string"))
				{	soap_flag_ns1__session = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__session))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), soap->type, soap->arrayType), SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header));
		if (a && soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	return (struct SOAP_ENV__Header*)cp->ptr;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToSOAP_ENV__Code))
		soap_mark_PointerToSOAP_ENV__Code(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_out_PointerToSOAP_ENV__Code(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_SOAP_ENV__Code(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_SOAP_ENV__Code(soap, tag, i, *a, type);
	}
	return soap_out_SOAP_ENV__Code(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp), *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	struct SOAP_ENV__Code *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_SOAP_ENV__Code(soap, tag, NULL, type)))
		{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToSOAP_ENV__Detail))
		soap_mark_PointerToSOAP_ENV__Detail(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_mark_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	soap_out_PointerToSOAP_ENV__Detail(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_SOAP_ENV__Detail, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_SOAP_ENV__Detail(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_SOAP_ENV__Detail(soap, tag, i, *a, type);
	}
	return soap_out_SOAP_ENV__Detail(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_SOAP_ENV__Detail, &pp), *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	struct SOAP_ENV__Detail *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct SOAP_ENV__Detail **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_SOAP_ENV__Detail(soap, tag, NULL, type)))
		{	a = (struct SOAP_ENV__Detail **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToSOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail *), 1), SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createItemResponse(struct soap *soap, _ns1__createItemResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__createItemResponse))
		soap_mark_PointerTo_ns1__createItemResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__createItemResponse(struct soap *soap, _ns1__createItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createItemResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__createItemResponse(struct soap *soap, _ns1__createItemResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createItemResponse(struct soap *soap, _ns1__createItemResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__createItemResponse);
	soap_out_PointerTo_ns1__createItemResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createItemResponse(struct soap *soap, const char *tag, int id, _ns1__createItemResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__createItemResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__createItemResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__createItemResponse, &pp), type);
}

SOAP_FMAC3 _ns1__createItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__createItemResponse(struct soap *soap, _ns1__createItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__createItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__createItemResponse(struct soap *soap, const char *tag, _ns1__createItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__createItemResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__createItemResponse, sizeof(_ns1__createItemResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__createItemResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__createItemResponse, sizeof(_ns1__createItemResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__createItemResponse *)soap_instantiate__ns1__createItemResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__createItemResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__createItemResponse, sizeof(_ns1__createItemResponse *), 1), SOAP_TYPE__ns1__createItemResponse, sizeof(_ns1__createItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createItemRequest(struct soap *soap, _ns1__createItemRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__createItemRequest))
		soap_mark_PointerTo_ns1__createItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__createItemRequest(struct soap *soap, _ns1__createItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createItemRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__createItemRequest(struct soap *soap, _ns1__createItemRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createItemRequest(struct soap *soap, _ns1__createItemRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__createItemRequest);
	soap_out_PointerTo_ns1__createItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createItemRequest(struct soap *soap, const char *tag, int id, _ns1__createItemRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__createItemRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__createItemRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__createItemRequest, &pp), type);
}

SOAP_FMAC3 _ns1__createItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__createItemRequest(struct soap *soap, _ns1__createItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__createItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__createItemRequest(struct soap *soap, const char *tag, _ns1__createItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__createItemRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__createItemRequest, sizeof(_ns1__createItemRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__createItemRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__createItemRequest, sizeof(_ns1__createItemRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__createItemRequest *)soap_instantiate__ns1__createItemRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__createItemRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__createItemRequest, sizeof(_ns1__createItemRequest *), 1), SOAP_TYPE__ns1__createItemRequest, sizeof(_ns1__createItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDeltaResponse(struct soap *soap, _ns1__getDeltaResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getDeltaResponse))
		soap_mark_PointerTo_ns1__getDeltaResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getDeltaResponse(struct soap *soap, _ns1__getDeltaResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDeltaResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getDeltaResponse(struct soap *soap, _ns1__getDeltaResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDeltaResponse(struct soap *soap, _ns1__getDeltaResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getDeltaResponse);
	soap_out_PointerTo_ns1__getDeltaResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDeltaResponse(struct soap *soap, const char *tag, int id, _ns1__getDeltaResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getDeltaResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getDeltaResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getDeltaResponse, &pp), type);
}

SOAP_FMAC3 _ns1__getDeltaResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDeltaResponse(struct soap *soap, _ns1__getDeltaResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDeltaResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getDeltaResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDeltaResponse(struct soap *soap, const char *tag, _ns1__getDeltaResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getDeltaResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getDeltaResponse, sizeof(_ns1__getDeltaResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getDeltaResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getDeltaResponse, sizeof(_ns1__getDeltaResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getDeltaResponse *)soap_instantiate__ns1__getDeltaResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getDeltaResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getDeltaResponse, sizeof(_ns1__getDeltaResponse *), 1), SOAP_TYPE__ns1__getDeltaResponse, sizeof(_ns1__getDeltaResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDeltaRequest(struct soap *soap, _ns1__getDeltaRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getDeltaRequest))
		soap_mark_PointerTo_ns1__getDeltaRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getDeltaRequest(struct soap *soap, _ns1__getDeltaRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDeltaRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getDeltaRequest(struct soap *soap, _ns1__getDeltaRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDeltaRequest(struct soap *soap, _ns1__getDeltaRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getDeltaRequest);
	soap_out_PointerTo_ns1__getDeltaRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDeltaRequest(struct soap *soap, const char *tag, int id, _ns1__getDeltaRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getDeltaRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getDeltaRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getDeltaRequest, &pp), type);
}

SOAP_FMAC3 _ns1__getDeltaRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDeltaRequest(struct soap *soap, _ns1__getDeltaRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDeltaRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getDeltaRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDeltaRequest(struct soap *soap, const char *tag, _ns1__getDeltaRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getDeltaRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getDeltaRequest, sizeof(_ns1__getDeltaRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getDeltaRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getDeltaRequest, sizeof(_ns1__getDeltaRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getDeltaRequest *)soap_instantiate__ns1__getDeltaRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getDeltaRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getDeltaRequest, sizeof(_ns1__getDeltaRequest *), 1), SOAP_TYPE__ns1__getDeltaRequest, sizeof(_ns1__getDeltaRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getFolderListResponse(struct soap *soap, _ns1__getFolderListResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getFolderListResponse))
		soap_mark_PointerTo_ns1__getFolderListResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getFolderListResponse(struct soap *soap, _ns1__getFolderListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getFolderListResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getFolderListResponse(struct soap *soap, _ns1__getFolderListResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getFolderListResponse(struct soap *soap, _ns1__getFolderListResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getFolderListResponse);
	soap_out_PointerTo_ns1__getFolderListResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getFolderListResponse(struct soap *soap, const char *tag, int id, _ns1__getFolderListResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getFolderListResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getFolderListResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getFolderListResponse, &pp), type);
}

SOAP_FMAC3 _ns1__getFolderListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getFolderListResponse(struct soap *soap, _ns1__getFolderListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getFolderListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getFolderListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getFolderListResponse(struct soap *soap, const char *tag, _ns1__getFolderListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getFolderListResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getFolderListResponse, sizeof(_ns1__getFolderListResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getFolderListResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getFolderListResponse, sizeof(_ns1__getFolderListResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getFolderListResponse *)soap_instantiate__ns1__getFolderListResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getFolderListResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getFolderListResponse, sizeof(_ns1__getFolderListResponse *), 1), SOAP_TYPE__ns1__getFolderListResponse, sizeof(_ns1__getFolderListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getFolderListRequest(struct soap *soap, _ns1__getFolderListRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getFolderListRequest))
		soap_mark_PointerTo_ns1__getFolderListRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getFolderListRequest(struct soap *soap, _ns1__getFolderListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getFolderListRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getFolderListRequest(struct soap *soap, _ns1__getFolderListRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getFolderListRequest(struct soap *soap, _ns1__getFolderListRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getFolderListRequest);
	soap_out_PointerTo_ns1__getFolderListRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getFolderListRequest(struct soap *soap, const char *tag, int id, _ns1__getFolderListRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getFolderListRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getFolderListRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getFolderListRequest, &pp), type);
}

SOAP_FMAC3 _ns1__getFolderListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getFolderListRequest(struct soap *soap, _ns1__getFolderListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getFolderListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getFolderListRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getFolderListRequest(struct soap *soap, const char *tag, _ns1__getFolderListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getFolderListRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getFolderListRequest, sizeof(_ns1__getFolderListRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getFolderListRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getFolderListRequest, sizeof(_ns1__getFolderListRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getFolderListRequest *)soap_instantiate__ns1__getFolderListRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getFolderListRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getFolderListRequest, sizeof(_ns1__getFolderListRequest *), 1), SOAP_TYPE__ns1__getFolderListRequest, sizeof(_ns1__getFolderListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getItemsResponse(struct soap *soap, _ns1__getItemsResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getItemsResponse))
		soap_mark_PointerTo_ns1__getItemsResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getItemsResponse(struct soap *soap, _ns1__getItemsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getItemsResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getItemsResponse(struct soap *soap, _ns1__getItemsResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getItemsResponse(struct soap *soap, _ns1__getItemsResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getItemsResponse);
	soap_out_PointerTo_ns1__getItemsResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getItemsResponse(struct soap *soap, const char *tag, int id, _ns1__getItemsResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getItemsResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getItemsResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getItemsResponse, &pp), type);
}

SOAP_FMAC3 _ns1__getItemsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getItemsResponse(struct soap *soap, _ns1__getItemsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getItemsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getItemsResponse(struct soap *soap, const char *tag, _ns1__getItemsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getItemsResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getItemsResponse, sizeof(_ns1__getItemsResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getItemsResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getItemsResponse, sizeof(_ns1__getItemsResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getItemsResponse *)soap_instantiate__ns1__getItemsResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getItemsResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getItemsResponse, sizeof(_ns1__getItemsResponse *), 1), SOAP_TYPE__ns1__getItemsResponse, sizeof(_ns1__getItemsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getItemsRequest(struct soap *soap, _ns1__getItemsRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getItemsRequest))
		soap_mark_PointerTo_ns1__getItemsRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getItemsRequest(struct soap *soap, _ns1__getItemsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getItemsRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getItemsRequest(struct soap *soap, _ns1__getItemsRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getItemsRequest(struct soap *soap, _ns1__getItemsRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getItemsRequest);
	soap_out_PointerTo_ns1__getItemsRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getItemsRequest(struct soap *soap, const char *tag, int id, _ns1__getItemsRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getItemsRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getItemsRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getItemsRequest, &pp), type);
}

SOAP_FMAC3 _ns1__getItemsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getItemsRequest(struct soap *soap, _ns1__getItemsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getItemsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getItemsRequest(struct soap *soap, const char *tag, _ns1__getItemsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getItemsRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getItemsRequest, sizeof(_ns1__getItemsRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getItemsRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getItemsRequest, sizeof(_ns1__getItemsRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getItemsRequest *)soap_instantiate__ns1__getItemsRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getItemsRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getItemsRequest, sizeof(_ns1__getItemsRequest *), 1), SOAP_TYPE__ns1__getItemsRequest, sizeof(_ns1__getItemsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getItemResponse(struct soap *soap, _ns1__getItemResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getItemResponse))
		soap_mark_PointerTo_ns1__getItemResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getItemResponse(struct soap *soap, _ns1__getItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getItemResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getItemResponse(struct soap *soap, _ns1__getItemResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getItemResponse(struct soap *soap, _ns1__getItemResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getItemResponse);
	soap_out_PointerTo_ns1__getItemResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getItemResponse(struct soap *soap, const char *tag, int id, _ns1__getItemResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getItemResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getItemResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getItemResponse, &pp), type);
}

SOAP_FMAC3 _ns1__getItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getItemResponse(struct soap *soap, _ns1__getItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getItemResponse(struct soap *soap, const char *tag, _ns1__getItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getItemResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getItemResponse, sizeof(_ns1__getItemResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getItemResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getItemResponse, sizeof(_ns1__getItemResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getItemResponse *)soap_instantiate__ns1__getItemResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getItemResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getItemResponse, sizeof(_ns1__getItemResponse *), 1), SOAP_TYPE__ns1__getItemResponse, sizeof(_ns1__getItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getItemRequest(struct soap *soap, _ns1__getItemRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getItemRequest))
		soap_mark_PointerTo_ns1__getItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getItemRequest(struct soap *soap, _ns1__getItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getItemRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getItemRequest(struct soap *soap, _ns1__getItemRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getItemRequest(struct soap *soap, _ns1__getItemRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getItemRequest);
	soap_out_PointerTo_ns1__getItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getItemRequest(struct soap *soap, const char *tag, int id, _ns1__getItemRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getItemRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getItemRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getItemRequest, &pp), type);
}

SOAP_FMAC3 _ns1__getItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getItemRequest(struct soap *soap, _ns1__getItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getItemRequest(struct soap *soap, const char *tag, _ns1__getItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getItemRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getItemRequest, sizeof(_ns1__getItemRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getItemRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getItemRequest, sizeof(_ns1__getItemRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getItemRequest *)soap_instantiate__ns1__getItemRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getItemRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getItemRequest, sizeof(_ns1__getItemRequest *), 1), SOAP_TYPE__ns1__getItemRequest, sizeof(_ns1__getItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAddressBookListResponse(struct soap *soap, _ns1__getAddressBookListResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getAddressBookListResponse))
		soap_mark_PointerTo_ns1__getAddressBookListResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getAddressBookListResponse(struct soap *soap, _ns1__getAddressBookListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAddressBookListResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getAddressBookListResponse(struct soap *soap, _ns1__getAddressBookListResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAddressBookListResponse(struct soap *soap, _ns1__getAddressBookListResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getAddressBookListResponse);
	soap_out_PointerTo_ns1__getAddressBookListResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAddressBookListResponse(struct soap *soap, const char *tag, int id, _ns1__getAddressBookListResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getAddressBookListResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getAddressBookListResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getAddressBookListResponse, &pp), type);
}

SOAP_FMAC3 _ns1__getAddressBookListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAddressBookListResponse(struct soap *soap, _ns1__getAddressBookListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAddressBookListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getAddressBookListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAddressBookListResponse(struct soap *soap, const char *tag, _ns1__getAddressBookListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getAddressBookListResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getAddressBookListResponse, sizeof(_ns1__getAddressBookListResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getAddressBookListResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getAddressBookListResponse, sizeof(_ns1__getAddressBookListResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getAddressBookListResponse *)soap_instantiate__ns1__getAddressBookListResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getAddressBookListResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getAddressBookListResponse, sizeof(_ns1__getAddressBookListResponse *), 1), SOAP_TYPE__ns1__getAddressBookListResponse, sizeof(_ns1__getAddressBookListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCategoryListResponse(struct soap *soap, _ns1__getCategoryListResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getCategoryListResponse))
		soap_mark_PointerTo_ns1__getCategoryListResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getCategoryListResponse(struct soap *soap, _ns1__getCategoryListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCategoryListResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getCategoryListResponse(struct soap *soap, _ns1__getCategoryListResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCategoryListResponse(struct soap *soap, _ns1__getCategoryListResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getCategoryListResponse);
	soap_out_PointerTo_ns1__getCategoryListResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCategoryListResponse(struct soap *soap, const char *tag, int id, _ns1__getCategoryListResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getCategoryListResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getCategoryListResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getCategoryListResponse, &pp), type);
}

SOAP_FMAC3 _ns1__getCategoryListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCategoryListResponse(struct soap *soap, _ns1__getCategoryListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCategoryListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getCategoryListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCategoryListResponse(struct soap *soap, const char *tag, _ns1__getCategoryListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getCategoryListResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getCategoryListResponse, sizeof(_ns1__getCategoryListResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getCategoryListResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getCategoryListResponse, sizeof(_ns1__getCategoryListResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getCategoryListResponse *)soap_instantiate__ns1__getCategoryListResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getCategoryListResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getCategoryListResponse, sizeof(_ns1__getCategoryListResponse *), 1), SOAP_TYPE__ns1__getCategoryListResponse, sizeof(_ns1__getCategoryListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__loginResponse))
		soap_mark_PointerTo_ns1__loginResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__loginResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__loginResponse);
	soap_out_PointerTo_ns1__loginResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__loginResponse(struct soap *soap, const char *tag, int id, _ns1__loginResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__loginResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__loginResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__loginResponse, &pp), type);
}

SOAP_FMAC3 _ns1__loginResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__loginResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__loginResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__loginResponse(struct soap *soap, const char *tag, _ns1__loginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__loginResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__loginResponse, sizeof(_ns1__loginResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__loginResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__loginResponse, sizeof(_ns1__loginResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__loginResponse *)soap_instantiate__ns1__loginResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__loginResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__loginResponse, sizeof(_ns1__loginResponse *), 1), SOAP_TYPE__ns1__loginResponse, sizeof(_ns1__loginResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__loginRequest(struct soap *soap, _ns1__loginRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__loginRequest))
		soap_mark_PointerTo_ns1__loginRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__loginRequest(struct soap *soap, _ns1__loginRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__loginRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__loginRequest(struct soap *soap, _ns1__loginRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__loginRequest(struct soap *soap, _ns1__loginRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__loginRequest);
	soap_out_PointerTo_ns1__loginRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__loginRequest(struct soap *soap, const char *tag, int id, _ns1__loginRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__loginRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__loginRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__loginRequest, &pp), type);
}

SOAP_FMAC3 _ns1__loginRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__loginRequest(struct soap *soap, _ns1__loginRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__loginRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__loginRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__loginRequest(struct soap *soap, const char *tag, _ns1__loginRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__loginRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__loginRequest, sizeof(_ns1__loginRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__loginRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__loginRequest, sizeof(_ns1__loginRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__loginRequest *)soap_instantiate__ns1__loginRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__loginRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__loginRequest, sizeof(_ns1__loginRequest *), 1), SOAP_TYPE__ns1__loginRequest, sizeof(_ns1__loginRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__sendItemResponse(struct soap *soap, _ns1__sendItemResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__sendItemResponse))
		soap_mark_PointerTo_ns1__sendItemResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__sendItemResponse(struct soap *soap, _ns1__sendItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__sendItemResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__sendItemResponse(struct soap *soap, _ns1__sendItemResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__sendItemResponse(struct soap *soap, _ns1__sendItemResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__sendItemResponse);
	soap_out_PointerTo_ns1__sendItemResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__sendItemResponse(struct soap *soap, const char *tag, int id, _ns1__sendItemResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__sendItemResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__sendItemResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__sendItemResponse, &pp), type);
}

SOAP_FMAC3 _ns1__sendItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__sendItemResponse(struct soap *soap, _ns1__sendItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__sendItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__sendItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__sendItemResponse(struct soap *soap, const char *tag, _ns1__sendItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__sendItemResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__sendItemResponse, sizeof(_ns1__sendItemResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__sendItemResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__sendItemResponse, sizeof(_ns1__sendItemResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__sendItemResponse *)soap_instantiate__ns1__sendItemResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__sendItemResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__sendItemResponse, sizeof(_ns1__sendItemResponse *), 1), SOAP_TYPE__ns1__sendItemResponse, sizeof(_ns1__sendItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__sendItemRequest(struct soap *soap, _ns1__sendItemRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__sendItemRequest))
		soap_mark_PointerTo_ns1__sendItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__sendItemRequest(struct soap *soap, _ns1__sendItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__sendItemRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__sendItemRequest(struct soap *soap, _ns1__sendItemRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__sendItemRequest(struct soap *soap, _ns1__sendItemRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__sendItemRequest);
	soap_out_PointerTo_ns1__sendItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__sendItemRequest(struct soap *soap, const char *tag, int id, _ns1__sendItemRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__sendItemRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__sendItemRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__sendItemRequest, &pp), type);
}

SOAP_FMAC3 _ns1__sendItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__sendItemRequest(struct soap *soap, _ns1__sendItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__sendItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__sendItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__sendItemRequest(struct soap *soap, const char *tag, _ns1__sendItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__sendItemRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__sendItemRequest, sizeof(_ns1__sendItemRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__sendItemRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__sendItemRequest, sizeof(_ns1__sendItemRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__sendItemRequest *)soap_instantiate__ns1__sendItemRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__sendItemRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__sendItemRequest, sizeof(_ns1__sendItemRequest *), 1), SOAP_TYPE__ns1__sendItemRequest, sizeof(_ns1__sendItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getFreeBusyResponse(struct soap *soap, _ns1__getFreeBusyResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getFreeBusyResponse))
		soap_mark_PointerTo_ns1__getFreeBusyResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getFreeBusyResponse(struct soap *soap, _ns1__getFreeBusyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getFreeBusyResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getFreeBusyResponse(struct soap *soap, _ns1__getFreeBusyResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getFreeBusyResponse(struct soap *soap, _ns1__getFreeBusyResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getFreeBusyResponse);
	soap_out_PointerTo_ns1__getFreeBusyResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getFreeBusyResponse(struct soap *soap, const char *tag, int id, _ns1__getFreeBusyResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getFreeBusyResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getFreeBusyResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getFreeBusyResponse, &pp), type);
}

SOAP_FMAC3 _ns1__getFreeBusyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getFreeBusyResponse(struct soap *soap, _ns1__getFreeBusyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getFreeBusyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getFreeBusyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getFreeBusyResponse(struct soap *soap, const char *tag, _ns1__getFreeBusyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getFreeBusyResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getFreeBusyResponse, sizeof(_ns1__getFreeBusyResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getFreeBusyResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getFreeBusyResponse, sizeof(_ns1__getFreeBusyResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getFreeBusyResponse *)soap_instantiate__ns1__getFreeBusyResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getFreeBusyResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getFreeBusyResponse, sizeof(_ns1__getFreeBusyResponse *), 1), SOAP_TYPE__ns1__getFreeBusyResponse, sizeof(_ns1__getFreeBusyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getFreeBusyRequest(struct soap *soap, _ns1__getFreeBusyRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__getFreeBusyRequest))
		soap_mark_PointerTo_ns1__getFreeBusyRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__getFreeBusyRequest(struct soap *soap, _ns1__getFreeBusyRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getFreeBusyRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__getFreeBusyRequest(struct soap *soap, _ns1__getFreeBusyRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getFreeBusyRequest(struct soap *soap, _ns1__getFreeBusyRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__getFreeBusyRequest);
	soap_out_PointerTo_ns1__getFreeBusyRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getFreeBusyRequest(struct soap *soap, const char *tag, int id, _ns1__getFreeBusyRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__getFreeBusyRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__getFreeBusyRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__getFreeBusyRequest, &pp), type);
}

SOAP_FMAC3 _ns1__getFreeBusyRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getFreeBusyRequest(struct soap *soap, _ns1__getFreeBusyRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getFreeBusyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__getFreeBusyRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getFreeBusyRequest(struct soap *soap, const char *tag, _ns1__getFreeBusyRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__getFreeBusyRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getFreeBusyRequest, sizeof(_ns1__getFreeBusyRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__getFreeBusyRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__getFreeBusyRequest, sizeof(_ns1__getFreeBusyRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__getFreeBusyRequest *)soap_instantiate__ns1__getFreeBusyRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__getFreeBusyRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__getFreeBusyRequest, sizeof(_ns1__getFreeBusyRequest *), 1), SOAP_TYPE__ns1__getFreeBusyRequest, sizeof(_ns1__getFreeBusyRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__closeFreeBusySessionResponse(struct soap *soap, _ns1__closeFreeBusySessionResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionResponse))
		soap_mark_PointerTo_ns1__closeFreeBusySessionResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__closeFreeBusySessionResponse(struct soap *soap, _ns1__closeFreeBusySessionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__closeFreeBusySessionResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__closeFreeBusySessionResponse(struct soap *soap, _ns1__closeFreeBusySessionResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__closeFreeBusySessionResponse(struct soap *soap, _ns1__closeFreeBusySessionResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionResponse);
	soap_out_PointerTo_ns1__closeFreeBusySessionResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__closeFreeBusySessionResponse(struct soap *soap, const char *tag, int id, _ns1__closeFreeBusySessionResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__closeFreeBusySessionResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__closeFreeBusySessionResponse, &pp), type);
}

SOAP_FMAC3 _ns1__closeFreeBusySessionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__closeFreeBusySessionResponse(struct soap *soap, _ns1__closeFreeBusySessionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__closeFreeBusySessionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__closeFreeBusySessionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__closeFreeBusySessionResponse(struct soap *soap, const char *tag, _ns1__closeFreeBusySessionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__closeFreeBusySessionResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionResponse, sizeof(_ns1__closeFreeBusySessionResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__closeFreeBusySessionResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionResponse, sizeof(_ns1__closeFreeBusySessionResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__closeFreeBusySessionResponse *)soap_instantiate__ns1__closeFreeBusySessionResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__closeFreeBusySessionResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionResponse, sizeof(_ns1__closeFreeBusySessionResponse *), 1), SOAP_TYPE__ns1__closeFreeBusySessionResponse, sizeof(_ns1__closeFreeBusySessionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__closeFreeBusySessionRequest(struct soap *soap, _ns1__closeFreeBusySessionRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionRequest))
		soap_mark_PointerTo_ns1__closeFreeBusySessionRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__closeFreeBusySessionRequest(struct soap *soap, _ns1__closeFreeBusySessionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__closeFreeBusySessionRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__closeFreeBusySessionRequest(struct soap *soap, _ns1__closeFreeBusySessionRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__closeFreeBusySessionRequest(struct soap *soap, _ns1__closeFreeBusySessionRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionRequest);
	soap_out_PointerTo_ns1__closeFreeBusySessionRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__closeFreeBusySessionRequest(struct soap *soap, const char *tag, int id, _ns1__closeFreeBusySessionRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__closeFreeBusySessionRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__closeFreeBusySessionRequest, &pp), type);
}

SOAP_FMAC3 _ns1__closeFreeBusySessionRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__closeFreeBusySessionRequest(struct soap *soap, _ns1__closeFreeBusySessionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__closeFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__closeFreeBusySessionRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__closeFreeBusySessionRequest(struct soap *soap, const char *tag, _ns1__closeFreeBusySessionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__closeFreeBusySessionRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionRequest, sizeof(_ns1__closeFreeBusySessionRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__closeFreeBusySessionRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionRequest, sizeof(_ns1__closeFreeBusySessionRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__closeFreeBusySessionRequest *)soap_instantiate__ns1__closeFreeBusySessionRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__closeFreeBusySessionRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__closeFreeBusySessionRequest, sizeof(_ns1__closeFreeBusySessionRequest *), 1), SOAP_TYPE__ns1__closeFreeBusySessionRequest, sizeof(_ns1__closeFreeBusySessionRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__startFreeBusySessionResponse(struct soap *soap, _ns1__startFreeBusySessionResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionResponse))
		soap_mark_PointerTo_ns1__startFreeBusySessionResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__startFreeBusySessionResponse(struct soap *soap, _ns1__startFreeBusySessionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__startFreeBusySessionResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__startFreeBusySessionResponse(struct soap *soap, _ns1__startFreeBusySessionResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__startFreeBusySessionResponse(struct soap *soap, _ns1__startFreeBusySessionResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionResponse);
	soap_out_PointerTo_ns1__startFreeBusySessionResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__startFreeBusySessionResponse(struct soap *soap, const char *tag, int id, _ns1__startFreeBusySessionResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__startFreeBusySessionResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__startFreeBusySessionResponse, &pp), type);
}

SOAP_FMAC3 _ns1__startFreeBusySessionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__startFreeBusySessionResponse(struct soap *soap, _ns1__startFreeBusySessionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__startFreeBusySessionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__startFreeBusySessionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__startFreeBusySessionResponse(struct soap *soap, const char *tag, _ns1__startFreeBusySessionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__startFreeBusySessionResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionResponse, sizeof(_ns1__startFreeBusySessionResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__startFreeBusySessionResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionResponse, sizeof(_ns1__startFreeBusySessionResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__startFreeBusySessionResponse *)soap_instantiate__ns1__startFreeBusySessionResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__startFreeBusySessionResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionResponse, sizeof(_ns1__startFreeBusySessionResponse *), 1), SOAP_TYPE__ns1__startFreeBusySessionResponse, sizeof(_ns1__startFreeBusySessionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__startFreeBusySessionRequest(struct soap *soap, _ns1__startFreeBusySessionRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionRequest))
		soap_mark_PointerTo_ns1__startFreeBusySessionRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__startFreeBusySessionRequest(struct soap *soap, _ns1__startFreeBusySessionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__startFreeBusySessionRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__startFreeBusySessionRequest(struct soap *soap, _ns1__startFreeBusySessionRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__startFreeBusySessionRequest(struct soap *soap, _ns1__startFreeBusySessionRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionRequest);
	soap_out_PointerTo_ns1__startFreeBusySessionRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__startFreeBusySessionRequest(struct soap *soap, const char *tag, int id, _ns1__startFreeBusySessionRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__startFreeBusySessionRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__startFreeBusySessionRequest, &pp), type);
}

SOAP_FMAC3 _ns1__startFreeBusySessionRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__startFreeBusySessionRequest(struct soap *soap, _ns1__startFreeBusySessionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__startFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__startFreeBusySessionRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__startFreeBusySessionRequest(struct soap *soap, const char *tag, _ns1__startFreeBusySessionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__startFreeBusySessionRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionRequest, sizeof(_ns1__startFreeBusySessionRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__startFreeBusySessionRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionRequest, sizeof(_ns1__startFreeBusySessionRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__startFreeBusySessionRequest *)soap_instantiate__ns1__startFreeBusySessionRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__startFreeBusySessionRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__startFreeBusySessionRequest, sizeof(_ns1__startFreeBusySessionRequest *), 1), SOAP_TYPE__ns1__startFreeBusySessionRequest, sizeof(_ns1__startFreeBusySessionRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeItemResponse(struct soap *soap, _ns1__removeItemResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__removeItemResponse))
		soap_mark_PointerTo_ns1__removeItemResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__removeItemResponse(struct soap *soap, _ns1__removeItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeItemResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__removeItemResponse(struct soap *soap, _ns1__removeItemResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeItemResponse(struct soap *soap, _ns1__removeItemResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__removeItemResponse);
	soap_out_PointerTo_ns1__removeItemResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeItemResponse(struct soap *soap, const char *tag, int id, _ns1__removeItemResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__removeItemResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__removeItemResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__removeItemResponse, &pp), type);
}

SOAP_FMAC3 _ns1__removeItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeItemResponse(struct soap *soap, _ns1__removeItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__removeItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeItemResponse(struct soap *soap, const char *tag, _ns1__removeItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__removeItemResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__removeItemResponse, sizeof(_ns1__removeItemResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__removeItemResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__removeItemResponse, sizeof(_ns1__removeItemResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__removeItemResponse *)soap_instantiate__ns1__removeItemResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__removeItemResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__removeItemResponse, sizeof(_ns1__removeItemResponse *), 1), SOAP_TYPE__ns1__removeItemResponse, sizeof(_ns1__removeItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeItemRequest(struct soap *soap, _ns1__removeItemRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__removeItemRequest))
		soap_mark_PointerTo_ns1__removeItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__removeItemRequest(struct soap *soap, _ns1__removeItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeItemRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__removeItemRequest(struct soap *soap, _ns1__removeItemRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeItemRequest(struct soap *soap, _ns1__removeItemRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__removeItemRequest);
	soap_out_PointerTo_ns1__removeItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeItemRequest(struct soap *soap, const char *tag, int id, _ns1__removeItemRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__removeItemRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__removeItemRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__removeItemRequest, &pp), type);
}

SOAP_FMAC3 _ns1__removeItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeItemRequest(struct soap *soap, _ns1__removeItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__removeItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeItemRequest(struct soap *soap, const char *tag, _ns1__removeItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__removeItemRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__removeItemRequest, sizeof(_ns1__removeItemRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__removeItemRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__removeItemRequest, sizeof(_ns1__removeItemRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__removeItemRequest *)soap_instantiate__ns1__removeItemRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__removeItemRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__removeItemRequest, sizeof(_ns1__removeItemRequest *), 1), SOAP_TYPE__ns1__removeItemRequest, sizeof(_ns1__removeItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__purgeItemResponse(struct soap *soap, _ns1__purgeItemResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__purgeItemResponse))
		soap_mark_PointerTo_ns1__purgeItemResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__purgeItemResponse(struct soap *soap, _ns1__purgeItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__purgeItemResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__purgeItemResponse(struct soap *soap, _ns1__purgeItemResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__purgeItemResponse(struct soap *soap, _ns1__purgeItemResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__purgeItemResponse);
	soap_out_PointerTo_ns1__purgeItemResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__purgeItemResponse(struct soap *soap, const char *tag, int id, _ns1__purgeItemResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__purgeItemResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__purgeItemResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__purgeItemResponse, &pp), type);
}

SOAP_FMAC3 _ns1__purgeItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__purgeItemResponse(struct soap *soap, _ns1__purgeItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__purgeItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__purgeItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__purgeItemResponse(struct soap *soap, const char *tag, _ns1__purgeItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__purgeItemResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__purgeItemResponse, sizeof(_ns1__purgeItemResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__purgeItemResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__purgeItemResponse, sizeof(_ns1__purgeItemResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__purgeItemResponse *)soap_instantiate__ns1__purgeItemResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__purgeItemResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__purgeItemResponse, sizeof(_ns1__purgeItemResponse *), 1), SOAP_TYPE__ns1__purgeItemResponse, sizeof(_ns1__purgeItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__purgeItemRequest(struct soap *soap, _ns1__purgeItemRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__purgeItemRequest))
		soap_mark_PointerTo_ns1__purgeItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__purgeItemRequest(struct soap *soap, _ns1__purgeItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__purgeItemRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__purgeItemRequest(struct soap *soap, _ns1__purgeItemRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__purgeItemRequest(struct soap *soap, _ns1__purgeItemRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__purgeItemRequest);
	soap_out_PointerTo_ns1__purgeItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__purgeItemRequest(struct soap *soap, const char *tag, int id, _ns1__purgeItemRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__purgeItemRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__purgeItemRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__purgeItemRequest, &pp), type);
}

SOAP_FMAC3 _ns1__purgeItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__purgeItemRequest(struct soap *soap, _ns1__purgeItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__purgeItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__purgeItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__purgeItemRequest(struct soap *soap, const char *tag, _ns1__purgeItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__purgeItemRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__purgeItemRequest, sizeof(_ns1__purgeItemRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__purgeItemRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__purgeItemRequest, sizeof(_ns1__purgeItemRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__purgeItemRequest *)soap_instantiate__ns1__purgeItemRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__purgeItemRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__purgeItemRequest, sizeof(_ns1__purgeItemRequest *), 1), SOAP_TYPE__ns1__purgeItemRequest, sizeof(_ns1__purgeItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__modifyItemResponse(struct soap *soap, _ns1__modifyItemResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__modifyItemResponse))
		soap_mark_PointerTo_ns1__modifyItemResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__modifyItemResponse(struct soap *soap, _ns1__modifyItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__modifyItemResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__modifyItemResponse(struct soap *soap, _ns1__modifyItemResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__modifyItemResponse(struct soap *soap, _ns1__modifyItemResponse *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__modifyItemResponse);
	soap_out_PointerTo_ns1__modifyItemResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__modifyItemResponse(struct soap *soap, const char *tag, int id, _ns1__modifyItemResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__modifyItemResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__modifyItemResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__modifyItemResponse, &pp), type);
}

SOAP_FMAC3 _ns1__modifyItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__modifyItemResponse(struct soap *soap, _ns1__modifyItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__modifyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__modifyItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__modifyItemResponse(struct soap *soap, const char *tag, _ns1__modifyItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__modifyItemResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__modifyItemResponse, sizeof(_ns1__modifyItemResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__modifyItemResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__modifyItemResponse, sizeof(_ns1__modifyItemResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__modifyItemResponse *)soap_instantiate__ns1__modifyItemResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__modifyItemResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__modifyItemResponse, sizeof(_ns1__modifyItemResponse *), 1), SOAP_TYPE__ns1__modifyItemResponse, sizeof(_ns1__modifyItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__modifyItemRequest(struct soap *soap, _ns1__modifyItemRequest *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTo_ns1__modifyItemRequest))
		soap_mark_PointerTo_ns1__modifyItemRequest(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTo_ns1__modifyItemRequest(struct soap *soap, _ns1__modifyItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__modifyItemRequest))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTo_ns1__modifyItemRequest(struct soap *soap, _ns1__modifyItemRequest **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__modifyItemRequest(struct soap *soap, _ns1__modifyItemRequest *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTo_ns1__modifyItemRequest);
	soap_out_PointerTo_ns1__modifyItemRequest(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__modifyItemRequest(struct soap *soap, const char *tag, int id, _ns1__modifyItemRequest *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTo_ns1__modifyItemRequest);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE__ns1__modifyItemRequest, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE__ns1__modifyItemRequest, &pp), type);
}

SOAP_FMAC3 _ns1__modifyItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__modifyItemRequest(struct soap *soap, _ns1__modifyItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__modifyItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__modifyItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__modifyItemRequest(struct soap *soap, const char *tag, _ns1__modifyItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (_ns1__modifyItemRequest **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__modifyItemRequest, sizeof(_ns1__modifyItemRequest *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (_ns1__modifyItemRequest **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTo_ns1__modifyItemRequest, sizeof(_ns1__modifyItemRequest *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (_ns1__modifyItemRequest *)soap_instantiate__ns1__modifyItemRequest(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (_ns1__modifyItemRequest **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTo_ns1__modifyItemRequest, sizeof(_ns1__modifyItemRequest *), 1), SOAP_TYPE__ns1__modifyItemRequest, sizeof(_ns1__modifyItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Alarm(struct soap *soap, ns1__Alarm *const*a)
{
		soap_mark_PointerTons1__Alarm(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Alarm(struct soap *soap, ns1__Alarm *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Alarm))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Alarm(struct soap *soap, ns1__Alarm **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Alarm(struct soap *soap, ns1__Alarm *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Alarm);
	soap_out_PointerTons1__Alarm(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Alarm(struct soap *soap, const char *tag, int id, ns1__Alarm *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Alarm);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Alarm, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Alarm, &pp), type);
}

SOAP_FMAC3 ns1__Alarm ** SOAP_FMAC4 soap_get_PointerTons1__Alarm(struct soap *soap, ns1__Alarm **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Alarm(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Alarm ** SOAP_FMAC4 soap_in_PointerTons1__Alarm(struct soap *soap, const char *tag, ns1__Alarm **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Alarm **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Alarm, sizeof(ns1__Alarm *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Alarm **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Alarm, sizeof(ns1__Alarm *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Alarm *)soap_instantiate_ns1__Alarm(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Alarm **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Alarm, sizeof(ns1__Alarm *), 1), SOAP_TYPE_ns1__Alarm, sizeof(ns1__Alarm), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PhoneFlags(struct soap *soap, ns1__PhoneFlags *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__PhoneFlags))
		soap_mark_PointerTons1__PhoneFlags(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__PhoneFlags(struct soap *soap, ns1__PhoneFlags *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PhoneFlags))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__PhoneFlags(struct soap *soap, ns1__PhoneFlags **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PhoneFlags(struct soap *soap, ns1__PhoneFlags *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__PhoneFlags);
	soap_out_PointerTons1__PhoneFlags(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PhoneFlags(struct soap *soap, const char *tag, int id, ns1__PhoneFlags *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__PhoneFlags);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__PhoneFlags, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__PhoneFlags, &pp), type);
}

SOAP_FMAC3 ns1__PhoneFlags ** SOAP_FMAC4 soap_get_PointerTons1__PhoneFlags(struct soap *soap, ns1__PhoneFlags **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PhoneFlags(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__PhoneFlags ** SOAP_FMAC4 soap_in_PointerTons1__PhoneFlags(struct soap *soap, const char *tag, ns1__PhoneFlags **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__PhoneFlags **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__PhoneFlags, sizeof(ns1__PhoneFlags *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__PhoneFlags **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__PhoneFlags, sizeof(ns1__PhoneFlags *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__PhoneFlags *)soap_instantiate_ns1__PhoneFlags(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__PhoneFlags **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__PhoneFlags, sizeof(ns1__PhoneFlags *), 1), SOAP_TYPE_ns1__PhoneFlags, sizeof(ns1__PhoneFlags), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccessControlList(struct soap *soap, ns1__AccessControlList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__AccessControlList))
		soap_mark_PointerTons1__AccessControlList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AccessControlList(struct soap *soap, ns1__AccessControlList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccessControlList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AccessControlList(struct soap *soap, ns1__AccessControlList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccessControlList(struct soap *soap, ns1__AccessControlList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AccessControlList);
	soap_out_PointerTons1__AccessControlList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccessControlList(struct soap *soap, const char *tag, int id, ns1__AccessControlList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AccessControlList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AccessControlList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AccessControlList, &pp), type);
}

SOAP_FMAC3 ns1__AccessControlList ** SOAP_FMAC4 soap_get_PointerTons1__AccessControlList(struct soap *soap, ns1__AccessControlList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccessControlList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AccessControlList ** SOAP_FMAC4 soap_in_PointerTons1__AccessControlList(struct soap *soap, const char *tag, ns1__AccessControlList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AccessControlList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessControlList, sizeof(ns1__AccessControlList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AccessControlList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AccessControlList, sizeof(ns1__AccessControlList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AccessControlList *)soap_instantiate_ns1__AccessControlList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AccessControlList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessControlList, sizeof(ns1__AccessControlList *), 1), SOAP_TYPE_ns1__AccessControlList, sizeof(ns1__AccessControlList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RecurrenceDateType(struct soap *soap, ns1__RecurrenceDateType *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__RecurrenceDateType))
		soap_mark_PointerTons1__RecurrenceDateType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__RecurrenceDateType(struct soap *soap, ns1__RecurrenceDateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RecurrenceDateType))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__RecurrenceDateType(struct soap *soap, ns1__RecurrenceDateType **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RecurrenceDateType(struct soap *soap, ns1__RecurrenceDateType *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__RecurrenceDateType);
	soap_out_PointerTons1__RecurrenceDateType(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RecurrenceDateType(struct soap *soap, const char *tag, int id, ns1__RecurrenceDateType *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__RecurrenceDateType);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__RecurrenceDateType, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__RecurrenceDateType, &pp), type);
}

SOAP_FMAC3 ns1__RecurrenceDateType ** SOAP_FMAC4 soap_get_PointerTons1__RecurrenceDateType(struct soap *soap, ns1__RecurrenceDateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RecurrenceDateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__RecurrenceDateType ** SOAP_FMAC4 soap_in_PointerTons1__RecurrenceDateType(struct soap *soap, const char *tag, ns1__RecurrenceDateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__RecurrenceDateType **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__RecurrenceDateType, sizeof(ns1__RecurrenceDateType *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__RecurrenceDateType **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__RecurrenceDateType, sizeof(ns1__RecurrenceDateType *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__RecurrenceDateType *)soap_instantiate_ns1__RecurrenceDateType(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__RecurrenceDateType **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__RecurrenceDateType, sizeof(ns1__RecurrenceDateType *), 1), SOAP_TYPE_ns1__RecurrenceDateType, sizeof(ns1__RecurrenceDateType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemOptions(struct soap *soap, ns1__ItemOptions *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ItemOptions))
		soap_mark_PointerTons1__ItemOptions(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ItemOptions(struct soap *soap, ns1__ItemOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ItemOptions))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ItemOptions(struct soap *soap, ns1__ItemOptions **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemOptions(struct soap *soap, ns1__ItemOptions *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ItemOptions);
	soap_out_PointerTons1__ItemOptions(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemOptions(struct soap *soap, const char *tag, int id, ns1__ItemOptions *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ItemOptions);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ItemOptions, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ItemOptions, &pp), type);
}

SOAP_FMAC3 ns1__ItemOptions ** SOAP_FMAC4 soap_get_PointerTons1__ItemOptions(struct soap *soap, ns1__ItemOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ItemOptions ** SOAP_FMAC4 soap_in_PointerTons1__ItemOptions(struct soap *soap, const char *tag, ns1__ItemOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ItemOptions **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemOptions, sizeof(ns1__ItemOptions *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ItemOptions **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ItemOptions, sizeof(ns1__ItemOptions *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ItemOptions *)soap_instantiate_ns1__ItemOptions(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ItemOptions **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemOptions, sizeof(ns1__ItemOptions *), 1), SOAP_TYPE_ns1__ItemOptions, sizeof(ns1__ItemOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AttachmentInfo(struct soap *soap, ns1__AttachmentInfo *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__AttachmentInfo))
		soap_mark_PointerTons1__AttachmentInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AttachmentInfo(struct soap *soap, ns1__AttachmentInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AttachmentInfo))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AttachmentInfo(struct soap *soap, ns1__AttachmentInfo **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AttachmentInfo(struct soap *soap, ns1__AttachmentInfo *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AttachmentInfo);
	soap_out_PointerTons1__AttachmentInfo(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AttachmentInfo(struct soap *soap, const char *tag, int id, ns1__AttachmentInfo *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AttachmentInfo);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AttachmentInfo, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AttachmentInfo, &pp), type);
}

SOAP_FMAC3 ns1__AttachmentInfo ** SOAP_FMAC4 soap_get_PointerTons1__AttachmentInfo(struct soap *soap, ns1__AttachmentInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AttachmentInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AttachmentInfo ** SOAP_FMAC4 soap_in_PointerTons1__AttachmentInfo(struct soap *soap, const char *tag, ns1__AttachmentInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AttachmentInfo **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AttachmentInfo, sizeof(ns1__AttachmentInfo *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AttachmentInfo **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AttachmentInfo, sizeof(ns1__AttachmentInfo *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AttachmentInfo *)soap_instantiate_ns1__AttachmentInfo(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AttachmentInfo **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AttachmentInfo, sizeof(ns1__AttachmentInfo *), 1), SOAP_TYPE_ns1__AttachmentInfo, sizeof(ns1__AttachmentInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MessageBody(struct soap *soap, ns1__MessageBody *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__MessageBody))
		soap_mark_PointerTons1__MessageBody(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__MessageBody(struct soap *soap, ns1__MessageBody *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MessageBody))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__MessageBody(struct soap *soap, ns1__MessageBody **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MessageBody(struct soap *soap, ns1__MessageBody *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__MessageBody);
	soap_out_PointerTons1__MessageBody(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MessageBody(struct soap *soap, const char *tag, int id, ns1__MessageBody *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__MessageBody);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__MessageBody, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__MessageBody, &pp), type);
}

SOAP_FMAC3 ns1__MessageBody ** SOAP_FMAC4 soap_get_PointerTons1__MessageBody(struct soap *soap, ns1__MessageBody **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MessageBody(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MessageBody ** SOAP_FMAC4 soap_in_PointerTons1__MessageBody(struct soap *soap, const char *tag, ns1__MessageBody **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__MessageBody **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__MessageBody, sizeof(ns1__MessageBody *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__MessageBody **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__MessageBody, sizeof(ns1__MessageBody *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__MessageBody *)soap_instantiate_ns1__MessageBody(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__MessageBody **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__MessageBody, sizeof(ns1__MessageBody *), 1), SOAP_TYPE_ns1__MessageBody, sizeof(ns1__MessageBody), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PersonalInfo(struct soap *soap, ns1__PersonalInfo *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__PersonalInfo))
		soap_mark_PointerTons1__PersonalInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__PersonalInfo(struct soap *soap, ns1__PersonalInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PersonalInfo))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__PersonalInfo(struct soap *soap, ns1__PersonalInfo **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PersonalInfo(struct soap *soap, ns1__PersonalInfo *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__PersonalInfo);
	soap_out_PointerTons1__PersonalInfo(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PersonalInfo(struct soap *soap, const char *tag, int id, ns1__PersonalInfo *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__PersonalInfo);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__PersonalInfo, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__PersonalInfo, &pp), type);
}

SOAP_FMAC3 ns1__PersonalInfo ** SOAP_FMAC4 soap_get_PointerTons1__PersonalInfo(struct soap *soap, ns1__PersonalInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PersonalInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__PersonalInfo ** SOAP_FMAC4 soap_in_PointerTons1__PersonalInfo(struct soap *soap, const char *tag, ns1__PersonalInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__PersonalInfo **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__PersonalInfo, sizeof(ns1__PersonalInfo *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__PersonalInfo **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__PersonalInfo, sizeof(ns1__PersonalInfo *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__PersonalInfo *)soap_instantiate_ns1__PersonalInfo(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__PersonalInfo **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__PersonalInfo, sizeof(ns1__PersonalInfo *), 1), SOAP_TYPE_ns1__PersonalInfo, sizeof(ns1__PersonalInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OfficeInfo(struct soap *soap, ns1__OfficeInfo *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__OfficeInfo))
		soap_mark_PointerTons1__OfficeInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__OfficeInfo(struct soap *soap, ns1__OfficeInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OfficeInfo))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__OfficeInfo(struct soap *soap, ns1__OfficeInfo **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OfficeInfo(struct soap *soap, ns1__OfficeInfo *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__OfficeInfo);
	soap_out_PointerTons1__OfficeInfo(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OfficeInfo(struct soap *soap, const char *tag, int id, ns1__OfficeInfo *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__OfficeInfo);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__OfficeInfo, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__OfficeInfo, &pp), type);
}

SOAP_FMAC3 ns1__OfficeInfo ** SOAP_FMAC4 soap_get_PointerTons1__OfficeInfo(struct soap *soap, ns1__OfficeInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OfficeInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__OfficeInfo ** SOAP_FMAC4 soap_in_PointerTons1__OfficeInfo(struct soap *soap, const char *tag, ns1__OfficeInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__OfficeInfo **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__OfficeInfo, sizeof(ns1__OfficeInfo *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__OfficeInfo **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__OfficeInfo, sizeof(ns1__OfficeInfo *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__OfficeInfo *)soap_instantiate_ns1__OfficeInfo(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__OfficeInfo **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__OfficeInfo, sizeof(ns1__OfficeInfo *), 1), SOAP_TYPE_ns1__OfficeInfo, sizeof(ns1__OfficeInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PostalAddressList(struct soap *soap, ns1__PostalAddressList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__PostalAddressList))
		soap_mark_PointerTons1__PostalAddressList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__PostalAddressList(struct soap *soap, ns1__PostalAddressList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PostalAddressList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__PostalAddressList(struct soap *soap, ns1__PostalAddressList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PostalAddressList(struct soap *soap, ns1__PostalAddressList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__PostalAddressList);
	soap_out_PointerTons1__PostalAddressList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PostalAddressList(struct soap *soap, const char *tag, int id, ns1__PostalAddressList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__PostalAddressList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__PostalAddressList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__PostalAddressList, &pp), type);
}

SOAP_FMAC3 ns1__PostalAddressList ** SOAP_FMAC4 soap_get_PointerTons1__PostalAddressList(struct soap *soap, ns1__PostalAddressList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PostalAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__PostalAddressList ** SOAP_FMAC4 soap_in_PointerTons1__PostalAddressList(struct soap *soap, const char *tag, ns1__PostalAddressList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__PostalAddressList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__PostalAddressList, sizeof(ns1__PostalAddressList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__PostalAddressList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__PostalAddressList, sizeof(ns1__PostalAddressList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__PostalAddressList *)soap_instantiate_ns1__PostalAddressList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__PostalAddressList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__PostalAddressList, sizeof(ns1__PostalAddressList *), 1), SOAP_TYPE_ns1__PostalAddressList, sizeof(ns1__PostalAddressList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ImAddressList(struct soap *soap, ns1__ImAddressList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ImAddressList))
		soap_mark_PointerTons1__ImAddressList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ImAddressList(struct soap *soap, ns1__ImAddressList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ImAddressList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ImAddressList(struct soap *soap, ns1__ImAddressList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ImAddressList(struct soap *soap, ns1__ImAddressList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ImAddressList);
	soap_out_PointerTons1__ImAddressList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ImAddressList(struct soap *soap, const char *tag, int id, ns1__ImAddressList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ImAddressList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ImAddressList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ImAddressList, &pp), type);
}

SOAP_FMAC3 ns1__ImAddressList ** SOAP_FMAC4 soap_get_PointerTons1__ImAddressList(struct soap *soap, ns1__ImAddressList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ImAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ImAddressList ** SOAP_FMAC4 soap_in_PointerTons1__ImAddressList(struct soap *soap, const char *tag, ns1__ImAddressList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ImAddressList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ImAddressList, sizeof(ns1__ImAddressList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ImAddressList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ImAddressList, sizeof(ns1__ImAddressList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ImAddressList *)soap_instantiate_ns1__ImAddressList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ImAddressList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ImAddressList, sizeof(ns1__ImAddressList *), 1), SOAP_TYPE_ns1__ImAddressList, sizeof(ns1__ImAddressList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EmailAddressList(struct soap *soap, ns1__EmailAddressList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__EmailAddressList))
		soap_mark_PointerTons1__EmailAddressList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__EmailAddressList(struct soap *soap, ns1__EmailAddressList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EmailAddressList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__EmailAddressList(struct soap *soap, ns1__EmailAddressList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EmailAddressList(struct soap *soap, ns1__EmailAddressList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__EmailAddressList);
	soap_out_PointerTons1__EmailAddressList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EmailAddressList(struct soap *soap, const char *tag, int id, ns1__EmailAddressList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__EmailAddressList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__EmailAddressList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__EmailAddressList, &pp), type);
}

SOAP_FMAC3 ns1__EmailAddressList ** SOAP_FMAC4 soap_get_PointerTons1__EmailAddressList(struct soap *soap, ns1__EmailAddressList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EmailAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__EmailAddressList ** SOAP_FMAC4 soap_in_PointerTons1__EmailAddressList(struct soap *soap, const char *tag, ns1__EmailAddressList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__EmailAddressList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__EmailAddressList, sizeof(ns1__EmailAddressList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__EmailAddressList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__EmailAddressList, sizeof(ns1__EmailAddressList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__EmailAddressList *)soap_instantiate_ns1__EmailAddressList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__EmailAddressList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__EmailAddressList, sizeof(ns1__EmailAddressList *), 1), SOAP_TYPE_ns1__EmailAddressList, sizeof(ns1__EmailAddressList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FullName(struct soap *soap, ns1__FullName *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FullName))
		soap_mark_PointerTons1__FullName(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FullName(struct soap *soap, ns1__FullName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FullName))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FullName(struct soap *soap, ns1__FullName **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FullName(struct soap *soap, ns1__FullName *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FullName);
	soap_out_PointerTons1__FullName(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FullName(struct soap *soap, const char *tag, int id, ns1__FullName *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FullName);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FullName, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FullName, &pp), type);
}

SOAP_FMAC3 ns1__FullName ** SOAP_FMAC4 soap_get_PointerTons1__FullName(struct soap *soap, ns1__FullName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FullName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FullName ** SOAP_FMAC4 soap_in_PointerTons1__FullName(struct soap *soap, const char *tag, ns1__FullName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FullName **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FullName, sizeof(ns1__FullName *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FullName **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FullName, sizeof(ns1__FullName *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FullName *)soap_instantiate_ns1__FullName(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FullName **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FullName, sizeof(ns1__FullName *), 1), SOAP_TYPE_ns1__FullName, sizeof(ns1__FullName), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UUID(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__UUID))
		soap_mark_PointerTons1__UUID(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__UUID(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UUID))
		soap_mark_ns1__UUID(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__UUID(struct soap *soap, std::string **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UUID(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__UUID);
	soap_out_PointerTons1__UUID(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UUID(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__UUID);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__UUID, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_ns1__UUID(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_ns1__UUID(soap, tag, i, *a, type);
	}
	return soap_out_ns1__UUID(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__UUID, &pp), *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__UUID(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UUID(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__UUID(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	std::string *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (std::string **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__UUID, sizeof(std::string *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_ns1__UUID(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_ns1__UUID(soap, tag, NULL, type)))
		{	a = (std::string **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTons1__UUID, sizeof(std::string *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__UUID, sizeof(std::string *), 1), SOAP_TYPE_ns1__UUID, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FolderACL(struct soap *soap, ns1__FolderACL *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FolderACL))
		soap_mark_PointerTons1__FolderACL(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FolderACL(struct soap *soap, ns1__FolderACL *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FolderACL))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FolderACL(struct soap *soap, ns1__FolderACL **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FolderACL(struct soap *soap, ns1__FolderACL *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FolderACL);
	soap_out_PointerTons1__FolderACL(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FolderACL(struct soap *soap, const char *tag, int id, ns1__FolderACL *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FolderACL);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FolderACL, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FolderACL, &pp), type);
}

SOAP_FMAC3 ns1__FolderACL ** SOAP_FMAC4 soap_get_PointerTons1__FolderACL(struct soap *soap, ns1__FolderACL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FolderACL(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FolderACL ** SOAP_FMAC4 soap_in_PointerTons1__FolderACL(struct soap *soap, const char *tag, ns1__FolderACL **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FolderACL **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FolderACL, sizeof(ns1__FolderACL *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FolderACL **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FolderACL, sizeof(ns1__FolderACL *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FolderACL *)soap_instantiate_ns1__FolderACL(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FolderACL **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FolderACL, sizeof(ns1__FolderACL *), 1), SOAP_TYPE_ns1__FolderACL, sizeof(ns1__FolderACL), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Query(struct soap *soap, ns1__Query *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Query))
		soap_mark_PointerTons1__Query(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Query(struct soap *soap, ns1__Query *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Query))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Query(struct soap *soap, ns1__Query **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Query(struct soap *soap, ns1__Query *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Query);
	soap_out_PointerTons1__Query(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Query(struct soap *soap, const char *tag, int id, ns1__Query *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Query);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Query, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Query, &pp), type);
}

SOAP_FMAC3 ns1__Query ** SOAP_FMAC4 soap_get_PointerTons1__Query(struct soap *soap, ns1__Query **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Query(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Query ** SOAP_FMAC4 soap_in_PointerTons1__Query(struct soap *soap, const char *tag, ns1__Query **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Query **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Query, sizeof(ns1__Query *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Query **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Query, sizeof(ns1__Query *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Query *)soap_instantiate_ns1__Query(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Query **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Query, sizeof(ns1__Query *), 1), SOAP_TYPE_ns1__Query, sizeof(ns1__Query), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FreeBusyBlockList(struct soap *soap, ns1__FreeBusyBlockList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FreeBusyBlockList))
		soap_mark_PointerTons1__FreeBusyBlockList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FreeBusyBlockList(struct soap *soap, ns1__FreeBusyBlockList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FreeBusyBlockList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FreeBusyBlockList(struct soap *soap, ns1__FreeBusyBlockList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FreeBusyBlockList(struct soap *soap, ns1__FreeBusyBlockList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FreeBusyBlockList);
	soap_out_PointerTons1__FreeBusyBlockList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FreeBusyBlockList(struct soap *soap, const char *tag, int id, ns1__FreeBusyBlockList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FreeBusyBlockList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FreeBusyBlockList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FreeBusyBlockList, &pp), type);
}

SOAP_FMAC3 ns1__FreeBusyBlockList ** SOAP_FMAC4 soap_get_PointerTons1__FreeBusyBlockList(struct soap *soap, ns1__FreeBusyBlockList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FreeBusyBlockList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FreeBusyBlockList ** SOAP_FMAC4 soap_in_PointerTons1__FreeBusyBlockList(struct soap *soap, const char *tag, ns1__FreeBusyBlockList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FreeBusyBlockList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyBlockList, sizeof(ns1__FreeBusyBlockList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FreeBusyBlockList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FreeBusyBlockList, sizeof(ns1__FreeBusyBlockList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FreeBusyBlockList *)soap_instantiate_ns1__FreeBusyBlockList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FreeBusyBlockList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyBlockList, sizeof(ns1__FreeBusyBlockList *), 1), SOAP_TYPE_ns1__FreeBusyBlockList, sizeof(ns1__FreeBusyBlockList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemClass(struct soap *soap, enum ns1__ItemClass *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ItemClass))
		soap_mark_PointerTons1__ItemClass(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ItemClass(struct soap *soap, enum ns1__ItemClass *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__ItemClass);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ItemClass(struct soap *soap, enum ns1__ItemClass **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemClass(struct soap *soap, enum ns1__ItemClass *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ItemClass);
	soap_out_PointerTons1__ItemClass(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemClass(struct soap *soap, const char *tag, int id, enum ns1__ItemClass *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ItemClass);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ItemClass, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_ns1__ItemClass(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_ns1__ItemClass(soap, tag, i, *a, type);
	}
	return soap_out_ns1__ItemClass(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ItemClass, &pp), *a, type);
}

SOAP_FMAC3 enum ns1__ItemClass ** SOAP_FMAC4 soap_get_PointerTons1__ItemClass(struct soap *soap, enum ns1__ItemClass **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemClass(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ns1__ItemClass ** SOAP_FMAC4 soap_in_PointerTons1__ItemClass(struct soap *soap, const char *tag, enum ns1__ItemClass **a, const char *type)
{
	enum ns1__ItemClass *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (enum ns1__ItemClass **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemClass, sizeof(enum ns1__ItemClass *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_ns1__ItemClass(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_ns1__ItemClass(soap, tag, NULL, type)))
		{	a = (enum ns1__ItemClass **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTons1__ItemClass, sizeof(enum ns1__ItemClass *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (enum ns1__ItemClass **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemClass, sizeof(enum ns1__ItemClass *), 1), SOAP_TYPE_ns1__ItemClass, sizeof(enum ns1__ItemClass), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemSource(struct soap *soap, enum ns1__ItemSource *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ItemSource))
		soap_mark_PointerTons1__ItemSource(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ItemSource(struct soap *soap, enum ns1__ItemSource *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__ItemSource);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ItemSource(struct soap *soap, enum ns1__ItemSource **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemSource(struct soap *soap, enum ns1__ItemSource *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ItemSource);
	soap_out_PointerTons1__ItemSource(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemSource(struct soap *soap, const char *tag, int id, enum ns1__ItemSource *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ItemSource);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ItemSource, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_ns1__ItemSource(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_ns1__ItemSource(soap, tag, i, *a, type);
	}
	return soap_out_ns1__ItemSource(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ItemSource, &pp), *a, type);
}

SOAP_FMAC3 enum ns1__ItemSource ** SOAP_FMAC4 soap_get_PointerTons1__ItemSource(struct soap *soap, enum ns1__ItemSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemSource(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ns1__ItemSource ** SOAP_FMAC4 soap_in_PointerTons1__ItemSource(struct soap *soap, const char *tag, enum ns1__ItemSource **a, const char *type)
{
	enum ns1__ItemSource *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (enum ns1__ItemSource **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemSource, sizeof(enum ns1__ItemSource *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_ns1__ItemSource(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_ns1__ItemSource(soap, tag, NULL, type)))
		{	a = (enum ns1__ItemSource **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTons1__ItemSource, sizeof(enum ns1__ItemSource *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (enum ns1__ItemSource **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemSource, sizeof(enum ns1__ItemSource *), 1), SOAP_TYPE_ns1__ItemSource, sizeof(enum ns1__ItemSource), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemStatus(struct soap *soap, ns1__ItemStatus *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ItemStatus))
		soap_mark_PointerTons1__ItemStatus(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ItemStatus(struct soap *soap, ns1__ItemStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ItemStatus))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ItemStatus(struct soap *soap, ns1__ItemStatus **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemStatus(struct soap *soap, ns1__ItemStatus *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ItemStatus);
	soap_out_PointerTons1__ItemStatus(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemStatus(struct soap *soap, const char *tag, int id, ns1__ItemStatus *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ItemStatus);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ItemStatus, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ItemStatus, &pp), type);
}

SOAP_FMAC3 ns1__ItemStatus ** SOAP_FMAC4 soap_get_PointerTons1__ItemStatus(struct soap *soap, ns1__ItemStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ItemStatus ** SOAP_FMAC4 soap_in_PointerTons1__ItemStatus(struct soap *soap, const char *tag, ns1__ItemStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ItemStatus **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemStatus, sizeof(ns1__ItemStatus *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ItemStatus **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ItemStatus, sizeof(ns1__ItemStatus *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ItemStatus *)soap_instantiate_ns1__ItemStatus(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ItemStatus **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemStatus, sizeof(ns1__ItemStatus *), 1), SOAP_TYPE_ns1__ItemStatus, sizeof(ns1__ItemStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RecipientStatus(struct soap *soap, ns1__RecipientStatus *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__RecipientStatus))
		soap_mark_PointerTons1__RecipientStatus(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__RecipientStatus(struct soap *soap, ns1__RecipientStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RecipientStatus))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__RecipientStatus(struct soap *soap, ns1__RecipientStatus **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RecipientStatus(struct soap *soap, ns1__RecipientStatus *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__RecipientStatus);
	soap_out_PointerTons1__RecipientStatus(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RecipientStatus(struct soap *soap, const char *tag, int id, ns1__RecipientStatus *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__RecipientStatus);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__RecipientStatus, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__RecipientStatus, &pp), type);
}

SOAP_FMAC3 ns1__RecipientStatus ** SOAP_FMAC4 soap_get_PointerTons1__RecipientStatus(struct soap *soap, ns1__RecipientStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RecipientStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__RecipientStatus ** SOAP_FMAC4 soap_in_PointerTons1__RecipientStatus(struct soap *soap, const char *tag, ns1__RecipientStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__RecipientStatus **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__RecipientStatus, sizeof(ns1__RecipientStatus *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__RecipientStatus **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__RecipientStatus, sizeof(ns1__RecipientStatus *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__RecipientStatus *)soap_instantiate_ns1__RecipientStatus(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__RecipientStatus **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__RecipientStatus, sizeof(ns1__RecipientStatus *), 1), SOAP_TYPE_ns1__RecipientStatus, sizeof(ns1__RecipientStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SharedFolderNotification(struct soap *soap, ns1__SharedFolderNotification *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__SharedFolderNotification))
		soap_mark_PointerTons1__SharedFolderNotification(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__SharedFolderNotification(struct soap *soap, ns1__SharedFolderNotification *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SharedFolderNotification))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__SharedFolderNotification(struct soap *soap, ns1__SharedFolderNotification **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SharedFolderNotification(struct soap *soap, ns1__SharedFolderNotification *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__SharedFolderNotification);
	soap_out_PointerTons1__SharedFolderNotification(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SharedFolderNotification(struct soap *soap, const char *tag, int id, ns1__SharedFolderNotification *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__SharedFolderNotification);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__SharedFolderNotification, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__SharedFolderNotification, &pp), type);
}

SOAP_FMAC3 ns1__SharedFolderNotification ** SOAP_FMAC4 soap_get_PointerTons1__SharedFolderNotification(struct soap *soap, ns1__SharedFolderNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SharedFolderNotification(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SharedFolderNotification ** SOAP_FMAC4 soap_in_PointerTons1__SharedFolderNotification(struct soap *soap, const char *tag, ns1__SharedFolderNotification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__SharedFolderNotification **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__SharedFolderNotification, sizeof(ns1__SharedFolderNotification *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__SharedFolderNotification **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__SharedFolderNotification, sizeof(ns1__SharedFolderNotification *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__SharedFolderNotification *)soap_instantiate_ns1__SharedFolderNotification(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__SharedFolderNotification **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__SharedFolderNotification, sizeof(ns1__SharedFolderNotification *), 1), SOAP_TYPE_ns1__SharedFolderNotification, sizeof(ns1__SharedFolderNotification), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToint))
		soap_mark_PointerToint(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerToint(struct soap *soap, int **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerToint);
	soap_out_PointerToint(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToint);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_int, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_int(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_int(soap, tag, i, *a, type);
	}
	return soap_out_int(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_int, &pp), *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	int *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (int **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToint, sizeof(int *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_int(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_int(soap, tag, NULL, type)))
		{	a = (int **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToint, sizeof(int *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToint, sizeof(int *), 1), SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, std::vector<ns1__FilterElement * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FilterElement))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, std::vector<ns1__FilterElement * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FilterElement))
		soap_mark_std__vectorTemplateOfPointerTons1__FilterElement(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, std::vector<ns1__FilterElement * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, std::vector<ns1__FilterElement * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FilterElement);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, const char *tag, int id, std::vector<ns1__FilterElement * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FilterElement);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FilterElement, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__FilterElement(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__FilterElement(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__FilterElement(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FilterElement, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__FilterElement * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, std::vector<ns1__FilterElement * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__FilterElement * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, const char *tag, std::vector<ns1__FilterElement * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__FilterElement * >**)soap_malloc(soap, sizeof(std::vector<ns1__FilterElement * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__FilterElement(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CategoryRefList(struct soap *soap, ns1__CategoryRefList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__CategoryRefList))
		soap_mark_PointerTons1__CategoryRefList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__CategoryRefList(struct soap *soap, ns1__CategoryRefList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CategoryRefList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__CategoryRefList(struct soap *soap, ns1__CategoryRefList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CategoryRefList(struct soap *soap, ns1__CategoryRefList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__CategoryRefList);
	soap_out_PointerTons1__CategoryRefList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CategoryRefList(struct soap *soap, const char *tag, int id, ns1__CategoryRefList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__CategoryRefList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__CategoryRefList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__CategoryRefList, &pp), type);
}

SOAP_FMAC3 ns1__CategoryRefList ** SOAP_FMAC4 soap_get_PointerTons1__CategoryRefList(struct soap *soap, ns1__CategoryRefList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CategoryRefList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CategoryRefList ** SOAP_FMAC4 soap_in_PointerTons1__CategoryRefList(struct soap *soap, const char *tag, ns1__CategoryRefList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__CategoryRefList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__CategoryRefList, sizeof(ns1__CategoryRefList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__CategoryRefList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__CategoryRefList, sizeof(ns1__CategoryRefList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__CategoryRefList *)soap_instantiate_ns1__CategoryRefList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__CategoryRefList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__CategoryRefList, sizeof(ns1__CategoryRefList *), 1), SOAP_TYPE_ns1__CategoryRefList, sizeof(ns1__CategoryRefList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, std::vector<ns1__ContainerRef * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, std::vector<ns1__ContainerRef * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ContainerRef))
		soap_mark_std__vectorTemplateOfPointerTons1__ContainerRef(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, std::vector<ns1__ContainerRef * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, std::vector<ns1__ContainerRef * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, const char *tag, int id, std::vector<ns1__ContainerRef * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ContainerRef, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__ContainerRef(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__ContainerRef(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__ContainerRef(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ContainerRef, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__ContainerRef * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, std::vector<ns1__ContainerRef * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__ContainerRef * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, const char *tag, std::vector<ns1__ContainerRef * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__ContainerRef * >**)soap_malloc(soap, sizeof(std::vector<ns1__ContainerRef * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__ContainerRef(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ContainerRef(struct soap *soap, ns1__ContainerRef *const*a)
{
		soap_mark_PointerTons1__ContainerRef(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ContainerRef(struct soap *soap, ns1__ContainerRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ContainerRef))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ContainerRef(struct soap *soap, ns1__ContainerRef **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ContainerRef(struct soap *soap, ns1__ContainerRef *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ContainerRef);
	soap_out_PointerTons1__ContainerRef(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ContainerRef(struct soap *soap, const char *tag, int id, ns1__ContainerRef *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ContainerRef);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ContainerRef, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ContainerRef, &pp), type);
}

SOAP_FMAC3 ns1__ContainerRef ** SOAP_FMAC4 soap_get_PointerTons1__ContainerRef(struct soap *soap, ns1__ContainerRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ContainerRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ContainerRef ** SOAP_FMAC4 soap_in_PointerTons1__ContainerRef(struct soap *soap, const char *tag, ns1__ContainerRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ContainerRef **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ContainerRef, sizeof(ns1__ContainerRef *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ContainerRef **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ContainerRef, sizeof(ns1__ContainerRef *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ContainerRef *)soap_instantiate_ns1__ContainerRef(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ContainerRef **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ContainerRef, sizeof(ns1__ContainerRef *), 1), SOAP_TYPE_ns1__ContainerRef, sizeof(ns1__ContainerRef), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedLong(struct soap *soap, unsigned long *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTounsignedLong))
		soap_mark_PointerTounsignedLong(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTounsignedLong(struct soap *soap, unsigned long *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTounsignedLong(struct soap *soap, unsigned long **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedLong(struct soap *soap, unsigned long *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTounsignedLong);
	soap_out_PointerTounsignedLong(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedLong(struct soap *soap, const char *tag, int id, unsigned long *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTounsignedLong);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_unsignedLong, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_unsignedLong(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_unsignedLong(soap, tag, i, *a, type);
	}
	return soap_out_unsignedLong(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_unsignedLong, &pp), *a, type);
}

SOAP_FMAC3 unsigned long ** SOAP_FMAC4 soap_get_PointerTounsignedLong(struct soap *soap, unsigned long **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned long ** SOAP_FMAC4 soap_in_PointerTounsignedLong(struct soap *soap, const char *tag, unsigned long **a, const char *type)
{
	unsigned long *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (unsigned long **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTounsignedLong, sizeof(unsigned long *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_unsignedLong(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_unsignedLong(soap, tag, NULL, type)))
		{	a = (unsigned long **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTounsignedLong, sizeof(unsigned long *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (unsigned long **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTounsignedLong, sizeof(unsigned long *), 1), SOAP_TYPE_unsignedLong, sizeof(unsigned long), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CategoryType(struct soap *soap, enum ns1__CategoryType *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__CategoryType))
		soap_mark_PointerTons1__CategoryType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__CategoryType(struct soap *soap, enum ns1__CategoryType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__CategoryType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__CategoryType(struct soap *soap, enum ns1__CategoryType **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CategoryType(struct soap *soap, enum ns1__CategoryType *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__CategoryType);
	soap_out_PointerTons1__CategoryType(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CategoryType(struct soap *soap, const char *tag, int id, enum ns1__CategoryType *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__CategoryType);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__CategoryType, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_ns1__CategoryType(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_ns1__CategoryType(soap, tag, i, *a, type);
	}
	return soap_out_ns1__CategoryType(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__CategoryType, &pp), *a, type);
}

SOAP_FMAC3 enum ns1__CategoryType ** SOAP_FMAC4 soap_get_PointerTons1__CategoryType(struct soap *soap, enum ns1__CategoryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CategoryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ns1__CategoryType ** SOAP_FMAC4 soap_in_PointerTons1__CategoryType(struct soap *soap, const char *tag, enum ns1__CategoryType **a, const char *type)
{
	enum ns1__CategoryType *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (enum ns1__CategoryType **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__CategoryType, sizeof(enum ns1__CategoryType *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_ns1__CategoryType(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_ns1__CategoryType(soap, tag, NULL, type)))
		{	a = (enum ns1__CategoryType **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTons1__CategoryType, sizeof(enum ns1__CategoryType *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (enum ns1__CategoryType **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__CategoryType, sizeof(enum ns1__CategoryType *), 1), SOAP_TYPE_ns1__CategoryType, sizeof(enum ns1__CategoryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccessMiscRight(struct soap *soap, ns1__AccessMiscRight *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__AccessMiscRight))
		soap_mark_PointerTons1__AccessMiscRight(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AccessMiscRight(struct soap *soap, ns1__AccessMiscRight *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccessMiscRight))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AccessMiscRight(struct soap *soap, ns1__AccessMiscRight **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccessMiscRight(struct soap *soap, ns1__AccessMiscRight *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AccessMiscRight);
	soap_out_PointerTons1__AccessMiscRight(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccessMiscRight(struct soap *soap, const char *tag, int id, ns1__AccessMiscRight *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AccessMiscRight);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AccessMiscRight, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AccessMiscRight, &pp), type);
}

SOAP_FMAC3 ns1__AccessMiscRight ** SOAP_FMAC4 soap_get_PointerTons1__AccessMiscRight(struct soap *soap, ns1__AccessMiscRight **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccessMiscRight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AccessMiscRight ** SOAP_FMAC4 soap_in_PointerTons1__AccessMiscRight(struct soap *soap, const char *tag, ns1__AccessMiscRight **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AccessMiscRight **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessMiscRight, sizeof(ns1__AccessMiscRight *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AccessMiscRight **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AccessMiscRight, sizeof(ns1__AccessMiscRight *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AccessMiscRight *)soap_instantiate_ns1__AccessMiscRight(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AccessMiscRight **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessMiscRight, sizeof(ns1__AccessMiscRight *), 1), SOAP_TYPE_ns1__AccessMiscRight, sizeof(ns1__AccessMiscRight), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccessRight(struct soap *soap, ns1__AccessRight *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__AccessRight))
		soap_mark_PointerTons1__AccessRight(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AccessRight(struct soap *soap, ns1__AccessRight *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccessRight))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AccessRight(struct soap *soap, ns1__AccessRight **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccessRight(struct soap *soap, ns1__AccessRight *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AccessRight);
	soap_out_PointerTons1__AccessRight(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccessRight(struct soap *soap, const char *tag, int id, ns1__AccessRight *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AccessRight);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AccessRight, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AccessRight, &pp), type);
}

SOAP_FMAC3 ns1__AccessRight ** SOAP_FMAC4 soap_get_PointerTons1__AccessRight(struct soap *soap, ns1__AccessRight **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccessRight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AccessRight ** SOAP_FMAC4 soap_in_PointerTons1__AccessRight(struct soap *soap, const char *tag, ns1__AccessRight **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AccessRight **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessRight, sizeof(ns1__AccessRight *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AccessRight **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AccessRight, sizeof(ns1__AccessRight *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AccessRight *)soap_instantiate_ns1__AccessRight(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AccessRight **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessRight, sizeof(ns1__AccessRight *), 1), SOAP_TYPE_ns1__AccessRight, sizeof(ns1__AccessRight), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Rights(struct soap *soap, ns1__Rights *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Rights))
		soap_mark_PointerTons1__Rights(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Rights(struct soap *soap, ns1__Rights *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Rights))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Rights(struct soap *soap, ns1__Rights **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Rights(struct soap *soap, ns1__Rights *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Rights);
	soap_out_PointerTons1__Rights(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Rights(struct soap *soap, const char *tag, int id, ns1__Rights *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Rights);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Rights, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Rights, &pp), type);
}

SOAP_FMAC3 ns1__Rights ** SOAP_FMAC4 soap_get_PointerTons1__Rights(struct soap *soap, ns1__Rights **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Rights(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Rights ** SOAP_FMAC4 soap_in_PointerTons1__Rights(struct soap *soap, const char *tag, ns1__Rights **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Rights **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Rights, sizeof(ns1__Rights *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Rights **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Rights, sizeof(ns1__Rights *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Rights *)soap_instantiate_ns1__Rights(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Rights **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Rights, sizeof(ns1__Rights *), 1), SOAP_TYPE_ns1__Rights, sizeof(ns1__Rights), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FreeBusyUserList(struct soap *soap, ns1__FreeBusyUserList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FreeBusyUserList))
		soap_mark_PointerTons1__FreeBusyUserList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FreeBusyUserList(struct soap *soap, ns1__FreeBusyUserList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FreeBusyUserList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FreeBusyUserList(struct soap *soap, ns1__FreeBusyUserList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FreeBusyUserList(struct soap *soap, ns1__FreeBusyUserList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FreeBusyUserList);
	soap_out_PointerTons1__FreeBusyUserList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FreeBusyUserList(struct soap *soap, const char *tag, int id, ns1__FreeBusyUserList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FreeBusyUserList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FreeBusyUserList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FreeBusyUserList, &pp), type);
}

SOAP_FMAC3 ns1__FreeBusyUserList ** SOAP_FMAC4 soap_get_PointerTons1__FreeBusyUserList(struct soap *soap, ns1__FreeBusyUserList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FreeBusyUserList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FreeBusyUserList ** SOAP_FMAC4 soap_in_PointerTons1__FreeBusyUserList(struct soap *soap, const char *tag, ns1__FreeBusyUserList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FreeBusyUserList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyUserList, sizeof(ns1__FreeBusyUserList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FreeBusyUserList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FreeBusyUserList, sizeof(ns1__FreeBusyUserList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FreeBusyUserList *)soap_instantiate_ns1__FreeBusyUserList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FreeBusyUserList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyUserList, sizeof(ns1__FreeBusyUserList *), 1), SOAP_TYPE_ns1__FreeBusyUserList, sizeof(ns1__FreeBusyUserList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemList(struct soap *soap, ns1__ItemList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ItemList))
		soap_mark_PointerTons1__ItemList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ItemList(struct soap *soap, ns1__ItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ItemList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ItemList(struct soap *soap, ns1__ItemList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemList(struct soap *soap, ns1__ItemList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ItemList);
	soap_out_PointerTons1__ItemList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemList(struct soap *soap, const char *tag, int id, ns1__ItemList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ItemList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ItemList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ItemList, &pp), type);
}

SOAP_FMAC3 ns1__ItemList ** SOAP_FMAC4 soap_get_PointerTons1__ItemList(struct soap *soap, ns1__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ItemList ** SOAP_FMAC4 soap_in_PointerTons1__ItemList(struct soap *soap, const char *tag, ns1__ItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ItemList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemList, sizeof(ns1__ItemList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ItemList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ItemList, sizeof(ns1__ItemList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ItemList *)soap_instantiate_ns1__ItemList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ItemList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemList, sizeof(ns1__ItemList *), 1), SOAP_TYPE_ns1__ItemList, sizeof(ns1__ItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SettingsList(struct soap *soap, ns1__SettingsList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__SettingsList))
		soap_mark_PointerTons1__SettingsList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__SettingsList(struct soap *soap, ns1__SettingsList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SettingsList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__SettingsList(struct soap *soap, ns1__SettingsList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SettingsList(struct soap *soap, ns1__SettingsList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__SettingsList);
	soap_out_PointerTons1__SettingsList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SettingsList(struct soap *soap, const char *tag, int id, ns1__SettingsList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__SettingsList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__SettingsList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__SettingsList, &pp), type);
}

SOAP_FMAC3 ns1__SettingsList ** SOAP_FMAC4 soap_get_PointerTons1__SettingsList(struct soap *soap, ns1__SettingsList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SettingsList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SettingsList ** SOAP_FMAC4 soap_in_PointerTons1__SettingsList(struct soap *soap, const char *tag, ns1__SettingsList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__SettingsList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__SettingsList, sizeof(ns1__SettingsList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__SettingsList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__SettingsList, sizeof(ns1__SettingsList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__SettingsList *)soap_instantiate_ns1__SettingsList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__SettingsList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__SettingsList, sizeof(ns1__SettingsList *), 1), SOAP_TYPE_ns1__SettingsList, sizeof(ns1__SettingsList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccessRightChanges(struct soap *soap, ns1__AccessRightChanges *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__AccessRightChanges))
		soap_mark_PointerTons1__AccessRightChanges(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AccessRightChanges(struct soap *soap, ns1__AccessRightChanges *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccessRightChanges))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AccessRightChanges(struct soap *soap, ns1__AccessRightChanges **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccessRightChanges(struct soap *soap, ns1__AccessRightChanges *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AccessRightChanges);
	soap_out_PointerTons1__AccessRightChanges(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccessRightChanges(struct soap *soap, const char *tag, int id, ns1__AccessRightChanges *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AccessRightChanges);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AccessRightChanges, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AccessRightChanges, &pp), type);
}

SOAP_FMAC3 ns1__AccessRightChanges ** SOAP_FMAC4 soap_get_PointerTons1__AccessRightChanges(struct soap *soap, ns1__AccessRightChanges **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccessRightChanges(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AccessRightChanges ** SOAP_FMAC4 soap_in_PointerTons1__AccessRightChanges(struct soap *soap, const char *tag, ns1__AccessRightChanges **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AccessRightChanges **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessRightChanges, sizeof(ns1__AccessRightChanges *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AccessRightChanges **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AccessRightChanges, sizeof(ns1__AccessRightChanges *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AccessRightChanges *)soap_instantiate_ns1__AccessRightChanges(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AccessRightChanges **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessRightChanges, sizeof(ns1__AccessRightChanges *), 1), SOAP_TYPE_ns1__AccessRightChanges, sizeof(ns1__AccessRightChanges), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UserInfo(struct soap *soap, ns1__UserInfo *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__UserInfo))
		soap_mark_PointerTons1__UserInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__UserInfo(struct soap *soap, ns1__UserInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UserInfo))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__UserInfo(struct soap *soap, ns1__UserInfo **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UserInfo(struct soap *soap, ns1__UserInfo *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__UserInfo);
	soap_out_PointerTons1__UserInfo(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UserInfo(struct soap *soap, const char *tag, int id, ns1__UserInfo *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__UserInfo);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__UserInfo, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__UserInfo, &pp), type);
}

SOAP_FMAC3 ns1__UserInfo ** SOAP_FMAC4 soap_get_PointerTons1__UserInfo(struct soap *soap, ns1__UserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UserInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__UserInfo ** SOAP_FMAC4 soap_in_PointerTons1__UserInfo(struct soap *soap, const char *tag, ns1__UserInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__UserInfo **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__UserInfo, sizeof(ns1__UserInfo *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__UserInfo **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__UserInfo, sizeof(ns1__UserInfo *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__UserInfo *)soap_instantiate_ns1__UserInfo(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__UserInfo **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__UserInfo, sizeof(ns1__UserInfo *), 1), SOAP_TYPE_ns1__UserInfo, sizeof(ns1__UserInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Authentication(struct soap *soap, ns1__Authentication *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Authentication))
		soap_mark_PointerTons1__Authentication(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Authentication(struct soap *soap, ns1__Authentication *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Authentication))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Authentication(struct soap *soap, ns1__Authentication **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Authentication(struct soap *soap, ns1__Authentication *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Authentication);
	soap_out_PointerTons1__Authentication(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Authentication(struct soap *soap, const char *tag, int id, ns1__Authentication *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Authentication);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Authentication, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Authentication, &pp), type);
}

SOAP_FMAC3 ns1__Authentication ** SOAP_FMAC4 soap_get_PointerTons1__Authentication(struct soap *soap, ns1__Authentication **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Authentication(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Authentication ** SOAP_FMAC4 soap_in_PointerTons1__Authentication(struct soap *soap, const char *tag, ns1__Authentication **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Authentication **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Authentication, sizeof(ns1__Authentication *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Authentication **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Authentication, sizeof(ns1__Authentication *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Authentication *)soap_instantiate_ns1__Authentication(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Authentication **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Authentication, sizeof(ns1__Authentication *), 1), SOAP_TYPE_ns1__Authentication, sizeof(ns1__Authentication), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TimezoneList(struct soap *soap, ns1__TimezoneList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__TimezoneList))
		soap_mark_PointerTons1__TimezoneList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__TimezoneList(struct soap *soap, ns1__TimezoneList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TimezoneList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__TimezoneList(struct soap *soap, ns1__TimezoneList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TimezoneList(struct soap *soap, ns1__TimezoneList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__TimezoneList);
	soap_out_PointerTons1__TimezoneList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TimezoneList(struct soap *soap, const char *tag, int id, ns1__TimezoneList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__TimezoneList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__TimezoneList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__TimezoneList, &pp), type);
}

SOAP_FMAC3 ns1__TimezoneList ** SOAP_FMAC4 soap_get_PointerTons1__TimezoneList(struct soap *soap, ns1__TimezoneList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TimezoneList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__TimezoneList ** SOAP_FMAC4 soap_in_PointerTons1__TimezoneList(struct soap *soap, const char *tag, ns1__TimezoneList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__TimezoneList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__TimezoneList, sizeof(ns1__TimezoneList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__TimezoneList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__TimezoneList, sizeof(ns1__TimezoneList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__TimezoneList *)soap_instantiate_ns1__TimezoneList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__TimezoneList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__TimezoneList, sizeof(ns1__TimezoneList *), 1), SOAP_TYPE_ns1__TimezoneList, sizeof(ns1__TimezoneList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Settings(struct soap *soap, ns1__Settings *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Settings))
		soap_mark_PointerTons1__Settings(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Settings(struct soap *soap, ns1__Settings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Settings))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Settings(struct soap *soap, ns1__Settings **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Settings(struct soap *soap, ns1__Settings *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Settings);
	soap_out_PointerTons1__Settings(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Settings(struct soap *soap, const char *tag, int id, ns1__Settings *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Settings);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Settings, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Settings, &pp), type);
}

SOAP_FMAC3 ns1__Settings ** SOAP_FMAC4 soap_get_PointerTons1__Settings(struct soap *soap, ns1__Settings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Settings(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Settings ** SOAP_FMAC4 soap_in_PointerTons1__Settings(struct soap *soap, const char *tag, ns1__Settings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Settings **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Settings, sizeof(ns1__Settings *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Settings **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Settings, sizeof(ns1__Settings *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Settings *)soap_instantiate_ns1__Settings(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Settings **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Settings, sizeof(ns1__Settings *), 1), SOAP_TYPE_ns1__Settings, sizeof(ns1__Settings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProxyList(struct soap *soap, ns1__ProxyList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ProxyList))
		soap_mark_PointerTons1__ProxyList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ProxyList(struct soap *soap, ns1__ProxyList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProxyList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ProxyList(struct soap *soap, ns1__ProxyList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProxyList(struct soap *soap, ns1__ProxyList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ProxyList);
	soap_out_PointerTons1__ProxyList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProxyList(struct soap *soap, const char *tag, int id, ns1__ProxyList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ProxyList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ProxyList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ProxyList, &pp), type);
}

SOAP_FMAC3 ns1__ProxyList ** SOAP_FMAC4 soap_get_PointerTons1__ProxyList(struct soap *soap, ns1__ProxyList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProxyList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ProxyList ** SOAP_FMAC4 soap_in_PointerTons1__ProxyList(struct soap *soap, const char *tag, ns1__ProxyList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ProxyList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ProxyList, sizeof(ns1__ProxyList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ProxyList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ProxyList, sizeof(ns1__ProxyList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ProxyList *)soap_instantiate_ns1__ProxyList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ProxyList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ProxyList, sizeof(ns1__ProxyList *), 1), SOAP_TYPE_ns1__ProxyList, sizeof(ns1__ProxyList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccessRightList(struct soap *soap, ns1__AccessRightList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__AccessRightList))
		soap_mark_PointerTons1__AccessRightList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AccessRightList(struct soap *soap, ns1__AccessRightList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccessRightList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AccessRightList(struct soap *soap, ns1__AccessRightList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccessRightList(struct soap *soap, ns1__AccessRightList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AccessRightList);
	soap_out_PointerTons1__AccessRightList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccessRightList(struct soap *soap, const char *tag, int id, ns1__AccessRightList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AccessRightList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AccessRightList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AccessRightList, &pp), type);
}

SOAP_FMAC3 ns1__AccessRightList ** SOAP_FMAC4 soap_get_PointerTons1__AccessRightList(struct soap *soap, ns1__AccessRightList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccessRightList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AccessRightList ** SOAP_FMAC4 soap_in_PointerTons1__AccessRightList(struct soap *soap, const char *tag, ns1__AccessRightList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AccessRightList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessRightList, sizeof(ns1__AccessRightList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AccessRightList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AccessRightList, sizeof(ns1__AccessRightList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AccessRightList *)soap_instantiate_ns1__AccessRightList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AccessRightList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessRightList, sizeof(ns1__AccessRightList *), 1), SOAP_TYPE_ns1__AccessRightList, sizeof(ns1__AccessRightList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__View(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__View))
		soap_mark_PointerTons1__View(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__View(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__View))
		soap_mark_ns1__View(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__View(struct soap *soap, std::string **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__View(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__View);
	soap_out_PointerTons1__View(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__View(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__View);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__View, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_ns1__View(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_ns1__View(soap, tag, i, *a, type);
	}
	return soap_out_ns1__View(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__View, &pp), *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__View(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__View(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__View(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	std::string *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (std::string **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__View, sizeof(std::string *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_ns1__View(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_ns1__View(soap, tag, NULL, type)))
		{	a = (std::string **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTons1__View, sizeof(std::string *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__View, sizeof(std::string *), 1), SOAP_TYPE_ns1__View, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FreeBusyInfoList(struct soap *soap, ns1__FreeBusyInfoList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FreeBusyInfoList))
		soap_mark_PointerTons1__FreeBusyInfoList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FreeBusyInfoList(struct soap *soap, ns1__FreeBusyInfoList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FreeBusyInfoList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FreeBusyInfoList(struct soap *soap, ns1__FreeBusyInfoList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FreeBusyInfoList(struct soap *soap, ns1__FreeBusyInfoList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FreeBusyInfoList);
	soap_out_PointerTons1__FreeBusyInfoList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FreeBusyInfoList(struct soap *soap, const char *tag, int id, ns1__FreeBusyInfoList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FreeBusyInfoList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FreeBusyInfoList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FreeBusyInfoList, &pp), type);
}

SOAP_FMAC3 ns1__FreeBusyInfoList ** SOAP_FMAC4 soap_get_PointerTons1__FreeBusyInfoList(struct soap *soap, ns1__FreeBusyInfoList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FreeBusyInfoList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FreeBusyInfoList ** SOAP_FMAC4 soap_in_PointerTons1__FreeBusyInfoList(struct soap *soap, const char *tag, ns1__FreeBusyInfoList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FreeBusyInfoList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyInfoList, sizeof(ns1__FreeBusyInfoList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FreeBusyInfoList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FreeBusyInfoList, sizeof(ns1__FreeBusyInfoList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FreeBusyInfoList *)soap_instantiate_ns1__FreeBusyInfoList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FreeBusyInfoList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyInfoList, sizeof(ns1__FreeBusyInfoList *), 1), SOAP_TYPE_ns1__FreeBusyInfoList, sizeof(ns1__FreeBusyInfoList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FreeBusyStats(struct soap *soap, ns1__FreeBusyStats *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FreeBusyStats))
		soap_mark_PointerTons1__FreeBusyStats(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FreeBusyStats(struct soap *soap, ns1__FreeBusyStats *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FreeBusyStats))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FreeBusyStats(struct soap *soap, ns1__FreeBusyStats **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FreeBusyStats(struct soap *soap, ns1__FreeBusyStats *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FreeBusyStats);
	soap_out_PointerTons1__FreeBusyStats(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FreeBusyStats(struct soap *soap, const char *tag, int id, ns1__FreeBusyStats *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FreeBusyStats);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FreeBusyStats, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FreeBusyStats, &pp), type);
}

SOAP_FMAC3 ns1__FreeBusyStats ** SOAP_FMAC4 soap_get_PointerTons1__FreeBusyStats(struct soap *soap, ns1__FreeBusyStats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FreeBusyStats(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FreeBusyStats ** SOAP_FMAC4 soap_in_PointerTons1__FreeBusyStats(struct soap *soap, const char *tag, ns1__FreeBusyStats **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FreeBusyStats **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyStats, sizeof(ns1__FreeBusyStats *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FreeBusyStats **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FreeBusyStats, sizeof(ns1__FreeBusyStats *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FreeBusyStats *)soap_instantiate_ns1__FreeBusyStats(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FreeBusyStats **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyStats, sizeof(ns1__FreeBusyStats *), 1), SOAP_TYPE_ns1__FreeBusyStats, sizeof(ns1__FreeBusyStats), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FolderList(struct soap *soap, ns1__FolderList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FolderList))
		soap_mark_PointerTons1__FolderList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FolderList(struct soap *soap, ns1__FolderList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FolderList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FolderList(struct soap *soap, ns1__FolderList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FolderList(struct soap *soap, ns1__FolderList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FolderList);
	soap_out_PointerTons1__FolderList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FolderList(struct soap *soap, const char *tag, int id, ns1__FolderList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FolderList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FolderList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FolderList, &pp), type);
}

SOAP_FMAC3 ns1__FolderList ** SOAP_FMAC4 soap_get_PointerTons1__FolderList(struct soap *soap, ns1__FolderList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FolderList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FolderList ** SOAP_FMAC4 soap_in_PointerTons1__FolderList(struct soap *soap, const char *tag, ns1__FolderList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FolderList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FolderList, sizeof(ns1__FolderList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FolderList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FolderList, sizeof(ns1__FolderList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FolderList *)soap_instantiate_ns1__FolderList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FolderList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FolderList, sizeof(ns1__FolderList *), 1), SOAP_TYPE_ns1__FolderList, sizeof(ns1__FolderList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DeltaList(struct soap *soap, ns1__DeltaList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__DeltaList))
		soap_mark_PointerTons1__DeltaList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__DeltaList(struct soap *soap, ns1__DeltaList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DeltaList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__DeltaList(struct soap *soap, ns1__DeltaList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DeltaList(struct soap *soap, ns1__DeltaList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__DeltaList);
	soap_out_PointerTons1__DeltaList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DeltaList(struct soap *soap, const char *tag, int id, ns1__DeltaList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__DeltaList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__DeltaList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__DeltaList, &pp), type);
}

SOAP_FMAC3 ns1__DeltaList ** SOAP_FMAC4 soap_get_PointerTons1__DeltaList(struct soap *soap, ns1__DeltaList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DeltaList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__DeltaList ** SOAP_FMAC4 soap_in_PointerTons1__DeltaList(struct soap *soap, const char *tag, ns1__DeltaList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__DeltaList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__DeltaList, sizeof(ns1__DeltaList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__DeltaList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__DeltaList, sizeof(ns1__DeltaList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__DeltaList *)soap_instantiate_ns1__DeltaList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__DeltaList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__DeltaList, sizeof(ns1__DeltaList *), 1), SOAP_TYPE_ns1__DeltaList, sizeof(ns1__DeltaList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CustomList(struct soap *soap, ns1__CustomList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__CustomList))
		soap_mark_PointerTons1__CustomList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__CustomList(struct soap *soap, ns1__CustomList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CustomList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__CustomList(struct soap *soap, ns1__CustomList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CustomList(struct soap *soap, ns1__CustomList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__CustomList);
	soap_out_PointerTons1__CustomList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CustomList(struct soap *soap, const char *tag, int id, ns1__CustomList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__CustomList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__CustomList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__CustomList, &pp), type);
}

SOAP_FMAC3 ns1__CustomList ** SOAP_FMAC4 soap_get_PointerTons1__CustomList(struct soap *soap, ns1__CustomList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CustomList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CustomList ** SOAP_FMAC4 soap_in_PointerTons1__CustomList(struct soap *soap, const char *tag, ns1__CustomList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__CustomList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__CustomList, sizeof(ns1__CustomList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__CustomList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__CustomList, sizeof(ns1__CustomList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__CustomList *)soap_instantiate_ns1__CustomList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__CustomList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__CustomList, sizeof(ns1__CustomList *), 1), SOAP_TYPE_ns1__CustomList, sizeof(ns1__CustomList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CategoryList(struct soap *soap, ns1__CategoryList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__CategoryList))
		soap_mark_PointerTons1__CategoryList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__CategoryList(struct soap *soap, ns1__CategoryList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CategoryList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__CategoryList(struct soap *soap, ns1__CategoryList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CategoryList(struct soap *soap, ns1__CategoryList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__CategoryList);
	soap_out_PointerTons1__CategoryList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CategoryList(struct soap *soap, const char *tag, int id, ns1__CategoryList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__CategoryList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__CategoryList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__CategoryList, &pp), type);
}

SOAP_FMAC3 ns1__CategoryList ** SOAP_FMAC4 soap_get_PointerTons1__CategoryList(struct soap *soap, ns1__CategoryList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CategoryList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CategoryList ** SOAP_FMAC4 soap_in_PointerTons1__CategoryList(struct soap *soap, const char *tag, ns1__CategoryList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__CategoryList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__CategoryList, sizeof(ns1__CategoryList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__CategoryList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__CategoryList, sizeof(ns1__CategoryList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__CategoryList *)soap_instantiate_ns1__CategoryList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__CategoryList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__CategoryList, sizeof(ns1__CategoryList *), 1), SOAP_TYPE_ns1__CategoryList, sizeof(ns1__CategoryList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AddressBookList(struct soap *soap, ns1__AddressBookList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__AddressBookList))
		soap_mark_PointerTons1__AddressBookList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AddressBookList(struct soap *soap, ns1__AddressBookList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AddressBookList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AddressBookList(struct soap *soap, ns1__AddressBookList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AddressBookList(struct soap *soap, ns1__AddressBookList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AddressBookList);
	soap_out_PointerTons1__AddressBookList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AddressBookList(struct soap *soap, const char *tag, int id, ns1__AddressBookList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AddressBookList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AddressBookList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AddressBookList, &pp), type);
}

SOAP_FMAC3 ns1__AddressBookList ** SOAP_FMAC4 soap_get_PointerTons1__AddressBookList(struct soap *soap, ns1__AddressBookList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AddressBookList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AddressBookList ** SOAP_FMAC4 soap_in_PointerTons1__AddressBookList(struct soap *soap, const char *tag, ns1__AddressBookList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AddressBookList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AddressBookList, sizeof(ns1__AddressBookList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AddressBookList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AddressBookList, sizeof(ns1__AddressBookList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AddressBookList *)soap_instantiate_ns1__AddressBookList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AddressBookList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AddressBookList, sizeof(ns1__AddressBookList *), 1), SOAP_TYPE_ns1__AddressBookList, sizeof(ns1__AddressBookList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Distribution(struct soap *soap, ns1__Distribution *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Distribution))
		soap_mark_PointerTons1__Distribution(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Distribution(struct soap *soap, ns1__Distribution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Distribution))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Distribution(struct soap *soap, ns1__Distribution **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Distribution(struct soap *soap, ns1__Distribution *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Distribution);
	soap_out_PointerTons1__Distribution(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Distribution(struct soap *soap, const char *tag, int id, ns1__Distribution *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Distribution);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Distribution, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Distribution, &pp), type);
}

SOAP_FMAC3 ns1__Distribution ** SOAP_FMAC4 soap_get_PointerTons1__Distribution(struct soap *soap, ns1__Distribution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Distribution(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Distribution ** SOAP_FMAC4 soap_in_PointerTons1__Distribution(struct soap *soap, const char *tag, ns1__Distribution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Distribution **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Distribution, sizeof(ns1__Distribution *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Distribution **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Distribution, sizeof(ns1__Distribution *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Distribution *)soap_instantiate_ns1__Distribution(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Distribution **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Distribution, sizeof(ns1__Distribution *), 1), SOAP_TYPE_ns1__Distribution, sizeof(ns1__Distribution), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GroupMemberList(struct soap *soap, ns1__GroupMemberList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__GroupMemberList))
		soap_mark_PointerTons1__GroupMemberList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__GroupMemberList(struct soap *soap, ns1__GroupMemberList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GroupMemberList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__GroupMemberList(struct soap *soap, ns1__GroupMemberList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GroupMemberList(struct soap *soap, ns1__GroupMemberList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__GroupMemberList);
	soap_out_PointerTons1__GroupMemberList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GroupMemberList(struct soap *soap, const char *tag, int id, ns1__GroupMemberList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__GroupMemberList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__GroupMemberList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__GroupMemberList, &pp), type);
}

SOAP_FMAC3 ns1__GroupMemberList ** SOAP_FMAC4 soap_get_PointerTons1__GroupMemberList(struct soap *soap, ns1__GroupMemberList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GroupMemberList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__GroupMemberList ** SOAP_FMAC4 soap_in_PointerTons1__GroupMemberList(struct soap *soap, const char *tag, ns1__GroupMemberList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__GroupMemberList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__GroupMemberList, sizeof(ns1__GroupMemberList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__GroupMemberList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__GroupMemberList, sizeof(ns1__GroupMemberList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__GroupMemberList *)soap_instantiate_ns1__GroupMemberList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__GroupMemberList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__GroupMemberList, sizeof(ns1__GroupMemberList *), 1), SOAP_TYPE_ns1__GroupMemberList, sizeof(ns1__GroupMemberList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Status(struct soap *soap, ns1__Status *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Status))
		soap_mark_PointerTons1__Status(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Status(struct soap *soap, ns1__Status *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Status))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Status(struct soap *soap, ns1__Status **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Status(struct soap *soap, ns1__Status *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Status);
	soap_out_PointerTons1__Status(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Status(struct soap *soap, const char *tag, int id, ns1__Status *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Status);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Status, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Status, &pp), type);
}

SOAP_FMAC3 ns1__Status ** SOAP_FMAC4 soap_get_PointerTons1__Status(struct soap *soap, ns1__Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Status(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Status ** SOAP_FMAC4 soap_in_PointerTons1__Status(struct soap *soap, const char *tag, ns1__Status **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Status **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Status, sizeof(ns1__Status *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Status **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Status, sizeof(ns1__Status *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Status *)soap_instantiate_ns1__Status(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Status **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Status, sizeof(ns1__Status *), 1), SOAP_TYPE_ns1__Status, sizeof(ns1__Status), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemRefList(struct soap *soap, ns1__ItemRefList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ItemRefList))
		soap_mark_PointerTons1__ItemRefList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ItemRefList(struct soap *soap, ns1__ItemRefList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ItemRefList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ItemRefList(struct soap *soap, ns1__ItemRefList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemRefList(struct soap *soap, ns1__ItemRefList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ItemRefList);
	soap_out_PointerTons1__ItemRefList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemRefList(struct soap *soap, const char *tag, int id, ns1__ItemRefList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ItemRefList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ItemRefList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ItemRefList, &pp), type);
}

SOAP_FMAC3 ns1__ItemRefList ** SOAP_FMAC4 soap_get_PointerTons1__ItemRefList(struct soap *soap, ns1__ItemRefList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemRefList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ItemRefList ** SOAP_FMAC4 soap_in_PointerTons1__ItemRefList(struct soap *soap, const char *tag, ns1__ItemRefList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ItemRefList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemRefList, sizeof(ns1__ItemRefList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ItemRefList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ItemRefList, sizeof(ns1__ItemRefList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ItemRefList *)soap_instantiate_ns1__ItemRefList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ItemRefList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemRefList, sizeof(ns1__ItemRefList *), 1), SOAP_TYPE_ns1__ItemRefList, sizeof(ns1__ItemRefList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, std::vector<ns1__Timezone * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Timezone))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Timezone(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, std::vector<ns1__Timezone * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Timezone))
		soap_mark_std__vectorTemplateOfPointerTons1__Timezone(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, std::vector<ns1__Timezone * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, std::vector<ns1__Timezone * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Timezone);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Timezone(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, const char *tag, int id, std::vector<ns1__Timezone * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Timezone);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Timezone, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__Timezone(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__Timezone(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__Timezone(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Timezone, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__Timezone * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, std::vector<ns1__Timezone * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__Timezone(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Timezone * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, const char *tag, std::vector<ns1__Timezone * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__Timezone * >**)soap_malloc(soap, sizeof(std::vector<ns1__Timezone * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__Timezone(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Timezone(struct soap *soap, ns1__Timezone *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Timezone))
		soap_mark_PointerTons1__Timezone(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Timezone(struct soap *soap, ns1__Timezone *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Timezone))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Timezone(struct soap *soap, ns1__Timezone **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Timezone(struct soap *soap, ns1__Timezone *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Timezone);
	soap_out_PointerTons1__Timezone(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Timezone(struct soap *soap, const char *tag, int id, ns1__Timezone *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Timezone);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Timezone, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Timezone, &pp), type);
}

SOAP_FMAC3 ns1__Timezone ** SOAP_FMAC4 soap_get_PointerTons1__Timezone(struct soap *soap, ns1__Timezone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Timezone(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Timezone ** SOAP_FMAC4 soap_in_PointerTons1__Timezone(struct soap *soap, const char *tag, ns1__Timezone **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Timezone **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Timezone, sizeof(ns1__Timezone *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Timezone **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Timezone, sizeof(ns1__Timezone *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Timezone *)soap_instantiate_ns1__Timezone(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Timezone **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Timezone, sizeof(ns1__Timezone *), 1), SOAP_TYPE_ns1__Timezone, sizeof(ns1__Timezone), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DayOfWeek(struct soap *soap, ns1__DayOfWeek *const*a)
{
		soap_mark_PointerTons1__DayOfWeek(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__DayOfWeek(struct soap *soap, ns1__DayOfWeek *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DayOfWeek))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__DayOfWeek(struct soap *soap, ns1__DayOfWeek **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DayOfWeek(struct soap *soap, ns1__DayOfWeek *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__DayOfWeek);
	soap_out_PointerTons1__DayOfWeek(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DayOfWeek(struct soap *soap, const char *tag, int id, ns1__DayOfWeek *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__DayOfWeek);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__DayOfWeek, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__DayOfWeek, &pp), type);
}

SOAP_FMAC3 ns1__DayOfWeek ** SOAP_FMAC4 soap_get_PointerTons1__DayOfWeek(struct soap *soap, ns1__DayOfWeek **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DayOfWeek(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__DayOfWeek ** SOAP_FMAC4 soap_in_PointerTons1__DayOfWeek(struct soap *soap, const char *tag, ns1__DayOfWeek **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__DayOfWeek **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__DayOfWeek, sizeof(ns1__DayOfWeek *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__DayOfWeek **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__DayOfWeek, sizeof(ns1__DayOfWeek *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__DayOfWeek *)soap_instantiate_ns1__DayOfWeek(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__DayOfWeek **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__DayOfWeek, sizeof(ns1__DayOfWeek *), 1), SOAP_TYPE_ns1__DayOfWeek, sizeof(ns1__DayOfWeek), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Day(struct soap *soap, unsigned char *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Day))
		soap_mark_PointerTons1__Day(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Day(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__Day);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Day(struct soap *soap, unsigned char **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Day(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Day);
	soap_out_PointerTons1__Day(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Day(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Day);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Day, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_ns1__Day(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_ns1__Day(soap, tag, i, *a, type);
	}
	return soap_out_ns1__Day(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Day, &pp), *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTons1__Day(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Day(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTons1__Day(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	unsigned char *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (unsigned char **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Day, sizeof(unsigned char *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_ns1__Day(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_ns1__Day(soap, tag, NULL, type)))
		{	a = (unsigned char **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTons1__Day, sizeof(unsigned char *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Day, sizeof(unsigned char *), 1), SOAP_TYPE_ns1__Day, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Minute(struct soap *soap, unsigned char *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Minute))
		soap_mark_PointerTons1__Minute(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Minute(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__Minute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Minute(struct soap *soap, unsigned char **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Minute(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Minute);
	soap_out_PointerTons1__Minute(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Minute(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Minute);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Minute, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_ns1__Minute(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_ns1__Minute(soap, tag, i, *a, type);
	}
	return soap_out_ns1__Minute(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Minute, &pp), *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTons1__Minute(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Minute(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTons1__Minute(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	unsigned char *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (unsigned char **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Minute, sizeof(unsigned char *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_ns1__Minute(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_ns1__Minute(soap, tag, NULL, type)))
		{	a = (unsigned char **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTons1__Minute, sizeof(unsigned char *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Minute, sizeof(unsigned char *), 1), SOAP_TYPE_ns1__Minute, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Hour(struct soap *soap, unsigned char *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Hour))
		soap_mark_PointerTons1__Hour(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Hour(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__Hour);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Hour(struct soap *soap, unsigned char **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Hour(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Hour);
	soap_out_PointerTons1__Hour(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Hour(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Hour);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Hour, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_ns1__Hour(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_ns1__Hour(soap, tag, i, *a, type);
	}
	return soap_out_ns1__Hour(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Hour, &pp), *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTons1__Hour(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Hour(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTons1__Hour(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	unsigned char *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (unsigned char **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Hour, sizeof(unsigned char *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_ns1__Hour(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_ns1__Hour(soap, tag, NULL, type)))
		{	a = (unsigned char **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTons1__Hour, sizeof(unsigned char *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Hour, sizeof(unsigned char *), 1), SOAP_TYPE_ns1__Hour, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Month(struct soap *soap, unsigned char *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Month))
		soap_mark_PointerTons1__Month(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Month(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__Month);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Month(struct soap *soap, unsigned char **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Month(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Month);
	soap_out_PointerTons1__Month(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Month(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Month);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Month, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_ns1__Month(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_ns1__Month(soap, tag, i, *a, type);
	}
	return soap_out_ns1__Month(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Month, &pp), *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTons1__Month(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Month(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTons1__Month(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	unsigned char *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (unsigned char **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Month, sizeof(unsigned char *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_ns1__Month(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_ns1__Month(soap, tag, NULL, type)))
		{	a = (unsigned char **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTons1__Month, sizeof(unsigned char *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Month, sizeof(unsigned char *), 1), SOAP_TYPE_ns1__Month, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TimezoneComponent(struct soap *soap, ns1__TimezoneComponent *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__TimezoneComponent))
		soap_mark_PointerTons1__TimezoneComponent(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__TimezoneComponent(struct soap *soap, ns1__TimezoneComponent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TimezoneComponent))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__TimezoneComponent(struct soap *soap, ns1__TimezoneComponent **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TimezoneComponent(struct soap *soap, ns1__TimezoneComponent *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__TimezoneComponent);
	soap_out_PointerTons1__TimezoneComponent(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TimezoneComponent(struct soap *soap, const char *tag, int id, ns1__TimezoneComponent *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__TimezoneComponent);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__TimezoneComponent, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__TimezoneComponent, &pp), type);
}

SOAP_FMAC3 ns1__TimezoneComponent ** SOAP_FMAC4 soap_get_PointerTons1__TimezoneComponent(struct soap *soap, ns1__TimezoneComponent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TimezoneComponent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__TimezoneComponent ** SOAP_FMAC4 soap_in_PointerTons1__TimezoneComponent(struct soap *soap, const char *tag, ns1__TimezoneComponent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__TimezoneComponent **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__TimezoneComponent, sizeof(ns1__TimezoneComponent *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__TimezoneComponent **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__TimezoneComponent, sizeof(ns1__TimezoneComponent *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__TimezoneComponent *)soap_instantiate_ns1__TimezoneComponent(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__TimezoneComponent **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__TimezoneComponent, sizeof(ns1__TimezoneComponent *), 1), SOAP_TYPE_ns1__TimezoneComponent, sizeof(ns1__TimezoneComponent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProblemList(struct soap *soap, ns1__ProblemList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ProblemList))
		soap_mark_PointerTons1__ProblemList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ProblemList(struct soap *soap, ns1__ProblemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProblemList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ProblemList(struct soap *soap, ns1__ProblemList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProblemList(struct soap *soap, ns1__ProblemList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ProblemList);
	soap_out_PointerTons1__ProblemList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProblemList(struct soap *soap, const char *tag, int id, ns1__ProblemList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ProblemList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ProblemList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ProblemList, &pp), type);
}

SOAP_FMAC3 ns1__ProblemList ** SOAP_FMAC4 soap_get_PointerTons1__ProblemList(struct soap *soap, ns1__ProblemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProblemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ProblemList ** SOAP_FMAC4 soap_in_PointerTons1__ProblemList(struct soap *soap, const char *tag, ns1__ProblemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ProblemList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ProblemList, sizeof(ns1__ProblemList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ProblemList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ProblemList, sizeof(ns1__ProblemList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ProblemList *)soap_instantiate_ns1__ProblemList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ProblemList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ProblemList, sizeof(ns1__ProblemList *), 1), SOAP_TYPE_ns1__ProblemList, sizeof(ns1__ProblemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, std::vector<ns1__SettingsGroup * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, std::vector<ns1__SettingsGroup * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SettingsGroup))
		soap_mark_std__vectorTemplateOfPointerTons1__SettingsGroup(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, std::vector<ns1__SettingsGroup * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, std::vector<ns1__SettingsGroup * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, const char *tag, int id, std::vector<ns1__SettingsGroup * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SettingsGroup, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__SettingsGroup(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__SettingsGroup(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__SettingsGroup(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SettingsGroup, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__SettingsGroup * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, std::vector<ns1__SettingsGroup * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__SettingsGroup * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, const char *tag, std::vector<ns1__SettingsGroup * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__SettingsGroup * >**)soap_malloc(soap, sizeof(std::vector<ns1__SettingsGroup * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__SettingsGroup(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SettingsGroup(struct soap *soap, ns1__SettingsGroup *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__SettingsGroup))
		soap_mark_PointerTons1__SettingsGroup(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__SettingsGroup(struct soap *soap, ns1__SettingsGroup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SettingsGroup))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__SettingsGroup(struct soap *soap, ns1__SettingsGroup **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SettingsGroup(struct soap *soap, ns1__SettingsGroup *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__SettingsGroup);
	soap_out_PointerTons1__SettingsGroup(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SettingsGroup(struct soap *soap, const char *tag, int id, ns1__SettingsGroup *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__SettingsGroup);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__SettingsGroup, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__SettingsGroup, &pp), type);
}

SOAP_FMAC3 ns1__SettingsGroup ** SOAP_FMAC4 soap_get_PointerTons1__SettingsGroup(struct soap *soap, ns1__SettingsGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SettingsGroup(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SettingsGroup ** SOAP_FMAC4 soap_in_PointerTons1__SettingsGroup(struct soap *soap, const char *tag, ns1__SettingsGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__SettingsGroup **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__SettingsGroup, sizeof(ns1__SettingsGroup *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__SettingsGroup **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__SettingsGroup, sizeof(ns1__SettingsGroup *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__SettingsGroup *)soap_instantiate_ns1__SettingsGroup(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__SettingsGroup **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__SettingsGroup, sizeof(ns1__SettingsGroup *), 1), SOAP_TYPE_ns1__SettingsGroup, sizeof(ns1__SettingsGroup), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReturnNotification(struct soap *soap, ns1__ReturnNotification *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ReturnNotification))
		soap_mark_PointerTons1__ReturnNotification(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ReturnNotification(struct soap *soap, ns1__ReturnNotification *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReturnNotification))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ReturnNotification(struct soap *soap, ns1__ReturnNotification **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReturnNotification(struct soap *soap, ns1__ReturnNotification *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ReturnNotification);
	soap_out_PointerTons1__ReturnNotification(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReturnNotification(struct soap *soap, const char *tag, int id, ns1__ReturnNotification *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ReturnNotification);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ReturnNotification, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ReturnNotification, &pp), type);
}

SOAP_FMAC3 ns1__ReturnNotification ** SOAP_FMAC4 soap_get_PointerTons1__ReturnNotification(struct soap *soap, ns1__ReturnNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReturnNotification(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ReturnNotification ** SOAP_FMAC4 soap_in_PointerTons1__ReturnNotification(struct soap *soap, const char *tag, ns1__ReturnNotification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ReturnNotification **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ReturnNotification, sizeof(ns1__ReturnNotification *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ReturnNotification **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ReturnNotification, sizeof(ns1__ReturnNotification *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ReturnNotification *)soap_instantiate_ns1__ReturnNotification(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ReturnNotification **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ReturnNotification, sizeof(ns1__ReturnNotification *), 1), SOAP_TYPE_ns1__ReturnNotification, sizeof(ns1__ReturnNotification), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StatusTracking(struct soap *soap, ns1__StatusTracking *const*a)
{
		soap_mark_PointerTons1__StatusTracking(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__StatusTracking(struct soap *soap, ns1__StatusTracking *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StatusTracking))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__StatusTracking(struct soap *soap, ns1__StatusTracking **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StatusTracking(struct soap *soap, ns1__StatusTracking *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__StatusTracking);
	soap_out_PointerTons1__StatusTracking(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StatusTracking(struct soap *soap, const char *tag, int id, ns1__StatusTracking *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__StatusTracking);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__StatusTracking, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__StatusTracking, &pp), type);
}

SOAP_FMAC3 ns1__StatusTracking ** SOAP_FMAC4 soap_get_PointerTons1__StatusTracking(struct soap *soap, ns1__StatusTracking **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StatusTracking(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__StatusTracking ** SOAP_FMAC4 soap_in_PointerTons1__StatusTracking(struct soap *soap, const char *tag, ns1__StatusTracking **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__StatusTracking **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__StatusTracking, sizeof(ns1__StatusTracking *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__StatusTracking **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__StatusTracking, sizeof(ns1__StatusTracking *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__StatusTracking *)soap_instantiate_ns1__StatusTracking(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__StatusTracking **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__StatusTracking, sizeof(ns1__StatusTracking *), 1), SOAP_TYPE_ns1__StatusTracking, sizeof(ns1__StatusTracking), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SendOptionsRequestReply(struct soap *soap, ns1__SendOptionsRequestReply *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__SendOptionsRequestReply))
		soap_mark_PointerTons1__SendOptionsRequestReply(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__SendOptionsRequestReply(struct soap *soap, ns1__SendOptionsRequestReply *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SendOptionsRequestReply))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__SendOptionsRequestReply(struct soap *soap, ns1__SendOptionsRequestReply **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SendOptionsRequestReply(struct soap *soap, ns1__SendOptionsRequestReply *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__SendOptionsRequestReply);
	soap_out_PointerTons1__SendOptionsRequestReply(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SendOptionsRequestReply(struct soap *soap, const char *tag, int id, ns1__SendOptionsRequestReply *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__SendOptionsRequestReply);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__SendOptionsRequestReply, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__SendOptionsRequestReply, &pp), type);
}

SOAP_FMAC3 ns1__SendOptionsRequestReply ** SOAP_FMAC4 soap_get_PointerTons1__SendOptionsRequestReply(struct soap *soap, ns1__SendOptionsRequestReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SendOptionsRequestReply(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SendOptionsRequestReply ** SOAP_FMAC4 soap_in_PointerTons1__SendOptionsRequestReply(struct soap *soap, const char *tag, ns1__SendOptionsRequestReply **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__SendOptionsRequestReply **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__SendOptionsRequestReply, sizeof(ns1__SendOptionsRequestReply *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__SendOptionsRequestReply **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__SendOptionsRequestReply, sizeof(ns1__SendOptionsRequestReply *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__SendOptionsRequestReply *)soap_instantiate_ns1__SendOptionsRequestReply(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__SendOptionsRequestReply **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__SendOptionsRequestReply, sizeof(ns1__SendOptionsRequestReply *), 1), SOAP_TYPE_ns1__SendOptionsRequestReply, sizeof(ns1__SendOptionsRequestReply), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReturnNotificationOptions(struct soap *soap, ns1__ReturnNotificationOptions *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ReturnNotificationOptions))
		soap_mark_PointerTons1__ReturnNotificationOptions(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ReturnNotificationOptions(struct soap *soap, ns1__ReturnNotificationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReturnNotificationOptions))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ReturnNotificationOptions(struct soap *soap, ns1__ReturnNotificationOptions **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReturnNotificationOptions(struct soap *soap, ns1__ReturnNotificationOptions *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ReturnNotificationOptions);
	soap_out_PointerTons1__ReturnNotificationOptions(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReturnNotificationOptions(struct soap *soap, const char *tag, int id, ns1__ReturnNotificationOptions *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ReturnNotificationOptions);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ReturnNotificationOptions, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ReturnNotificationOptions, &pp), type);
}

SOAP_FMAC3 ns1__ReturnNotificationOptions ** SOAP_FMAC4 soap_get_PointerTons1__ReturnNotificationOptions(struct soap *soap, ns1__ReturnNotificationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReturnNotificationOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ReturnNotificationOptions ** SOAP_FMAC4 soap_in_PointerTons1__ReturnNotificationOptions(struct soap *soap, const char *tag, ns1__ReturnNotificationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ReturnNotificationOptions **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ReturnNotificationOptions, sizeof(ns1__ReturnNotificationOptions *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ReturnNotificationOptions **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ReturnNotificationOptions, sizeof(ns1__ReturnNotificationOptions *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ReturnNotificationOptions *)soap_instantiate_ns1__ReturnNotificationOptions(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ReturnNotificationOptions **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ReturnNotificationOptions, sizeof(ns1__ReturnNotificationOptions *), 1), SOAP_TYPE_ns1__ReturnNotificationOptions, sizeof(ns1__ReturnNotificationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfxsd__date(struct soap *soap, std::vector<char * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfxsd__date))
		soap_mark_PointerTostd__vectorTemplateOfxsd__date(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfxsd__date(struct soap *soap, std::vector<char * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfxsd__date))
		soap_mark_std__vectorTemplateOfxsd__date(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfxsd__date(struct soap *soap, std::vector<char * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfxsd__date(struct soap *soap, std::vector<char * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfxsd__date);
	soap_out_PointerTostd__vectorTemplateOfxsd__date(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfxsd__date(struct soap *soap, const char *tag, int id, std::vector<char * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfxsd__date);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfxsd__date, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfxsd__date(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfxsd__date(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfxsd__date(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfxsd__date, &pp), *a, type);
}

SOAP_FMAC3 std::vector<char * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfxsd__date(struct soap *soap, std::vector<char * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfxsd__date(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<char * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfxsd__date(struct soap *soap, const char *tag, std::vector<char * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<char * >**)soap_malloc(soap, sizeof(std::vector<char * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfxsd__date(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DelegateeStatus(struct soap *soap, ns1__DelegateeStatus *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__DelegateeStatus))
		soap_mark_PointerTons1__DelegateeStatus(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__DelegateeStatus(struct soap *soap, ns1__DelegateeStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DelegateeStatus))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__DelegateeStatus(struct soap *soap, ns1__DelegateeStatus **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DelegateeStatus(struct soap *soap, ns1__DelegateeStatus *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__DelegateeStatus);
	soap_out_PointerTons1__DelegateeStatus(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DelegateeStatus(struct soap *soap, const char *tag, int id, ns1__DelegateeStatus *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__DelegateeStatus);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__DelegateeStatus, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__DelegateeStatus, &pp), type);
}

SOAP_FMAC3 ns1__DelegateeStatus ** SOAP_FMAC4 soap_get_PointerTons1__DelegateeStatus(struct soap *soap, ns1__DelegateeStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DelegateeStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__DelegateeStatus ** SOAP_FMAC4 soap_in_PointerTons1__DelegateeStatus(struct soap *soap, const char *tag, ns1__DelegateeStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__DelegateeStatus **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__DelegateeStatus, sizeof(ns1__DelegateeStatus *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__DelegateeStatus **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__DelegateeStatus, sizeof(ns1__DelegateeStatus *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__DelegateeStatus *)soap_instantiate_ns1__DelegateeStatus(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__DelegateeStatus **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__DelegateeStatus, sizeof(ns1__DelegateeStatus *), 1), SOAP_TYPE_ns1__DelegateeStatus, sizeof(ns1__DelegateeStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DelegatedStatus(struct soap *soap, ns1__DelegatedStatus *const*a)
{
		soap_mark_PointerTons1__DelegatedStatus(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__DelegatedStatus(struct soap *soap, ns1__DelegatedStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DelegatedStatus))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__DelegatedStatus(struct soap *soap, ns1__DelegatedStatus **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DelegatedStatus(struct soap *soap, ns1__DelegatedStatus *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__DelegatedStatus);
	soap_out_PointerTons1__DelegatedStatus(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DelegatedStatus(struct soap *soap, const char *tag, int id, ns1__DelegatedStatus *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__DelegatedStatus);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__DelegatedStatus, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__DelegatedStatus, &pp), type);
}

SOAP_FMAC3 ns1__DelegatedStatus ** SOAP_FMAC4 soap_get_PointerTons1__DelegatedStatus(struct soap *soap, ns1__DelegatedStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DelegatedStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__DelegatedStatus ** SOAP_FMAC4 soap_in_PointerTons1__DelegatedStatus(struct soap *soap, const char *tag, ns1__DelegatedStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__DelegatedStatus **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__DelegatedStatus, sizeof(ns1__DelegatedStatus *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__DelegatedStatus **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__DelegatedStatus, sizeof(ns1__DelegatedStatus *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__DelegatedStatus *)soap_instantiate_ns1__DelegatedStatus(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__DelegatedStatus **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__DelegatedStatus, sizeof(ns1__DelegatedStatus *), 1), SOAP_TYPE_ns1__DelegatedStatus, sizeof(ns1__DelegatedStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CommentStatus(struct soap *soap, ns1__CommentStatus *const*a)
{
		soap_mark_PointerTons1__CommentStatus(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__CommentStatus(struct soap *soap, ns1__CommentStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CommentStatus))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__CommentStatus(struct soap *soap, ns1__CommentStatus **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CommentStatus(struct soap *soap, ns1__CommentStatus *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__CommentStatus);
	soap_out_PointerTons1__CommentStatus(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CommentStatus(struct soap *soap, const char *tag, int id, ns1__CommentStatus *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__CommentStatus);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__CommentStatus, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__CommentStatus, &pp), type);
}

SOAP_FMAC3 ns1__CommentStatus ** SOAP_FMAC4 soap_get_PointerTons1__CommentStatus(struct soap *soap, ns1__CommentStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CommentStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CommentStatus ** SOAP_FMAC4 soap_in_PointerTons1__CommentStatus(struct soap *soap, const char *tag, ns1__CommentStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__CommentStatus **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__CommentStatus, sizeof(ns1__CommentStatus *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__CommentStatus **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__CommentStatus, sizeof(ns1__CommentStatus *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__CommentStatus *)soap_instantiate_ns1__CommentStatus(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__CommentStatus **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__CommentStatus, sizeof(ns1__CommentStatus *), 1), SOAP_TYPE_ns1__CommentStatus, sizeof(ns1__CommentStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, std::vector<ns1__Recipient * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Recipient))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Recipient(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, std::vector<ns1__Recipient * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Recipient))
		soap_mark_std__vectorTemplateOfPointerTons1__Recipient(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, std::vector<ns1__Recipient * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, std::vector<ns1__Recipient * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Recipient);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Recipient(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, const char *tag, int id, std::vector<ns1__Recipient * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Recipient);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Recipient, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__Recipient(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__Recipient(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__Recipient(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Recipient, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__Recipient * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, std::vector<ns1__Recipient * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__Recipient(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Recipient * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, const char *tag, std::vector<ns1__Recipient * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__Recipient * >**)soap_malloc(soap, sizeof(std::vector<ns1__Recipient * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__Recipient(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Recipient(struct soap *soap, ns1__Recipient *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Recipient))
		soap_mark_PointerTons1__Recipient(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Recipient(struct soap *soap, ns1__Recipient *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Recipient))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Recipient(struct soap *soap, ns1__Recipient **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Recipient(struct soap *soap, ns1__Recipient *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Recipient);
	soap_out_PointerTons1__Recipient(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Recipient(struct soap *soap, const char *tag, int id, ns1__Recipient *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Recipient);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Recipient, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Recipient, &pp), type);
}

SOAP_FMAC3 ns1__Recipient ** SOAP_FMAC4 soap_get_PointerTons1__Recipient(struct soap *soap, ns1__Recipient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Recipient(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Recipient ** SOAP_FMAC4 soap_in_PointerTons1__Recipient(struct soap *soap, const char *tag, ns1__Recipient **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Recipient **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Recipient, sizeof(ns1__Recipient *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Recipient **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Recipient, sizeof(ns1__Recipient *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Recipient *)soap_instantiate_ns1__Recipient(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Recipient **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Recipient, sizeof(ns1__Recipient *), 1), SOAP_TYPE_ns1__Recipient, sizeof(ns1__Recipient), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__uid(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__uid))
		soap_mark_PointerTons1__uid(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__uid(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__uid))
		soap_mark_ns1__uid(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__uid(struct soap *soap, std::string **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__uid(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__uid);
	soap_out_PointerTons1__uid(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__uid(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__uid);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__uid, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_ns1__uid(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_ns1__uid(soap, tag, i, *a, type);
	}
	return soap_out_ns1__uid(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__uid, &pp), *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons1__uid(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__uid(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons1__uid(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	std::string *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (std::string **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__uid, sizeof(std::string *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_ns1__uid(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_ns1__uid(soap, tag, NULL, type)))
		{	a = (std::string **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTons1__uid, sizeof(std::string *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__uid, sizeof(std::string *), 1), SOAP_TYPE_ns1__uid, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Filter(struct soap *soap, ns1__Filter *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Filter))
		soap_mark_PointerTons1__Filter(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Filter(struct soap *soap, ns1__Filter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Filter))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Filter(struct soap *soap, ns1__Filter **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Filter(struct soap *soap, ns1__Filter *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Filter);
	soap_out_PointerTons1__Filter(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Filter(struct soap *soap, const char *tag, int id, ns1__Filter *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Filter);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Filter, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Filter, &pp), type);
}

SOAP_FMAC3 ns1__Filter ** SOAP_FMAC4 soap_get_PointerTons1__Filter(struct soap *soap, ns1__Filter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Filter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Filter ** SOAP_FMAC4 soap_in_PointerTons1__Filter(struct soap *soap, const char *tag, ns1__Filter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Filter **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Filter, sizeof(ns1__Filter *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Filter **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Filter, sizeof(ns1__Filter *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Filter *)soap_instantiate_ns1__Filter(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Filter **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Filter, sizeof(ns1__Filter *), 1), SOAP_TYPE_ns1__Filter, sizeof(ns1__Filter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QueryTarget(struct soap *soap, ns1__QueryTarget *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__QueryTarget))
		soap_mark_PointerTons1__QueryTarget(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__QueryTarget(struct soap *soap, ns1__QueryTarget *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__QueryTarget))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__QueryTarget(struct soap *soap, ns1__QueryTarget **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QueryTarget(struct soap *soap, ns1__QueryTarget *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__QueryTarget);
	soap_out_PointerTons1__QueryTarget(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QueryTarget(struct soap *soap, const char *tag, int id, ns1__QueryTarget *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__QueryTarget);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__QueryTarget, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__QueryTarget, &pp), type);
}

SOAP_FMAC3 ns1__QueryTarget ** SOAP_FMAC4 soap_get_PointerTons1__QueryTarget(struct soap *soap, ns1__QueryTarget **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QueryTarget(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__QueryTarget ** SOAP_FMAC4 soap_in_PointerTons1__QueryTarget(struct soap *soap, const char *tag, ns1__QueryTarget **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__QueryTarget **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__QueryTarget, sizeof(ns1__QueryTarget *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__QueryTarget **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__QueryTarget, sizeof(ns1__QueryTarget *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__QueryTarget *)soap_instantiate_ns1__QueryTarget(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__QueryTarget **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__QueryTarget, sizeof(ns1__QueryTarget *), 1), SOAP_TYPE_ns1__QueryTarget, sizeof(ns1__QueryTarget), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, std::vector<ns1__NameAndEmail * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, std::vector<ns1__NameAndEmail * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__NameAndEmail))
		soap_mark_std__vectorTemplateOfPointerTons1__NameAndEmail(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, std::vector<ns1__NameAndEmail * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, std::vector<ns1__NameAndEmail * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, const char *tag, int id, std::vector<ns1__NameAndEmail * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__NameAndEmail, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__NameAndEmail(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__NameAndEmail(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__NameAndEmail(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__NameAndEmail, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__NameAndEmail * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, std::vector<ns1__NameAndEmail * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__NameAndEmail * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, const char *tag, std::vector<ns1__NameAndEmail * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__NameAndEmail * >**)soap_malloc(soap, sizeof(std::vector<ns1__NameAndEmail * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__NameAndEmail(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NameAndEmail(struct soap *soap, ns1__NameAndEmail *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__NameAndEmail))
		soap_mark_PointerTons1__NameAndEmail(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__NameAndEmail(struct soap *soap, ns1__NameAndEmail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NameAndEmail))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__NameAndEmail(struct soap *soap, ns1__NameAndEmail **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NameAndEmail(struct soap *soap, ns1__NameAndEmail *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__NameAndEmail);
	soap_out_PointerTons1__NameAndEmail(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NameAndEmail(struct soap *soap, const char *tag, int id, ns1__NameAndEmail *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__NameAndEmail);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__NameAndEmail, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__NameAndEmail, &pp), type);
}

SOAP_FMAC3 ns1__NameAndEmail ** SOAP_FMAC4 soap_get_PointerTons1__NameAndEmail(struct soap *soap, ns1__NameAndEmail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NameAndEmail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__NameAndEmail ** SOAP_FMAC4 soap_in_PointerTons1__NameAndEmail(struct soap *soap, const char *tag, ns1__NameAndEmail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__NameAndEmail **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__NameAndEmail, sizeof(ns1__NameAndEmail *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__NameAndEmail **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__NameAndEmail, sizeof(ns1__NameAndEmail *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__NameAndEmail *)soap_instantiate_ns1__NameAndEmail(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__NameAndEmail **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__NameAndEmail, sizeof(ns1__NameAndEmail *), 1), SOAP_TYPE_ns1__NameAndEmail, sizeof(ns1__NameAndEmail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, std::vector<ns1__ProblemEntry * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, std::vector<ns1__ProblemEntry * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProblemEntry))
		soap_mark_std__vectorTemplateOfPointerTons1__ProblemEntry(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, std::vector<ns1__ProblemEntry * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, std::vector<ns1__ProblemEntry * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, const char *tag, int id, std::vector<ns1__ProblemEntry * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProblemEntry, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__ProblemEntry(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__ProblemEntry(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__ProblemEntry(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProblemEntry, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__ProblemEntry * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, std::vector<ns1__ProblemEntry * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__ProblemEntry * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, const char *tag, std::vector<ns1__ProblemEntry * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__ProblemEntry * >**)soap_malloc(soap, sizeof(std::vector<ns1__ProblemEntry * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__ProblemEntry(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProblemEntry(struct soap *soap, ns1__ProblemEntry *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ProblemEntry))
		soap_mark_PointerTons1__ProblemEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ProblemEntry(struct soap *soap, ns1__ProblemEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProblemEntry))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ProblemEntry(struct soap *soap, ns1__ProblemEntry **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProblemEntry(struct soap *soap, ns1__ProblemEntry *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ProblemEntry);
	soap_out_PointerTons1__ProblemEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProblemEntry(struct soap *soap, const char *tag, int id, ns1__ProblemEntry *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ProblemEntry);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ProblemEntry, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ProblemEntry, &pp), type);
}

SOAP_FMAC3 ns1__ProblemEntry ** SOAP_FMAC4 soap_get_PointerTons1__ProblemEntry(struct soap *soap, ns1__ProblemEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProblemEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ProblemEntry ** SOAP_FMAC4 soap_in_PointerTons1__ProblemEntry(struct soap *soap, const char *tag, ns1__ProblemEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ProblemEntry **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ProblemEntry, sizeof(ns1__ProblemEntry *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ProblemEntry **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ProblemEntry, sizeof(ns1__ProblemEntry *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ProblemEntry *)soap_instantiate_ns1__ProblemEntry(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ProblemEntry **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ProblemEntry, sizeof(ns1__ProblemEntry *), 1), SOAP_TYPE_ns1__ProblemEntry, sizeof(ns1__ProblemEntry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, std::vector<ns1__PostalAddress * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, std::vector<ns1__PostalAddress * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PostalAddress))
		soap_mark_std__vectorTemplateOfPointerTons1__PostalAddress(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, std::vector<ns1__PostalAddress * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, std::vector<ns1__PostalAddress * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, const char *tag, int id, std::vector<ns1__PostalAddress * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PostalAddress, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__PostalAddress(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__PostalAddress(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__PostalAddress(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PostalAddress, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__PostalAddress * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, std::vector<ns1__PostalAddress * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__PostalAddress * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, const char *tag, std::vector<ns1__PostalAddress * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__PostalAddress * >**)soap_malloc(soap, sizeof(std::vector<ns1__PostalAddress * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__PostalAddress(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PostalAddress(struct soap *soap, ns1__PostalAddress *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__PostalAddress))
		soap_mark_PointerTons1__PostalAddress(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__PostalAddress(struct soap *soap, ns1__PostalAddress *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PostalAddress))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__PostalAddress(struct soap *soap, ns1__PostalAddress **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PostalAddress(struct soap *soap, ns1__PostalAddress *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__PostalAddress);
	soap_out_PointerTons1__PostalAddress(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PostalAddress(struct soap *soap, const char *tag, int id, ns1__PostalAddress *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__PostalAddress);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__PostalAddress, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__PostalAddress, &pp), type);
}

SOAP_FMAC3 ns1__PostalAddress ** SOAP_FMAC4 soap_get_PointerTons1__PostalAddress(struct soap *soap, ns1__PostalAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PostalAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__PostalAddress ** SOAP_FMAC4 soap_in_PointerTons1__PostalAddress(struct soap *soap, const char *tag, ns1__PostalAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__PostalAddress **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__PostalAddress, sizeof(ns1__PostalAddress *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__PostalAddress **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__PostalAddress, sizeof(ns1__PostalAddress *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__PostalAddress *)soap_instantiate_ns1__PostalAddress(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__PostalAddress **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__PostalAddress, sizeof(ns1__PostalAddress *), 1), SOAP_TYPE_ns1__PostalAddress, sizeof(ns1__PostalAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemRef(struct soap *soap, ns1__ItemRef *const*a)
{
		soap_mark_PointerTons1__ItemRef(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ItemRef(struct soap *soap, ns1__ItemRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ItemRef))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ItemRef(struct soap *soap, ns1__ItemRef **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemRef(struct soap *soap, ns1__ItemRef *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ItemRef);
	soap_out_PointerTons1__ItemRef(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemRef(struct soap *soap, const char *tag, int id, ns1__ItemRef *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ItemRef);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ItemRef, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ItemRef, &pp), type);
}

SOAP_FMAC3 ns1__ItemRef ** SOAP_FMAC4 soap_get_PointerTons1__ItemRef(struct soap *soap, ns1__ItemRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ItemRef ** SOAP_FMAC4 soap_in_PointerTons1__ItemRef(struct soap *soap, const char *tag, ns1__ItemRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ItemRef **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemRef, sizeof(ns1__ItemRef *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ItemRef **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ItemRef, sizeof(ns1__ItemRef *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ItemRef *)soap_instantiate_ns1__ItemRef(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ItemRef **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemRef, sizeof(ns1__ItemRef *), 1), SOAP_TYPE_ns1__ItemRef, sizeof(ns1__ItemRef), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, std::vector<ns1__MessagePart * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__MessagePart))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, std::vector<ns1__MessagePart * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MessagePart))
		soap_mark_std__vectorTemplateOfPointerTons1__MessagePart(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, std::vector<ns1__MessagePart * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, std::vector<ns1__MessagePart * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__MessagePart);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, const char *tag, int id, std::vector<ns1__MessagePart * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__MessagePart);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MessagePart, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__MessagePart(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__MessagePart(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__MessagePart(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MessagePart, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__MessagePart * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, std::vector<ns1__MessagePart * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__MessagePart * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, const char *tag, std::vector<ns1__MessagePart * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__MessagePart * >**)soap_malloc(soap, sizeof(std::vector<ns1__MessagePart * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__MessagePart(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MessagePart(struct soap *soap, ns1__MessagePart *const*a)
{
		soap_mark_PointerTons1__MessagePart(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__MessagePart(struct soap *soap, ns1__MessagePart *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MessagePart))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__MessagePart(struct soap *soap, ns1__MessagePart **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MessagePart(struct soap *soap, ns1__MessagePart *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__MessagePart);
	soap_out_PointerTons1__MessagePart(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MessagePart(struct soap *soap, const char *tag, int id, ns1__MessagePart *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__MessagePart);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__MessagePart, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__MessagePart, &pp), type);
}

SOAP_FMAC3 ns1__MessagePart ** SOAP_FMAC4 soap_get_PointerTons1__MessagePart(struct soap *soap, ns1__MessagePart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MessagePart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MessagePart ** SOAP_FMAC4 soap_in_PointerTons1__MessagePart(struct soap *soap, const char *tag, ns1__MessagePart **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__MessagePart **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__MessagePart, sizeof(ns1__MessagePart *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__MessagePart **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__MessagePart, sizeof(ns1__MessagePart *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__MessagePart *)soap_instantiate_ns1__MessagePart(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__MessagePart **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__MessagePart, sizeof(ns1__MessagePart *), 1), SOAP_TYPE_ns1__MessagePart, sizeof(ns1__MessagePart), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__Item(struct soap *soap, std::vector<ns1__Item * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Item))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Item(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Item(struct soap *soap, std::vector<ns1__Item * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Item))
		soap_mark_std__vectorTemplateOfPointerTons1__Item(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__Item(struct soap *soap, std::vector<ns1__Item * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__Item(struct soap *soap, std::vector<ns1__Item * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Item);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Item(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__Item(struct soap *soap, const char *tag, int id, std::vector<ns1__Item * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Item);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Item, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__Item(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__Item(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__Item(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Item, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__Item * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__Item(struct soap *soap, std::vector<ns1__Item * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__Item(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Item * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__Item(struct soap *soap, const char *tag, std::vector<ns1__Item * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__Item * >**)soap_malloc(soap, sizeof(std::vector<ns1__Item * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__Item(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Item(struct soap *soap, ns1__Item *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Item))
		soap_mark_PointerTons1__Item(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Item(struct soap *soap, ns1__Item *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Item))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Item(struct soap *soap, ns1__Item **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Item(struct soap *soap, ns1__Item *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Item);
	soap_out_PointerTons1__Item(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Item(struct soap *soap, const char *tag, int id, ns1__Item *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Item);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Item, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Item, &pp), type);
}

SOAP_FMAC3 ns1__Item ** SOAP_FMAC4 soap_get_PointerTons1__Item(struct soap *soap, ns1__Item **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Item(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Item ** SOAP_FMAC4 soap_in_PointerTons1__Item(struct soap *soap, const char *tag, ns1__Item **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Item **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Item, sizeof(ns1__Item *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Item **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Item, sizeof(ns1__Item *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Item *)soap_instantiate_ns1__Item(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Item **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Item, sizeof(ns1__Item *), 1), SOAP_TYPE_ns1__Item, sizeof(ns1__Item), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemChanges(struct soap *soap, ns1__ItemChanges *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ItemChanges))
		soap_mark_PointerTons1__ItemChanges(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ItemChanges(struct soap *soap, ns1__ItemChanges *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ItemChanges))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ItemChanges(struct soap *soap, ns1__ItemChanges **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemChanges(struct soap *soap, ns1__ItemChanges *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ItemChanges);
	soap_out_PointerTons1__ItemChanges(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemChanges(struct soap *soap, const char *tag, int id, ns1__ItemChanges *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ItemChanges);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ItemChanges, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ItemChanges, &pp), type);
}

SOAP_FMAC3 ns1__ItemChanges ** SOAP_FMAC4 soap_get_PointerTons1__ItemChanges(struct soap *soap, ns1__ItemChanges **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemChanges(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ItemChanges ** SOAP_FMAC4 soap_in_PointerTons1__ItemChanges(struct soap *soap, const char *tag, ns1__ItemChanges **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ItemChanges **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemChanges, sizeof(ns1__ItemChanges *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ItemChanges **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ItemChanges, sizeof(ns1__ItemChanges *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ItemChanges *)soap_instantiate_ns1__ItemChanges(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ItemChanges **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ItemChanges, sizeof(ns1__ItemChanges *), 1), SOAP_TYPE_ns1__ItemChanges, sizeof(ns1__ItemChanges), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, std::vector<ns1__ImAddress * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ImAddress))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, std::vector<ns1__ImAddress * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ImAddress))
		soap_mark_std__vectorTemplateOfPointerTons1__ImAddress(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, std::vector<ns1__ImAddress * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, std::vector<ns1__ImAddress * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ImAddress);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, const char *tag, int id, std::vector<ns1__ImAddress * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ImAddress);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ImAddress, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__ImAddress(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__ImAddress(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__ImAddress(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ImAddress, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__ImAddress * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, std::vector<ns1__ImAddress * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__ImAddress * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, const char *tag, std::vector<ns1__ImAddress * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__ImAddress * >**)soap_malloc(soap, sizeof(std::vector<ns1__ImAddress * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__ImAddress(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ImAddress(struct soap *soap, ns1__ImAddress *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__ImAddress))
		soap_mark_PointerTons1__ImAddress(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__ImAddress(struct soap *soap, ns1__ImAddress *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ImAddress))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__ImAddress(struct soap *soap, ns1__ImAddress **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ImAddress(struct soap *soap, ns1__ImAddress *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__ImAddress);
	soap_out_PointerTons1__ImAddress(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ImAddress(struct soap *soap, const char *tag, int id, ns1__ImAddress *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__ImAddress);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__ImAddress, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__ImAddress, &pp), type);
}

SOAP_FMAC3 ns1__ImAddress ** SOAP_FMAC4 soap_get_PointerTons1__ImAddress(struct soap *soap, ns1__ImAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ImAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ImAddress ** SOAP_FMAC4 soap_in_PointerTons1__ImAddress(struct soap *soap, const char *tag, ns1__ImAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__ImAddress **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ImAddress, sizeof(ns1__ImAddress *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__ImAddress **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__ImAddress, sizeof(ns1__ImAddress *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__ImAddress *)soap_instantiate_ns1__ImAddress(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__ImAddress **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__ImAddress, sizeof(ns1__ImAddress *), 1), SOAP_TYPE_ns1__ImAddress, sizeof(ns1__ImAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, std::vector<ns1__GroupMember * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__GroupMember))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, std::vector<ns1__GroupMember * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupMember))
		soap_mark_std__vectorTemplateOfPointerTons1__GroupMember(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, std::vector<ns1__GroupMember * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, std::vector<ns1__GroupMember * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__GroupMember);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, const char *tag, int id, std::vector<ns1__GroupMember * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__GroupMember);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupMember, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__GroupMember(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__GroupMember(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__GroupMember(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupMember, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__GroupMember * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, std::vector<ns1__GroupMember * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__GroupMember * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, const char *tag, std::vector<ns1__GroupMember * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__GroupMember * >**)soap_malloc(soap, sizeof(std::vector<ns1__GroupMember * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__GroupMember(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GroupMember(struct soap *soap, ns1__GroupMember *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__GroupMember))
		soap_mark_PointerTons1__GroupMember(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__GroupMember(struct soap *soap, ns1__GroupMember *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GroupMember))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__GroupMember(struct soap *soap, ns1__GroupMember **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GroupMember(struct soap *soap, ns1__GroupMember *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__GroupMember);
	soap_out_PointerTons1__GroupMember(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GroupMember(struct soap *soap, const char *tag, int id, ns1__GroupMember *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__GroupMember);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__GroupMember, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__GroupMember, &pp), type);
}

SOAP_FMAC3 ns1__GroupMember ** SOAP_FMAC4 soap_get_PointerTons1__GroupMember(struct soap *soap, ns1__GroupMember **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GroupMember(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__GroupMember ** SOAP_FMAC4 soap_in_PointerTons1__GroupMember(struct soap *soap, const char *tag, ns1__GroupMember **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__GroupMember **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__GroupMember, sizeof(ns1__GroupMember *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__GroupMember **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__GroupMember, sizeof(ns1__GroupMember *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__GroupMember *)soap_instantiate_ns1__GroupMember(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__GroupMember **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__GroupMember, sizeof(ns1__GroupMember *), 1), SOAP_TYPE_ns1__GroupMember, sizeof(ns1__GroupMember), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, std::vector<ns1__FreeBusyInfo * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, std::vector<ns1__FreeBusyInfo * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyInfo))
		soap_mark_std__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, std::vector<ns1__FreeBusyInfo * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, std::vector<ns1__FreeBusyInfo * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, const char *tag, int id, std::vector<ns1__FreeBusyInfo * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyInfo, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyInfo, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__FreeBusyInfo * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, std::vector<ns1__FreeBusyInfo * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__FreeBusyInfo * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, const char *tag, std::vector<ns1__FreeBusyInfo * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__FreeBusyInfo * >**)soap_malloc(soap, sizeof(std::vector<ns1__FreeBusyInfo * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FreeBusyInfo(struct soap *soap, ns1__FreeBusyInfo *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FreeBusyInfo))
		soap_mark_PointerTons1__FreeBusyInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FreeBusyInfo(struct soap *soap, ns1__FreeBusyInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FreeBusyInfo))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FreeBusyInfo(struct soap *soap, ns1__FreeBusyInfo **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FreeBusyInfo(struct soap *soap, ns1__FreeBusyInfo *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FreeBusyInfo);
	soap_out_PointerTons1__FreeBusyInfo(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FreeBusyInfo(struct soap *soap, const char *tag, int id, ns1__FreeBusyInfo *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FreeBusyInfo);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FreeBusyInfo, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FreeBusyInfo, &pp), type);
}

SOAP_FMAC3 ns1__FreeBusyInfo ** SOAP_FMAC4 soap_get_PointerTons1__FreeBusyInfo(struct soap *soap, ns1__FreeBusyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FreeBusyInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FreeBusyInfo ** SOAP_FMAC4 soap_in_PointerTons1__FreeBusyInfo(struct soap *soap, const char *tag, ns1__FreeBusyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FreeBusyInfo **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyInfo, sizeof(ns1__FreeBusyInfo *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FreeBusyInfo **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FreeBusyInfo, sizeof(ns1__FreeBusyInfo *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FreeBusyInfo *)soap_instantiate_ns1__FreeBusyInfo(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FreeBusyInfo **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyInfo, sizeof(ns1__FreeBusyInfo *), 1), SOAP_TYPE_ns1__FreeBusyInfo, sizeof(ns1__FreeBusyInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, std::vector<ns1__FreeBusyUser * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, std::vector<ns1__FreeBusyUser * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyUser))
		soap_mark_std__vectorTemplateOfPointerTons1__FreeBusyUser(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, std::vector<ns1__FreeBusyUser * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, std::vector<ns1__FreeBusyUser * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, const char *tag, int id, std::vector<ns1__FreeBusyUser * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyUser, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__FreeBusyUser(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__FreeBusyUser(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__FreeBusyUser(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyUser, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__FreeBusyUser * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, std::vector<ns1__FreeBusyUser * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__FreeBusyUser * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, const char *tag, std::vector<ns1__FreeBusyUser * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__FreeBusyUser * >**)soap_malloc(soap, sizeof(std::vector<ns1__FreeBusyUser * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__FreeBusyUser(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FreeBusyUser(struct soap *soap, ns1__FreeBusyUser *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FreeBusyUser))
		soap_mark_PointerTons1__FreeBusyUser(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FreeBusyUser(struct soap *soap, ns1__FreeBusyUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FreeBusyUser))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FreeBusyUser(struct soap *soap, ns1__FreeBusyUser **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FreeBusyUser(struct soap *soap, ns1__FreeBusyUser *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FreeBusyUser);
	soap_out_PointerTons1__FreeBusyUser(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FreeBusyUser(struct soap *soap, const char *tag, int id, ns1__FreeBusyUser *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FreeBusyUser);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FreeBusyUser, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FreeBusyUser, &pp), type);
}

SOAP_FMAC3 ns1__FreeBusyUser ** SOAP_FMAC4 soap_get_PointerTons1__FreeBusyUser(struct soap *soap, ns1__FreeBusyUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FreeBusyUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FreeBusyUser ** SOAP_FMAC4 soap_in_PointerTons1__FreeBusyUser(struct soap *soap, const char *tag, ns1__FreeBusyUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FreeBusyUser **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyUser, sizeof(ns1__FreeBusyUser *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FreeBusyUser **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FreeBusyUser, sizeof(ns1__FreeBusyUser *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FreeBusyUser *)soap_instantiate_ns1__FreeBusyUser(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FreeBusyUser **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyUser, sizeof(ns1__FreeBusyUser *), 1), SOAP_TYPE_ns1__FreeBusyUser, sizeof(ns1__FreeBusyUser), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, std::vector<ns1__FreeBusyBlock * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, std::vector<ns1__FreeBusyBlock * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyBlock))
		soap_mark_std__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, std::vector<ns1__FreeBusyBlock * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, std::vector<ns1__FreeBusyBlock * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, const char *tag, int id, std::vector<ns1__FreeBusyBlock * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyBlock, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyBlock, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__FreeBusyBlock * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, std::vector<ns1__FreeBusyBlock * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__FreeBusyBlock * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, const char *tag, std::vector<ns1__FreeBusyBlock * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__FreeBusyBlock * >**)soap_malloc(soap, sizeof(std::vector<ns1__FreeBusyBlock * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FreeBusyBlock(struct soap *soap, ns1__FreeBusyBlock *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FreeBusyBlock))
		soap_mark_PointerTons1__FreeBusyBlock(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FreeBusyBlock(struct soap *soap, ns1__FreeBusyBlock *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FreeBusyBlock))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FreeBusyBlock(struct soap *soap, ns1__FreeBusyBlock **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FreeBusyBlock(struct soap *soap, ns1__FreeBusyBlock *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FreeBusyBlock);
	soap_out_PointerTons1__FreeBusyBlock(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FreeBusyBlock(struct soap *soap, const char *tag, int id, ns1__FreeBusyBlock *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FreeBusyBlock);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FreeBusyBlock, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FreeBusyBlock, &pp), type);
}

SOAP_FMAC3 ns1__FreeBusyBlock ** SOAP_FMAC4 soap_get_PointerTons1__FreeBusyBlock(struct soap *soap, ns1__FreeBusyBlock **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FreeBusyBlock(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FreeBusyBlock ** SOAP_FMAC4 soap_in_PointerTons1__FreeBusyBlock(struct soap *soap, const char *tag, ns1__FreeBusyBlock **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FreeBusyBlock **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyBlock, sizeof(ns1__FreeBusyBlock *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FreeBusyBlock **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FreeBusyBlock, sizeof(ns1__FreeBusyBlock *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FreeBusyBlock *)soap_instantiate_ns1__FreeBusyBlock(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FreeBusyBlock **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FreeBusyBlock, sizeof(ns1__FreeBusyBlock *), 1), SOAP_TYPE_ns1__FreeBusyBlock, sizeof(ns1__FreeBusyBlock), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__Folder(struct soap *soap, std::vector<ns1__Folder * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Folder))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Folder(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Folder(struct soap *soap, std::vector<ns1__Folder * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Folder))
		soap_mark_std__vectorTemplateOfPointerTons1__Folder(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__Folder(struct soap *soap, std::vector<ns1__Folder * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__Folder(struct soap *soap, std::vector<ns1__Folder * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Folder);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Folder(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__Folder(struct soap *soap, const char *tag, int id, std::vector<ns1__Folder * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Folder);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Folder, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__Folder(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__Folder(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__Folder(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Folder, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__Folder * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__Folder(struct soap *soap, std::vector<ns1__Folder * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__Folder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Folder * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__Folder(struct soap *soap, const char *tag, std::vector<ns1__Folder * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__Folder * >**)soap_malloc(soap, sizeof(std::vector<ns1__Folder * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__Folder(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Folder(struct soap *soap, ns1__Folder *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Folder))
		soap_mark_PointerTons1__Folder(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Folder(struct soap *soap, ns1__Folder *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Folder))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Folder(struct soap *soap, ns1__Folder **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Folder(struct soap *soap, ns1__Folder *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Folder);
	soap_out_PointerTons1__Folder(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Folder(struct soap *soap, const char *tag, int id, ns1__Folder *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Folder);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Folder, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Folder, &pp), type);
}

SOAP_FMAC3 ns1__Folder ** SOAP_FMAC4 soap_get_PointerTons1__Folder(struct soap *soap, ns1__Folder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Folder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Folder ** SOAP_FMAC4 soap_in_PointerTons1__Folder(struct soap *soap, const char *tag, ns1__Folder **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Folder **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Folder, sizeof(ns1__Folder *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Folder **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Folder, sizeof(ns1__Folder *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Folder *)soap_instantiate_ns1__Folder(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Folder **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Folder, sizeof(ns1__Folder *), 1), SOAP_TYPE_ns1__Folder, sizeof(ns1__Folder), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, std::vector<ns1__FolderACLEntry * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, std::vector<ns1__FolderACLEntry * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FolderACLEntry))
		soap_mark_std__vectorTemplateOfPointerTons1__FolderACLEntry(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, std::vector<ns1__FolderACLEntry * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, std::vector<ns1__FolderACLEntry * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, const char *tag, int id, std::vector<ns1__FolderACLEntry * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FolderACLEntry, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__FolderACLEntry(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__FolderACLEntry(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__FolderACLEntry(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FolderACLEntry, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__FolderACLEntry * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, std::vector<ns1__FolderACLEntry * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__FolderACLEntry * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, const char *tag, std::vector<ns1__FolderACLEntry * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__FolderACLEntry * >**)soap_malloc(soap, sizeof(std::vector<ns1__FolderACLEntry * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__FolderACLEntry(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FolderACLEntry(struct soap *soap, ns1__FolderACLEntry *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FolderACLEntry))
		soap_mark_PointerTons1__FolderACLEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FolderACLEntry(struct soap *soap, ns1__FolderACLEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FolderACLEntry))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FolderACLEntry(struct soap *soap, ns1__FolderACLEntry **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FolderACLEntry(struct soap *soap, ns1__FolderACLEntry *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FolderACLEntry);
	soap_out_PointerTons1__FolderACLEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FolderACLEntry(struct soap *soap, const char *tag, int id, ns1__FolderACLEntry *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FolderACLEntry);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FolderACLEntry, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FolderACLEntry, &pp), type);
}

SOAP_FMAC3 ns1__FolderACLEntry ** SOAP_FMAC4 soap_get_PointerTons1__FolderACLEntry(struct soap *soap, ns1__FolderACLEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FolderACLEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FolderACLEntry ** SOAP_FMAC4 soap_in_PointerTons1__FolderACLEntry(struct soap *soap, const char *tag, ns1__FolderACLEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FolderACLEntry **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FolderACLEntry, sizeof(ns1__FolderACLEntry *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FolderACLEntry **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FolderACLEntry, sizeof(ns1__FolderACLEntry *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FolderACLEntry *)soap_instantiate_ns1__FolderACLEntry(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FolderACLEntry **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FolderACLEntry, sizeof(ns1__FolderACLEntry *), 1), SOAP_TYPE_ns1__FolderACLEntry, sizeof(ns1__FolderACLEntry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FilterElement(struct soap *soap, ns1__FilterElement *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__FilterElement))
		soap_mark_PointerTons1__FilterElement(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__FilterElement(struct soap *soap, ns1__FilterElement *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FilterElement))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__FilterElement(struct soap *soap, ns1__FilterElement **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FilterElement(struct soap *soap, ns1__FilterElement *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__FilterElement);
	soap_out_PointerTons1__FilterElement(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FilterElement(struct soap *soap, const char *tag, int id, ns1__FilterElement *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__FilterElement);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__FilterElement, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__FilterElement, &pp), type);
}

SOAP_FMAC3 ns1__FilterElement ** SOAP_FMAC4 soap_get_PointerTons1__FilterElement(struct soap *soap, ns1__FilterElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FilterElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__FilterElement ** SOAP_FMAC4 soap_in_PointerTons1__FilterElement(struct soap *soap, const char *tag, ns1__FilterElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__FilterElement **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FilterElement, sizeof(ns1__FilterElement *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__FilterElement **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__FilterElement, sizeof(ns1__FilterElement *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__FilterElement *)soap_instantiate_ns1__FilterElement(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__FilterElement **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__FilterElement, sizeof(ns1__FilterElement *), 1), SOAP_TYPE_ns1__FilterElement, sizeof(ns1__FilterElement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfstd__string))
		soap_mark_PointerTostd__vectorTemplateOfstd__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfstd__string))
		soap_mark_std__vectorTemplateOfstd__string(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfstd__string);
	soap_out_PointerTostd__vectorTemplateOfstd__string(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, std::vector<std::string >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfstd__string);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfstd__string, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfstd__string(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfstd__string(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfstd__string(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfstd__string, &pp), *a, type);
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfstd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<std::string >**)soap_malloc(soap, sizeof(std::vector<std::string >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfstd__string(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SendOptions(struct soap *soap, ns1__SendOptions *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__SendOptions))
		soap_mark_PointerTons1__SendOptions(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__SendOptions(struct soap *soap, ns1__SendOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SendOptions))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__SendOptions(struct soap *soap, ns1__SendOptions **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SendOptions(struct soap *soap, ns1__SendOptions *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__SendOptions);
	soap_out_PointerTons1__SendOptions(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SendOptions(struct soap *soap, const char *tag, int id, ns1__SendOptions *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__SendOptions);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__SendOptions, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__SendOptions, &pp), type);
}

SOAP_FMAC3 ns1__SendOptions ** SOAP_FMAC4 soap_get_PointerTons1__SendOptions(struct soap *soap, ns1__SendOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SendOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SendOptions ** SOAP_FMAC4 soap_in_PointerTons1__SendOptions(struct soap *soap, const char *tag, ns1__SendOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__SendOptions **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__SendOptions, sizeof(ns1__SendOptions *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__SendOptions **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__SendOptions, sizeof(ns1__SendOptions *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__SendOptions *)soap_instantiate_ns1__SendOptions(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__SendOptions **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__SendOptions, sizeof(ns1__SendOptions *), 1), SOAP_TYPE_ns1__SendOptions, sizeof(ns1__SendOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RecipientList(struct soap *soap, ns1__RecipientList *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__RecipientList))
		soap_mark_PointerTons1__RecipientList(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__RecipientList(struct soap *soap, ns1__RecipientList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RecipientList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__RecipientList(struct soap *soap, ns1__RecipientList **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RecipientList(struct soap *soap, ns1__RecipientList *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__RecipientList);
	soap_out_PointerTons1__RecipientList(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RecipientList(struct soap *soap, const char *tag, int id, ns1__RecipientList *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__RecipientList);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__RecipientList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__RecipientList, &pp), type);
}

SOAP_FMAC3 ns1__RecipientList ** SOAP_FMAC4 soap_get_PointerTons1__RecipientList(struct soap *soap, ns1__RecipientList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RecipientList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__RecipientList ** SOAP_FMAC4 soap_in_PointerTons1__RecipientList(struct soap *soap, const char *tag, ns1__RecipientList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__RecipientList **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__RecipientList, sizeof(ns1__RecipientList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__RecipientList **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__RecipientList, sizeof(ns1__RecipientList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__RecipientList *)soap_instantiate_ns1__RecipientList(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__RecipientList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__RecipientList, sizeof(ns1__RecipientList *), 1), SOAP_TYPE_ns1__RecipientList, sizeof(ns1__RecipientList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__From(struct soap *soap, ns1__From *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__From))
		soap_mark_PointerTons1__From(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__From(struct soap *soap, ns1__From *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__From))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__From(struct soap *soap, ns1__From **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__From(struct soap *soap, ns1__From *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__From);
	soap_out_PointerTons1__From(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__From(struct soap *soap, const char *tag, int id, ns1__From *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__From);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__From, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__From, &pp), type);
}

SOAP_FMAC3 ns1__From ** SOAP_FMAC4 soap_get_PointerTons1__From(struct soap *soap, ns1__From **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__From(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__From ** SOAP_FMAC4 soap_in_PointerTons1__From(struct soap *soap, const char *tag, ns1__From **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__From **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__From, sizeof(ns1__From *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__From **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__From, sizeof(ns1__From *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__From *)soap_instantiate_ns1__From(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__From **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__From, sizeof(ns1__From *), 1), SOAP_TYPE_ns1__From, sizeof(ns1__From), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Items(struct soap *soap, ns1__Items *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Items))
		soap_mark_PointerTons1__Items(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Items(struct soap *soap, ns1__Items *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Items))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Items(struct soap *soap, ns1__Items **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Items(struct soap *soap, ns1__Items *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Items);
	soap_out_PointerTons1__Items(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Items(struct soap *soap, const char *tag, int id, ns1__Items *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Items);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Items, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Items, &pp), type);
}

SOAP_FMAC3 ns1__Items ** SOAP_FMAC4 soap_get_PointerTons1__Items(struct soap *soap, ns1__Items **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Items(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Items ** SOAP_FMAC4 soap_in_PointerTons1__Items(struct soap *soap, const char *tag, ns1__Items **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Items **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Items, sizeof(ns1__Items *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Items **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Items, sizeof(ns1__Items *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Items *)soap_instantiate_ns1__Items(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Items **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Items, sizeof(ns1__Items *), 1), SOAP_TYPE_ns1__Items, sizeof(ns1__Items), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__Custom(struct soap *soap, std::vector<ns1__Custom * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Custom))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Custom(struct soap *soap, std::vector<ns1__Custom * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Custom))
		soap_mark_std__vectorTemplateOfPointerTons1__Custom(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__Custom(struct soap *soap, std::vector<ns1__Custom * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__Custom(struct soap *soap, std::vector<ns1__Custom * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Custom);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__Custom(struct soap *soap, const char *tag, int id, std::vector<ns1__Custom * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Custom);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Custom, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__Custom(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__Custom(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__Custom(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Custom, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__Custom * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__Custom(struct soap *soap, std::vector<ns1__Custom * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__Custom(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Custom * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__Custom(struct soap *soap, const char *tag, std::vector<ns1__Custom * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__Custom * >**)soap_malloc(soap, sizeof(std::vector<ns1__Custom * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__Custom(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Custom(struct soap *soap, ns1__Custom *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Custom))
		soap_mark_PointerTons1__Custom(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Custom(struct soap *soap, ns1__Custom *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Custom))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Custom(struct soap *soap, ns1__Custom **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Custom(struct soap *soap, ns1__Custom *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Custom);
	soap_out_PointerTons1__Custom(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Custom(struct soap *soap, const char *tag, int id, ns1__Custom *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Custom);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Custom, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Custom, &pp), type);
}

SOAP_FMAC3 ns1__Custom ** SOAP_FMAC4 soap_get_PointerTons1__Custom(struct soap *soap, ns1__Custom **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Custom(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Custom ** SOAP_FMAC4 soap_in_PointerTons1__Custom(struct soap *soap, const char *tag, ns1__Custom **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Custom **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Custom, sizeof(ns1__Custom *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Custom **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Custom, sizeof(ns1__Custom *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Custom *)soap_instantiate_ns1__Custom(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Custom **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Custom, sizeof(ns1__Custom *), 1), SOAP_TYPE_ns1__Custom, sizeof(ns1__Custom), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfns1__uid(struct soap *soap, std::vector<std::string >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfns1__uid))
		soap_mark_PointerTostd__vectorTemplateOfns1__uid(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfns1__uid(struct soap *soap, std::vector<std::string >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfns1__uid))
		soap_mark_std__vectorTemplateOfns1__uid(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfns1__uid(struct soap *soap, std::vector<std::string >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfns1__uid(struct soap *soap, std::vector<std::string >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfns1__uid);
	soap_out_PointerTostd__vectorTemplateOfns1__uid(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfns1__uid(struct soap *soap, const char *tag, int id, std::vector<std::string >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfns1__uid);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfns1__uid, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfns1__uid(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfns1__uid(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfns1__uid(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfns1__uid, &pp), *a, type);
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfns1__uid(struct soap *soap, std::vector<std::string >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfns1__uid(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfns1__uid(struct soap *soap, const char *tag, std::vector<std::string >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<std::string >**)soap_malloc(soap, sizeof(std::vector<std::string >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfns1__uid(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__Category(struct soap *soap, std::vector<ns1__Category * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Category))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Category(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__Category(struct soap *soap, std::vector<ns1__Category * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Category))
		soap_mark_std__vectorTemplateOfPointerTons1__Category(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__Category(struct soap *soap, std::vector<ns1__Category * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__Category(struct soap *soap, std::vector<ns1__Category * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Category);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__Category(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__Category(struct soap *soap, const char *tag, int id, std::vector<ns1__Category * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Category);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Category, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__Category(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__Category(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__Category(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Category, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__Category * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__Category(struct soap *soap, std::vector<ns1__Category * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__Category(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Category * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__Category(struct soap *soap, const char *tag, std::vector<ns1__Category * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__Category * >**)soap_malloc(soap, sizeof(std::vector<ns1__Category * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__Category(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Category(struct soap *soap, ns1__Category *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__Category))
		soap_mark_PointerTons1__Category(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__Category(struct soap *soap, ns1__Category *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Category))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__Category(struct soap *soap, ns1__Category **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Category(struct soap *soap, ns1__Category *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__Category);
	soap_out_PointerTons1__Category(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Category(struct soap *soap, const char *tag, int id, ns1__Category *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__Category);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__Category, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__Category, &pp), type);
}

SOAP_FMAC3 ns1__Category ** SOAP_FMAC4 soap_get_PointerTons1__Category(struct soap *soap, ns1__Category **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Category(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Category ** SOAP_FMAC4 soap_in_PointerTons1__Category(struct soap *soap, const char *tag, ns1__Category **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__Category **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Category, sizeof(ns1__Category *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__Category **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__Category, sizeof(ns1__Category *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__Category *)soap_instantiate_ns1__Category(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__Category **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__Category, sizeof(ns1__Category *), 1), SOAP_TYPE_ns1__Category, sizeof(ns1__Category), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToxsd__base64Binary))
		soap_mark_PointerToxsd__base64Binary(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_xsd__base64Binary))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	soap_out_PointerToxsd__base64Binary(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToxsd__base64Binary);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_array_pointer_lookup(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_xsd__base64Binary, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_xsd__base64Binary, &pp), type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (xsd__base64Binary **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToxsd__base64Binary, sizeof(xsd__base64Binary *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (xsd__base64Binary **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerToxsd__base64Binary, sizeof(xsd__base64Binary *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToxsd__base64Binary, sizeof(xsd__base64Binary *), 1), SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__string))
		soap_mark_PointerTostd__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_mark_std__string(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__string(struct soap *soap, std::string **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__string);
	soap_out_PointerTostd__string(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__string);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__string, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__string(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__string(soap, tag, i, *a, type);
	}
	return soap_out_std__string(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__string, &pp), *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	std::string *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (std::string **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTostd__string, sizeof(std::string *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_std__string(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_std__string(soap, tag, NULL, type)))
		{	a = (std::string **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTostd__string, sizeof(std::string *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTostd__string, sizeof(std::string *), 1), SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AttachmentID(struct soap *soap, ns1__AttachmentID *const*a)
{
		soap_mark_PointerTons1__AttachmentID(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AttachmentID(struct soap *soap, ns1__AttachmentID *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AttachmentID))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AttachmentID(struct soap *soap, ns1__AttachmentID **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AttachmentID(struct soap *soap, ns1__AttachmentID *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AttachmentID);
	soap_out_PointerTons1__AttachmentID(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AttachmentID(struct soap *soap, const char *tag, int id, ns1__AttachmentID *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AttachmentID);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AttachmentID, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AttachmentID, &pp), type);
}

SOAP_FMAC3 ns1__AttachmentID ** SOAP_FMAC4 soap_get_PointerTons1__AttachmentID(struct soap *soap, ns1__AttachmentID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AttachmentID(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AttachmentID ** SOAP_FMAC4 soap_in_PointerTons1__AttachmentID(struct soap *soap, const char *tag, ns1__AttachmentID **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AttachmentID **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AttachmentID, sizeof(ns1__AttachmentID *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AttachmentID **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AttachmentID, sizeof(ns1__AttachmentID *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AttachmentID *)soap_instantiate_ns1__AttachmentID(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AttachmentID **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AttachmentID, sizeof(ns1__AttachmentID *), 1), SOAP_TYPE_ns1__AttachmentID, sizeof(ns1__AttachmentID), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, std::vector<ns1__AttachmentItemInfo * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, std::vector<ns1__AttachmentItemInfo * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttachmentItemInfo))
		soap_mark_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, std::vector<ns1__AttachmentItemInfo * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, std::vector<ns1__AttachmentItemInfo * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, const char *tag, int id, std::vector<ns1__AttachmentItemInfo * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttachmentItemInfo, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttachmentItemInfo, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__AttachmentItemInfo * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, std::vector<ns1__AttachmentItemInfo * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__AttachmentItemInfo * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, const char *tag, std::vector<ns1__AttachmentItemInfo * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__AttachmentItemInfo * >**)soap_malloc(soap, sizeof(std::vector<ns1__AttachmentItemInfo * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AttachmentItemInfo(struct soap *soap, ns1__AttachmentItemInfo *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__AttachmentItemInfo))
		soap_mark_PointerTons1__AttachmentItemInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AttachmentItemInfo(struct soap *soap, ns1__AttachmentItemInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AttachmentItemInfo))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AttachmentItemInfo(struct soap *soap, ns1__AttachmentItemInfo **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AttachmentItemInfo(struct soap *soap, ns1__AttachmentItemInfo *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AttachmentItemInfo);
	soap_out_PointerTons1__AttachmentItemInfo(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AttachmentItemInfo(struct soap *soap, const char *tag, int id, ns1__AttachmentItemInfo *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AttachmentItemInfo);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AttachmentItemInfo, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AttachmentItemInfo, &pp), type);
}

SOAP_FMAC3 ns1__AttachmentItemInfo ** SOAP_FMAC4 soap_get_PointerTons1__AttachmentItemInfo(struct soap *soap, ns1__AttachmentItemInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AttachmentItemInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AttachmentItemInfo ** SOAP_FMAC4 soap_in_PointerTons1__AttachmentItemInfo(struct soap *soap, const char *tag, ns1__AttachmentItemInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AttachmentItemInfo **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AttachmentItemInfo, sizeof(ns1__AttachmentItemInfo *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AttachmentItemInfo **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AttachmentItemInfo, sizeof(ns1__AttachmentItemInfo *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AttachmentItemInfo *)soap_instantiate_ns1__AttachmentItemInfo(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AttachmentItemInfo **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AttachmentItemInfo, sizeof(ns1__AttachmentItemInfo *), 1), SOAP_TYPE_ns1__AttachmentItemInfo, sizeof(ns1__AttachmentItemInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, std::vector<ns1__AddressBook * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AddressBook))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, std::vector<ns1__AddressBook * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AddressBook))
		soap_mark_std__vectorTemplateOfPointerTons1__AddressBook(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, std::vector<ns1__AddressBook * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, std::vector<ns1__AddressBook * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AddressBook);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, const char *tag, int id, std::vector<ns1__AddressBook * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AddressBook);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AddressBook, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__AddressBook(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__AddressBook(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__AddressBook(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AddressBook, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__AddressBook * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, std::vector<ns1__AddressBook * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__AddressBook * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, const char *tag, std::vector<ns1__AddressBook * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__AddressBook * >**)soap_malloc(soap, sizeof(std::vector<ns1__AddressBook * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__AddressBook(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AddressBook(struct soap *soap, ns1__AddressBook *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__AddressBook))
		soap_mark_PointerTons1__AddressBook(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AddressBook(struct soap *soap, ns1__AddressBook *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AddressBook))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AddressBook(struct soap *soap, ns1__AddressBook **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AddressBook(struct soap *soap, ns1__AddressBook *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AddressBook);
	soap_out_PointerTons1__AddressBook(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AddressBook(struct soap *soap, const char *tag, int id, ns1__AddressBook *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AddressBook);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AddressBook, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AddressBook, &pp), type);
}

SOAP_FMAC3 ns1__AddressBook ** SOAP_FMAC4 soap_get_PointerTons1__AddressBook(struct soap *soap, ns1__AddressBook **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AddressBook(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AddressBook ** SOAP_FMAC4 soap_in_PointerTons1__AddressBook(struct soap *soap, const char *tag, ns1__AddressBook **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AddressBook **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AddressBook, sizeof(ns1__AddressBook *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AddressBook **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AddressBook, sizeof(ns1__AddressBook *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AddressBook *)soap_instantiate_ns1__AddressBook(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AddressBook **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AddressBook, sizeof(ns1__AddressBook *), 1), SOAP_TYPE_ns1__AddressBook, sizeof(ns1__AddressBook), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, std::vector<ns1__AccessRightEntry * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, std::vector<ns1__AccessRightEntry * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessRightEntry))
		soap_mark_std__vectorTemplateOfPointerTons1__AccessRightEntry(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, std::vector<ns1__AccessRightEntry * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, std::vector<ns1__AccessRightEntry * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, const char *tag, int id, std::vector<ns1__AccessRightEntry * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessRightEntry, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__AccessRightEntry(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__AccessRightEntry(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__AccessRightEntry(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessRightEntry, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__AccessRightEntry * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, std::vector<ns1__AccessRightEntry * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__AccessRightEntry * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, const char *tag, std::vector<ns1__AccessRightEntry * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__AccessRightEntry * >**)soap_malloc(soap, sizeof(std::vector<ns1__AccessRightEntry * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__AccessRightEntry(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccessRightEntry(struct soap *soap, ns1__AccessRightEntry *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__AccessRightEntry))
		soap_mark_PointerTons1__AccessRightEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AccessRightEntry(struct soap *soap, ns1__AccessRightEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccessRightEntry))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AccessRightEntry(struct soap *soap, ns1__AccessRightEntry **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccessRightEntry(struct soap *soap, ns1__AccessRightEntry *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AccessRightEntry);
	soap_out_PointerTons1__AccessRightEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccessRightEntry(struct soap *soap, const char *tag, int id, ns1__AccessRightEntry *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AccessRightEntry);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AccessRightEntry, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AccessRightEntry, &pp), type);
}

SOAP_FMAC3 ns1__AccessRightEntry ** SOAP_FMAC4 soap_get_PointerTons1__AccessRightEntry(struct soap *soap, ns1__AccessRightEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccessRightEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AccessRightEntry ** SOAP_FMAC4 soap_in_PointerTons1__AccessRightEntry(struct soap *soap, const char *tag, ns1__AccessRightEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AccessRightEntry **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessRightEntry, sizeof(ns1__AccessRightEntry *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AccessRightEntry **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AccessRightEntry, sizeof(ns1__AccessRightEntry *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AccessRightEntry *)soap_instantiate_ns1__AccessRightEntry(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AccessRightEntry **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessRightEntry, sizeof(ns1__AccessRightEntry *), 1), SOAP_TYPE_ns1__AccessRightEntry, sizeof(ns1__AccessRightEntry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTobool))
		soap_mark_PointerTobool(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTobool(struct soap *soap, bool **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTobool);
	soap_out_PointerTobool(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTobool);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_bool, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_bool(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_bool(soap, tag, i, *a, type);
	}
	return soap_out_bool(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_bool, &pp), *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	bool *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (bool **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTobool, sizeof(bool *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_bool(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_bool(soap, tag, NULL, type)))
		{	a = (bool **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTobool, sizeof(bool *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTobool, sizeof(bool *), 1), SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, std::vector<ns1__AccessControlListEntry * >*const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry))
		soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, std::vector<ns1__AccessControlListEntry * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessControlListEntry))
		soap_mark_std__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, std::vector<ns1__AccessControlListEntry * >**a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, std::vector<ns1__AccessControlListEntry * >*const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry);
	soap_out_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, const char *tag, int id, std::vector<ns1__AccessControlListEntry * >*const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessControlListEntry, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_std__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_std__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, tag, i, *a, type);
	}
	return soap_out_std__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessControlListEntry, &pp), *a, type);
}

SOAP_FMAC3 std::vector<ns1__AccessControlListEntry * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, std::vector<ns1__AccessControlListEntry * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__AccessControlListEntry * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, const char *tag, std::vector<ns1__AccessControlListEntry * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if ((a = (std::vector<ns1__AccessControlListEntry * >**)soap_malloc(soap, sizeof(std::vector<ns1__AccessControlListEntry * >*))))
			*a = NULL;
			else
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccessControlListEntry(struct soap *soap, ns1__AccessControlListEntry *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons1__AccessControlListEntry))
		soap_mark_PointerTons1__AccessControlListEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTons1__AccessControlListEntry(struct soap *soap, ns1__AccessControlListEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccessControlListEntry))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTons1__AccessControlListEntry(struct soap *soap, ns1__AccessControlListEntry **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccessControlListEntry(struct soap *soap, ns1__AccessControlListEntry *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTons1__AccessControlListEntry);
	soap_out_PointerTons1__AccessControlListEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccessControlListEntry(struct soap *soap, const char *tag, int id, ns1__AccessControlListEntry *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons1__AccessControlListEntry);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns1__AccessControlListEntry, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns1__AccessControlListEntry, &pp), type);
}

SOAP_FMAC3 ns1__AccessControlListEntry ** SOAP_FMAC4 soap_get_PointerTons1__AccessControlListEntry(struct soap *soap, ns1__AccessControlListEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccessControlListEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AccessControlListEntry ** SOAP_FMAC4 soap_in_PointerTons1__AccessControlListEntry(struct soap *soap, const char *tag, ns1__AccessControlListEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns1__AccessControlListEntry **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessControlListEntry, sizeof(ns1__AccessControlListEntry *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns1__AccessControlListEntry **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons1__AccessControlListEntry, sizeof(ns1__AccessControlListEntry *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns1__AccessControlListEntry *)soap_instantiate_ns1__AccessControlListEntry(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns1__AccessControlListEntry **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons1__AccessControlListEntry, sizeof(ns1__AccessControlListEntry *), 1), SOAP_TYPE_ns1__AccessControlListEntry, sizeof(ns1__AccessControlListEntry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__language(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__language
	*a = SOAP_DEFAULT_xsd__language;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__language(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__language);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__language(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__language);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__language(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_xsd__language);
	soap_out_xsd__language(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__language(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__language);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__language(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__language(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__language(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__language, 1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__decimal(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__decimal
	*a = SOAP_DEFAULT_xsd__decimal;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__decimal(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_xsd__decimal);
	soap_out_xsd__decimal(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__date(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__date
	*a = SOAP_DEFAULT_xsd__date;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__date(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_xsd__date);
	soap_out_xsd__date(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__bool(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__bool
	*a = SOAP_DEFAULT_xsd__bool;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__bool(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__bool);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__bool(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__bool(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_xsd__bool);
	soap_out_xsd__bool(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__bool(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__bool);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__bool(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__bool(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__bool, 1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTounsignedByte))
		soap_mark_PointerTounsignedByte(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTounsignedByte(struct soap *soap, unsigned char **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTounsignedByte);
	soap_out_PointerTounsignedByte(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTounsignedByte);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_unsignedByte, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_unsignedByte(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_unsignedByte(soap, tag, i, *a, type);
	}
	return soap_out_unsignedByte(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_unsignedByte, &pp), *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	unsigned char *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (unsigned char **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTounsignedByte, sizeof(unsigned char *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_unsignedByte(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_unsignedByte(soap, tag, NULL, type)))
		{	a = (unsigned char **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerTounsignedByte, sizeof(unsigned char *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTounsignedByte, sizeof(unsigned char *), 1), SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__anyURI
	*a = SOAP_DEFAULT_xsd__anyURI;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__anyURI(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_xsd__anyURI);
	soap_out_xsd__anyURI(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE__QName);
	soap_out__QName(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_string);
	soap_out_string(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, std::vector<ns1__FilterElement * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FilterElement))
		soap_mark_std__vectorTemplateOfPointerTons1__FilterElement(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, const std::vector<ns1__FilterElement * >*a)
{
	for (std::vector<ns1__FilterElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__FilterElement(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, std::vector<ns1__FilterElement * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, const std::vector<ns1__FilterElement * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FilterElement);
	soap_out_std__vectorTemplateOfPointerTons1__FilterElement(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, const char *tag, int id, const std::vector<ns1__FilterElement * >*a, const char *type)
{
	for (std::vector<ns1__FilterElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__FilterElement(soap, tag, id, &(*i), "ns1:FilterElement"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__FilterElement * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, std::vector<ns1__FilterElement * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__FilterElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__FilterElement * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, const char *tag, std::vector<ns1__FilterElement * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__FilterElement(soap, -1)))
			return NULL;
	ns1__FilterElement *n;
	ns1__FilterElement **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__FilterElement(soap, tag, NULL, "ns1:FilterElement")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FilterElement, a, 1);
		}
		else
		{	soap_default_PointerTons1__FilterElement(soap, &n);
			if (!soap_in_PointerTons1__FilterElement(soap, tag, &n, "ns1:FilterElement"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__FilterElement * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__FilterElement(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, std::vector<ns1__FilterElement * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__FilterElement * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__FilterElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__FilterElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FilterElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__FilterElement * >;
		if (size)
			*size = sizeof(std::vector<ns1__FilterElement * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__FilterElement * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__FilterElement * >);
	}
	return (std::vector<ns1__FilterElement * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, std::vector<ns1__ContainerRef * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ContainerRef))
		soap_mark_std__vectorTemplateOfPointerTons1__ContainerRef(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, const std::vector<ns1__ContainerRef * >*a)
{
	for (std::vector<ns1__ContainerRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__ContainerRef(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, std::vector<ns1__ContainerRef * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, const std::vector<ns1__ContainerRef * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ContainerRef);
	soap_out_std__vectorTemplateOfPointerTons1__ContainerRef(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, const char *tag, int id, const std::vector<ns1__ContainerRef * >*a, const char *type)
{
	for (std::vector<ns1__ContainerRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__ContainerRef(soap, tag, id, &(*i), "ns1:ContainerRef"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ContainerRef * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, std::vector<ns1__ContainerRef * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__ContainerRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__ContainerRef * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, const char *tag, std::vector<ns1__ContainerRef * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__ContainerRef(soap, -1)))
			return NULL;
	ns1__ContainerRef *n;
	ns1__ContainerRef **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__ContainerRef(soap, tag, NULL, "ns1:ContainerRef")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ContainerRef, a, 1);
		}
		else
		{	soap_default_PointerTons1__ContainerRef(soap, &n);
			if (!soap_in_PointerTons1__ContainerRef(soap, tag, &n, "ns1:ContainerRef"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__ContainerRef * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__ContainerRef(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, std::vector<ns1__ContainerRef * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__ContainerRef * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__ContainerRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ContainerRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ContainerRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__ContainerRef * >;
		if (size)
			*size = sizeof(std::vector<ns1__ContainerRef * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__ContainerRef * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__ContainerRef * >);
	}
	return (std::vector<ns1__ContainerRef * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, std::vector<ns1__Timezone * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Timezone))
		soap_mark_std__vectorTemplateOfPointerTons1__Timezone(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, const std::vector<ns1__Timezone * >*a)
{
	for (std::vector<ns1__Timezone * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__Timezone(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, std::vector<ns1__Timezone * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, const std::vector<ns1__Timezone * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Timezone);
	soap_out_std__vectorTemplateOfPointerTons1__Timezone(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, const char *tag, int id, const std::vector<ns1__Timezone * >*a, const char *type)
{
	for (std::vector<ns1__Timezone * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__Timezone(soap, tag, id, &(*i), "ns1:Timezone"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Timezone * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, std::vector<ns1__Timezone * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__Timezone(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Timezone * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, const char *tag, std::vector<ns1__Timezone * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__Timezone(soap, -1)))
			return NULL;
	ns1__Timezone *n;
	ns1__Timezone **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__Timezone(soap, tag, NULL, "ns1:Timezone")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Timezone, a, 1);
		}
		else
		{	soap_default_PointerTons1__Timezone(soap, &n);
			if (!soap_in_PointerTons1__Timezone(soap, tag, &n, "ns1:Timezone"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__Timezone * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__Timezone(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, std::vector<ns1__Timezone * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__Timezone * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__Timezone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Timezone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Timezone, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__Timezone * >;
		if (size)
			*size = sizeof(std::vector<ns1__Timezone * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__Timezone * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__Timezone * >);
	}
	return (std::vector<ns1__Timezone * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, std::vector<ns1__SettingsGroup * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SettingsGroup))
		soap_mark_std__vectorTemplateOfPointerTons1__SettingsGroup(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, const std::vector<ns1__SettingsGroup * >*a)
{
	for (std::vector<ns1__SettingsGroup * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__SettingsGroup(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, std::vector<ns1__SettingsGroup * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, const std::vector<ns1__SettingsGroup * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SettingsGroup);
	soap_out_std__vectorTemplateOfPointerTons1__SettingsGroup(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, const char *tag, int id, const std::vector<ns1__SettingsGroup * >*a, const char *type)
{
	for (std::vector<ns1__SettingsGroup * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__SettingsGroup(soap, tag, id, &(*i), "ns1:SettingsGroup"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SettingsGroup * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, std::vector<ns1__SettingsGroup * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__SettingsGroup(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__SettingsGroup * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, const char *tag, std::vector<ns1__SettingsGroup * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__SettingsGroup(soap, -1)))
			return NULL;
	ns1__SettingsGroup *n;
	ns1__SettingsGroup **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__SettingsGroup(soap, tag, NULL, "ns1:SettingsGroup")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SettingsGroup, a, 1);
		}
		else
		{	soap_default_PointerTons1__SettingsGroup(soap, &n);
			if (!soap_in_PointerTons1__SettingsGroup(soap, tag, &n, "ns1:SettingsGroup"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__SettingsGroup * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__SettingsGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, std::vector<ns1__SettingsGroup * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__SettingsGroup * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__SettingsGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SettingsGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SettingsGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__SettingsGroup * >;
		if (size)
			*size = sizeof(std::vector<ns1__SettingsGroup * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__SettingsGroup * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__SettingsGroup * >);
	}
	return (std::vector<ns1__SettingsGroup * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__date(struct soap *soap, std::vector<char * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfxsd__date))
		soap_mark_std__vectorTemplateOfxsd__date(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfxsd__date(struct soap *soap, const std::vector<char * >*a)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_xsd__date(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__date(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfxsd__date(struct soap *soap, const std::vector<char * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfxsd__date);
	soap_out_std__vectorTemplateOfxsd__date(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__date(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_xsd__date(soap, tag, id, &(*i), "xsd:date"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfxsd__date(struct soap *soap, std::vector<char * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfxsd__date(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__date(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfxsd__date(soap, -1)))
			return NULL;
	char *n;
	char **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_xsd__date(soap, tag, NULL, "xsd:date")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfxsd__date, a, 1);
		}
		else
		{	soap_default_xsd__date(soap, &n);
			if (!soap_in_xsd__date(soap, tag, &n, "xsd:date"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<char * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfxsd__date(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfxsd__date(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfxsd__date(struct soap *soap, std::vector<char * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<char * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfxsd__date(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__date(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__date, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char * >;
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char * >[n];
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
	return (std::vector<char * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, std::vector<ns1__Recipient * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Recipient))
		soap_mark_std__vectorTemplateOfPointerTons1__Recipient(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, const std::vector<ns1__Recipient * >*a)
{
	for (std::vector<ns1__Recipient * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__Recipient(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, std::vector<ns1__Recipient * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, const std::vector<ns1__Recipient * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Recipient);
	soap_out_std__vectorTemplateOfPointerTons1__Recipient(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, const char *tag, int id, const std::vector<ns1__Recipient * >*a, const char *type)
{
	for (std::vector<ns1__Recipient * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__Recipient(soap, tag, id, &(*i), "ns1:Recipient"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Recipient * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, std::vector<ns1__Recipient * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__Recipient(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Recipient * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, const char *tag, std::vector<ns1__Recipient * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__Recipient(soap, -1)))
			return NULL;
	ns1__Recipient *n;
	ns1__Recipient **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__Recipient(soap, tag, NULL, "ns1:Recipient")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Recipient, a, 1);
		}
		else
		{	soap_default_PointerTons1__Recipient(soap, &n);
			if (!soap_in_PointerTons1__Recipient(soap, tag, &n, "ns1:Recipient"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__Recipient * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__Recipient(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, std::vector<ns1__Recipient * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__Recipient * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__Recipient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Recipient(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Recipient, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__Recipient * >;
		if (size)
			*size = sizeof(std::vector<ns1__Recipient * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__Recipient * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__Recipient * >);
	}
	return (std::vector<ns1__Recipient * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, std::vector<ns1__NameAndEmail * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__NameAndEmail))
		soap_mark_std__vectorTemplateOfPointerTons1__NameAndEmail(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, const std::vector<ns1__NameAndEmail * >*a)
{
	for (std::vector<ns1__NameAndEmail * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__NameAndEmail(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, std::vector<ns1__NameAndEmail * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, const std::vector<ns1__NameAndEmail * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__NameAndEmail);
	soap_out_std__vectorTemplateOfPointerTons1__NameAndEmail(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, const char *tag, int id, const std::vector<ns1__NameAndEmail * >*a, const char *type)
{
	for (std::vector<ns1__NameAndEmail * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__NameAndEmail(soap, tag, id, &(*i), "ns1:NameAndEmail"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__NameAndEmail * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, std::vector<ns1__NameAndEmail * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__NameAndEmail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__NameAndEmail * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, const char *tag, std::vector<ns1__NameAndEmail * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__NameAndEmail(soap, -1)))
			return NULL;
	ns1__NameAndEmail *n;
	ns1__NameAndEmail **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__NameAndEmail(soap, tag, NULL, "ns1:NameAndEmail")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__NameAndEmail, a, 1);
		}
		else
		{	soap_default_PointerTons1__NameAndEmail(soap, &n);
			if (!soap_in_PointerTons1__NameAndEmail(soap, tag, &n, "ns1:NameAndEmail"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__NameAndEmail * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__NameAndEmail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, std::vector<ns1__NameAndEmail * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__NameAndEmail * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__NameAndEmail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__NameAndEmail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__NameAndEmail, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__NameAndEmail * >;
		if (size)
			*size = sizeof(std::vector<ns1__NameAndEmail * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__NameAndEmail * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__NameAndEmail * >);
	}
	return (std::vector<ns1__NameAndEmail * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, std::vector<ns1__ProblemEntry * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProblemEntry))
		soap_mark_std__vectorTemplateOfPointerTons1__ProblemEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, const std::vector<ns1__ProblemEntry * >*a)
{
	for (std::vector<ns1__ProblemEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__ProblemEntry(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, std::vector<ns1__ProblemEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, const std::vector<ns1__ProblemEntry * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProblemEntry);
	soap_out_std__vectorTemplateOfPointerTons1__ProblemEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, const char *tag, int id, const std::vector<ns1__ProblemEntry * >*a, const char *type)
{
	for (std::vector<ns1__ProblemEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__ProblemEntry(soap, tag, id, &(*i), "ns1:ProblemEntry"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ProblemEntry * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, std::vector<ns1__ProblemEntry * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__ProblemEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__ProblemEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, const char *tag, std::vector<ns1__ProblemEntry * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__ProblemEntry(soap, -1)))
			return NULL;
	ns1__ProblemEntry *n;
	ns1__ProblemEntry **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__ProblemEntry(soap, tag, NULL, "ns1:ProblemEntry")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProblemEntry, a, 1);
		}
		else
		{	soap_default_PointerTons1__ProblemEntry(soap, &n);
			if (!soap_in_PointerTons1__ProblemEntry(soap, tag, &n, "ns1:ProblemEntry"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__ProblemEntry * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__ProblemEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, std::vector<ns1__ProblemEntry * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__ProblemEntry * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__ProblemEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ProblemEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProblemEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__ProblemEntry * >;
		if (size)
			*size = sizeof(std::vector<ns1__ProblemEntry * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__ProblemEntry * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__ProblemEntry * >);
	}
	return (std::vector<ns1__ProblemEntry * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, std::vector<ns1__PostalAddress * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PostalAddress))
		soap_mark_std__vectorTemplateOfPointerTons1__PostalAddress(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, const std::vector<ns1__PostalAddress * >*a)
{
	for (std::vector<ns1__PostalAddress * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__PostalAddress(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, std::vector<ns1__PostalAddress * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, const std::vector<ns1__PostalAddress * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PostalAddress);
	soap_out_std__vectorTemplateOfPointerTons1__PostalAddress(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, const char *tag, int id, const std::vector<ns1__PostalAddress * >*a, const char *type)
{
	for (std::vector<ns1__PostalAddress * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__PostalAddress(soap, tag, id, &(*i), "ns1:PostalAddress"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__PostalAddress * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, std::vector<ns1__PostalAddress * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__PostalAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__PostalAddress * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, const char *tag, std::vector<ns1__PostalAddress * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__PostalAddress(soap, -1)))
			return NULL;
	ns1__PostalAddress *n;
	ns1__PostalAddress **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__PostalAddress(soap, tag, NULL, "ns1:PostalAddress")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PostalAddress, a, 1);
		}
		else
		{	soap_default_PointerTons1__PostalAddress(soap, &n);
			if (!soap_in_PointerTons1__PostalAddress(soap, tag, &n, "ns1:PostalAddress"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__PostalAddress * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__PostalAddress(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, std::vector<ns1__PostalAddress * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__PostalAddress * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__PostalAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__PostalAddress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PostalAddress, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__PostalAddress * >;
		if (size)
			*size = sizeof(std::vector<ns1__PostalAddress * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__PostalAddress * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__PostalAddress * >);
	}
	return (std::vector<ns1__PostalAddress * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, std::vector<ns1__MessagePart * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MessagePart))
		soap_mark_std__vectorTemplateOfPointerTons1__MessagePart(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, const std::vector<ns1__MessagePart * >*a)
{
	for (std::vector<ns1__MessagePart * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__MessagePart(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, std::vector<ns1__MessagePart * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, const std::vector<ns1__MessagePart * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MessagePart);
	soap_out_std__vectorTemplateOfPointerTons1__MessagePart(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, const char *tag, int id, const std::vector<ns1__MessagePart * >*a, const char *type)
{
	for (std::vector<ns1__MessagePart * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__MessagePart(soap, tag, id, &(*i), "ns1:MessagePart"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__MessagePart * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, std::vector<ns1__MessagePart * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__MessagePart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__MessagePart * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, const char *tag, std::vector<ns1__MessagePart * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__MessagePart(soap, -1)))
			return NULL;
	ns1__MessagePart *n;
	ns1__MessagePart **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__MessagePart(soap, tag, NULL, "ns1:MessagePart")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MessagePart, a, 1);
		}
		else
		{	soap_default_PointerTons1__MessagePart(soap, &n);
			if (!soap_in_PointerTons1__MessagePart(soap, tag, &n, "ns1:MessagePart"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__MessagePart * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__MessagePart(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, std::vector<ns1__MessagePart * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__MessagePart * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__MessagePart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__MessagePart(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MessagePart, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__MessagePart * >;
		if (size)
			*size = sizeof(std::vector<ns1__MessagePart * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__MessagePart * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__MessagePart * >);
	}
	return (std::vector<ns1__MessagePart * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Item(struct soap *soap, std::vector<ns1__Item * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Item))
		soap_mark_std__vectorTemplateOfPointerTons1__Item(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__Item(struct soap *soap, const std::vector<ns1__Item * >*a)
{
	for (std::vector<ns1__Item * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__Item(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Item(struct soap *soap, std::vector<ns1__Item * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__Item(struct soap *soap, const std::vector<ns1__Item * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Item);
	soap_out_std__vectorTemplateOfPointerTons1__Item(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Item(struct soap *soap, const char *tag, int id, const std::vector<ns1__Item * >*a, const char *type)
{
	for (std::vector<ns1__Item * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__Item(soap, tag, id, &(*i), "ns1:Item"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Item * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__Item(struct soap *soap, std::vector<ns1__Item * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__Item(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Item * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Item(struct soap *soap, const char *tag, std::vector<ns1__Item * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__Item(soap, -1)))
			return NULL;
	ns1__Item *n;
	ns1__Item **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__Item(soap, tag, NULL, "ns1:Item")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Item, a, 1);
		}
		else
		{	soap_default_PointerTons1__Item(soap, &n);
			if (!soap_in_PointerTons1__Item(soap, tag, &n, "ns1:Item"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__Item * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__Item(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__Item(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__Item(struct soap *soap, std::vector<ns1__Item * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__Item * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__Item(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Item(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Item, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__Item * >;
		if (size)
			*size = sizeof(std::vector<ns1__Item * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__Item * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__Item * >);
	}
	return (std::vector<ns1__Item * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, std::vector<ns1__ImAddress * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ImAddress))
		soap_mark_std__vectorTemplateOfPointerTons1__ImAddress(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, const std::vector<ns1__ImAddress * >*a)
{
	for (std::vector<ns1__ImAddress * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__ImAddress(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, std::vector<ns1__ImAddress * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, const std::vector<ns1__ImAddress * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ImAddress);
	soap_out_std__vectorTemplateOfPointerTons1__ImAddress(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, const char *tag, int id, const std::vector<ns1__ImAddress * >*a, const char *type)
{
	for (std::vector<ns1__ImAddress * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__ImAddress(soap, tag, id, &(*i), "ns1:ImAddress"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ImAddress * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, std::vector<ns1__ImAddress * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__ImAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__ImAddress * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, const char *tag, std::vector<ns1__ImAddress * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__ImAddress(soap, -1)))
			return NULL;
	ns1__ImAddress *n;
	ns1__ImAddress **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__ImAddress(soap, tag, NULL, "ns1:ImAddress")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ImAddress, a, 1);
		}
		else
		{	soap_default_PointerTons1__ImAddress(soap, &n);
			if (!soap_in_PointerTons1__ImAddress(soap, tag, &n, "ns1:ImAddress"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__ImAddress * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__ImAddress(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, std::vector<ns1__ImAddress * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__ImAddress * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__ImAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ImAddress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ImAddress, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__ImAddress * >;
		if (size)
			*size = sizeof(std::vector<ns1__ImAddress * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__ImAddress * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__ImAddress * >);
	}
	return (std::vector<ns1__ImAddress * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, std::vector<ns1__GroupMember * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupMember))
		soap_mark_std__vectorTemplateOfPointerTons1__GroupMember(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, const std::vector<ns1__GroupMember * >*a)
{
	for (std::vector<ns1__GroupMember * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__GroupMember(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, std::vector<ns1__GroupMember * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, const std::vector<ns1__GroupMember * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupMember);
	soap_out_std__vectorTemplateOfPointerTons1__GroupMember(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, const char *tag, int id, const std::vector<ns1__GroupMember * >*a, const char *type)
{
	for (std::vector<ns1__GroupMember * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__GroupMember(soap, tag, id, &(*i), "ns1:GroupMember"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__GroupMember * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, std::vector<ns1__GroupMember * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__GroupMember(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__GroupMember * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, const char *tag, std::vector<ns1__GroupMember * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__GroupMember(soap, -1)))
			return NULL;
	ns1__GroupMember *n;
	ns1__GroupMember **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__GroupMember(soap, tag, NULL, "ns1:GroupMember")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupMember, a, 1);
		}
		else
		{	soap_default_PointerTons1__GroupMember(soap, &n);
			if (!soap_in_PointerTons1__GroupMember(soap, tag, &n, "ns1:GroupMember"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__GroupMember * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__GroupMember(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, std::vector<ns1__GroupMember * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__GroupMember * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__GroupMember(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__GroupMember(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupMember, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__GroupMember * >;
		if (size)
			*size = sizeof(std::vector<ns1__GroupMember * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__GroupMember * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__GroupMember * >);
	}
	return (std::vector<ns1__GroupMember * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, std::vector<ns1__FreeBusyInfo * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyInfo))
		soap_mark_std__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, const std::vector<ns1__FreeBusyInfo * >*a)
{
	for (std::vector<ns1__FreeBusyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__FreeBusyInfo(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, std::vector<ns1__FreeBusyInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, const std::vector<ns1__FreeBusyInfo * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyInfo);
	soap_out_std__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, const char *tag, int id, const std::vector<ns1__FreeBusyInfo * >*a, const char *type)
{
	for (std::vector<ns1__FreeBusyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__FreeBusyInfo(soap, tag, id, &(*i), "ns1:FreeBusyInfo"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__FreeBusyInfo * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, std::vector<ns1__FreeBusyInfo * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__FreeBusyInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, const char *tag, std::vector<ns1__FreeBusyInfo * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, -1)))
			return NULL;
	ns1__FreeBusyInfo *n;
	ns1__FreeBusyInfo **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__FreeBusyInfo(soap, tag, NULL, "ns1:FreeBusyInfo")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyInfo, a, 1);
		}
		else
		{	soap_default_PointerTons1__FreeBusyInfo(soap, &n);
			if (!soap_in_PointerTons1__FreeBusyInfo(soap, tag, &n, "ns1:FreeBusyInfo"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__FreeBusyInfo * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, std::vector<ns1__FreeBusyInfo * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__FreeBusyInfo * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__FreeBusyInfo * >;
		if (size)
			*size = sizeof(std::vector<ns1__FreeBusyInfo * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__FreeBusyInfo * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__FreeBusyInfo * >);
	}
	return (std::vector<ns1__FreeBusyInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, std::vector<ns1__FreeBusyUser * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyUser))
		soap_mark_std__vectorTemplateOfPointerTons1__FreeBusyUser(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, const std::vector<ns1__FreeBusyUser * >*a)
{
	for (std::vector<ns1__FreeBusyUser * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__FreeBusyUser(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, std::vector<ns1__FreeBusyUser * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, const std::vector<ns1__FreeBusyUser * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyUser);
	soap_out_std__vectorTemplateOfPointerTons1__FreeBusyUser(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, const char *tag, int id, const std::vector<ns1__FreeBusyUser * >*a, const char *type)
{
	for (std::vector<ns1__FreeBusyUser * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__FreeBusyUser(soap, tag, id, &(*i), "ns1:FreeBusyUser"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__FreeBusyUser * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, std::vector<ns1__FreeBusyUser * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__FreeBusyUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__FreeBusyUser * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, const char *tag, std::vector<ns1__FreeBusyUser * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__FreeBusyUser(soap, -1)))
			return NULL;
	ns1__FreeBusyUser *n;
	ns1__FreeBusyUser **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__FreeBusyUser(soap, tag, NULL, "ns1:FreeBusyUser")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyUser, a, 1);
		}
		else
		{	soap_default_PointerTons1__FreeBusyUser(soap, &n);
			if (!soap_in_PointerTons1__FreeBusyUser(soap, tag, &n, "ns1:FreeBusyUser"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__FreeBusyUser * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, std::vector<ns1__FreeBusyUser * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__FreeBusyUser * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__FreeBusyUser * >;
		if (size)
			*size = sizeof(std::vector<ns1__FreeBusyUser * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__FreeBusyUser * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__FreeBusyUser * >);
	}
	return (std::vector<ns1__FreeBusyUser * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, std::vector<ns1__FreeBusyBlock * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyBlock))
		soap_mark_std__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, const std::vector<ns1__FreeBusyBlock * >*a)
{
	for (std::vector<ns1__FreeBusyBlock * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__FreeBusyBlock(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, std::vector<ns1__FreeBusyBlock * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, const std::vector<ns1__FreeBusyBlock * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyBlock);
	soap_out_std__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, const char *tag, int id, const std::vector<ns1__FreeBusyBlock * >*a, const char *type)
{
	for (std::vector<ns1__FreeBusyBlock * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__FreeBusyBlock(soap, tag, id, &(*i), "ns1:FreeBusyBlock"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__FreeBusyBlock * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, std::vector<ns1__FreeBusyBlock * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__FreeBusyBlock * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, const char *tag, std::vector<ns1__FreeBusyBlock * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, -1)))
			return NULL;
	ns1__FreeBusyBlock *n;
	ns1__FreeBusyBlock **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__FreeBusyBlock(soap, tag, NULL, "ns1:FreeBusyBlock")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyBlock, a, 1);
		}
		else
		{	soap_default_PointerTons1__FreeBusyBlock(soap, &n);
			if (!soap_in_PointerTons1__FreeBusyBlock(soap, tag, &n, "ns1:FreeBusyBlock"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__FreeBusyBlock * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyBlock(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, std::vector<ns1__FreeBusyBlock * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__FreeBusyBlock * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyBlock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__FreeBusyBlock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FreeBusyBlock, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__FreeBusyBlock * >;
		if (size)
			*size = sizeof(std::vector<ns1__FreeBusyBlock * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__FreeBusyBlock * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__FreeBusyBlock * >);
	}
	return (std::vector<ns1__FreeBusyBlock * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Folder(struct soap *soap, std::vector<ns1__Folder * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Folder))
		soap_mark_std__vectorTemplateOfPointerTons1__Folder(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__Folder(struct soap *soap, const std::vector<ns1__Folder * >*a)
{
	for (std::vector<ns1__Folder * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__Folder(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Folder(struct soap *soap, std::vector<ns1__Folder * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__Folder(struct soap *soap, const std::vector<ns1__Folder * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Folder);
	soap_out_std__vectorTemplateOfPointerTons1__Folder(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Folder(struct soap *soap, const char *tag, int id, const std::vector<ns1__Folder * >*a, const char *type)
{
	for (std::vector<ns1__Folder * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__Folder(soap, tag, id, &(*i), "ns1:Folder"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Folder * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__Folder(struct soap *soap, std::vector<ns1__Folder * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__Folder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Folder * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Folder(struct soap *soap, const char *tag, std::vector<ns1__Folder * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__Folder(soap, -1)))
			return NULL;
	ns1__Folder *n;
	ns1__Folder **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__Folder(soap, tag, NULL, "ns1:Folder")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Folder, a, 1);
		}
		else
		{	soap_default_PointerTons1__Folder(soap, &n);
			if (!soap_in_PointerTons1__Folder(soap, tag, &n, "ns1:Folder"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__Folder * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__Folder(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__Folder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__Folder(struct soap *soap, std::vector<ns1__Folder * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__Folder * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__Folder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Folder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Folder, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__Folder * >;
		if (size)
			*size = sizeof(std::vector<ns1__Folder * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__Folder * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__Folder * >);
	}
	return (std::vector<ns1__Folder * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, std::vector<ns1__FolderACLEntry * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FolderACLEntry))
		soap_mark_std__vectorTemplateOfPointerTons1__FolderACLEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, const std::vector<ns1__FolderACLEntry * >*a)
{
	for (std::vector<ns1__FolderACLEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__FolderACLEntry(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, std::vector<ns1__FolderACLEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, const std::vector<ns1__FolderACLEntry * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FolderACLEntry);
	soap_out_std__vectorTemplateOfPointerTons1__FolderACLEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, const char *tag, int id, const std::vector<ns1__FolderACLEntry * >*a, const char *type)
{
	for (std::vector<ns1__FolderACLEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__FolderACLEntry(soap, tag, id, &(*i), "ns1:FolderACLEntry"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__FolderACLEntry * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, std::vector<ns1__FolderACLEntry * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__FolderACLEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__FolderACLEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, const char *tag, std::vector<ns1__FolderACLEntry * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__FolderACLEntry(soap, -1)))
			return NULL;
	ns1__FolderACLEntry *n;
	ns1__FolderACLEntry **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__FolderACLEntry(soap, tag, NULL, "ns1:FolderACLEntry")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FolderACLEntry, a, 1);
		}
		else
		{	soap_default_PointerTons1__FolderACLEntry(soap, &n);
			if (!soap_in_PointerTons1__FolderACLEntry(soap, tag, &n, "ns1:FolderACLEntry"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__FolderACLEntry * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__FolderACLEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, std::vector<ns1__FolderACLEntry * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__FolderACLEntry * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__FolderACLEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__FolderACLEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FolderACLEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__FolderACLEntry * >;
		if (size)
			*size = sizeof(std::vector<ns1__FolderACLEntry * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__FolderACLEntry * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__FolderACLEntry * >);
	}
	return (std::vector<ns1__FolderACLEntry * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfstd__string))
		soap_mark_std__vectorTemplateOfstd__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_std__string(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfstd__string);
	soap_out_std__vectorTemplateOfstd__string(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_std__string(soap, tag, id, &(*i), "xsd:string"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_get_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfstd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
			return NULL;
	std::string n;
	std::string *p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_std__string(soap, tag, NULL, "xsd:string")))
				break;
			soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfstd__string, a, 0);
		}
		else
		{	soap_default_std__string(soap, &n);
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Custom(struct soap *soap, std::vector<ns1__Custom * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Custom))
		soap_mark_std__vectorTemplateOfPointerTons1__Custom(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__Custom(struct soap *soap, const std::vector<ns1__Custom * >*a)
{
	for (std::vector<ns1__Custom * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__Custom(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Custom(struct soap *soap, std::vector<ns1__Custom * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__Custom(struct soap *soap, const std::vector<ns1__Custom * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Custom);
	soap_out_std__vectorTemplateOfPointerTons1__Custom(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Custom(struct soap *soap, const char *tag, int id, const std::vector<ns1__Custom * >*a, const char *type)
{
	for (std::vector<ns1__Custom * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__Custom(soap, tag, id, &(*i), "ns1:Custom"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Custom * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__Custom(struct soap *soap, std::vector<ns1__Custom * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__Custom(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Custom * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Custom(struct soap *soap, const char *tag, std::vector<ns1__Custom * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__Custom(soap, -1)))
			return NULL;
	ns1__Custom *n;
	ns1__Custom **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__Custom(soap, tag, NULL, "ns1:Custom")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Custom, a, 1);
		}
		else
		{	soap_default_PointerTons1__Custom(soap, &n);
			if (!soap_in_PointerTons1__Custom(soap, tag, &n, "ns1:Custom"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__Custom * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__Custom(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__Custom(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__Custom(struct soap *soap, std::vector<ns1__Custom * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__Custom * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__Custom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Custom(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Custom, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__Custom * >;
		if (size)
			*size = sizeof(std::vector<ns1__Custom * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__Custom * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__Custom * >);
	}
	return (std::vector<ns1__Custom * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__uid(struct soap *soap, std::vector<std::string >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfns1__uid))
		soap_mark_std__vectorTemplateOfns1__uid(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfns1__uid(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_ns1__uid(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__uid(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfns1__uid(struct soap *soap, const std::vector<std::string >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfns1__uid);
	soap_out_std__vectorTemplateOfns1__uid(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__uid(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_ns1__uid(soap, tag, id, &(*i), "ns1:uid"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_get_std__vectorTemplateOfns1__uid(struct soap *soap, std::vector<std::string >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfns1__uid(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__uid(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfns1__uid(soap, -1)))
			return NULL;
	std::string n;
	std::string *p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_ns1__uid(soap, tag, NULL, "ns1:uid")))
				break;
			soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfns1__uid, a, 0);
		}
		else
		{	soap_default_ns1__uid(soap, &n);
			if (!soap_in_ns1__uid(soap, tag, &n, "ns1:uid"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfns1__uid(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfns1__uid(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfns1__uid(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfns1__uid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__uid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns1__uid, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Category(struct soap *soap, std::vector<ns1__Category * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Category))
		soap_mark_std__vectorTemplateOfPointerTons1__Category(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__Category(struct soap *soap, const std::vector<ns1__Category * >*a)
{
	for (std::vector<ns1__Category * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__Category(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Category(struct soap *soap, std::vector<ns1__Category * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__Category(struct soap *soap, const std::vector<ns1__Category * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Category);
	soap_out_std__vectorTemplateOfPointerTons1__Category(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Category(struct soap *soap, const char *tag, int id, const std::vector<ns1__Category * >*a, const char *type)
{
	for (std::vector<ns1__Category * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__Category(soap, tag, id, &(*i), "ns1:Category"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Category * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__Category(struct soap *soap, std::vector<ns1__Category * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__Category(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__Category * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Category(struct soap *soap, const char *tag, std::vector<ns1__Category * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__Category(soap, -1)))
			return NULL;
	ns1__Category *n;
	ns1__Category **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__Category(soap, tag, NULL, "ns1:Category")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Category, a, 1);
		}
		else
		{	soap_default_PointerTons1__Category(soap, &n);
			if (!soap_in_PointerTons1__Category(soap, tag, &n, "ns1:Category"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__Category * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__Category(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__Category(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__Category(struct soap *soap, std::vector<ns1__Category * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__Category * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__Category(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Category(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Category, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__Category * >;
		if (size)
			*size = sizeof(std::vector<ns1__Category * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__Category * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__Category * >);
	}
	return (std::vector<ns1__Category * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, std::vector<ns1__AttachmentItemInfo * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttachmentItemInfo))
		soap_mark_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, const std::vector<ns1__AttachmentItemInfo * >*a)
{
	for (std::vector<ns1__AttachmentItemInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__AttachmentItemInfo(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, std::vector<ns1__AttachmentItemInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, const std::vector<ns1__AttachmentItemInfo * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttachmentItemInfo);
	soap_out_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, const char *tag, int id, const std::vector<ns1__AttachmentItemInfo * >*a, const char *type)
{
	for (std::vector<ns1__AttachmentItemInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__AttachmentItemInfo(soap, tag, id, &(*i), "ns1:AttachmentItemInfo"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__AttachmentItemInfo * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, std::vector<ns1__AttachmentItemInfo * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__AttachmentItemInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, const char *tag, std::vector<ns1__AttachmentItemInfo * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, -1)))
			return NULL;
	ns1__AttachmentItemInfo *n;
	ns1__AttachmentItemInfo **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__AttachmentItemInfo(soap, tag, NULL, "ns1:AttachmentItemInfo")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttachmentItemInfo, a, 1);
		}
		else
		{	soap_default_PointerTons1__AttachmentItemInfo(soap, &n);
			if (!soap_in_PointerTons1__AttachmentItemInfo(soap, tag, &n, "ns1:AttachmentItemInfo"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__AttachmentItemInfo * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, std::vector<ns1__AttachmentItemInfo * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__AttachmentItemInfo * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__AttachmentItemInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttachmentItemInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__AttachmentItemInfo * >;
		if (size)
			*size = sizeof(std::vector<ns1__AttachmentItemInfo * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__AttachmentItemInfo * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__AttachmentItemInfo * >);
	}
	return (std::vector<ns1__AttachmentItemInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, std::vector<ns1__AddressBook * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AddressBook))
		soap_mark_std__vectorTemplateOfPointerTons1__AddressBook(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, const std::vector<ns1__AddressBook * >*a)
{
	for (std::vector<ns1__AddressBook * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__AddressBook(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, std::vector<ns1__AddressBook * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, const std::vector<ns1__AddressBook * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AddressBook);
	soap_out_std__vectorTemplateOfPointerTons1__AddressBook(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, const char *tag, int id, const std::vector<ns1__AddressBook * >*a, const char *type)
{
	for (std::vector<ns1__AddressBook * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__AddressBook(soap, tag, id, &(*i), "ns1:AddressBook"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__AddressBook * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, std::vector<ns1__AddressBook * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__AddressBook(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__AddressBook * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, const char *tag, std::vector<ns1__AddressBook * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__AddressBook(soap, -1)))
			return NULL;
	ns1__AddressBook *n;
	ns1__AddressBook **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__AddressBook(soap, tag, NULL, "ns1:AddressBook")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AddressBook, a, 1);
		}
		else
		{	soap_default_PointerTons1__AddressBook(soap, &n);
			if (!soap_in_PointerTons1__AddressBook(soap, tag, &n, "ns1:AddressBook"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__AddressBook * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__AddressBook(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, std::vector<ns1__AddressBook * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__AddressBook * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__AddressBook(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__AddressBook(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AddressBook, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__AddressBook * >;
		if (size)
			*size = sizeof(std::vector<ns1__AddressBook * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__AddressBook * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__AddressBook * >);
	}
	return (std::vector<ns1__AddressBook * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, std::vector<ns1__AccessRightEntry * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessRightEntry))
		soap_mark_std__vectorTemplateOfPointerTons1__AccessRightEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, const std::vector<ns1__AccessRightEntry * >*a)
{
	for (std::vector<ns1__AccessRightEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__AccessRightEntry(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, std::vector<ns1__AccessRightEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, const std::vector<ns1__AccessRightEntry * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessRightEntry);
	soap_out_std__vectorTemplateOfPointerTons1__AccessRightEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, const char *tag, int id, const std::vector<ns1__AccessRightEntry * >*a, const char *type)
{
	for (std::vector<ns1__AccessRightEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__AccessRightEntry(soap, tag, id, &(*i), "ns1:AccessRightEntry"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__AccessRightEntry * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, std::vector<ns1__AccessRightEntry * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__AccessRightEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__AccessRightEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, const char *tag, std::vector<ns1__AccessRightEntry * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__AccessRightEntry(soap, -1)))
			return NULL;
	ns1__AccessRightEntry *n;
	ns1__AccessRightEntry **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__AccessRightEntry(soap, tag, NULL, "ns1:AccessRightEntry")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessRightEntry, a, 1);
		}
		else
		{	soap_default_PointerTons1__AccessRightEntry(soap, &n);
			if (!soap_in_PointerTons1__AccessRightEntry(soap, tag, &n, "ns1:AccessRightEntry"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__AccessRightEntry * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__AccessRightEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, std::vector<ns1__AccessRightEntry * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__AccessRightEntry * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__AccessRightEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__AccessRightEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessRightEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__AccessRightEntry * >;
		if (size)
			*size = sizeof(std::vector<ns1__AccessRightEntry * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__AccessRightEntry * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__AccessRightEntry * >);
	}
	return (std::vector<ns1__AccessRightEntry * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, std::vector<ns1__AccessControlListEntry * >const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessControlListEntry))
		soap_mark_std__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_std__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, const std::vector<ns1__AccessControlListEntry * >*a)
{
	for (std::vector<ns1__AccessControlListEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_mark_PointerTons1__AccessControlListEntry(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, std::vector<ns1__AccessControlListEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, const std::vector<ns1__AccessControlListEntry * >*a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessControlListEntry);
	soap_out_std__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, const char *tag, int id, const std::vector<ns1__AccessControlListEntry * >*a, const char *type)
{
	for (std::vector<ns1__AccessControlListEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		if (soap_out_PointerTons1__AccessControlListEntry(soap, tag, id, &(*i), "ns1:AccessControlListEntry"))
			return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__AccessControlListEntry * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, std::vector<ns1__AccessControlListEntry * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ns1__AccessControlListEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, const char *tag, std::vector<ns1__AccessControlListEntry * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = soap_new_std__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, -1)))
			return NULL;
	ns1__AccessControlListEntry *n;
	ns1__AccessControlListEntry **p;
	do
	{	if (*soap->id || *soap->href)
		{	if (!(p = soap_in_PointerTons1__AccessControlListEntry(soap, tag, NULL, "ns1:AccessControlListEntry")))
				break;
			if (*p)
				a->insert(a->end(), *p);
			else
				soap_container_id_forward(soap, soap->href, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessControlListEntry, a, 1);
		}
		else
		{	soap_default_PointerTons1__AccessControlListEntry(soap, &n);
			if (!soap_in_PointerTons1__AccessControlListEntry(soap, tag, &n, "ns1:AccessControlListEntry"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_peek_element(soap));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__AccessControlListEntry * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__AccessControlListEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, std::vector<ns1__AccessControlListEntry * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ns1__AccessControlListEntry * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTons1__AccessControlListEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__AccessControlListEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccessControlListEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__AccessControlListEntry * >;
		if (size)
			*size = sizeof(std::vector<ns1__AccessControlListEntry * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__AccessControlListEntry * >[n];
		if (size)
			*size = n * sizeof(std::vector<ns1__AccessControlListEntry * >);
	}
	return (std::vector<ns1__AccessControlListEntry * >*)cp->ptr;
}

SOAP_END_NAMESPACE(soap)

/* end of soapC.cpp */
