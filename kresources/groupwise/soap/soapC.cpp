/* soapC.cpp
   Generated by gSOAP 2.7.3 from ./groupwise.h
   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.3 2006-05-18 13:53:47 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version != 1 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_ngwt__DayOfMonth:
		return soap_in_ngwt__DayOfMonth(soap, NULL, NULL, "ngwt:DayOfMonth");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_ngwt__WeekOfYear:
		return soap_in_ngwt__WeekOfYear(soap, NULL, NULL, "ngwt:WeekOfYear");
	case SOAP_TYPE_ngwt__DayOfYear:
		return soap_in_ngwt__DayOfYear(soap, NULL, NULL, "ngwt:DayOfYear");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_ngwt__GMTOffset:
		return soap_in_ngwt__GMTOffset(soap, NULL, NULL, "ngwt:GMTOffset");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_ngwt__Month:
		return soap_in_ngwt__Month(soap, NULL, NULL, "ngwt:Month");
	case SOAP_TYPE_ngwt__Minute:
		return soap_in_ngwt__Minute(soap, NULL, NULL, "ngwt:Minute");
	case SOAP_TYPE_ngwt__Hour:
		return soap_in_ngwt__Hour(soap, NULL, NULL, "ngwt:Hour");
	case SOAP_TYPE_ngwt__Day:
		return soap_in_ngwt__Day(soap, NULL, NULL, "ngwt:Day");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_in_unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ngwe__ItemType:
		return soap_in_ngwe__ItemType(soap, NULL, NULL, "ngwe:ItemType");
	case SOAP_TYPE_ngwe__Field:
		return soap_in_ngwe__Field(soap, NULL, NULL, "ngwe:Field");
	case SOAP_TYPE_ngwe__EventType:
		return soap_in_ngwe__EventType(soap, NULL, NULL, "ngwe:EventType");
	case SOAP_TYPE_ngwt__WeekDay:
		return soap_in_ngwt__WeekDay(soap, NULL, NULL, "ngwt:WeekDay");
	case SOAP_TYPE_ngwt__VersionStatus:
		return soap_in_ngwt__VersionStatus(soap, NULL, NULL, "ngwt:VersionStatus");
	case SOAP_TYPE_ngwt__VersionEventType:
		return soap_in_ngwt__VersionEventType(soap, NULL, NULL, "ngwt:VersionEventType");
	case SOAP_TYPE_ngwt__StatusTrackingOptions:
		return soap_in_ngwt__StatusTrackingOptions(soap, NULL, NULL, "ngwt:StatusTrackingOptions");
	case SOAP_TYPE_ngwt__RuleActionType:
		return soap_in_ngwt__RuleActionType(soap, NULL, NULL, "ngwt:RuleActionType");
	case SOAP_TYPE_ngwt__RetractType:
		return soap_in_ngwt__RetractType(soap, NULL, NULL, "ngwt:RetractType");
	case SOAP_TYPE_ngwt__RecipientType:
		return soap_in_ngwt__RecipientType(soap, NULL, NULL, "ngwt:RecipientType");
	case SOAP_TYPE_ngwt__PostalAddressType:
		return soap_in_ngwt__PostalAddressType(soap, NULL, NULL, "ngwt:PostalAddressType");
	case SOAP_TYPE_ngwt__PhoneNumberType:
		return soap_in_ngwt__PhoneNumberType(soap, NULL, NULL, "ngwt:PhoneNumberType");
	case SOAP_TYPE_ngwt__OccurrenceType:
		return soap_in_ngwt__OccurrenceType(soap, NULL, NULL, "ngwt:OccurrenceType");
	case SOAP_TYPE_ngwt__NotificationType:
		return soap_in_ngwt__NotificationType(soap, NULL, NULL, "ngwt:NotificationType");
	case SOAP_TYPE_ngwt__MessageType:
		return soap_in_ngwt__MessageType(soap, NULL, NULL, "ngwt:MessageType");
	case SOAP_TYPE_ngwt__MessageList:
		return soap_in_ngwt__MessageList(soap, NULL, NULL, "ngwt:MessageList");
	case SOAP_TYPE_ngwt__LinkType:
		return soap_in_ngwt__LinkType(soap, NULL, NULL, "ngwt:LinkType");
	case SOAP_TYPE_ngwt__JunkMatchType:
		return soap_in_ngwt__JunkMatchType(soap, NULL, NULL, "ngwt:JunkMatchType");
	case SOAP_TYPE_ngwt__JunkHandlingListType:
		return soap_in_ngwt__JunkHandlingListType(soap, NULL, NULL, "ngwt:JunkHandlingListType");
	case SOAP_TYPE_ngwt__ItemSource:
		return soap_in_ngwt__ItemSource(soap, NULL, NULL, "ngwt:ItemSource");
	case SOAP_TYPE_ngwt__ItemSecurity:
		return soap_in_ngwt__ItemSecurity(soap, NULL, NULL, "ngwt:ItemSecurity");
	case SOAP_TYPE_ngwt__ItemOptionsPriority:
		return soap_in_ngwt__ItemOptionsPriority(soap, NULL, NULL, "ngwt:ItemOptionsPriority");
	case SOAP_TYPE_ngwt__ItemClass:
		return soap_in_ngwt__ItemClass(soap, NULL, NULL, "ngwt:ItemClass");
	case SOAP_TYPE_ngwt__Frequency:
		return soap_in_ngwt__Frequency(soap, NULL, NULL, "ngwt:Frequency");
	case SOAP_TYPE_ngwt__FolderType:
		return soap_in_ngwt__FolderType(soap, NULL, NULL, "ngwt:FolderType");
	case SOAP_TYPE_ngwt__FolderACLStatus:
		return soap_in_ngwt__FolderACLStatus(soap, NULL, NULL, "ngwt:FolderACLStatus");
	case SOAP_TYPE_ngwt__FilterOp:
		return soap_in_ngwt__FilterOp(soap, NULL, NULL, "ngwt:FilterOp");
	case SOAP_TYPE_ngwt__FilterDate:
		return soap_in_ngwt__FilterDate(soap, NULL, NULL, "ngwt:FilterDate");
	case SOAP_TYPE_ngwt__Execution:
		return soap_in_ngwt__Execution(soap, NULL, NULL, "ngwt:Execution");
	case SOAP_TYPE_ngwt__DistributionType:
		return soap_in_ngwt__DistributionType(soap, NULL, NULL, "ngwt:DistributionType");
	case SOAP_TYPE_ngwt__DeltaSyncType:
		return soap_in_ngwt__DeltaSyncType(soap, NULL, NULL, "ngwt:DeltaSyncType");
	case SOAP_TYPE_ngwt__CustomType:
		return soap_in_ngwt__CustomType(soap, NULL, NULL, "ngwt:CustomType");
	case SOAP_TYPE_ngwt__CursorSeek:
		return soap_in_ngwt__CursorSeek(soap, NULL, NULL, "ngwt:CursorSeek");
	case SOAP_TYPE_ngwt__ContactType:
		return soap_in_ngwt__ContactType(soap, NULL, NULL, "ngwt:ContactType");
	case SOAP_TYPE_ngwt__CategoryType:
		return soap_in_ngwt__CategoryType(soap, NULL, NULL, "ngwt:CategoryType");
	case SOAP_TYPE_ngwt__CalendarFolderFlags:
		return soap_in_ngwt__CalendarFolderFlags(soap, NULL, NULL, "ngwt:CalendarFolderFlags");
	case SOAP_TYPE_ngwt__AppointmentConflict:
		return soap_in_ngwt__AppointmentConflict(soap, NULL, NULL, "ngwt:AppointmentConflict");
	case SOAP_TYPE_ngwt__AgeAction:
		return soap_in_ngwt__AgeAction(soap, NULL, NULL, "ngwt:AgeAction");
	case SOAP_TYPE_ngwt__AcceptLevel:
		return soap_in_ngwt__AcceptLevel(soap, NULL, NULL, "ngwt:AcceptLevel");
	case SOAP_TYPE_ngwe__ItemTypeList:
		return soap_in_ngwe__ItemTypeList(soap, NULL, NULL, "ngwe:ItemTypeList");
	case SOAP_TYPE_ngwe__FieldList:
		return soap_in_ngwe__FieldList(soap, NULL, NULL, "ngwe:FieldList");
	case SOAP_TYPE_ngwt__MessageTypeList:
		return soap_in_ngwt__MessageTypeList(soap, NULL, NULL, "ngwt:MessageTypeList");
	case SOAP_TYPE_ngwt__ItemSourceList:
		return soap_in_ngwt__ItemSourceList(soap, NULL, NULL, "ngwt:ItemSourceList");
	case SOAP_TYPE_ngwt__UUID:
		return soap_in_ngwt__UUID(soap, NULL, NULL, "ngwt:UUID");
	case SOAP_TYPE_ngwt__uid:
		return soap_in_ngwt__uid(soap, NULL, NULL, "ngwt:uid");
	case SOAP_TYPE_ngwt__View:
		return soap_in_ngwt__View(soap, NULL, NULL, "ngwt:View");
	case SOAP_TYPE__ngwe__removeEventsResponse:
		return soap_in__ngwe__removeEventsResponse(soap, NULL, NULL, "ngwe:removeEventsResponse");
	case SOAP_TYPE__ngwe__removeEventsRequest:
		return soap_in__ngwe__removeEventsRequest(soap, NULL, NULL, "ngwe:removeEventsRequest");
	case SOAP_TYPE__ngwe__removeEventConfigurationResponse:
		return soap_in__ngwe__removeEventConfigurationResponse(soap, NULL, NULL, "ngwe:removeEventConfigurationResponse");
	case SOAP_TYPE__ngwe__removeEventConfigurationRequest:
		return soap_in__ngwe__removeEventConfigurationRequest(soap, NULL, NULL, "ngwe:removeEventConfigurationRequest");
	case SOAP_TYPE__ngwe__getEventsResponse:
		return soap_in__ngwe__getEventsResponse(soap, NULL, NULL, "ngwe:getEventsResponse");
	case SOAP_TYPE__ngwe__getEventsRequest:
		return soap_in__ngwe__getEventsRequest(soap, NULL, NULL, "ngwe:getEventsRequest");
	case SOAP_TYPE__ngwe__getEventConfigurationResponse:
		return soap_in__ngwe__getEventConfigurationResponse(soap, NULL, NULL, "ngwe:getEventConfigurationResponse");
	case SOAP_TYPE__ngwe__getEventConfigurationRequest:
		return soap_in__ngwe__getEventConfigurationRequest(soap, NULL, NULL, "ngwe:getEventConfigurationRequest");
	case SOAP_TYPE__ngwe__configureEventsResponse:
		return soap_in__ngwe__configureEventsResponse(soap, NULL, NULL, "ngwe:configureEventsResponse");
	case SOAP_TYPE__ngwe__configureEventsRequest:
		return soap_in__ngwe__configureEventsRequest(soap, NULL, NULL, "ngwe:configureEventsRequest");
	case SOAP_TYPE__ngwe__cleanEventConfigurationResponse:
		return soap_in__ngwe__cleanEventConfigurationResponse(soap, NULL, NULL, "ngwe:cleanEventConfigurationResponse");
	case SOAP_TYPE__ngwe__cleanEventConfigurationRequest:
		return soap_in__ngwe__cleanEventConfigurationRequest(soap, NULL, NULL, "ngwe:cleanEventConfigurationRequest");
	case SOAP_TYPE_ngwe__Notify:
		return soap_in_ngwe__Notify(soap, NULL, NULL, "ngwe:Notify");
	case SOAP_TYPE_ngwe__EventTypeList:
		return soap_in_ngwe__EventTypeList(soap, NULL, NULL, "ngwe:EventTypeList");
	case SOAP_TYPE_ngwe__EventsList:
		return soap_in_ngwe__EventsList(soap, NULL, NULL, "ngwe:EventsList");
	case SOAP_TYPE_ngwe__Events:
		return soap_in_ngwe__Events(soap, NULL, NULL, "ngwe:Events");
	case SOAP_TYPE_ngwe__EventList:
		return soap_in_ngwe__EventList(soap, NULL, NULL, "ngwe:EventList");
	case SOAP_TYPE_ngwe__EventDefinition:
		return soap_in_ngwe__EventDefinition(soap, NULL, NULL, "ngwe:EventDefinition");
	case SOAP_TYPE_ngwe__Event:
		return soap_in_ngwe__Event(soap, NULL, NULL, "ngwe:Event");
	case SOAP_TYPE_ngwe__ContainerList:
		return soap_in_ngwe__ContainerList(soap, NULL, NULL, "ngwe:ContainerList");
	case SOAP_TYPE__ngwm__updateVersionStatusResponse:
		return soap_in__ngwm__updateVersionStatusResponse(soap, NULL, NULL, "ngwm:updateVersionStatusResponse");
	case SOAP_TYPE__ngwm__updateVersionStatusRequest:
		return soap_in__ngwm__updateVersionStatusRequest(soap, NULL, NULL, "ngwm:updateVersionStatusRequest");
	case SOAP_TYPE__ngwm__uncompleteResponse:
		return soap_in__ngwm__uncompleteResponse(soap, NULL, NULL, "ngwm:uncompleteResponse");
	case SOAP_TYPE__ngwm__uncompleteRequest:
		return soap_in__ngwm__uncompleteRequest(soap, NULL, NULL, "ngwm:uncompleteRequest");
	case SOAP_TYPE__ngwm__unacceptResponse:
		return soap_in__ngwm__unacceptResponse(soap, NULL, NULL, "ngwm:unacceptResponse");
	case SOAP_TYPE__ngwm__unacceptRequest:
		return soap_in__ngwm__unacceptRequest(soap, NULL, NULL, "ngwm:unacceptRequest");
	case SOAP_TYPE__ngwm__startFreeBusySessionResponse:
		return soap_in__ngwm__startFreeBusySessionResponse(soap, NULL, NULL, "ngwm:startFreeBusySessionResponse");
	case SOAP_TYPE__ngwm__startFreeBusySessionRequest:
		return soap_in__ngwm__startFreeBusySessionRequest(soap, NULL, NULL, "ngwm:startFreeBusySessionRequest");
	case SOAP_TYPE__ngwm__setTimestampResponse:
		return soap_in__ngwm__setTimestampResponse(soap, NULL, NULL, "ngwm:setTimestampResponse");
	case SOAP_TYPE__ngwm__setTimestampRequest:
		return soap_in__ngwm__setTimestampRequest(soap, NULL, NULL, "ngwm:setTimestampRequest");
	case SOAP_TYPE__ngwm__sendItemResponse:
		return soap_in__ngwm__sendItemResponse(soap, NULL, NULL, "ngwm:sendItemResponse");
	case SOAP_TYPE__ngwm__sendItemRequest:
		return soap_in__ngwm__sendItemRequest(soap, NULL, NULL, "ngwm:sendItemRequest");
	case SOAP_TYPE__ngwm__retractResponse:
		return soap_in__ngwm__retractResponse(soap, NULL, NULL, "ngwm:retractResponse");
	case SOAP_TYPE__ngwm__retractRequest:
		return soap_in__ngwm__retractRequest(soap, NULL, NULL, "ngwm:retractRequest");
	case SOAP_TYPE__ngwm__replyResponse:
		return soap_in__ngwm__replyResponse(soap, NULL, NULL, "ngwm:replyResponse");
	case SOAP_TYPE__ngwm__replyRequest:
		return soap_in__ngwm__replyRequest(soap, NULL, NULL, "ngwm:replyRequest");
	case SOAP_TYPE__ngwm__removeSignatureResponse:
		return soap_in__ngwm__removeSignatureResponse(soap, NULL, NULL, "ngwm:removeSignatureResponse");
	case SOAP_TYPE__ngwm__removeSignatureRequest:
		return soap_in__ngwm__removeSignatureRequest(soap, NULL, NULL, "ngwm:removeSignatureRequest");
	case SOAP_TYPE__ngwm__removeProxyUserResponse:
		return soap_in__ngwm__removeProxyUserResponse(soap, NULL, NULL, "ngwm:removeProxyUserResponse");
	case SOAP_TYPE__ngwm__removeProxyUserRequest:
		return soap_in__ngwm__removeProxyUserRequest(soap, NULL, NULL, "ngwm:removeProxyUserRequest");
	case SOAP_TYPE__ngwm__removeProxyAccessResponse:
		return soap_in__ngwm__removeProxyAccessResponse(soap, NULL, NULL, "ngwm:removeProxyAccessResponse");
	case SOAP_TYPE__ngwm__removeProxyAccessRequest:
		return soap_in__ngwm__removeProxyAccessRequest(soap, NULL, NULL, "ngwm:removeProxyAccessRequest");
	case SOAP_TYPE__ngwm__removeMembersResponse:
		return soap_in__ngwm__removeMembersResponse(soap, NULL, NULL, "ngwm:removeMembersResponse");
	case SOAP_TYPE__ngwm__removeMembersRequest:
		return soap_in__ngwm__removeMembersRequest(soap, NULL, NULL, "ngwm:removeMembersRequest");
	case SOAP_TYPE__ngwm__removeJunkEntryResponse:
		return soap_in__ngwm__removeJunkEntryResponse(soap, NULL, NULL, "ngwm:removeJunkEntryResponse");
	case SOAP_TYPE__ngwm__removeJunkEntryRequest:
		return soap_in__ngwm__removeJunkEntryRequest(soap, NULL, NULL, "ngwm:removeJunkEntryRequest");
	case SOAP_TYPE__ngwm__removeItemsResponse:
		return soap_in__ngwm__removeItemsResponse(soap, NULL, NULL, "ngwm:removeItemsResponse");
	case SOAP_TYPE__ngwm__removeItemsRequest:
		return soap_in__ngwm__removeItemsRequest(soap, NULL, NULL, "ngwm:removeItemsRequest");
	case SOAP_TYPE__ngwm__removeItemResponse:
		return soap_in__ngwm__removeItemResponse(soap, NULL, NULL, "ngwm:removeItemResponse");
	case SOAP_TYPE__ngwm__removeItemRequest:
		return soap_in__ngwm__removeItemRequest(soap, NULL, NULL, "ngwm:removeItemRequest");
	case SOAP_TYPE__ngwm__removeCustomDefinitionResponse:
		return soap_in__ngwm__removeCustomDefinitionResponse(soap, NULL, NULL, "ngwm:removeCustomDefinitionResponse");
	case SOAP_TYPE__ngwm__removeCustomDefinitionRequest:
		return soap_in__ngwm__removeCustomDefinitionRequest(soap, NULL, NULL, "ngwm:removeCustomDefinitionRequest");
	case SOAP_TYPE__ngwm__readCursorResponse:
		return soap_in__ngwm__readCursorResponse(soap, NULL, NULL, "ngwm:readCursorResponse");
	case SOAP_TYPE__ngwm__readCursorRequest:
		return soap_in__ngwm__readCursorRequest(soap, NULL, NULL, "ngwm:readCursorRequest");
	case SOAP_TYPE__ngwm__purgeResponse:
		return soap_in__ngwm__purgeResponse(soap, NULL, NULL, "ngwm:purgeResponse");
	case SOAP_TYPE__ngwm__purgeRequest:
		return soap_in__ngwm__purgeRequest(soap, NULL, NULL, "ngwm:purgeRequest");
	case SOAP_TYPE__ngwm__purgeDeletedItemsResponse:
		return soap_in__ngwm__purgeDeletedItemsResponse(soap, NULL, NULL, "ngwm:purgeDeletedItemsResponse");
	case SOAP_TYPE__ngwm__purgeDeletedItemsRequest:
		return soap_in__ngwm__purgeDeletedItemsRequest(soap, NULL, NULL, "ngwm:purgeDeletedItemsRequest");
	case SOAP_TYPE__ngwm__positionCursorResponse:
		return soap_in__ngwm__positionCursorResponse(soap, NULL, NULL, "ngwm:positionCursorResponse");
	case SOAP_TYPE__ngwm__positionCursorRequest:
		return soap_in__ngwm__positionCursorRequest(soap, NULL, NULL, "ngwm:positionCursorRequest");
	case SOAP_TYPE__ngwm__moveItemResponse:
		return soap_in__ngwm__moveItemResponse(soap, NULL, NULL, "ngwm:moveItemResponse");
	case SOAP_TYPE__ngwm__moveItemRequest:
		return soap_in__ngwm__moveItemRequest(soap, NULL, NULL, "ngwm:moveItemRequest");
	case SOAP_TYPE__ngwm__modifySignaturesResponse:
		return soap_in__ngwm__modifySignaturesResponse(soap, NULL, NULL, "ngwm:modifySignaturesResponse");
	case SOAP_TYPE__ngwm__modifySignaturesRequest:
		return soap_in__ngwm__modifySignaturesRequest(soap, NULL, NULL, "ngwm:modifySignaturesRequest");
	case SOAP_TYPE__ngwm__modifySettingsResponse:
		return soap_in__ngwm__modifySettingsResponse(soap, NULL, NULL, "ngwm:modifySettingsResponse");
	case SOAP_TYPE__ngwm__modifySettingsRequest:
		return soap_in__ngwm__modifySettingsRequest(soap, NULL, NULL, "ngwm:modifySettingsRequest");
	case SOAP_TYPE__ngwm__modifyProxyAccessResponse:
		return soap_in__ngwm__modifyProxyAccessResponse(soap, NULL, NULL, "ngwm:modifyProxyAccessResponse");
	case SOAP_TYPE__ngwm__modifyProxyAccessRequest:
		return soap_in__ngwm__modifyProxyAccessRequest(soap, NULL, NULL, "ngwm:modifyProxyAccessRequest");
	case SOAP_TYPE__ngwm__modifyPasswordResponse:
		return soap_in__ngwm__modifyPasswordResponse(soap, NULL, NULL, "ngwm:modifyPasswordResponse");
	case SOAP_TYPE__ngwm__modifyPasswordRequest:
		return soap_in__ngwm__modifyPasswordRequest(soap, NULL, NULL, "ngwm:modifyPasswordRequest");
	case SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse:
		return soap_in__ngwm__modifyJunkMailSettingsResponse(soap, NULL, NULL, "ngwm:modifyJunkMailSettingsResponse");
	case SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest:
		return soap_in__ngwm__modifyJunkMailSettingsRequest(soap, NULL, NULL, "ngwm:modifyJunkMailSettingsRequest");
	case SOAP_TYPE__ngwm__modifyJunkEntryResponse:
		return soap_in__ngwm__modifyJunkEntryResponse(soap, NULL, NULL, "ngwm:modifyJunkEntryResponse");
	case SOAP_TYPE__ngwm__modifyJunkEntryRequest:
		return soap_in__ngwm__modifyJunkEntryRequest(soap, NULL, NULL, "ngwm:modifyJunkEntryRequest");
	case SOAP_TYPE__ngwm__modifyItemsResponse:
		return soap_in__ngwm__modifyItemsResponse(soap, NULL, NULL, "ngwm:modifyItemsResponse");
	case SOAP_TYPE__ngwm__modifyItemsRequest:
		return soap_in__ngwm__modifyItemsRequest(soap, NULL, NULL, "ngwm:modifyItemsRequest");
	case SOAP_TYPE__ngwm__modifyItemResponse:
		return soap_in__ngwm__modifyItemResponse(soap, NULL, NULL, "ngwm:modifyItemResponse");
	case SOAP_TYPE__ngwm__modifyItemRequest:
		return soap_in__ngwm__modifyItemRequest(soap, NULL, NULL, "ngwm:modifyItemRequest");
	case SOAP_TYPE__ngwm__markUnReadResponse:
		return soap_in__ngwm__markUnReadResponse(soap, NULL, NULL, "ngwm:markUnReadResponse");
	case SOAP_TYPE__ngwm__markUnReadRequest:
		return soap_in__ngwm__markUnReadRequest(soap, NULL, NULL, "ngwm:markUnReadRequest");
	case SOAP_TYPE__ngwm__markUnPrivateResponse:
		return soap_in__ngwm__markUnPrivateResponse(soap, NULL, NULL, "ngwm:markUnPrivateResponse");
	case SOAP_TYPE__ngwm__markUnPrivateRequest:
		return soap_in__ngwm__markUnPrivateRequest(soap, NULL, NULL, "ngwm:markUnPrivateRequest");
	case SOAP_TYPE__ngwm__markReadResponse:
		return soap_in__ngwm__markReadResponse(soap, NULL, NULL, "ngwm:markReadResponse");
	case SOAP_TYPE__ngwm__markReadRequest:
		return soap_in__ngwm__markReadRequest(soap, NULL, NULL, "ngwm:markReadRequest");
	case SOAP_TYPE__ngwm__markPrivateResponse:
		return soap_in__ngwm__markPrivateResponse(soap, NULL, NULL, "ngwm:markPrivateResponse");
	case SOAP_TYPE__ngwm__markPrivateRequest:
		return soap_in__ngwm__markPrivateRequest(soap, NULL, NULL, "ngwm:markPrivateRequest");
	case SOAP_TYPE__ngwm__logoutResponse:
		return soap_in__ngwm__logoutResponse(soap, NULL, NULL, "ngwm:logoutResponse");
	case SOAP_TYPE__ngwm__logoutRequest:
		return soap_in__ngwm__logoutRequest(soap, NULL, NULL, "ngwm:logoutRequest");
	case SOAP_TYPE__ngwm__loginResponse:
		return soap_in__ngwm__loginResponse(soap, NULL, NULL, "ngwm:loginResponse");
	case SOAP_TYPE__ngwm__loginRequest:
		return soap_in__ngwm__loginRequest(soap, NULL, NULL, "ngwm:loginRequest");
	case SOAP_TYPE__ngwm__getUserListResponse:
		return soap_in__ngwm__getUserListResponse(soap, NULL, NULL, "ngwm:getUserListResponse");
	case SOAP_TYPE__ngwm__getUserListRequest:
		return soap_in__ngwm__getUserListRequest(soap, NULL, NULL, "ngwm:getUserListRequest");
	case SOAP_TYPE__ngwm__getTimezoneListResponse:
		return soap_in__ngwm__getTimezoneListResponse(soap, NULL, NULL, "ngwm:getTimezoneListResponse");
	case SOAP_TYPE__ngwm__getTimezoneListRequest:
		return soap_in__ngwm__getTimezoneListRequest(soap, NULL, NULL, "ngwm:getTimezoneListRequest");
	case SOAP_TYPE__ngwm__getTimestampResponse:
		return soap_in__ngwm__getTimestampResponse(soap, NULL, NULL, "ngwm:getTimestampResponse");
	case SOAP_TYPE__ngwm__getTimestampRequest:
		return soap_in__ngwm__getTimestampRequest(soap, NULL, NULL, "ngwm:getTimestampRequest");
	case SOAP_TYPE__ngwm__getSignaturesResponse:
		return soap_in__ngwm__getSignaturesResponse(soap, NULL, NULL, "ngwm:getSignaturesResponse");
	case SOAP_TYPE__ngwm__getSignaturesRequest:
		return soap_in__ngwm__getSignaturesRequest(soap, NULL, NULL, "ngwm:getSignaturesRequest");
	case SOAP_TYPE__ngwm__getSettingsResponse:
		return soap_in__ngwm__getSettingsResponse(soap, NULL, NULL, "ngwm:getSettingsResponse");
	case SOAP_TYPE__ngwm__getSettingsRequest:
		return soap_in__ngwm__getSettingsRequest(soap, NULL, NULL, "ngwm:getSettingsRequest");
	case SOAP_TYPE__ngwm__getRuleListResponse:
		return soap_in__ngwm__getRuleListResponse(soap, NULL, NULL, "ngwm:getRuleListResponse");
	case SOAP_TYPE__ngwm__getRuleListRequest:
		return soap_in__ngwm__getRuleListRequest(soap, NULL, NULL, "ngwm:getRuleListRequest");
	case SOAP_TYPE__ngwm__getProxyListResponse:
		return soap_in__ngwm__getProxyListResponse(soap, NULL, NULL, "ngwm:getProxyListResponse");
	case SOAP_TYPE__ngwm__getProxyListRequest:
		return soap_in__ngwm__getProxyListRequest(soap, NULL, NULL, "ngwm:getProxyListRequest");
	case SOAP_TYPE__ngwm__getProxyAccessListResponse:
		return soap_in__ngwm__getProxyAccessListResponse(soap, NULL, NULL, "ngwm:getProxyAccessListResponse");
	case SOAP_TYPE__ngwm__getProxyAccessListRequest:
		return soap_in__ngwm__getProxyAccessListRequest(soap, NULL, NULL, "ngwm:getProxyAccessListRequest");
	case SOAP_TYPE__ngwm__getQuickMessagesResponse:
		return soap_in__ngwm__getQuickMessagesResponse(soap, NULL, NULL, "ngwm:getQuickMessagesResponse");
	case SOAP_TYPE__ngwm__getQuickMessagesRequest:
		return soap_in__ngwm__getQuickMessagesRequest(soap, NULL, NULL, "ngwm:getQuickMessagesRequest");
	case SOAP_TYPE__ngwm__getLibraryListResponse:
		return soap_in__ngwm__getLibraryListResponse(soap, NULL, NULL, "ngwm:getLibraryListResponse");
	case SOAP_TYPE__ngwm__getLibraryListRequest:
		return soap_in__ngwm__getLibraryListRequest(soap, NULL, NULL, "ngwm:getLibraryListRequest");
	case SOAP_TYPE__ngwm__getLibraryItemResponse:
		return soap_in__ngwm__getLibraryItemResponse(soap, NULL, NULL, "ngwm:getLibraryItemResponse");
	case SOAP_TYPE__ngwm__getLibraryItemRequest:
		return soap_in__ngwm__getLibraryItemRequest(soap, NULL, NULL, "ngwm:getLibraryItemRequest");
	case SOAP_TYPE__ngwm__getJunkMailSettingsResponse:
		return soap_in__ngwm__getJunkMailSettingsResponse(soap, NULL, NULL, "ngwm:getJunkMailSettingsResponse");
	case SOAP_TYPE__ngwm__getJunkMailSettingsRequest:
		return soap_in__ngwm__getJunkMailSettingsRequest(soap, NULL, NULL, "ngwm:getJunkMailSettingsRequest");
	case SOAP_TYPE__ngwm__getJunkEntriesResponse:
		return soap_in__ngwm__getJunkEntriesResponse(soap, NULL, NULL, "ngwm:getJunkEntriesResponse");
	case SOAP_TYPE__ngwm__getJunkEntriesRequest:
		return soap_in__ngwm__getJunkEntriesRequest(soap, NULL, NULL, "ngwm:getJunkEntriesRequest");
	case SOAP_TYPE__ngwm__getItemsResponse:
		return soap_in__ngwm__getItemsResponse(soap, NULL, NULL, "ngwm:getItemsResponse");
	case SOAP_TYPE__ngwm__getItemsRequest:
		return soap_in__ngwm__getItemsRequest(soap, NULL, NULL, "ngwm:getItemsRequest");
	case SOAP_TYPE__ngwm__getItemResponse:
		return soap_in__ngwm__getItemResponse(soap, NULL, NULL, "ngwm:getItemResponse");
	case SOAP_TYPE__ngwm__getItemRequest:
		return soap_in__ngwm__getItemRequest(soap, NULL, NULL, "ngwm:getItemRequest");
	case SOAP_TYPE__ngwm__getFreeBusyResponse:
		return soap_in__ngwm__getFreeBusyResponse(soap, NULL, NULL, "ngwm:getFreeBusyResponse");
	case SOAP_TYPE__ngwm__getFreeBusyRequest:
		return soap_in__ngwm__getFreeBusyRequest(soap, NULL, NULL, "ngwm:getFreeBusyRequest");
	case SOAP_TYPE__ngwm__getFolderListResponse:
		return soap_in__ngwm__getFolderListResponse(soap, NULL, NULL, "ngwm:getFolderListResponse");
	case SOAP_TYPE__ngwm__getFolderListRequest:
		return soap_in__ngwm__getFolderListRequest(soap, NULL, NULL, "ngwm:getFolderListRequest");
	case SOAP_TYPE__ngwm__getFolderResponse:
		return soap_in__ngwm__getFolderResponse(soap, NULL, NULL, "ngwm:getFolderResponse");
	case SOAP_TYPE__ngwm__getFolderRequest:
		return soap_in__ngwm__getFolderRequest(soap, NULL, NULL, "ngwm:getFolderRequest");
	case SOAP_TYPE__ngwm__getDocumentTypeListResponse:
		return soap_in__ngwm__getDocumentTypeListResponse(soap, NULL, NULL, "ngwm:getDocumentTypeListResponse");
	case SOAP_TYPE__ngwm__getDocumentTypeListRequest:
		return soap_in__ngwm__getDocumentTypeListRequest(soap, NULL, NULL, "ngwm:getDocumentTypeListRequest");
	case SOAP_TYPE__ngwm__getDeltaInfoResponse:
		return soap_in__ngwm__getDeltaInfoResponse(soap, NULL, NULL, "ngwm:getDeltaInfoResponse");
	case SOAP_TYPE__ngwm__getDeltaInfoRequest:
		return soap_in__ngwm__getDeltaInfoRequest(soap, NULL, NULL, "ngwm:getDeltaInfoRequest");
	case SOAP_TYPE__ngwm__getDeltasResponse:
		return soap_in__ngwm__getDeltasResponse(soap, NULL, NULL, "ngwm:getDeltasResponse");
	case SOAP_TYPE__ngwm__getDeltasRequest:
		return soap_in__ngwm__getDeltasRequest(soap, NULL, NULL, "ngwm:getDeltasRequest");
	case SOAP_TYPE__ngwm__getCustomListResponse:
		return soap_in__ngwm__getCustomListResponse(soap, NULL, NULL, "ngwm:getCustomListResponse");
	case SOAP_TYPE__ngwm__getCustomListRequest:
		return soap_in__ngwm__getCustomListRequest(soap, NULL, NULL, "ngwm:getCustomListRequest");
	case SOAP_TYPE__ngwm__getCategoryListResponse:
		return soap_in__ngwm__getCategoryListResponse(soap, NULL, NULL, "ngwm:getCategoryListResponse");
	case SOAP_TYPE__ngwm__getCategoryListRequest:
		return soap_in__ngwm__getCategoryListRequest(soap, NULL, NULL, "ngwm:getCategoryListRequest");
	case SOAP_TYPE__ngwm__getAttachmentResponse:
		return soap_in__ngwm__getAttachmentResponse(soap, NULL, NULL, "ngwm:getAttachmentResponse");
	case SOAP_TYPE__ngwm__getAttachmentRequest:
		return soap_in__ngwm__getAttachmentRequest(soap, NULL, NULL, "ngwm:getAttachmentRequest");
	case SOAP_TYPE__ngwm__getAddressBookListResponse:
		return soap_in__ngwm__getAddressBookListResponse(soap, NULL, NULL, "ngwm:getAddressBookListResponse");
	case SOAP_TYPE__ngwm__getAddressBookListRequest:
		return soap_in__ngwm__getAddressBookListRequest(soap, NULL, NULL, "ngwm:getAddressBookListRequest");
	case SOAP_TYPE__ngwm__forwardResponse:
		return soap_in__ngwm__forwardResponse(soap, NULL, NULL, "ngwm:forwardResponse");
	case SOAP_TYPE__ngwm__forwardRequest:
		return soap_in__ngwm__forwardRequest(soap, NULL, NULL, "ngwm:forwardRequest");
	case SOAP_TYPE__ngwm__executeRuleResponse:
		return soap_in__ngwm__executeRuleResponse(soap, NULL, NULL, "ngwm:executeRuleResponse");
	case SOAP_TYPE__ngwm__executeRuleRequest:
		return soap_in__ngwm__executeRuleRequest(soap, NULL, NULL, "ngwm:executeRuleRequest");
	case SOAP_TYPE__ngwm__destroyCursorResponse:
		return soap_in__ngwm__destroyCursorResponse(soap, NULL, NULL, "ngwm:destroyCursorResponse");
	case SOAP_TYPE__ngwm__destroyCursorRequest:
		return soap_in__ngwm__destroyCursorRequest(soap, NULL, NULL, "ngwm:destroyCursorRequest");
	case SOAP_TYPE__ngwm__delegateResponse:
		return soap_in__ngwm__delegateResponse(soap, NULL, NULL, "ngwm:delegateResponse");
	case SOAP_TYPE__ngwm__delegateRequest:
		return soap_in__ngwm__delegateRequest(soap, NULL, NULL, "ngwm:delegateRequest");
	case SOAP_TYPE__ngwm__declineResponse:
		return soap_in__ngwm__declineResponse(soap, NULL, NULL, "ngwm:declineResponse");
	case SOAP_TYPE__ngwm__declineRequest:
		return soap_in__ngwm__declineRequest(soap, NULL, NULL, "ngwm:declineRequest");
	case SOAP_TYPE__ngwm__createSignatureResponse:
		return soap_in__ngwm__createSignatureResponse(soap, NULL, NULL, "ngwm:createSignatureResponse");
	case SOAP_TYPE__ngwm__createSignatureRequest:
		return soap_in__ngwm__createSignatureRequest(soap, NULL, NULL, "ngwm:createSignatureRequest");
	case SOAP_TYPE__ngwm__createProxyAccessResponse:
		return soap_in__ngwm__createProxyAccessResponse(soap, NULL, NULL, "ngwm:createProxyAccessResponse");
	case SOAP_TYPE__ngwm__createProxyAccessRequest:
		return soap_in__ngwm__createProxyAccessRequest(soap, NULL, NULL, "ngwm:createProxyAccessRequest");
	case SOAP_TYPE__ngwm__createJunkEntryResponse:
		return soap_in__ngwm__createJunkEntryResponse(soap, NULL, NULL, "ngwm:createJunkEntryResponse");
	case SOAP_TYPE__ngwm__createJunkEntryRequest:
		return soap_in__ngwm__createJunkEntryRequest(soap, NULL, NULL, "ngwm:createJunkEntryRequest");
	case SOAP_TYPE__ngwm__createItemsResponse:
		return soap_in__ngwm__createItemsResponse(soap, NULL, NULL, "ngwm:createItemsResponse");
	case SOAP_TYPE__ngwm__createItemsRequest:
		return soap_in__ngwm__createItemsRequest(soap, NULL, NULL, "ngwm:createItemsRequest");
	case SOAP_TYPE__ngwm__createItemResponse:
		return soap_in__ngwm__createItemResponse(soap, NULL, NULL, "ngwm:createItemResponse");
	case SOAP_TYPE__ngwm__createItemRequest:
		return soap_in__ngwm__createItemRequest(soap, NULL, NULL, "ngwm:createItemRequest");
	case SOAP_TYPE__ngwm__createCursorResponse:
		return soap_in__ngwm__createCursorResponse(soap, NULL, NULL, "ngwm:createCursorResponse");
	case SOAP_TYPE__ngwm__createCursorRequest:
		return soap_in__ngwm__createCursorRequest(soap, NULL, NULL, "ngwm:createCursorRequest");
	case SOAP_TYPE__ngwm__completeResponse:
		return soap_in__ngwm__completeResponse(soap, NULL, NULL, "ngwm:completeResponse");
	case SOAP_TYPE__ngwm__completeRequest:
		return soap_in__ngwm__completeRequest(soap, NULL, NULL, "ngwm:completeRequest");
	case SOAP_TYPE__ngwm__closeFreeBusySessionResponse:
		return soap_in__ngwm__closeFreeBusySessionResponse(soap, NULL, NULL, "ngwm:closeFreeBusySessionResponse");
	case SOAP_TYPE__ngwm__closeFreeBusySessionRequest:
		return soap_in__ngwm__closeFreeBusySessionRequest(soap, NULL, NULL, "ngwm:closeFreeBusySessionRequest");
	case SOAP_TYPE__ngwm__addMembersResponse:
		return soap_in__ngwm__addMembersResponse(soap, NULL, NULL, "ngwm:addMembersResponse");
	case SOAP_TYPE__ngwm__addMembersRequest:
		return soap_in__ngwm__addMembersRequest(soap, NULL, NULL, "ngwm:addMembersRequest");
	case SOAP_TYPE__ngwm__addItemsResponse:
		return soap_in__ngwm__addItemsResponse(soap, NULL, NULL, "ngwm:addItemsResponse");
	case SOAP_TYPE__ngwm__addItemsRequest:
		return soap_in__ngwm__addItemsRequest(soap, NULL, NULL, "ngwm:addItemsRequest");
	case SOAP_TYPE__ngwm__addItemResponse:
		return soap_in__ngwm__addItemResponse(soap, NULL, NULL, "ngwm:addItemResponse");
	case SOAP_TYPE__ngwm__addItemRequest:
		return soap_in__ngwm__addItemRequest(soap, NULL, NULL, "ngwm:addItemRequest");
	case SOAP_TYPE__ngwm__acceptShareResponse:
		return soap_in__ngwm__acceptShareResponse(soap, NULL, NULL, "ngwm:acceptShareResponse");
	case SOAP_TYPE__ngwm__acceptShareRequest:
		return soap_in__ngwm__acceptShareRequest(soap, NULL, NULL, "ngwm:acceptShareRequest");
	case SOAP_TYPE__ngwm__acceptResponse:
		return soap_in__ngwm__acceptResponse(soap, NULL, NULL, "ngwm:acceptResponse");
	case SOAP_TYPE__ngwm__acceptRequest:
		return soap_in__ngwm__acceptRequest(soap, NULL, NULL, "ngwm:acceptRequest");
	case SOAP_TYPE_ngwt__VersionEvent:
		return soap_in_ngwt__VersionEvent(soap, NULL, NULL, "ngwt:VersionEvent");
	case SOAP_TYPE_ngwt__Version:
		return soap_in_ngwt__Version(soap, NULL, NULL, "ngwt:Version");
	case SOAP_TYPE_ngwt__UserList:
		return soap_in_ngwt__UserList(soap, NULL, NULL, "ngwt:UserList");
	case SOAP_TYPE_ngwt__UserInfo:
		return soap_in_ngwt__UserInfo(soap, NULL, NULL, "ngwt:UserInfo");
	case SOAP_TYPE_ngwt__TrustedApplication:
		return soap_in_ngwt__TrustedApplication(soap, NULL, NULL, "ngwt:TrustedApplication");
	case SOAP_TYPE_ngwt__TransferFailedStatus:
		return soap_in_ngwt__TransferFailedStatus(soap, NULL, NULL, "ngwt:TransferFailedStatus");
	case SOAP_TYPE_ngwt__TimezoneList:
		return soap_in_ngwt__TimezoneList(soap, NULL, NULL, "ngwt:TimezoneList");
	case SOAP_TYPE_ngwt__TimezoneComponent:
		return soap_in_ngwt__TimezoneComponent(soap, NULL, NULL, "ngwt:TimezoneComponent");
	case SOAP_TYPE_ngwt__Timezone:
		return soap_in_ngwt__Timezone(soap, NULL, NULL, "ngwt:Timezone");
	case SOAP_TYPE_ngwt__Task:
		return soap_in_ngwt__Task(soap, NULL, NULL, "ngwt:Task");
	case SOAP_TYPE_ngwt__SystemFolder:
		return soap_in_ngwt__SystemFolder(soap, NULL, NULL, "ngwt:SystemFolder");
	case SOAP_TYPE_ngwt__StatusTracking:
		return soap_in_ngwt__StatusTracking(soap, NULL, NULL, "ngwt:StatusTracking");
	case SOAP_TYPE_ngwt__Status:
		return soap_in_ngwt__Status(soap, NULL, NULL, "ngwt:Status");
	case SOAP_TYPE_ngwt__SMimeOperation:
		return soap_in_ngwt__SMimeOperation(soap, NULL, NULL, "ngwt:SMimeOperation");
	case SOAP_TYPE_ngwt__SignatureData:
		return soap_in_ngwt__SignatureData(soap, NULL, NULL, "ngwt:SignatureData");
	case SOAP_TYPE_ngwt__Signatures:
		return soap_in_ngwt__Signatures(soap, NULL, NULL, "ngwt:Signatures");
	case SOAP_TYPE_ngwt__Signature:
		return soap_in_ngwt__Signature(soap, NULL, NULL, "ngwt:Signature");
	case SOAP_TYPE_ngwt__SharedNotification:
		return soap_in_ngwt__SharedNotification(soap, NULL, NULL, "ngwt:SharedNotification");
	case SOAP_TYPE_ngwt__SharedFolderNotification:
		return soap_in_ngwt__SharedFolderNotification(soap, NULL, NULL, "ngwt:SharedFolderNotification");
	case SOAP_TYPE_ngwt__SharedFolder:
		return soap_in_ngwt__SharedFolder(soap, NULL, NULL, "ngwt:SharedFolder");
	case SOAP_TYPE_ngwt__SettingsList:
		return soap_in_ngwt__SettingsList(soap, NULL, NULL, "ngwt:SettingsList");
	case SOAP_TYPE_ngwt__SettingsGroup:
		return soap_in_ngwt__SettingsGroup(soap, NULL, NULL, "ngwt:SettingsGroup");
	case SOAP_TYPE_ngwt__Settings:
		return soap_in_ngwt__Settings(soap, NULL, NULL, "ngwt:Settings");
	case SOAP_TYPE_ngwt__SendOptions:
		return soap_in_ngwt__SendOptions(soap, NULL, NULL, "ngwt:SendOptions");
	case SOAP_TYPE_ngwt__SendOptionsRequestReply:
		return soap_in_ngwt__SendOptionsRequestReply(soap, NULL, NULL, "ngwt:SendOptionsRequestReply");
	case SOAP_TYPE_ngwt__RuleList:
		return soap_in_ngwt__RuleList(soap, NULL, NULL, "ngwt:RuleList");
	case SOAP_TYPE_ngwt__RuleActionList:
		return soap_in_ngwt__RuleActionList(soap, NULL, NULL, "ngwt:RuleActionList");
	case SOAP_TYPE_ngwt__RuleAction:
		return soap_in_ngwt__RuleAction(soap, NULL, NULL, "ngwt:RuleAction");
	case SOAP_TYPE_ngwt__Rule:
		return soap_in_ngwt__Rule(soap, NULL, NULL, "ngwt:Rule");
	case SOAP_TYPE_ngwt__Rights:
		return soap_in_ngwt__Rights(soap, NULL, NULL, "ngwt:Rights");
	case SOAP_TYPE_ngwt__ReturnNotificationOptions:
		return soap_in_ngwt__ReturnNotificationOptions(soap, NULL, NULL, "ngwt:ReturnNotificationOptions");
	case SOAP_TYPE_ngwt__ReturnNotification:
		return soap_in_ngwt__ReturnNotification(soap, NULL, NULL, "ngwt:ReturnNotification");
	case SOAP_TYPE_ngwt__Resource:
		return soap_in_ngwt__Resource(soap, NULL, NULL, "ngwt:Resource");
	case SOAP_TYPE_ngwt__ReferenceInfo:
		return soap_in_ngwt__ReferenceInfo(soap, NULL, NULL, "ngwt:ReferenceInfo");
	case SOAP_TYPE_ngwt__RecurrenceRule:
		return soap_in_ngwt__RecurrenceRule(soap, NULL, NULL, "ngwt:RecurrenceRule");
	case SOAP_TYPE_ngwt__RecurrenceDateType:
		return soap_in_ngwt__RecurrenceDateType(soap, NULL, NULL, "ngwt:RecurrenceDateType");
	case SOAP_TYPE_ngwt__RecipientStatus:
		return soap_in_ngwt__RecipientStatus(soap, NULL, NULL, "ngwt:RecipientStatus");
	case SOAP_TYPE_ngwt__RecipientList:
		return soap_in_ngwt__RecipientList(soap, NULL, NULL, "ngwt:RecipientList");
	case SOAP_TYPE_ngwt__Recipient:
		return soap_in_ngwt__Recipient(soap, NULL, NULL, "ngwt:Recipient");
	case SOAP_TYPE_ngwt__QueryTarget:
		return soap_in_ngwt__QueryTarget(soap, NULL, NULL, "ngwt:QueryTarget");
	case SOAP_TYPE_ngwt__QueryFolder:
		return soap_in_ngwt__QueryFolder(soap, NULL, NULL, "ngwt:QueryFolder");
	case SOAP_TYPE_ngwt__Query:
		return soap_in_ngwt__Query(soap, NULL, NULL, "ngwt:Query");
	case SOAP_TYPE_ngwt__ProxyList:
		return soap_in_ngwt__ProxyList(soap, NULL, NULL, "ngwt:ProxyList");
	case SOAP_TYPE_ngwt__ProxyUser:
		return soap_in_ngwt__ProxyUser(soap, NULL, NULL, "ngwt:ProxyUser");
	case SOAP_TYPE_ngwt__Proxy:
		return soap_in_ngwt__Proxy(soap, NULL, NULL, "ngwt:Proxy");
	case SOAP_TYPE_ngwt__ProblemList:
		return soap_in_ngwt__ProblemList(soap, NULL, NULL, "ngwt:ProblemList");
	case SOAP_TYPE_ngwt__ProblemEntry:
		return soap_in_ngwt__ProblemEntry(soap, NULL, NULL, "ngwt:ProblemEntry");
	case SOAP_TYPE_ngwt__PostalAddressList:
		return soap_in_ngwt__PostalAddressList(soap, NULL, NULL, "ngwt:PostalAddressList");
	case SOAP_TYPE_ngwt__PostalAddress:
		return soap_in_ngwt__PostalAddress(soap, NULL, NULL, "ngwt:PostalAddress");
	case SOAP_TYPE_ngwt__PlainText:
		return soap_in_ngwt__PlainText(soap, NULL, NULL, "ngwt:PlainText");
	case SOAP_TYPE_ngwt__PhoneNumber:
		return soap_in_ngwt__PhoneNumber(soap, NULL, NULL, "ngwt:PhoneNumber");
	case SOAP_TYPE_ngwt__PhoneMessage:
		return soap_in_ngwt__PhoneMessage(soap, NULL, NULL, "ngwt:PhoneMessage");
	case SOAP_TYPE_ngwt__PhoneList:
		return soap_in_ngwt__PhoneList(soap, NULL, NULL, "ngwt:PhoneList");
	case SOAP_TYPE_ngwt__PhoneFlags:
		return soap_in_ngwt__PhoneFlags(soap, NULL, NULL, "ngwt:PhoneFlags");
	case SOAP_TYPE_ngwt__PersonalInfo:
		return soap_in_ngwt__PersonalInfo(soap, NULL, NULL, "ngwt:PersonalInfo");
	case SOAP_TYPE_ngwt__Organization:
		return soap_in_ngwt__Organization(soap, NULL, NULL, "ngwt:Organization");
	case SOAP_TYPE_ngwt__OfficeInfo:
		return soap_in_ngwt__OfficeInfo(soap, NULL, NULL, "ngwt:OfficeInfo");
	case SOAP_TYPE_ngwt__Note:
		return soap_in_ngwt__Note(soap, NULL, NULL, "ngwt:Note");
	case SOAP_TYPE_ngwt__NameAndEmail:
		return soap_in_ngwt__NameAndEmail(soap, NULL, NULL, "ngwt:NameAndEmail");
	case SOAP_TYPE_ngwt__MonthList:
		return soap_in_ngwt__MonthList(soap, NULL, NULL, "ngwt:MonthList");
	case SOAP_TYPE_ngwt__ModifyItem:
		return soap_in_ngwt__ModifyItem(soap, NULL, NULL, "ngwt:ModifyItem");
	case SOAP_TYPE_ngwt__MessagePart:
		return soap_in_ngwt__MessagePart(soap, NULL, NULL, "ngwt:MessagePart");
	case SOAP_TYPE_ngwt__MessageBody:
		return soap_in_ngwt__MessageBody(soap, NULL, NULL, "ngwt:MessageBody");
	case SOAP_TYPE_ngwt__Mail:
		return soap_in_ngwt__Mail(soap, NULL, NULL, "ngwt:Mail");
	case SOAP_TYPE_ngwt__LinkInfo:
		return soap_in_ngwt__LinkInfo(soap, NULL, NULL, "ngwt:LinkInfo");
	case SOAP_TYPE_ngwt__LibraryList:
		return soap_in_ngwt__LibraryList(soap, NULL, NULL, "ngwt:LibraryList");
	case SOAP_TYPE_ngwt__Library:
		return soap_in_ngwt__Library(soap, NULL, NULL, "ngwt:Library");
	case SOAP_TYPE_ngwt__JunkHandlingList:
		return soap_in_ngwt__JunkHandlingList(soap, NULL, NULL, "ngwt:JunkHandlingList");
	case SOAP_TYPE_ngwt__JunkEntry:
		return soap_in_ngwt__JunkEntry(soap, NULL, NULL, "ngwt:JunkEntry");
	case SOAP_TYPE_ngwt__ItemStatus:
		return soap_in_ngwt__ItemStatus(soap, NULL, NULL, "ngwt:ItemStatus");
	case SOAP_TYPE_ngwt__Items:
		return soap_in_ngwt__Items(soap, NULL, NULL, "ngwt:Items");
	case SOAP_TYPE_ngwt__ItemRefList:
		return soap_in_ngwt__ItemRefList(soap, NULL, NULL, "ngwt:ItemRefList");
	case SOAP_TYPE_ngwt__ItemRef:
		return soap_in_ngwt__ItemRef(soap, NULL, NULL, "ngwt:ItemRef");
	case SOAP_TYPE_ngwt__ItemOptions:
		return soap_in_ngwt__ItemOptions(soap, NULL, NULL, "ngwt:ItemOptions");
	case SOAP_TYPE_ngwt__ItemList:
		return soap_in_ngwt__ItemList(soap, NULL, NULL, "ngwt:ItemList");
	case SOAP_TYPE_ngwt__ItemChanges:
		return soap_in_ngwt__ItemChanges(soap, NULL, NULL, "ngwt:ItemChanges");
	case SOAP_TYPE_ngwt__Item:
		return soap_in_ngwt__Item(soap, NULL, NULL, "ngwt:Item");
	case SOAP_TYPE_ngwt__ImAddressList:
		return soap_in_ngwt__ImAddressList(soap, NULL, NULL, "ngwt:ImAddressList");
	case SOAP_TYPE_ngwt__ImAddress:
		return soap_in_ngwt__ImAddress(soap, NULL, NULL, "ngwt:ImAddress");
	case SOAP_TYPE_ngwt__Host:
		return soap_in_ngwt__Host(soap, NULL, NULL, "ngwt:Host");
	case SOAP_TYPE_ngwt__GroupMemberList:
		return soap_in_ngwt__GroupMemberList(soap, NULL, NULL, "ngwt:GroupMemberList");
	case SOAP_TYPE_ngwt__GroupMember:
		return soap_in_ngwt__GroupMember(soap, NULL, NULL, "ngwt:GroupMember");
	case SOAP_TYPE_ngwt__Group:
		return soap_in_ngwt__Group(soap, NULL, NULL, "ngwt:Group");
	case SOAP_TYPE_ngwt__FullName:
		return soap_in_ngwt__FullName(soap, NULL, NULL, "ngwt:FullName");
	case SOAP_TYPE_ngwt__From:
		return soap_in_ngwt__From(soap, NULL, NULL, "ngwt:From");
	case SOAP_TYPE_ngwt__FreeBusyStats:
		return soap_in_ngwt__FreeBusyStats(soap, NULL, NULL, "ngwt:FreeBusyStats");
	case SOAP_TYPE_ngwt__FreeBusyInfoList:
		return soap_in_ngwt__FreeBusyInfoList(soap, NULL, NULL, "ngwt:FreeBusyInfoList");
	case SOAP_TYPE_ngwt__FreeBusyUserList:
		return soap_in_ngwt__FreeBusyUserList(soap, NULL, NULL, "ngwt:FreeBusyUserList");
	case SOAP_TYPE_ngwt__FreeBusyInfo:
		return soap_in_ngwt__FreeBusyInfo(soap, NULL, NULL, "ngwt:FreeBusyInfo");
	case SOAP_TYPE_ngwt__FreeBusyBlock:
		return soap_in_ngwt__FreeBusyBlock(soap, NULL, NULL, "ngwt:FreeBusyBlock");
	case SOAP_TYPE_ngwt__FreeBusyBlockList:
		return soap_in_ngwt__FreeBusyBlockList(soap, NULL, NULL, "ngwt:FreeBusyBlockList");
	case SOAP_TYPE_ngwt__FolderList:
		return soap_in_ngwt__FolderList(soap, NULL, NULL, "ngwt:FolderList");
	case SOAP_TYPE_ngwt__FolderACLEntry:
		return soap_in_ngwt__FolderACLEntry(soap, NULL, NULL, "ngwt:FolderACLEntry");
	case SOAP_TYPE_ngwt__FolderACL:
		return soap_in_ngwt__FolderACL(soap, NULL, NULL, "ngwt:FolderACL");
	case SOAP_TYPE_ngwt__Folder:
		return soap_in_ngwt__Folder(soap, NULL, NULL, "ngwt:Folder");
	case SOAP_TYPE_ngwt__FilterGroup:
		return soap_in_ngwt__FilterGroup(soap, NULL, NULL, "ngwt:FilterGroup");
	case SOAP_TYPE_ngwt__FilterEntry:
		return soap_in_ngwt__FilterEntry(soap, NULL, NULL, "ngwt:FilterEntry");
	case SOAP_TYPE_ngwt__FilterElement:
		return soap_in_ngwt__FilterElement(soap, NULL, NULL, "ngwt:FilterElement");
	case SOAP_TYPE_ngwt__Filter:
		return soap_in_ngwt__Filter(soap, NULL, NULL, "ngwt:Filter");
	case SOAP_TYPE_ngwt__EmailAddressList:
		return soap_in_ngwt__EmailAddressList(soap, NULL, NULL, "ngwt:EmailAddressList");
	case SOAP_TYPE_ngwt__DocumentTypeList:
		return soap_in_ngwt__DocumentTypeList(soap, NULL, NULL, "ngwt:DocumentTypeList");
	case SOAP_TYPE_ngwt__DocumentType:
		return soap_in_ngwt__DocumentType(soap, NULL, NULL, "ngwt:DocumentType");
	case SOAP_TYPE_ngwt__DocumentRef:
		return soap_in_ngwt__DocumentRef(soap, NULL, NULL, "ngwt:DocumentRef");
	case SOAP_TYPE_ngwt__Document:
		return soap_in_ngwt__Document(soap, NULL, NULL, "ngwt:Document");
	case SOAP_TYPE_ngwt__Distribution:
		return soap_in_ngwt__Distribution(soap, NULL, NULL, "ngwt:Distribution");
	case SOAP_TYPE_ngwt__DeltaInfo:
		return soap_in_ngwt__DeltaInfo(soap, NULL, NULL, "ngwt:DeltaInfo");
	case SOAP_TYPE_ngwt__DelegateeStatus:
		return soap_in_ngwt__DelegateeStatus(soap, NULL, NULL, "ngwt:DelegateeStatus");
	case SOAP_TYPE_ngwt__DelegatedStatus:
		return soap_in_ngwt__DelegatedStatus(soap, NULL, NULL, "ngwt:DelegatedStatus");
	case SOAP_TYPE_ngwt__DayOfYearWeekList:
		return soap_in_ngwt__DayOfYearWeekList(soap, NULL, NULL, "ngwt:DayOfYearWeekList");
	case SOAP_TYPE_ngwt__DayOfYearWeek:
		return soap_in_ngwt__DayOfYearWeek(soap, NULL, NULL, "ngwt:DayOfYearWeek");
	case SOAP_TYPE_ngwt__DayOfYearList:
		return soap_in_ngwt__DayOfYearList(soap, NULL, NULL, "ngwt:DayOfYearList");
	case SOAP_TYPE_ngwt__DayOfWeek:
		return soap_in_ngwt__DayOfWeek(soap, NULL, NULL, "ngwt:DayOfWeek");
	case SOAP_TYPE_ngwt__DayOfMonthList:
		return soap_in_ngwt__DayOfMonthList(soap, NULL, NULL, "ngwt:DayOfMonthList");
	case SOAP_TYPE_ngwt__CustomList:
		return soap_in_ngwt__CustomList(soap, NULL, NULL, "ngwt:CustomList");
	case SOAP_TYPE_ngwt__Custom:
		return soap_in_ngwt__Custom(soap, NULL, NULL, "ngwt:Custom");
	case SOAP_TYPE_ngwt__ContainerRef:
		return soap_in_ngwt__ContainerRef(soap, NULL, NULL, "ngwt:ContainerRef");
	case SOAP_TYPE_ngwt__ContainerItem:
		return soap_in_ngwt__ContainerItem(soap, NULL, NULL, "ngwt:ContainerItem");
	case SOAP_TYPE_ngwt__ContactFolder:
		return soap_in_ngwt__ContactFolder(soap, NULL, NULL, "ngwt:ContactFolder");
	case SOAP_TYPE_ngwt__Contact:
		return soap_in_ngwt__Contact(soap, NULL, NULL, "ngwt:Contact");
	case SOAP_TYPE_ngwt__CommentStatus:
		return soap_in_ngwt__CommentStatus(soap, NULL, NULL, "ngwt:CommentStatus");
	case SOAP_TYPE_ngwt__CategoryRefList:
		return soap_in_ngwt__CategoryRefList(soap, NULL, NULL, "ngwt:CategoryRefList");
	case SOAP_TYPE_ngwt__CategoryList:
		return soap_in_ngwt__CategoryList(soap, NULL, NULL, "ngwt:CategoryList");
	case SOAP_TYPE_ngwt__Category:
		return soap_in_ngwt__Category(soap, NULL, NULL, "ngwt:Category");
	case SOAP_TYPE_ngwt__CalendarItem:
		return soap_in_ngwt__CalendarItem(soap, NULL, NULL, "ngwt:CalendarItem");
	case SOAP_TYPE_ngwt__CalendarFolderAttribute:
		return soap_in_ngwt__CalendarFolderAttribute(soap, NULL, NULL, "ngwt:CalendarFolderAttribute");
	case SOAP_TYPE_ngwt__BoxEntry:
		return soap_in_ngwt__BoxEntry(soap, NULL, NULL, "ngwt:BoxEntry");
	case SOAP_TYPE_ngwt__Authentication:
		return soap_in_ngwt__Authentication(soap, NULL, NULL, "ngwt:Authentication");
	case SOAP_TYPE_ngwt__AttachmentItemInfo:
		return soap_in_ngwt__AttachmentItemInfo(soap, NULL, NULL, "ngwt:AttachmentItemInfo");
	case SOAP_TYPE_ngwt__AttachmentInfo:
		return soap_in_ngwt__AttachmentInfo(soap, NULL, NULL, "ngwt:AttachmentInfo");
	case SOAP_TYPE_ngwt__AttachmentID:
		return soap_in_ngwt__AttachmentID(soap, NULL, NULL, "ngwt:AttachmentID");
	case SOAP_TYPE_ngwt__Appointment:
		return soap_in_ngwt__Appointment(soap, NULL, NULL, "ngwt:Appointment");
	case SOAP_TYPE_ngwt__Alarm:
		return soap_in_ngwt__Alarm(soap, NULL, NULL, "ngwt:Alarm");
	case SOAP_TYPE_ngwt__AddressBookList:
		return soap_in_ngwt__AddressBookList(soap, NULL, NULL, "ngwt:AddressBookList");
	case SOAP_TYPE_ngwt__AddressBookItem:
		return soap_in_ngwt__AddressBookItem(soap, NULL, NULL, "ngwt:AddressBookItem");
	case SOAP_TYPE_ngwt__AddressBook:
		return soap_in_ngwt__AddressBook(soap, NULL, NULL, "ngwt:AddressBook");
	case SOAP_TYPE_ngwt__AccessRightList:
		return soap_in_ngwt__AccessRightList(soap, NULL, NULL, "ngwt:AccessRightList");
	case SOAP_TYPE_ngwt__AccessRightEntry:
		return soap_in_ngwt__AccessRightEntry(soap, NULL, NULL, "ngwt:AccessRightEntry");
	case SOAP_TYPE_ngwt__AccessRightChanges:
		return soap_in_ngwt__AccessRightChanges(soap, NULL, NULL, "ngwt:AccessRightChanges");
	case SOAP_TYPE_ngwt__AccessRight:
		return soap_in_ngwt__AccessRight(soap, NULL, NULL, "ngwt:AccessRight");
	case SOAP_TYPE_ngwt__AccessMiscRight:
		return soap_in_ngwt__AccessMiscRight(soap, NULL, NULL, "ngwt:AccessMiscRight");
	case SOAP_TYPE_ngwt__AccessControlList:
		return soap_in_ngwt__AccessControlList(soap, NULL, NULL, "ngwt:AccessControlList");
	case SOAP_TYPE_ngwt__AccessControlListEntry:
		return soap_in_ngwt__AccessControlListEntry(soap, NULL, NULL, "ngwt:AccessControlListEntry");
	case SOAP_TYPE_xsd__language:
		return soap_in_xsd__language(soap, NULL, NULL, "xsd:language");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ngwe__removeEventsResponse:
		return soap_in_PointerTo_ngwe__removeEventsResponse(soap, NULL, NULL, "ngwe:removeEventsResponse");
	case SOAP_TYPE_PointerTo_ngwe__removeEventsRequest:
		return soap_in_PointerTo_ngwe__removeEventsRequest(soap, NULL, NULL, "ngwe:removeEventsRequest");
	case SOAP_TYPE_PointerTo_ngwe__removeEventConfigurationResponse:
		return soap_in_PointerTo_ngwe__removeEventConfigurationResponse(soap, NULL, NULL, "ngwe:removeEventConfigurationResponse");
	case SOAP_TYPE_PointerTo_ngwe__removeEventConfigurationRequest:
		return soap_in_PointerTo_ngwe__removeEventConfigurationRequest(soap, NULL, NULL, "ngwe:removeEventConfigurationRequest");
	case SOAP_TYPE_PointerTo_ngwe__getEventsResponse:
		return soap_in_PointerTo_ngwe__getEventsResponse(soap, NULL, NULL, "ngwe:getEventsResponse");
	case SOAP_TYPE_PointerTo_ngwe__getEventsRequest:
		return soap_in_PointerTo_ngwe__getEventsRequest(soap, NULL, NULL, "ngwe:getEventsRequest");
	case SOAP_TYPE_PointerTo_ngwe__getEventConfigurationResponse:
		return soap_in_PointerTo_ngwe__getEventConfigurationResponse(soap, NULL, NULL, "ngwe:getEventConfigurationResponse");
	case SOAP_TYPE_PointerTo_ngwe__getEventConfigurationRequest:
		return soap_in_PointerTo_ngwe__getEventConfigurationRequest(soap, NULL, NULL, "ngwe:getEventConfigurationRequest");
	case SOAP_TYPE_PointerTo_ngwe__configureEventsResponse:
		return soap_in_PointerTo_ngwe__configureEventsResponse(soap, NULL, NULL, "ngwe:configureEventsResponse");
	case SOAP_TYPE_PointerTo_ngwe__configureEventsRequest:
		return soap_in_PointerTo_ngwe__configureEventsRequest(soap, NULL, NULL, "ngwe:configureEventsRequest");
	case SOAP_TYPE_PointerTo_ngwe__cleanEventConfigurationResponse:
		return soap_in_PointerTo_ngwe__cleanEventConfigurationResponse(soap, NULL, NULL, "ngwe:cleanEventConfigurationResponse");
	case SOAP_TYPE_PointerTo_ngwe__cleanEventConfigurationRequest:
		return soap_in_PointerTo_ngwe__cleanEventConfigurationRequest(soap, NULL, NULL, "ngwe:cleanEventConfigurationRequest");
	case SOAP_TYPE_PointerTo_ngwm__updateVersionStatusResponse:
		return soap_in_PointerTo_ngwm__updateVersionStatusResponse(soap, NULL, NULL, "ngwm:updateVersionStatusResponse");
	case SOAP_TYPE_PointerTo_ngwm__updateVersionStatusRequest:
		return soap_in_PointerTo_ngwm__updateVersionStatusRequest(soap, NULL, NULL, "ngwm:updateVersionStatusRequest");
	case SOAP_TYPE_PointerTo_ngwm__uncompleteResponse:
		return soap_in_PointerTo_ngwm__uncompleteResponse(soap, NULL, NULL, "ngwm:uncompleteResponse");
	case SOAP_TYPE_PointerTo_ngwm__uncompleteRequest:
		return soap_in_PointerTo_ngwm__uncompleteRequest(soap, NULL, NULL, "ngwm:uncompleteRequest");
	case SOAP_TYPE_PointerTo_ngwm__unacceptResponse:
		return soap_in_PointerTo_ngwm__unacceptResponse(soap, NULL, NULL, "ngwm:unacceptResponse");
	case SOAP_TYPE_PointerTo_ngwm__unacceptRequest:
		return soap_in_PointerTo_ngwm__unacceptRequest(soap, NULL, NULL, "ngwm:unacceptRequest");
	case SOAP_TYPE_PointerTo_ngwm__startFreeBusySessionResponse:
		return soap_in_PointerTo_ngwm__startFreeBusySessionResponse(soap, NULL, NULL, "ngwm:startFreeBusySessionResponse");
	case SOAP_TYPE_PointerTo_ngwm__startFreeBusySessionRequest:
		return soap_in_PointerTo_ngwm__startFreeBusySessionRequest(soap, NULL, NULL, "ngwm:startFreeBusySessionRequest");
	case SOAP_TYPE_PointerTo_ngwm__setTimestampResponse:
		return soap_in_PointerTo_ngwm__setTimestampResponse(soap, NULL, NULL, "ngwm:setTimestampResponse");
	case SOAP_TYPE_PointerTo_ngwm__setTimestampRequest:
		return soap_in_PointerTo_ngwm__setTimestampRequest(soap, NULL, NULL, "ngwm:setTimestampRequest");
	case SOAP_TYPE_PointerTo_ngwm__sendItemResponse:
		return soap_in_PointerTo_ngwm__sendItemResponse(soap, NULL, NULL, "ngwm:sendItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__sendItemRequest:
		return soap_in_PointerTo_ngwm__sendItemRequest(soap, NULL, NULL, "ngwm:sendItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__retractResponse:
		return soap_in_PointerTo_ngwm__retractResponse(soap, NULL, NULL, "ngwm:retractResponse");
	case SOAP_TYPE_PointerTo_ngwm__retractRequest:
		return soap_in_PointerTo_ngwm__retractRequest(soap, NULL, NULL, "ngwm:retractRequest");
	case SOAP_TYPE_PointerTo_ngwm__replyResponse:
		return soap_in_PointerTo_ngwm__replyResponse(soap, NULL, NULL, "ngwm:replyResponse");
	case SOAP_TYPE_PointerTo_ngwm__replyRequest:
		return soap_in_PointerTo_ngwm__replyRequest(soap, NULL, NULL, "ngwm:replyRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeSignatureResponse:
		return soap_in_PointerTo_ngwm__removeSignatureResponse(soap, NULL, NULL, "ngwm:removeSignatureResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeSignatureRequest:
		return soap_in_PointerTo_ngwm__removeSignatureRequest(soap, NULL, NULL, "ngwm:removeSignatureRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeProxyUserResponse:
		return soap_in_PointerTo_ngwm__removeProxyUserResponse(soap, NULL, NULL, "ngwm:removeProxyUserResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeProxyUserRequest:
		return soap_in_PointerTo_ngwm__removeProxyUserRequest(soap, NULL, NULL, "ngwm:removeProxyUserRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeProxyAccessResponse:
		return soap_in_PointerTo_ngwm__removeProxyAccessResponse(soap, NULL, NULL, "ngwm:removeProxyAccessResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeProxyAccessRequest:
		return soap_in_PointerTo_ngwm__removeProxyAccessRequest(soap, NULL, NULL, "ngwm:removeProxyAccessRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeMembersResponse:
		return soap_in_PointerTo_ngwm__removeMembersResponse(soap, NULL, NULL, "ngwm:removeMembersResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeMembersRequest:
		return soap_in_PointerTo_ngwm__removeMembersRequest(soap, NULL, NULL, "ngwm:removeMembersRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeJunkEntryResponse:
		return soap_in_PointerTo_ngwm__removeJunkEntryResponse(soap, NULL, NULL, "ngwm:removeJunkEntryResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeJunkEntryRequest:
		return soap_in_PointerTo_ngwm__removeJunkEntryRequest(soap, NULL, NULL, "ngwm:removeJunkEntryRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeItemsResponse:
		return soap_in_PointerTo_ngwm__removeItemsResponse(soap, NULL, NULL, "ngwm:removeItemsResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeItemsRequest:
		return soap_in_PointerTo_ngwm__removeItemsRequest(soap, NULL, NULL, "ngwm:removeItemsRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeItemResponse:
		return soap_in_PointerTo_ngwm__removeItemResponse(soap, NULL, NULL, "ngwm:removeItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeItemRequest:
		return soap_in_PointerTo_ngwm__removeItemRequest(soap, NULL, NULL, "ngwm:removeItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeCustomDefinitionResponse:
		return soap_in_PointerTo_ngwm__removeCustomDefinitionResponse(soap, NULL, NULL, "ngwm:removeCustomDefinitionResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeCustomDefinitionRequest:
		return soap_in_PointerTo_ngwm__removeCustomDefinitionRequest(soap, NULL, NULL, "ngwm:removeCustomDefinitionRequest");
	case SOAP_TYPE_PointerTo_ngwm__readCursorResponse:
		return soap_in_PointerTo_ngwm__readCursorResponse(soap, NULL, NULL, "ngwm:readCursorResponse");
	case SOAP_TYPE_PointerTo_ngwm__readCursorRequest:
		return soap_in_PointerTo_ngwm__readCursorRequest(soap, NULL, NULL, "ngwm:readCursorRequest");
	case SOAP_TYPE_PointerTo_ngwm__purgeResponse:
		return soap_in_PointerTo_ngwm__purgeResponse(soap, NULL, NULL, "ngwm:purgeResponse");
	case SOAP_TYPE_PointerTo_ngwm__purgeRequest:
		return soap_in_PointerTo_ngwm__purgeRequest(soap, NULL, NULL, "ngwm:purgeRequest");
	case SOAP_TYPE_PointerTo_ngwm__purgeDeletedItemsResponse:
		return soap_in_PointerTo_ngwm__purgeDeletedItemsResponse(soap, NULL, NULL, "ngwm:purgeDeletedItemsResponse");
	case SOAP_TYPE_PointerTo_ngwm__purgeDeletedItemsRequest:
		return soap_in_PointerTo_ngwm__purgeDeletedItemsRequest(soap, NULL, NULL, "ngwm:purgeDeletedItemsRequest");
	case SOAP_TYPE_PointerTo_ngwm__positionCursorResponse:
		return soap_in_PointerTo_ngwm__positionCursorResponse(soap, NULL, NULL, "ngwm:positionCursorResponse");
	case SOAP_TYPE_PointerTo_ngwm__positionCursorRequest:
		return soap_in_PointerTo_ngwm__positionCursorRequest(soap, NULL, NULL, "ngwm:positionCursorRequest");
	case SOAP_TYPE_PointerTo_ngwm__moveItemResponse:
		return soap_in_PointerTo_ngwm__moveItemResponse(soap, NULL, NULL, "ngwm:moveItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__moveItemRequest:
		return soap_in_PointerTo_ngwm__moveItemRequest(soap, NULL, NULL, "ngwm:moveItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifySignaturesResponse:
		return soap_in_PointerTo_ngwm__modifySignaturesResponse(soap, NULL, NULL, "ngwm:modifySignaturesResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifySignaturesRequest:
		return soap_in_PointerTo_ngwm__modifySignaturesRequest(soap, NULL, NULL, "ngwm:modifySignaturesRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifySettingsResponse:
		return soap_in_PointerTo_ngwm__modifySettingsResponse(soap, NULL, NULL, "ngwm:modifySettingsResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifySettingsRequest:
		return soap_in_PointerTo_ngwm__modifySettingsRequest(soap, NULL, NULL, "ngwm:modifySettingsRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifyProxyAccessResponse:
		return soap_in_PointerTo_ngwm__modifyProxyAccessResponse(soap, NULL, NULL, "ngwm:modifyProxyAccessResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifyProxyAccessRequest:
		return soap_in_PointerTo_ngwm__modifyProxyAccessRequest(soap, NULL, NULL, "ngwm:modifyProxyAccessRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifyPasswordResponse:
		return soap_in_PointerTo_ngwm__modifyPasswordResponse(soap, NULL, NULL, "ngwm:modifyPasswordResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifyPasswordRequest:
		return soap_in_PointerTo_ngwm__modifyPasswordRequest(soap, NULL, NULL, "ngwm:modifyPasswordRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkMailSettingsResponse:
		return soap_in_PointerTo_ngwm__modifyJunkMailSettingsResponse(soap, NULL, NULL, "ngwm:modifyJunkMailSettingsResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkMailSettingsRequest:
		return soap_in_PointerTo_ngwm__modifyJunkMailSettingsRequest(soap, NULL, NULL, "ngwm:modifyJunkMailSettingsRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkEntryResponse:
		return soap_in_PointerTo_ngwm__modifyJunkEntryResponse(soap, NULL, NULL, "ngwm:modifyJunkEntryResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkEntryRequest:
		return soap_in_PointerTo_ngwm__modifyJunkEntryRequest(soap, NULL, NULL, "ngwm:modifyJunkEntryRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifyItemResponse:
		return soap_in_PointerTo_ngwm__modifyItemResponse(soap, NULL, NULL, "ngwm:modifyItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifyItemRequest:
		return soap_in_PointerTo_ngwm__modifyItemRequest(soap, NULL, NULL, "ngwm:modifyItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__markUnReadResponse:
		return soap_in_PointerTo_ngwm__markUnReadResponse(soap, NULL, NULL, "ngwm:markUnReadResponse");
	case SOAP_TYPE_PointerTo_ngwm__markUnReadRequest:
		return soap_in_PointerTo_ngwm__markUnReadRequest(soap, NULL, NULL, "ngwm:markUnReadRequest");
	case SOAP_TYPE_PointerTo_ngwm__markUnPrivateResponse:
		return soap_in_PointerTo_ngwm__markUnPrivateResponse(soap, NULL, NULL, "ngwm:markUnPrivateResponse");
	case SOAP_TYPE_PointerTo_ngwm__markUnPrivateRequest:
		return soap_in_PointerTo_ngwm__markUnPrivateRequest(soap, NULL, NULL, "ngwm:markUnPrivateRequest");
	case SOAP_TYPE_PointerTo_ngwm__markReadResponse:
		return soap_in_PointerTo_ngwm__markReadResponse(soap, NULL, NULL, "ngwm:markReadResponse");
	case SOAP_TYPE_PointerTo_ngwm__markReadRequest:
		return soap_in_PointerTo_ngwm__markReadRequest(soap, NULL, NULL, "ngwm:markReadRequest");
	case SOAP_TYPE_PointerTo_ngwm__markPrivateResponse:
		return soap_in_PointerTo_ngwm__markPrivateResponse(soap, NULL, NULL, "ngwm:markPrivateResponse");
	case SOAP_TYPE_PointerTo_ngwm__markPrivateRequest:
		return soap_in_PointerTo_ngwm__markPrivateRequest(soap, NULL, NULL, "ngwm:markPrivateRequest");
	case SOAP_TYPE_PointerTo_ngwm__logoutResponse:
		return soap_in_PointerTo_ngwm__logoutResponse(soap, NULL, NULL, "ngwm:logoutResponse");
	case SOAP_TYPE_PointerTo_ngwm__logoutRequest:
		return soap_in_PointerTo_ngwm__logoutRequest(soap, NULL, NULL, "ngwm:logoutRequest");
	case SOAP_TYPE_PointerTo_ngwm__loginResponse:
		return soap_in_PointerTo_ngwm__loginResponse(soap, NULL, NULL, "ngwm:loginResponse");
	case SOAP_TYPE_PointerTo_ngwm__loginRequest:
		return soap_in_PointerTo_ngwm__loginRequest(soap, NULL, NULL, "ngwm:loginRequest");
	case SOAP_TYPE_PointerTo_ngwm__getUserListResponse:
		return soap_in_PointerTo_ngwm__getUserListResponse(soap, NULL, NULL, "ngwm:getUserListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getUserListRequest:
		return soap_in_PointerTo_ngwm__getUserListRequest(soap, NULL, NULL, "ngwm:getUserListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getTimezoneListResponse:
		return soap_in_PointerTo_ngwm__getTimezoneListResponse(soap, NULL, NULL, "ngwm:getTimezoneListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getTimezoneListRequest:
		return soap_in_PointerTo_ngwm__getTimezoneListRequest(soap, NULL, NULL, "ngwm:getTimezoneListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getTimestampResponse:
		return soap_in_PointerTo_ngwm__getTimestampResponse(soap, NULL, NULL, "ngwm:getTimestampResponse");
	case SOAP_TYPE_PointerTo_ngwm__getTimestampRequest:
		return soap_in_PointerTo_ngwm__getTimestampRequest(soap, NULL, NULL, "ngwm:getTimestampRequest");
	case SOAP_TYPE_PointerTo_ngwm__getSignaturesResponse:
		return soap_in_PointerTo_ngwm__getSignaturesResponse(soap, NULL, NULL, "ngwm:getSignaturesResponse");
	case SOAP_TYPE_PointerTo_ngwm__getSignaturesRequest:
		return soap_in_PointerTo_ngwm__getSignaturesRequest(soap, NULL, NULL, "ngwm:getSignaturesRequest");
	case SOAP_TYPE_PointerTo_ngwm__getSettingsResponse:
		return soap_in_PointerTo_ngwm__getSettingsResponse(soap, NULL, NULL, "ngwm:getSettingsResponse");
	case SOAP_TYPE_PointerTo_ngwm__getSettingsRequest:
		return soap_in_PointerTo_ngwm__getSettingsRequest(soap, NULL, NULL, "ngwm:getSettingsRequest");
	case SOAP_TYPE_PointerTo_ngwm__getRuleListResponse:
		return soap_in_PointerTo_ngwm__getRuleListResponse(soap, NULL, NULL, "ngwm:getRuleListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getRuleListRequest:
		return soap_in_PointerTo_ngwm__getRuleListRequest(soap, NULL, NULL, "ngwm:getRuleListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getProxyListResponse:
		return soap_in_PointerTo_ngwm__getProxyListResponse(soap, NULL, NULL, "ngwm:getProxyListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getProxyListRequest:
		return soap_in_PointerTo_ngwm__getProxyListRequest(soap, NULL, NULL, "ngwm:getProxyListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getProxyAccessListResponse:
		return soap_in_PointerTo_ngwm__getProxyAccessListResponse(soap, NULL, NULL, "ngwm:getProxyAccessListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getProxyAccessListRequest:
		return soap_in_PointerTo_ngwm__getProxyAccessListRequest(soap, NULL, NULL, "ngwm:getProxyAccessListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getQuickMessagesResponse:
		return soap_in_PointerTo_ngwm__getQuickMessagesResponse(soap, NULL, NULL, "ngwm:getQuickMessagesResponse");
	case SOAP_TYPE_PointerTo_ngwm__getQuickMessagesRequest:
		return soap_in_PointerTo_ngwm__getQuickMessagesRequest(soap, NULL, NULL, "ngwm:getQuickMessagesRequest");
	case SOAP_TYPE_PointerTo_ngwm__getLibraryListResponse:
		return soap_in_PointerTo_ngwm__getLibraryListResponse(soap, NULL, NULL, "ngwm:getLibraryListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getLibraryListRequest:
		return soap_in_PointerTo_ngwm__getLibraryListRequest(soap, NULL, NULL, "ngwm:getLibraryListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getLibraryItemResponse:
		return soap_in_PointerTo_ngwm__getLibraryItemResponse(soap, NULL, NULL, "ngwm:getLibraryItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__getLibraryItemRequest:
		return soap_in_PointerTo_ngwm__getLibraryItemRequest(soap, NULL, NULL, "ngwm:getLibraryItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__getJunkMailSettingsResponse:
		return soap_in_PointerTo_ngwm__getJunkMailSettingsResponse(soap, NULL, NULL, "ngwm:getJunkMailSettingsResponse");
	case SOAP_TYPE_PointerTo_ngwm__getJunkMailSettingsRequest:
		return soap_in_PointerTo_ngwm__getJunkMailSettingsRequest(soap, NULL, NULL, "ngwm:getJunkMailSettingsRequest");
	case SOAP_TYPE_PointerTo_ngwm__getJunkEntriesResponse:
		return soap_in_PointerTo_ngwm__getJunkEntriesResponse(soap, NULL, NULL, "ngwm:getJunkEntriesResponse");
	case SOAP_TYPE_PointerTo_ngwm__getJunkEntriesRequest:
		return soap_in_PointerTo_ngwm__getJunkEntriesRequest(soap, NULL, NULL, "ngwm:getJunkEntriesRequest");
	case SOAP_TYPE_PointerTo_ngwm__getItemsResponse:
		return soap_in_PointerTo_ngwm__getItemsResponse(soap, NULL, NULL, "ngwm:getItemsResponse");
	case SOAP_TYPE_PointerTo_ngwm__getItemsRequest:
		return soap_in_PointerTo_ngwm__getItemsRequest(soap, NULL, NULL, "ngwm:getItemsRequest");
	case SOAP_TYPE_PointerTo_ngwm__getItemResponse:
		return soap_in_PointerTo_ngwm__getItemResponse(soap, NULL, NULL, "ngwm:getItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__getItemRequest:
		return soap_in_PointerTo_ngwm__getItemRequest(soap, NULL, NULL, "ngwm:getItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__getFreeBusyResponse:
		return soap_in_PointerTo_ngwm__getFreeBusyResponse(soap, NULL, NULL, "ngwm:getFreeBusyResponse");
	case SOAP_TYPE_PointerTo_ngwm__getFreeBusyRequest:
		return soap_in_PointerTo_ngwm__getFreeBusyRequest(soap, NULL, NULL, "ngwm:getFreeBusyRequest");
	case SOAP_TYPE_PointerTo_ngwm__getFolderListResponse:
		return soap_in_PointerTo_ngwm__getFolderListResponse(soap, NULL, NULL, "ngwm:getFolderListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getFolderListRequest:
		return soap_in_PointerTo_ngwm__getFolderListRequest(soap, NULL, NULL, "ngwm:getFolderListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getFolderResponse:
		return soap_in_PointerTo_ngwm__getFolderResponse(soap, NULL, NULL, "ngwm:getFolderResponse");
	case SOAP_TYPE_PointerTo_ngwm__getFolderRequest:
		return soap_in_PointerTo_ngwm__getFolderRequest(soap, NULL, NULL, "ngwm:getFolderRequest");
	case SOAP_TYPE_PointerTo_ngwm__getDocumentTypeListResponse:
		return soap_in_PointerTo_ngwm__getDocumentTypeListResponse(soap, NULL, NULL, "ngwm:getDocumentTypeListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getDocumentTypeListRequest:
		return soap_in_PointerTo_ngwm__getDocumentTypeListRequest(soap, NULL, NULL, "ngwm:getDocumentTypeListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getDeltaInfoResponse:
		return soap_in_PointerTo_ngwm__getDeltaInfoResponse(soap, NULL, NULL, "ngwm:getDeltaInfoResponse");
	case SOAP_TYPE_PointerTo_ngwm__getDeltaInfoRequest:
		return soap_in_PointerTo_ngwm__getDeltaInfoRequest(soap, NULL, NULL, "ngwm:getDeltaInfoRequest");
	case SOAP_TYPE_PointerTo_ngwm__getDeltasResponse:
		return soap_in_PointerTo_ngwm__getDeltasResponse(soap, NULL, NULL, "ngwm:getDeltasResponse");
	case SOAP_TYPE_PointerTo_ngwm__getDeltasRequest:
		return soap_in_PointerTo_ngwm__getDeltasRequest(soap, NULL, NULL, "ngwm:getDeltasRequest");
	case SOAP_TYPE_PointerTo_ngwm__getCustomListResponse:
		return soap_in_PointerTo_ngwm__getCustomListResponse(soap, NULL, NULL, "ngwm:getCustomListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getCustomListRequest:
		return soap_in_PointerTo_ngwm__getCustomListRequest(soap, NULL, NULL, "ngwm:getCustomListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getCategoryListResponse:
		return soap_in_PointerTo_ngwm__getCategoryListResponse(soap, NULL, NULL, "ngwm:getCategoryListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getCategoryListRequest:
		return soap_in_PointerTo_ngwm__getCategoryListRequest(soap, NULL, NULL, "ngwm:getCategoryListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getAttachmentResponse:
		return soap_in_PointerTo_ngwm__getAttachmentResponse(soap, NULL, NULL, "ngwm:getAttachmentResponse");
	case SOAP_TYPE_PointerTo_ngwm__getAttachmentRequest:
		return soap_in_PointerTo_ngwm__getAttachmentRequest(soap, NULL, NULL, "ngwm:getAttachmentRequest");
	case SOAP_TYPE_PointerTo_ngwm__getAddressBookListResponse:
		return soap_in_PointerTo_ngwm__getAddressBookListResponse(soap, NULL, NULL, "ngwm:getAddressBookListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getAddressBookListRequest:
		return soap_in_PointerTo_ngwm__getAddressBookListRequest(soap, NULL, NULL, "ngwm:getAddressBookListRequest");
	case SOAP_TYPE_PointerTo_ngwm__forwardResponse:
		return soap_in_PointerTo_ngwm__forwardResponse(soap, NULL, NULL, "ngwm:forwardResponse");
	case SOAP_TYPE_PointerTo_ngwm__forwardRequest:
		return soap_in_PointerTo_ngwm__forwardRequest(soap, NULL, NULL, "ngwm:forwardRequest");
	case SOAP_TYPE_PointerTo_ngwm__executeRuleResponse:
		return soap_in_PointerTo_ngwm__executeRuleResponse(soap, NULL, NULL, "ngwm:executeRuleResponse");
	case SOAP_TYPE_PointerTo_ngwm__executeRuleRequest:
		return soap_in_PointerTo_ngwm__executeRuleRequest(soap, NULL, NULL, "ngwm:executeRuleRequest");
	case SOAP_TYPE_PointerTo_ngwm__destroyCursorResponse:
		return soap_in_PointerTo_ngwm__destroyCursorResponse(soap, NULL, NULL, "ngwm:destroyCursorResponse");
	case SOAP_TYPE_PointerTo_ngwm__destroyCursorRequest:
		return soap_in_PointerTo_ngwm__destroyCursorRequest(soap, NULL, NULL, "ngwm:destroyCursorRequest");
	case SOAP_TYPE_PointerTo_ngwm__delegateResponse:
		return soap_in_PointerTo_ngwm__delegateResponse(soap, NULL, NULL, "ngwm:delegateResponse");
	case SOAP_TYPE_PointerTo_ngwm__delegateRequest:
		return soap_in_PointerTo_ngwm__delegateRequest(soap, NULL, NULL, "ngwm:delegateRequest");
	case SOAP_TYPE_PointerTo_ngwm__declineResponse:
		return soap_in_PointerTo_ngwm__declineResponse(soap, NULL, NULL, "ngwm:declineResponse");
	case SOAP_TYPE_PointerTo_ngwm__declineRequest:
		return soap_in_PointerTo_ngwm__declineRequest(soap, NULL, NULL, "ngwm:declineRequest");
	case SOAP_TYPE_PointerTo_ngwm__createSignatureResponse:
		return soap_in_PointerTo_ngwm__createSignatureResponse(soap, NULL, NULL, "ngwm:createSignatureResponse");
	case SOAP_TYPE_PointerTo_ngwm__createSignatureRequest:
		return soap_in_PointerTo_ngwm__createSignatureRequest(soap, NULL, NULL, "ngwm:createSignatureRequest");
	case SOAP_TYPE_PointerTo_ngwm__createProxyAccessResponse:
		return soap_in_PointerTo_ngwm__createProxyAccessResponse(soap, NULL, NULL, "ngwm:createProxyAccessResponse");
	case SOAP_TYPE_PointerTo_ngwm__createProxyAccessRequest:
		return soap_in_PointerTo_ngwm__createProxyAccessRequest(soap, NULL, NULL, "ngwm:createProxyAccessRequest");
	case SOAP_TYPE_PointerTo_ngwm__createJunkEntryResponse:
		return soap_in_PointerTo_ngwm__createJunkEntryResponse(soap, NULL, NULL, "ngwm:createJunkEntryResponse");
	case SOAP_TYPE_PointerTo_ngwm__createJunkEntryRequest:
		return soap_in_PointerTo_ngwm__createJunkEntryRequest(soap, NULL, NULL, "ngwm:createJunkEntryRequest");
	case SOAP_TYPE_PointerTo_ngwm__createItemsResponse:
		return soap_in_PointerTo_ngwm__createItemsResponse(soap, NULL, NULL, "ngwm:createItemsResponse");
	case SOAP_TYPE_PointerTo_ngwm__createItemsRequest:
		return soap_in_PointerTo_ngwm__createItemsRequest(soap, NULL, NULL, "ngwm:createItemsRequest");
	case SOAP_TYPE_PointerTo_ngwm__createItemResponse:
		return soap_in_PointerTo_ngwm__createItemResponse(soap, NULL, NULL, "ngwm:createItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__createItemRequest:
		return soap_in_PointerTo_ngwm__createItemRequest(soap, NULL, NULL, "ngwm:createItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__createCursorResponse:
		return soap_in_PointerTo_ngwm__createCursorResponse(soap, NULL, NULL, "ngwm:createCursorResponse");
	case SOAP_TYPE_PointerTo_ngwm__createCursorRequest:
		return soap_in_PointerTo_ngwm__createCursorRequest(soap, NULL, NULL, "ngwm:createCursorRequest");
	case SOAP_TYPE_PointerTo_ngwm__completeResponse:
		return soap_in_PointerTo_ngwm__completeResponse(soap, NULL, NULL, "ngwm:completeResponse");
	case SOAP_TYPE_PointerTo_ngwm__completeRequest:
		return soap_in_PointerTo_ngwm__completeRequest(soap, NULL, NULL, "ngwm:completeRequest");
	case SOAP_TYPE_PointerTo_ngwm__closeFreeBusySessionResponse:
		return soap_in_PointerTo_ngwm__closeFreeBusySessionResponse(soap, NULL, NULL, "ngwm:closeFreeBusySessionResponse");
	case SOAP_TYPE_PointerTo_ngwm__closeFreeBusySessionRequest:
		return soap_in_PointerTo_ngwm__closeFreeBusySessionRequest(soap, NULL, NULL, "ngwm:closeFreeBusySessionRequest");
	case SOAP_TYPE_PointerTo_ngwm__addMembersResponse:
		return soap_in_PointerTo_ngwm__addMembersResponse(soap, NULL, NULL, "ngwm:addMembersResponse");
	case SOAP_TYPE_PointerTo_ngwm__addMembersRequest:
		return soap_in_PointerTo_ngwm__addMembersRequest(soap, NULL, NULL, "ngwm:addMembersRequest");
	case SOAP_TYPE_PointerTo_ngwm__addItemsResponse:
		return soap_in_PointerTo_ngwm__addItemsResponse(soap, NULL, NULL, "ngwm:addItemsResponse");
	case SOAP_TYPE_PointerTo_ngwm__addItemsRequest:
		return soap_in_PointerTo_ngwm__addItemsRequest(soap, NULL, NULL, "ngwm:addItemsRequest");
	case SOAP_TYPE_PointerTo_ngwm__addItemResponse:
		return soap_in_PointerTo_ngwm__addItemResponse(soap, NULL, NULL, "ngwm:addItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__addItemRequest:
		return soap_in_PointerTo_ngwm__addItemRequest(soap, NULL, NULL, "ngwm:addItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__acceptShareResponse:
		return soap_in_PointerTo_ngwm__acceptShareResponse(soap, NULL, NULL, "ngwm:acceptShareResponse");
	case SOAP_TYPE_PointerTo_ngwm__acceptShareRequest:
		return soap_in_PointerTo_ngwm__acceptShareRequest(soap, NULL, NULL, "ngwm:acceptShareRequest");
	case SOAP_TYPE_PointerTo_ngwm__acceptResponse:
		return soap_in_PointerTo_ngwm__acceptResponse(soap, NULL, NULL, "ngwm:acceptResponse");
	case SOAP_TYPE_PointerTo_ngwm__acceptRequest:
		return soap_in_PointerTo_ngwm__acceptRequest(soap, NULL, NULL, "ngwm:acceptRequest");
	case SOAP_TYPE_PointerTongwt__Alarm:
		return soap_in_PointerTongwt__Alarm(soap, NULL, NULL, "ngwt:Alarm");
	case SOAP_TYPE_PointerTongwt__PhoneFlags:
		return soap_in_PointerTongwt__PhoneFlags(soap, NULL, NULL, "ngwt:PhoneFlags");
	case SOAP_TYPE_PointerTongwt__RecurrenceRule:
		return soap_in_PointerTongwt__RecurrenceRule(soap, NULL, NULL, "ngwt:RecurrenceRule");
	case SOAP_TYPE_PointerTongwt__RecurrenceDateType:
		return soap_in_PointerTongwt__RecurrenceDateType(soap, NULL, NULL, "ngwt:RecurrenceDateType");
	case SOAP_TYPE_PointerTongwt__SMimeOperation:
		return soap_in_PointerTongwt__SMimeOperation(soap, NULL, NULL, "ngwt:SMimeOperation");
	case SOAP_TYPE_PointerTongwt__LinkInfo:
		return soap_in_PointerTongwt__LinkInfo(soap, NULL, NULL, "ngwt:LinkInfo");
	case SOAP_TYPE_PointerTongwt__ItemOptions:
		return soap_in_PointerTongwt__ItemOptions(soap, NULL, NULL, "ngwt:ItemOptions");
	case SOAP_TYPE_PointerTongwt__AttachmentInfo:
		return soap_in_PointerTongwt__AttachmentInfo(soap, NULL, NULL, "ngwt:AttachmentInfo");
	case SOAP_TYPE_PointerTongwt__MessageBody:
		return soap_in_PointerTongwt__MessageBody(soap, NULL, NULL, "ngwt:MessageBody");
	case SOAP_TYPE_PointerTongwt__ReferenceInfo:
		return soap_in_PointerTongwt__ReferenceInfo(soap, NULL, NULL, "ngwt:ReferenceInfo");
	case SOAP_TYPE_PointerTongwt__PersonalInfo:
		return soap_in_PointerTongwt__PersonalInfo(soap, NULL, NULL, "ngwt:PersonalInfo");
	case SOAP_TYPE_PointerTongwt__OfficeInfo:
		return soap_in_PointerTongwt__OfficeInfo(soap, NULL, NULL, "ngwt:OfficeInfo");
	case SOAP_TYPE_PointerTongwt__PostalAddressList:
		return soap_in_PointerTongwt__PostalAddressList(soap, NULL, NULL, "ngwt:PostalAddressList");
	case SOAP_TYPE_PointerTongwt__PhoneList:
		return soap_in_PointerTongwt__PhoneList(soap, NULL, NULL, "ngwt:PhoneList");
	case SOAP_TYPE_PointerTongwt__ImAddressList:
		return soap_in_PointerTongwt__ImAddressList(soap, NULL, NULL, "ngwt:ImAddressList");
	case SOAP_TYPE_PointerTongwt__EmailAddressList:
		return soap_in_PointerTongwt__EmailAddressList(soap, NULL, NULL, "ngwt:EmailAddressList");
	case SOAP_TYPE_PointerTongwt__FullName:
		return soap_in_PointerTongwt__FullName(soap, NULL, NULL, "ngwt:FullName");
	case SOAP_TYPE_PointerTongwt__VersionStatus:
		return soap_in_PointerTongwt__VersionStatus(soap, NULL, NULL, "ngwt:VersionStatus");
	case SOAP_TYPE_PointerTongwt__FolderACL:
		return soap_in_PointerTongwt__FolderACL(soap, NULL, NULL, "ngwt:FolderACL");
	case SOAP_TYPE_PointerTongwt__RuleActionList:
		return soap_in_PointerTongwt__RuleActionList(soap, NULL, NULL, "ngwt:RuleActionList");
	case SOAP_TYPE_PointerTongwt__Execution:
		return soap_in_PointerTongwt__Execution(soap, NULL, NULL, "ngwt:Execution");
	case SOAP_TYPE_PointerTongwt__Query:
		return soap_in_PointerTongwt__Query(soap, NULL, NULL, "ngwt:Query");
	case SOAP_TYPE_PointerTongwt__FolderACLStatus:
		return soap_in_PointerTongwt__FolderACLStatus(soap, NULL, NULL, "ngwt:FolderACLStatus");
	case SOAP_TYPE_PointerTongwt__AccessControlList:
		return soap_in_PointerTongwt__AccessControlList(soap, NULL, NULL, "ngwt:AccessControlList");
	case SOAP_TYPE_PointerTongwt__WeekOfYear:
		return soap_in_PointerTongwt__WeekOfYear(soap, NULL, NULL, "ngwt:WeekOfYear");
	case SOAP_TYPE_PointerTongwt__OccurrenceType:
		return soap_in_PointerTongwt__OccurrenceType(soap, NULL, NULL, "ngwt:OccurrenceType");
	case SOAP_TYPE_PointerTongwt__ItemSecurity:
		return soap_in_PointerTongwt__ItemSecurity(soap, NULL, NULL, "ngwt:ItemSecurity");
	case SOAP_TYPE_PointerTongwt__ItemClass:
		return soap_in_PointerTongwt__ItemClass(soap, NULL, NULL, "ngwt:ItemClass");
	case SOAP_TYPE_PointerTongwt__ItemSource:
		return soap_in_PointerTongwt__ItemSource(soap, NULL, NULL, "ngwt:ItemSource");
	case SOAP_TYPE_PointerTongwt__ItemStatus:
		return soap_in_PointerTongwt__ItemStatus(soap, NULL, NULL, "ngwt:ItemStatus");
	case SOAP_TYPE_PointerTongwt__DeltaSyncType:
		return soap_in_PointerTongwt__DeltaSyncType(soap, NULL, NULL, "ngwt:DeltaSyncType");
	case SOAP_TYPE_PointerTongwt__RecipientStatus:
		return soap_in_PointerTongwt__RecipientStatus(soap, NULL, NULL, "ngwt:RecipientStatus");
	case SOAP_TYPE_PointerTongwt__FreeBusyBlockList:
		return soap_in_PointerTongwt__FreeBusyBlockList(soap, NULL, NULL, "ngwt:FreeBusyBlockList");
	case SOAP_TYPE_PointerTongwt__CalendarFolderAttribute:
		return soap_in_PointerTongwt__CalendarFolderAttribute(soap, NULL, NULL, "ngwt:CalendarFolderAttribute");
	case SOAP_TYPE_PointerTongwt__FilterDate:
		return soap_in_PointerTongwt__FilterDate(soap, NULL, NULL, "ngwt:FilterDate");
	case SOAP_TYPE_PointerTongwt__ContainerRef:
		return soap_in_PointerTongwt__ContainerRef(soap, NULL, NULL, "ngwt:ContainerRef");
	case SOAP_TYPE_PointerTongwt__CategoryType:
		return soap_in_PointerTongwt__CategoryType(soap, NULL, NULL, "ngwt:CategoryType");
	case SOAP_TYPE_PointerTongwt__AccessMiscRight:
		return soap_in_PointerTongwt__AccessMiscRight(soap, NULL, NULL, "ngwt:AccessMiscRight");
	case SOAP_TYPE_PointerTongwt__AccessRight:
		return soap_in_PointerTongwt__AccessRight(soap, NULL, NULL, "ngwt:AccessRight");
	case SOAP_TYPE_PointerTongwt__Rights:
		return soap_in_PointerTongwt__Rights(soap, NULL, NULL, "ngwt:Rights");
	case SOAP_TYPE_PointerTongwe__EventList:
		return soap_in_PointerTongwe__EventList(soap, NULL, NULL, "ngwe:EventList");
	case SOAP_TYPE_PointerTongwe__EventsList:
		return soap_in_PointerTongwe__EventsList(soap, NULL, NULL, "ngwe:EventsList");
	case SOAP_TYPE_PointerTongwe__Events:
		return soap_in_PointerTongwe__Events(soap, NULL, NULL, "ngwe:Events");
	case SOAP_TYPE_PointerTongwe__EventDefinition:
		return soap_in_PointerTongwe__EventDefinition(soap, NULL, NULL, "ngwe:EventDefinition");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTongwe__Event:
		return soap_in_PointerTongwe__Event(soap, NULL, NULL, "ngwe:Event");
	case SOAP_TYPE_PointerTongwe__ContainerList:
		return soap_in_PointerTongwe__ContainerList(soap, NULL, NULL, "ngwe:ContainerList");
	case SOAP_TYPE_PointerTongwe__ItemTypeList:
		return soap_in_PointerTongwe__ItemTypeList(soap, NULL, NULL, "ngwe:ItemTypeList");
	case SOAP_TYPE_PointerTongwe__EventTypeList:
		return soap_in_PointerTongwe__EventTypeList(soap, NULL, NULL, "ngwe:EventTypeList");
	case SOAP_TYPE_PointerTongwe__ItemType:
		return soap_in_PointerTongwe__ItemType(soap, NULL, NULL, "ngwe:ItemType");
	case SOAP_TYPE_PointerTongwe__FieldList:
		return soap_in_PointerTongwe__FieldList(soap, NULL, NULL, "ngwe:FieldList");
	case SOAP_TYPE_PointerTongwt__FreeBusyUserList:
		return soap_in_PointerTongwt__FreeBusyUserList(soap, NULL, NULL, "ngwt:FreeBusyUserList");
	case SOAP_TYPE_PointerTongwt__RetractType:
		return soap_in_PointerTongwt__RetractType(soap, NULL, NULL, "ngwt:RetractType");
	case SOAP_TYPE_PointerTongwt__ItemList:
		return soap_in_PointerTongwt__ItemList(soap, NULL, NULL, "ngwt:ItemList");
	case SOAP_TYPE_PointerTongwt__CursorSeek:
		return soap_in_PointerTongwt__CursorSeek(soap, NULL, NULL, "ngwt:CursorSeek");
	case SOAP_TYPE_PointerTongwt__AccessRightChanges:
		return soap_in_PointerTongwt__AccessRightChanges(soap, NULL, NULL, "ngwt:AccessRightChanges");
	case SOAP_TYPE_PointerTongwt__ModifyItem:
		return soap_in_PointerTongwt__ModifyItem(soap, NULL, NULL, "ngwt:ModifyItem");
	case SOAP_TYPE_PointerTongwt__Host:
		return soap_in_PointerTongwt__Host(soap, NULL, NULL, "ngwt:Host");
	case SOAP_TYPE_PointerTongwt__Authentication:
		return soap_in_PointerTongwt__Authentication(soap, NULL, NULL, "ngwt:Authentication");
	case SOAP_TYPE_PointerTongwt__UserList:
		return soap_in_PointerTongwt__UserList(soap, NULL, NULL, "ngwt:UserList");
	case SOAP_TYPE_PointerTongwt__TimezoneList:
		return soap_in_PointerTongwt__TimezoneList(soap, NULL, NULL, "ngwt:TimezoneList");
	case SOAP_TYPE_PointerTongwt__Signatures:
		return soap_in_PointerTongwt__Signatures(soap, NULL, NULL, "ngwt:Signatures");
	case SOAP_TYPE_PointerTongwt__Settings:
		return soap_in_PointerTongwt__Settings(soap, NULL, NULL, "ngwt:Settings");
	case SOAP_TYPE_PointerTongwt__RuleList:
		return soap_in_PointerTongwt__RuleList(soap, NULL, NULL, "ngwt:RuleList");
	case SOAP_TYPE_PointerTongwt__ProxyList:
		return soap_in_PointerTongwt__ProxyList(soap, NULL, NULL, "ngwt:ProxyList");
	case SOAP_TYPE_PointerTongwt__AccessRightList:
		return soap_in_PointerTongwt__AccessRightList(soap, NULL, NULL, "ngwt:AccessRightList");
	case SOAP_TYPE_PointerTongwt__LibraryList:
		return soap_in_PointerTongwt__LibraryList(soap, NULL, NULL, "ngwt:LibraryList");
	case SOAP_TYPE_PointerTongwt__SettingsList:
		return soap_in_PointerTongwt__SettingsList(soap, NULL, NULL, "ngwt:SettingsList");
	case SOAP_TYPE_PointerTongwt__JunkHandlingList:
		return soap_in_PointerTongwt__JunkHandlingList(soap, NULL, NULL, "ngwt:JunkHandlingList");
	case SOAP_TYPE_PointerTongwt__FreeBusyInfoList:
		return soap_in_PointerTongwt__FreeBusyInfoList(soap, NULL, NULL, "ngwt:FreeBusyInfoList");
	case SOAP_TYPE_PointerTongwt__FreeBusyStats:
		return soap_in_PointerTongwt__FreeBusyStats(soap, NULL, NULL, "ngwt:FreeBusyStats");
	case SOAP_TYPE_PointerTongwt__FolderList:
		return soap_in_PointerTongwt__FolderList(soap, NULL, NULL, "ngwt:FolderList");
	case SOAP_TYPE_PointerTongwt__ItemSourceList:
		return soap_in_PointerTongwt__ItemSourceList(soap, NULL, NULL, "ngwt:ItemSourceList");
	case SOAP_TYPE_PointerTongwt__MessageTypeList:
		return soap_in_PointerTongwt__MessageTypeList(soap, NULL, NULL, "ngwt:MessageTypeList");
	case SOAP_TYPE_PointerTongwt__FolderType:
		return soap_in_PointerTongwt__FolderType(soap, NULL, NULL, "ngwt:FolderType");
	case SOAP_TYPE_PointerTongwt__DocumentTypeList:
		return soap_in_PointerTongwt__DocumentTypeList(soap, NULL, NULL, "ngwt:DocumentTypeList");
	case SOAP_TYPE_PointerTongwt__Items:
		return soap_in_PointerTongwt__Items(soap, NULL, NULL, "ngwt:Items");
	case SOAP_TYPE_PointerTongwt__DeltaInfo:
		return soap_in_PointerTongwt__DeltaInfo(soap, NULL, NULL, "ngwt:DeltaInfo");
	case SOAP_TYPE_PointerTongwt__CustomList:
		return soap_in_PointerTongwt__CustomList(soap, NULL, NULL, "ngwt:CustomList");
	case SOAP_TYPE_PointerTongwt__CategoryList:
		return soap_in_PointerTongwt__CategoryList(soap, NULL, NULL, "ngwt:CategoryList");
	case SOAP_TYPE_PointerTongwt__AddressBookList:
		return soap_in_PointerTongwt__AddressBookList(soap, NULL, NULL, "ngwt:AddressBookList");
	case SOAP_TYPE_PointerTongwt__Distribution:
		return soap_in_PointerTongwt__Distribution(soap, NULL, NULL, "ngwt:Distribution");
	case SOAP_TYPE_PointerTongwt__View:
		return soap_in_PointerTongwt__View(soap, NULL, NULL, "ngwt:View");
	case SOAP_TYPE_PointerTongwt__Status:
		return soap_in_PointerTongwt__Status(soap, NULL, NULL, "ngwt:Status");
	case SOAP_TYPE_PointerTongwt__ItemRefList:
		return soap_in_PointerTongwt__ItemRefList(soap, NULL, NULL, "ngwt:ItemRefList");
	case SOAP_TYPE_PointerTongwt__UserInfo:
		return soap_in_PointerTongwt__UserInfo(soap, NULL, NULL, "ngwt:UserInfo");
	case SOAP_TYPE_PointerTongwt__RecipientType:
		return soap_in_PointerTongwt__RecipientType(soap, NULL, NULL, "ngwt:RecipientType");
	case SOAP_TYPE_PointerTongwt__Timezone:
		return soap_in_PointerTongwt__Timezone(soap, NULL, NULL, "ngwt:Timezone");
	case SOAP_TYPE_PointerTongwt__Minute:
		return soap_in_PointerTongwt__Minute(soap, NULL, NULL, "ngwt:Minute");
	case SOAP_TYPE_PointerTongwt__Hour:
		return soap_in_PointerTongwt__Hour(soap, NULL, NULL, "ngwt:Hour");
	case SOAP_TYPE_PointerTongwt__DayOfWeek:
		return soap_in_PointerTongwt__DayOfWeek(soap, NULL, NULL, "ngwt:DayOfWeek");
	case SOAP_TYPE_PointerTongwt__Day:
		return soap_in_PointerTongwt__Day(soap, NULL, NULL, "ngwt:Day");
	case SOAP_TYPE_PointerTongwt__Month:
		return soap_in_PointerTongwt__Month(soap, NULL, NULL, "ngwt:Month");
	case SOAP_TYPE_PointerTongwt__TimezoneComponent:
		return soap_in_PointerTongwt__TimezoneComponent(soap, NULL, NULL, "ngwt:TimezoneComponent");
	case SOAP_TYPE_PointerTongwt__ProblemList:
		return soap_in_PointerTongwt__ProblemList(soap, NULL, NULL, "ngwt:ProblemList");
	case SOAP_TYPE_PointerTongwt__Signature:
		return soap_in_PointerTongwt__Signature(soap, NULL, NULL, "ngwt:Signature");
	case SOAP_TYPE_PointerTongwt__SignatureData:
		return soap_in_PointerTongwt__SignatureData(soap, NULL, NULL, "ngwt:SignatureData");
	case SOAP_TYPE_PointerTongwt__SettingsGroup:
		return soap_in_PointerTongwt__SettingsGroup(soap, NULL, NULL, "ngwt:SettingsGroup");
	case SOAP_TYPE_PointerTongwt__ReturnNotification:
		return soap_in_PointerTongwt__ReturnNotification(soap, NULL, NULL, "ngwt:ReturnNotification");
	case SOAP_TYPE_PointerTongwt__StatusTracking:
		return soap_in_PointerTongwt__StatusTracking(soap, NULL, NULL, "ngwt:StatusTracking");
	case SOAP_TYPE_PointerTongwt__SendOptionsRequestReply:
		return soap_in_PointerTongwt__SendOptionsRequestReply(soap, NULL, NULL, "ngwt:SendOptionsRequestReply");
	case SOAP_TYPE_PointerTongwt__Rule:
		return soap_in_PointerTongwt__Rule(soap, NULL, NULL, "ngwt:Rule");
	case SOAP_TYPE_PointerTongwt__RuleAction:
		return soap_in_PointerTongwt__RuleAction(soap, NULL, NULL, "ngwt:RuleAction");
	case SOAP_TYPE_PointerTongwt__CategoryRefList:
		return soap_in_PointerTongwt__CategoryRefList(soap, NULL, NULL, "ngwt:CategoryRefList");
	case SOAP_TYPE_PointerTongwt__Mail:
		return soap_in_PointerTongwt__Mail(soap, NULL, NULL, "ngwt:Mail");
	case SOAP_TYPE_PointerTongwt__ReturnNotificationOptions:
		return soap_in_PointerTongwt__ReturnNotificationOptions(soap, NULL, NULL, "ngwt:ReturnNotificationOptions");
	case SOAP_TYPE_PointerTongwt__MonthList:
		return soap_in_PointerTongwt__MonthList(soap, NULL, NULL, "ngwt:MonthList");
	case SOAP_TYPE_PointerTongwt__DayOfYearList:
		return soap_in_PointerTongwt__DayOfYearList(soap, NULL, NULL, "ngwt:DayOfYearList");
	case SOAP_TYPE_PointerTongwt__DayOfMonthList:
		return soap_in_PointerTongwt__DayOfMonthList(soap, NULL, NULL, "ngwt:DayOfMonthList");
	case SOAP_TYPE_PointerTongwt__DayOfYearWeekList:
		return soap_in_PointerTongwt__DayOfYearWeekList(soap, NULL, NULL, "ngwt:DayOfYearWeekList");
	case SOAP_TYPE_PointerTongwt__Frequency:
		return soap_in_PointerTongwt__Frequency(soap, NULL, NULL, "ngwt:Frequency");
	case SOAP_TYPE_PointerTongwt__DelegateeStatus:
		return soap_in_PointerTongwt__DelegateeStatus(soap, NULL, NULL, "ngwt:DelegateeStatus");
	case SOAP_TYPE_PointerTongwt__DelegatedStatus:
		return soap_in_PointerTongwt__DelegatedStatus(soap, NULL, NULL, "ngwt:DelegatedStatus");
	case SOAP_TYPE_PointerTongwt__CommentStatus:
		return soap_in_PointerTongwt__CommentStatus(soap, NULL, NULL, "ngwt:CommentStatus");
	case SOAP_TYPE_PointerTongwt__TransferFailedStatus:
		return soap_in_PointerTongwt__TransferFailedStatus(soap, NULL, NULL, "ngwt:TransferFailedStatus");
	case SOAP_TYPE_PointerTongwt__Recipient:
		return soap_in_PointerTongwt__Recipient(soap, NULL, NULL, "ngwt:Recipient");
	case SOAP_TYPE_PointerTongwt__Filter:
		return soap_in_PointerTongwt__Filter(soap, NULL, NULL, "ngwt:Filter");
	case SOAP_TYPE_PointerTongwt__QueryTarget:
		return soap_in_PointerTongwt__QueryTarget(soap, NULL, NULL, "ngwt:QueryTarget");
	case SOAP_TYPE_PointerTongwt__ProxyUser:
		return soap_in_PointerTongwt__ProxyUser(soap, NULL, NULL, "ngwt:ProxyUser");
	case SOAP_TYPE_PointerTongwt__ProblemEntry:
		return soap_in_PointerTongwt__ProblemEntry(soap, NULL, NULL, "ngwt:ProblemEntry");
	case SOAP_TYPE_PointerTongwt__PostalAddress:
		return soap_in_PointerTongwt__PostalAddress(soap, NULL, NULL, "ngwt:PostalAddress");
	case SOAP_TYPE_PointerTongwt__PhoneNumber:
		return soap_in_PointerTongwt__PhoneNumber(soap, NULL, NULL, "ngwt:PhoneNumber");
	case SOAP_TYPE_PointerToxsd__date:
		return soap_in_PointerToxsd__date(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_PointerTongwt__ItemRef:
		return soap_in_PointerTongwt__ItemRef(soap, NULL, NULL, "ngwt:ItemRef");
	case SOAP_TYPE_PointerTongwt__UUID:
		return soap_in_PointerTongwt__UUID(soap, NULL, NULL, "ngwt:UUID");
	case SOAP_TYPE_PointerTongwt__SharedFolderNotification:
		return soap_in_PointerTongwt__SharedFolderNotification(soap, NULL, NULL, "ngwt:SharedFolderNotification");
	case SOAP_TYPE_PointerTongwt__MessagePart:
		return soap_in_PointerTongwt__MessagePart(soap, NULL, NULL, "ngwt:MessagePart");
	case SOAP_TYPE_PointerTongwt__Library:
		return soap_in_PointerTongwt__Library(soap, NULL, NULL, "ngwt:Library");
	case SOAP_TYPE_PointerTongwt__JunkEntry:
		return soap_in_PointerTongwt__JunkEntry(soap, NULL, NULL, "ngwt:JunkEntry");
	case SOAP_TYPE_PointerTongwt__JunkHandlingListType:
		return soap_in_PointerTongwt__JunkHandlingListType(soap, NULL, NULL, "ngwt:JunkHandlingListType");
	case SOAP_TYPE_PointerTongwt__Item:
		return soap_in_PointerTongwt__Item(soap, NULL, NULL, "ngwt:Item");
	case SOAP_TYPE_PointerTongwt__ItemChanges:
		return soap_in_PointerTongwt__ItemChanges(soap, NULL, NULL, "ngwt:ItemChanges");
	case SOAP_TYPE_PointerTongwt__ImAddress:
		return soap_in_PointerTongwt__ImAddress(soap, NULL, NULL, "ngwt:ImAddress");
	case SOAP_TYPE_PointerTongwt__GroupMember:
		return soap_in_PointerTongwt__GroupMember(soap, NULL, NULL, "ngwt:GroupMember");
	case SOAP_TYPE_PointerTongwt__GroupMemberList:
		return soap_in_PointerTongwt__GroupMemberList(soap, NULL, NULL, "ngwt:GroupMemberList");
	case SOAP_TYPE_PointerTongwt__FreeBusyInfo:
		return soap_in_PointerTongwt__FreeBusyInfo(soap, NULL, NULL, "ngwt:FreeBusyInfo");
	case SOAP_TYPE_PointerTongwt__NameAndEmail:
		return soap_in_PointerTongwt__NameAndEmail(soap, NULL, NULL, "ngwt:NameAndEmail");
	case SOAP_TYPE_PointerTongwt__AcceptLevel:
		return soap_in_PointerTongwt__AcceptLevel(soap, NULL, NULL, "ngwt:AcceptLevel");
	case SOAP_TYPE_PointerTongwt__FreeBusyBlock:
		return soap_in_PointerTongwt__FreeBusyBlock(soap, NULL, NULL, "ngwt:FreeBusyBlock");
	case SOAP_TYPE_PointerTongwt__Folder:
		return soap_in_PointerTongwt__Folder(soap, NULL, NULL, "ngwt:Folder");
	case SOAP_TYPE_PointerTongwt__FolderACLEntry:
		return soap_in_PointerTongwt__FolderACLEntry(soap, NULL, NULL, "ngwt:FolderACLEntry");
	case SOAP_TYPE_PointerTongwt__FilterElement:
		return soap_in_PointerTongwt__FilterElement(soap, NULL, NULL, "ngwt:FilterElement");
	case SOAP_TYPE_PointerTongwt__DocumentType:
		return soap_in_PointerTongwt__DocumentType(soap, NULL, NULL, "ngwt:DocumentType");
	case SOAP_TYPE_PointerTongwt__AgeAction:
		return soap_in_PointerTongwt__AgeAction(soap, NULL, NULL, "ngwt:AgeAction");
	case SOAP_TYPE_PointerTongwt__SendOptions:
		return soap_in_PointerTongwt__SendOptions(soap, NULL, NULL, "ngwt:SendOptions");
	case SOAP_TYPE_PointerTongwt__RecipientList:
		return soap_in_PointerTongwt__RecipientList(soap, NULL, NULL, "ngwt:RecipientList");
	case SOAP_TYPE_PointerTongwt__From:
		return soap_in_PointerTongwt__From(soap, NULL, NULL, "ngwt:From");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTongwt__DayOfYearWeek:
		return soap_in_PointerTongwt__DayOfYearWeek(soap, NULL, NULL, "ngwt:DayOfYearWeek");
	case SOAP_TYPE_PointerTongwt__Custom:
		return soap_in_PointerTongwt__Custom(soap, NULL, NULL, "ngwt:Custom");
	case SOAP_TYPE_PointerTongwt__CustomType:
		return soap_in_PointerTongwt__CustomType(soap, NULL, NULL, "ngwt:CustomType");
	case SOAP_TYPE_PointerTongwt__uid:
		return soap_in_PointerTongwt__uid(soap, NULL, NULL, "ngwt:uid");
	case SOAP_TYPE_PointerTongwt__Category:
		return soap_in_PointerTongwt__Category(soap, NULL, NULL, "ngwt:Category");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTounsignedLong:
		return soap_in_PointerTounsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTongwt__AttachmentID:
		return soap_in_PointerTongwt__AttachmentID(soap, NULL, NULL, "ngwt:AttachmentID");
	case SOAP_TYPE_PointerTongwt__AttachmentItemInfo:
		return soap_in_PointerTongwt__AttachmentItemInfo(soap, NULL, NULL, "ngwt:AttachmentItemInfo");
	case SOAP_TYPE_PointerTongwt__AddressBook:
		return soap_in_PointerTongwt__AddressBook(soap, NULL, NULL, "ngwt:AddressBook");
	case SOAP_TYPE_PointerTongwt__AccessRightEntry:
		return soap_in_PointerTongwt__AccessRightEntry(soap, NULL, NULL, "ngwt:AccessRightEntry");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTongwt__AccessControlListEntry:
		return soap_in_PointerTongwt__AccessControlListEntry(soap, NULL, NULL, "ngwt:AccessControlListEntry");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ngwt:DayOfMonth"))
		{	*type = SOAP_TYPE_ngwt__DayOfMonth;
			return soap_in_ngwt__DayOfMonth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:WeekOfYear"))
		{	*type = SOAP_TYPE_ngwt__WeekOfYear;
			return soap_in_ngwt__WeekOfYear(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DayOfYear"))
		{	*type = SOAP_TYPE_ngwt__DayOfYear;
			return soap_in_ngwt__DayOfYear(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:GMTOffset"))
		{	*type = SOAP_TYPE_ngwt__GMTOffset;
			return soap_in_ngwt__GMTOffset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Month"))
		{	*type = SOAP_TYPE_ngwt__Month;
			return soap_in_ngwt__Month(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Minute"))
		{	*type = SOAP_TYPE_ngwt__Minute;
			return soap_in_ngwt__Minute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Hour"))
		{	*type = SOAP_TYPE_ngwt__Hour;
			return soap_in_ngwt__Hour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Day"))
		{	*type = SOAP_TYPE_ngwt__Day;
			return soap_in_ngwt__Day(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLong;
			return soap_in_unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:ItemType"))
		{	*type = SOAP_TYPE_ngwe__ItemType;
			return soap_in_ngwe__ItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:Field"))
		{	*type = SOAP_TYPE_ngwe__Field;
			return soap_in_ngwe__Field(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:EventType"))
		{	*type = SOAP_TYPE_ngwe__EventType;
			return soap_in_ngwe__EventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:WeekDay"))
		{	*type = SOAP_TYPE_ngwt__WeekDay;
			return soap_in_ngwt__WeekDay(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:VersionStatus"))
		{	*type = SOAP_TYPE_ngwt__VersionStatus;
			return soap_in_ngwt__VersionStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:VersionEventType"))
		{	*type = SOAP_TYPE_ngwt__VersionEventType;
			return soap_in_ngwt__VersionEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:StatusTrackingOptions"))
		{	*type = SOAP_TYPE_ngwt__StatusTrackingOptions;
			return soap_in_ngwt__StatusTrackingOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:RuleActionType"))
		{	*type = SOAP_TYPE_ngwt__RuleActionType;
			return soap_in_ngwt__RuleActionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:RetractType"))
		{	*type = SOAP_TYPE_ngwt__RetractType;
			return soap_in_ngwt__RetractType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:RecipientType"))
		{	*type = SOAP_TYPE_ngwt__RecipientType;
			return soap_in_ngwt__RecipientType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:PostalAddressType"))
		{	*type = SOAP_TYPE_ngwt__PostalAddressType;
			return soap_in_ngwt__PostalAddressType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:PhoneNumberType"))
		{	*type = SOAP_TYPE_ngwt__PhoneNumberType;
			return soap_in_ngwt__PhoneNumberType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:OccurrenceType"))
		{	*type = SOAP_TYPE_ngwt__OccurrenceType;
			return soap_in_ngwt__OccurrenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:NotificationType"))
		{	*type = SOAP_TYPE_ngwt__NotificationType;
			return soap_in_ngwt__NotificationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:MessageType"))
		{	*type = SOAP_TYPE_ngwt__MessageType;
			return soap_in_ngwt__MessageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:MessageList"))
		{	*type = SOAP_TYPE_ngwt__MessageList;
			return soap_in_ngwt__MessageList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:LinkType"))
		{	*type = SOAP_TYPE_ngwt__LinkType;
			return soap_in_ngwt__LinkType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:JunkMatchType"))
		{	*type = SOAP_TYPE_ngwt__JunkMatchType;
			return soap_in_ngwt__JunkMatchType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:JunkHandlingListType"))
		{	*type = SOAP_TYPE_ngwt__JunkHandlingListType;
			return soap_in_ngwt__JunkHandlingListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ItemSource"))
		{	*type = SOAP_TYPE_ngwt__ItemSource;
			return soap_in_ngwt__ItemSource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ItemSecurity"))
		{	*type = SOAP_TYPE_ngwt__ItemSecurity;
			return soap_in_ngwt__ItemSecurity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ItemOptionsPriority"))
		{	*type = SOAP_TYPE_ngwt__ItemOptionsPriority;
			return soap_in_ngwt__ItemOptionsPriority(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ItemClass"))
		{	*type = SOAP_TYPE_ngwt__ItemClass;
			return soap_in_ngwt__ItemClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Frequency"))
		{	*type = SOAP_TYPE_ngwt__Frequency;
			return soap_in_ngwt__Frequency(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FolderType"))
		{	*type = SOAP_TYPE_ngwt__FolderType;
			return soap_in_ngwt__FolderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FolderACLStatus"))
		{	*type = SOAP_TYPE_ngwt__FolderACLStatus;
			return soap_in_ngwt__FolderACLStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FilterOp"))
		{	*type = SOAP_TYPE_ngwt__FilterOp;
			return soap_in_ngwt__FilterOp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FilterDate"))
		{	*type = SOAP_TYPE_ngwt__FilterDate;
			return soap_in_ngwt__FilterDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Execution"))
		{	*type = SOAP_TYPE_ngwt__Execution;
			return soap_in_ngwt__Execution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DistributionType"))
		{	*type = SOAP_TYPE_ngwt__DistributionType;
			return soap_in_ngwt__DistributionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DeltaSyncType"))
		{	*type = SOAP_TYPE_ngwt__DeltaSyncType;
			return soap_in_ngwt__DeltaSyncType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:CustomType"))
		{	*type = SOAP_TYPE_ngwt__CustomType;
			return soap_in_ngwt__CustomType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:CursorSeek"))
		{	*type = SOAP_TYPE_ngwt__CursorSeek;
			return soap_in_ngwt__CursorSeek(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ContactType"))
		{	*type = SOAP_TYPE_ngwt__ContactType;
			return soap_in_ngwt__ContactType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:CategoryType"))
		{	*type = SOAP_TYPE_ngwt__CategoryType;
			return soap_in_ngwt__CategoryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:CalendarFolderFlags"))
		{	*type = SOAP_TYPE_ngwt__CalendarFolderFlags;
			return soap_in_ngwt__CalendarFolderFlags(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AppointmentConflict"))
		{	*type = SOAP_TYPE_ngwt__AppointmentConflict;
			return soap_in_ngwt__AppointmentConflict(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AgeAction"))
		{	*type = SOAP_TYPE_ngwt__AgeAction;
			return soap_in_ngwt__AgeAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AcceptLevel"))
		{	*type = SOAP_TYPE_ngwt__AcceptLevel;
			return soap_in_ngwt__AcceptLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:ItemTypeList"))
		{	*type = SOAP_TYPE_ngwe__ItemTypeList;
			return soap_in_ngwe__ItemTypeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:FieldList"))
		{	*type = SOAP_TYPE_ngwe__FieldList;
			return soap_in_ngwe__FieldList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:MessageTypeList"))
		{	*type = SOAP_TYPE_ngwt__MessageTypeList;
			return soap_in_ngwt__MessageTypeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ItemSourceList"))
		{	*type = SOAP_TYPE_ngwt__ItemSourceList;
			return soap_in_ngwt__ItemSourceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:UUID"))
		{	*type = SOAP_TYPE_ngwt__UUID;
			return soap_in_ngwt__UUID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:uid"))
		{	*type = SOAP_TYPE_ngwt__uid;
			return soap_in_ngwt__uid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:View"))
		{	*type = SOAP_TYPE_ngwt__View;
			return soap_in_ngwt__View(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:removeEventsResponse"))
		{	*type = SOAP_TYPE__ngwe__removeEventsResponse;
			return soap_in__ngwe__removeEventsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:removeEventsRequest"))
		{	*type = SOAP_TYPE__ngwe__removeEventsRequest;
			return soap_in__ngwe__removeEventsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:removeEventConfigurationResponse"))
		{	*type = SOAP_TYPE__ngwe__removeEventConfigurationResponse;
			return soap_in__ngwe__removeEventConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:removeEventConfigurationRequest"))
		{	*type = SOAP_TYPE__ngwe__removeEventConfigurationRequest;
			return soap_in__ngwe__removeEventConfigurationRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:getEventsResponse"))
		{	*type = SOAP_TYPE__ngwe__getEventsResponse;
			return soap_in__ngwe__getEventsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:getEventsRequest"))
		{	*type = SOAP_TYPE__ngwe__getEventsRequest;
			return soap_in__ngwe__getEventsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:getEventConfigurationResponse"))
		{	*type = SOAP_TYPE__ngwe__getEventConfigurationResponse;
			return soap_in__ngwe__getEventConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:getEventConfigurationRequest"))
		{	*type = SOAP_TYPE__ngwe__getEventConfigurationRequest;
			return soap_in__ngwe__getEventConfigurationRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:configureEventsResponse"))
		{	*type = SOAP_TYPE__ngwe__configureEventsResponse;
			return soap_in__ngwe__configureEventsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:configureEventsRequest"))
		{	*type = SOAP_TYPE__ngwe__configureEventsRequest;
			return soap_in__ngwe__configureEventsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:cleanEventConfigurationResponse"))
		{	*type = SOAP_TYPE__ngwe__cleanEventConfigurationResponse;
			return soap_in__ngwe__cleanEventConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:cleanEventConfigurationRequest"))
		{	*type = SOAP_TYPE__ngwe__cleanEventConfigurationRequest;
			return soap_in__ngwe__cleanEventConfigurationRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:Notify"))
		{	*type = SOAP_TYPE_ngwe__Notify;
			return soap_in_ngwe__Notify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:EventTypeList"))
		{	*type = SOAP_TYPE_ngwe__EventTypeList;
			return soap_in_ngwe__EventTypeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:EventsList"))
		{	*type = SOAP_TYPE_ngwe__EventsList;
			return soap_in_ngwe__EventsList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:Events"))
		{	*type = SOAP_TYPE_ngwe__Events;
			return soap_in_ngwe__Events(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:EventList"))
		{	*type = SOAP_TYPE_ngwe__EventList;
			return soap_in_ngwe__EventList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:EventDefinition"))
		{	*type = SOAP_TYPE_ngwe__EventDefinition;
			return soap_in_ngwe__EventDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:Event"))
		{	*type = SOAP_TYPE_ngwe__Event;
			return soap_in_ngwe__Event(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwe:ContainerList"))
		{	*type = SOAP_TYPE_ngwe__ContainerList;
			return soap_in_ngwe__ContainerList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:updateVersionStatusResponse"))
		{	*type = SOAP_TYPE__ngwm__updateVersionStatusResponse;
			return soap_in__ngwm__updateVersionStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:updateVersionStatusRequest"))
		{	*type = SOAP_TYPE__ngwm__updateVersionStatusRequest;
			return soap_in__ngwm__updateVersionStatusRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:uncompleteResponse"))
		{	*type = SOAP_TYPE__ngwm__uncompleteResponse;
			return soap_in__ngwm__uncompleteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:uncompleteRequest"))
		{	*type = SOAP_TYPE__ngwm__uncompleteRequest;
			return soap_in__ngwm__uncompleteRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:unacceptResponse"))
		{	*type = SOAP_TYPE__ngwm__unacceptResponse;
			return soap_in__ngwm__unacceptResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:unacceptRequest"))
		{	*type = SOAP_TYPE__ngwm__unacceptRequest;
			return soap_in__ngwm__unacceptRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:startFreeBusySessionResponse"))
		{	*type = SOAP_TYPE__ngwm__startFreeBusySessionResponse;
			return soap_in__ngwm__startFreeBusySessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:startFreeBusySessionRequest"))
		{	*type = SOAP_TYPE__ngwm__startFreeBusySessionRequest;
			return soap_in__ngwm__startFreeBusySessionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:setTimestampResponse"))
		{	*type = SOAP_TYPE__ngwm__setTimestampResponse;
			return soap_in__ngwm__setTimestampResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:setTimestampRequest"))
		{	*type = SOAP_TYPE__ngwm__setTimestampRequest;
			return soap_in__ngwm__setTimestampRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:sendItemResponse"))
		{	*type = SOAP_TYPE__ngwm__sendItemResponse;
			return soap_in__ngwm__sendItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:sendItemRequest"))
		{	*type = SOAP_TYPE__ngwm__sendItemRequest;
			return soap_in__ngwm__sendItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:retractResponse"))
		{	*type = SOAP_TYPE__ngwm__retractResponse;
			return soap_in__ngwm__retractResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:retractRequest"))
		{	*type = SOAP_TYPE__ngwm__retractRequest;
			return soap_in__ngwm__retractRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:replyResponse"))
		{	*type = SOAP_TYPE__ngwm__replyResponse;
			return soap_in__ngwm__replyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:replyRequest"))
		{	*type = SOAP_TYPE__ngwm__replyRequest;
			return soap_in__ngwm__replyRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeSignatureResponse"))
		{	*type = SOAP_TYPE__ngwm__removeSignatureResponse;
			return soap_in__ngwm__removeSignatureResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeSignatureRequest"))
		{	*type = SOAP_TYPE__ngwm__removeSignatureRequest;
			return soap_in__ngwm__removeSignatureRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeProxyUserResponse"))
		{	*type = SOAP_TYPE__ngwm__removeProxyUserResponse;
			return soap_in__ngwm__removeProxyUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeProxyUserRequest"))
		{	*type = SOAP_TYPE__ngwm__removeProxyUserRequest;
			return soap_in__ngwm__removeProxyUserRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeProxyAccessResponse"))
		{	*type = SOAP_TYPE__ngwm__removeProxyAccessResponse;
			return soap_in__ngwm__removeProxyAccessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeProxyAccessRequest"))
		{	*type = SOAP_TYPE__ngwm__removeProxyAccessRequest;
			return soap_in__ngwm__removeProxyAccessRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeMembersResponse"))
		{	*type = SOAP_TYPE__ngwm__removeMembersResponse;
			return soap_in__ngwm__removeMembersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeMembersRequest"))
		{	*type = SOAP_TYPE__ngwm__removeMembersRequest;
			return soap_in__ngwm__removeMembersRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeJunkEntryResponse"))
		{	*type = SOAP_TYPE__ngwm__removeJunkEntryResponse;
			return soap_in__ngwm__removeJunkEntryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeJunkEntryRequest"))
		{	*type = SOAP_TYPE__ngwm__removeJunkEntryRequest;
			return soap_in__ngwm__removeJunkEntryRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeItemsResponse"))
		{	*type = SOAP_TYPE__ngwm__removeItemsResponse;
			return soap_in__ngwm__removeItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeItemsRequest"))
		{	*type = SOAP_TYPE__ngwm__removeItemsRequest;
			return soap_in__ngwm__removeItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeItemResponse"))
		{	*type = SOAP_TYPE__ngwm__removeItemResponse;
			return soap_in__ngwm__removeItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeItemRequest"))
		{	*type = SOAP_TYPE__ngwm__removeItemRequest;
			return soap_in__ngwm__removeItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeCustomDefinitionResponse"))
		{	*type = SOAP_TYPE__ngwm__removeCustomDefinitionResponse;
			return soap_in__ngwm__removeCustomDefinitionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:removeCustomDefinitionRequest"))
		{	*type = SOAP_TYPE__ngwm__removeCustomDefinitionRequest;
			return soap_in__ngwm__removeCustomDefinitionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:readCursorResponse"))
		{	*type = SOAP_TYPE__ngwm__readCursorResponse;
			return soap_in__ngwm__readCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:readCursorRequest"))
		{	*type = SOAP_TYPE__ngwm__readCursorRequest;
			return soap_in__ngwm__readCursorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:purgeResponse"))
		{	*type = SOAP_TYPE__ngwm__purgeResponse;
			return soap_in__ngwm__purgeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:purgeRequest"))
		{	*type = SOAP_TYPE__ngwm__purgeRequest;
			return soap_in__ngwm__purgeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:purgeDeletedItemsResponse"))
		{	*type = SOAP_TYPE__ngwm__purgeDeletedItemsResponse;
			return soap_in__ngwm__purgeDeletedItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:purgeDeletedItemsRequest"))
		{	*type = SOAP_TYPE__ngwm__purgeDeletedItemsRequest;
			return soap_in__ngwm__purgeDeletedItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:positionCursorResponse"))
		{	*type = SOAP_TYPE__ngwm__positionCursorResponse;
			return soap_in__ngwm__positionCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:positionCursorRequest"))
		{	*type = SOAP_TYPE__ngwm__positionCursorRequest;
			return soap_in__ngwm__positionCursorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:moveItemResponse"))
		{	*type = SOAP_TYPE__ngwm__moveItemResponse;
			return soap_in__ngwm__moveItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:moveItemRequest"))
		{	*type = SOAP_TYPE__ngwm__moveItemRequest;
			return soap_in__ngwm__moveItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifySignaturesResponse"))
		{	*type = SOAP_TYPE__ngwm__modifySignaturesResponse;
			return soap_in__ngwm__modifySignaturesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifySignaturesRequest"))
		{	*type = SOAP_TYPE__ngwm__modifySignaturesRequest;
			return soap_in__ngwm__modifySignaturesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifySettingsResponse"))
		{	*type = SOAP_TYPE__ngwm__modifySettingsResponse;
			return soap_in__ngwm__modifySettingsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifySettingsRequest"))
		{	*type = SOAP_TYPE__ngwm__modifySettingsRequest;
			return soap_in__ngwm__modifySettingsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyProxyAccessResponse"))
		{	*type = SOAP_TYPE__ngwm__modifyProxyAccessResponse;
			return soap_in__ngwm__modifyProxyAccessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyProxyAccessRequest"))
		{	*type = SOAP_TYPE__ngwm__modifyProxyAccessRequest;
			return soap_in__ngwm__modifyProxyAccessRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyPasswordResponse"))
		{	*type = SOAP_TYPE__ngwm__modifyPasswordResponse;
			return soap_in__ngwm__modifyPasswordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyPasswordRequest"))
		{	*type = SOAP_TYPE__ngwm__modifyPasswordRequest;
			return soap_in__ngwm__modifyPasswordRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyJunkMailSettingsResponse"))
		{	*type = SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse;
			return soap_in__ngwm__modifyJunkMailSettingsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyJunkMailSettingsRequest"))
		{	*type = SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest;
			return soap_in__ngwm__modifyJunkMailSettingsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyJunkEntryResponse"))
		{	*type = SOAP_TYPE__ngwm__modifyJunkEntryResponse;
			return soap_in__ngwm__modifyJunkEntryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyJunkEntryRequest"))
		{	*type = SOAP_TYPE__ngwm__modifyJunkEntryRequest;
			return soap_in__ngwm__modifyJunkEntryRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyItemsResponse"))
		{	*type = SOAP_TYPE__ngwm__modifyItemsResponse;
			return soap_in__ngwm__modifyItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyItemsRequest"))
		{	*type = SOAP_TYPE__ngwm__modifyItemsRequest;
			return soap_in__ngwm__modifyItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyItemResponse"))
		{	*type = SOAP_TYPE__ngwm__modifyItemResponse;
			return soap_in__ngwm__modifyItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:modifyItemRequest"))
		{	*type = SOAP_TYPE__ngwm__modifyItemRequest;
			return soap_in__ngwm__modifyItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:markUnReadResponse"))
		{	*type = SOAP_TYPE__ngwm__markUnReadResponse;
			return soap_in__ngwm__markUnReadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:markUnReadRequest"))
		{	*type = SOAP_TYPE__ngwm__markUnReadRequest;
			return soap_in__ngwm__markUnReadRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:markUnPrivateResponse"))
		{	*type = SOAP_TYPE__ngwm__markUnPrivateResponse;
			return soap_in__ngwm__markUnPrivateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:markUnPrivateRequest"))
		{	*type = SOAP_TYPE__ngwm__markUnPrivateRequest;
			return soap_in__ngwm__markUnPrivateRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:markReadResponse"))
		{	*type = SOAP_TYPE__ngwm__markReadResponse;
			return soap_in__ngwm__markReadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:markReadRequest"))
		{	*type = SOAP_TYPE__ngwm__markReadRequest;
			return soap_in__ngwm__markReadRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:markPrivateResponse"))
		{	*type = SOAP_TYPE__ngwm__markPrivateResponse;
			return soap_in__ngwm__markPrivateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:markPrivateRequest"))
		{	*type = SOAP_TYPE__ngwm__markPrivateRequest;
			return soap_in__ngwm__markPrivateRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:logoutResponse"))
		{	*type = SOAP_TYPE__ngwm__logoutResponse;
			return soap_in__ngwm__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:logoutRequest"))
		{	*type = SOAP_TYPE__ngwm__logoutRequest;
			return soap_in__ngwm__logoutRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:loginResponse"))
		{	*type = SOAP_TYPE__ngwm__loginResponse;
			return soap_in__ngwm__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:loginRequest"))
		{	*type = SOAP_TYPE__ngwm__loginRequest;
			return soap_in__ngwm__loginRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getUserListResponse"))
		{	*type = SOAP_TYPE__ngwm__getUserListResponse;
			return soap_in__ngwm__getUserListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getUserListRequest"))
		{	*type = SOAP_TYPE__ngwm__getUserListRequest;
			return soap_in__ngwm__getUserListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getTimezoneListResponse"))
		{	*type = SOAP_TYPE__ngwm__getTimezoneListResponse;
			return soap_in__ngwm__getTimezoneListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getTimezoneListRequest"))
		{	*type = SOAP_TYPE__ngwm__getTimezoneListRequest;
			return soap_in__ngwm__getTimezoneListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getTimestampResponse"))
		{	*type = SOAP_TYPE__ngwm__getTimestampResponse;
			return soap_in__ngwm__getTimestampResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getTimestampRequest"))
		{	*type = SOAP_TYPE__ngwm__getTimestampRequest;
			return soap_in__ngwm__getTimestampRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getSignaturesResponse"))
		{	*type = SOAP_TYPE__ngwm__getSignaturesResponse;
			return soap_in__ngwm__getSignaturesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getSignaturesRequest"))
		{	*type = SOAP_TYPE__ngwm__getSignaturesRequest;
			return soap_in__ngwm__getSignaturesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getSettingsResponse"))
		{	*type = SOAP_TYPE__ngwm__getSettingsResponse;
			return soap_in__ngwm__getSettingsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getSettingsRequest"))
		{	*type = SOAP_TYPE__ngwm__getSettingsRequest;
			return soap_in__ngwm__getSettingsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getRuleListResponse"))
		{	*type = SOAP_TYPE__ngwm__getRuleListResponse;
			return soap_in__ngwm__getRuleListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getRuleListRequest"))
		{	*type = SOAP_TYPE__ngwm__getRuleListRequest;
			return soap_in__ngwm__getRuleListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getProxyListResponse"))
		{	*type = SOAP_TYPE__ngwm__getProxyListResponse;
			return soap_in__ngwm__getProxyListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getProxyListRequest"))
		{	*type = SOAP_TYPE__ngwm__getProxyListRequest;
			return soap_in__ngwm__getProxyListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getProxyAccessListResponse"))
		{	*type = SOAP_TYPE__ngwm__getProxyAccessListResponse;
			return soap_in__ngwm__getProxyAccessListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getProxyAccessListRequest"))
		{	*type = SOAP_TYPE__ngwm__getProxyAccessListRequest;
			return soap_in__ngwm__getProxyAccessListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getQuickMessagesResponse"))
		{	*type = SOAP_TYPE__ngwm__getQuickMessagesResponse;
			return soap_in__ngwm__getQuickMessagesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getQuickMessagesRequest"))
		{	*type = SOAP_TYPE__ngwm__getQuickMessagesRequest;
			return soap_in__ngwm__getQuickMessagesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getLibraryListResponse"))
		{	*type = SOAP_TYPE__ngwm__getLibraryListResponse;
			return soap_in__ngwm__getLibraryListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getLibraryListRequest"))
		{	*type = SOAP_TYPE__ngwm__getLibraryListRequest;
			return soap_in__ngwm__getLibraryListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getLibraryItemResponse"))
		{	*type = SOAP_TYPE__ngwm__getLibraryItemResponse;
			return soap_in__ngwm__getLibraryItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getLibraryItemRequest"))
		{	*type = SOAP_TYPE__ngwm__getLibraryItemRequest;
			return soap_in__ngwm__getLibraryItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getJunkMailSettingsResponse"))
		{	*type = SOAP_TYPE__ngwm__getJunkMailSettingsResponse;
			return soap_in__ngwm__getJunkMailSettingsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getJunkMailSettingsRequest"))
		{	*type = SOAP_TYPE__ngwm__getJunkMailSettingsRequest;
			return soap_in__ngwm__getJunkMailSettingsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getJunkEntriesResponse"))
		{	*type = SOAP_TYPE__ngwm__getJunkEntriesResponse;
			return soap_in__ngwm__getJunkEntriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getJunkEntriesRequest"))
		{	*type = SOAP_TYPE__ngwm__getJunkEntriesRequest;
			return soap_in__ngwm__getJunkEntriesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getItemsResponse"))
		{	*type = SOAP_TYPE__ngwm__getItemsResponse;
			return soap_in__ngwm__getItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getItemsRequest"))
		{	*type = SOAP_TYPE__ngwm__getItemsRequest;
			return soap_in__ngwm__getItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getItemResponse"))
		{	*type = SOAP_TYPE__ngwm__getItemResponse;
			return soap_in__ngwm__getItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getItemRequest"))
		{	*type = SOAP_TYPE__ngwm__getItemRequest;
			return soap_in__ngwm__getItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getFreeBusyResponse"))
		{	*type = SOAP_TYPE__ngwm__getFreeBusyResponse;
			return soap_in__ngwm__getFreeBusyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getFreeBusyRequest"))
		{	*type = SOAP_TYPE__ngwm__getFreeBusyRequest;
			return soap_in__ngwm__getFreeBusyRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getFolderListResponse"))
		{	*type = SOAP_TYPE__ngwm__getFolderListResponse;
			return soap_in__ngwm__getFolderListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getFolderListRequest"))
		{	*type = SOAP_TYPE__ngwm__getFolderListRequest;
			return soap_in__ngwm__getFolderListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getFolderResponse"))
		{	*type = SOAP_TYPE__ngwm__getFolderResponse;
			return soap_in__ngwm__getFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getFolderRequest"))
		{	*type = SOAP_TYPE__ngwm__getFolderRequest;
			return soap_in__ngwm__getFolderRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getDocumentTypeListResponse"))
		{	*type = SOAP_TYPE__ngwm__getDocumentTypeListResponse;
			return soap_in__ngwm__getDocumentTypeListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getDocumentTypeListRequest"))
		{	*type = SOAP_TYPE__ngwm__getDocumentTypeListRequest;
			return soap_in__ngwm__getDocumentTypeListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getDeltaInfoResponse"))
		{	*type = SOAP_TYPE__ngwm__getDeltaInfoResponse;
			return soap_in__ngwm__getDeltaInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getDeltaInfoRequest"))
		{	*type = SOAP_TYPE__ngwm__getDeltaInfoRequest;
			return soap_in__ngwm__getDeltaInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getDeltasResponse"))
		{	*type = SOAP_TYPE__ngwm__getDeltasResponse;
			return soap_in__ngwm__getDeltasResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getDeltasRequest"))
		{	*type = SOAP_TYPE__ngwm__getDeltasRequest;
			return soap_in__ngwm__getDeltasRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getCustomListResponse"))
		{	*type = SOAP_TYPE__ngwm__getCustomListResponse;
			return soap_in__ngwm__getCustomListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getCustomListRequest"))
		{	*type = SOAP_TYPE__ngwm__getCustomListRequest;
			return soap_in__ngwm__getCustomListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getCategoryListResponse"))
		{	*type = SOAP_TYPE__ngwm__getCategoryListResponse;
			return soap_in__ngwm__getCategoryListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getCategoryListRequest"))
		{	*type = SOAP_TYPE__ngwm__getCategoryListRequest;
			return soap_in__ngwm__getCategoryListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getAttachmentResponse"))
		{	*type = SOAP_TYPE__ngwm__getAttachmentResponse;
			return soap_in__ngwm__getAttachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getAttachmentRequest"))
		{	*type = SOAP_TYPE__ngwm__getAttachmentRequest;
			return soap_in__ngwm__getAttachmentRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getAddressBookListResponse"))
		{	*type = SOAP_TYPE__ngwm__getAddressBookListResponse;
			return soap_in__ngwm__getAddressBookListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:getAddressBookListRequest"))
		{	*type = SOAP_TYPE__ngwm__getAddressBookListRequest;
			return soap_in__ngwm__getAddressBookListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:forwardResponse"))
		{	*type = SOAP_TYPE__ngwm__forwardResponse;
			return soap_in__ngwm__forwardResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:forwardRequest"))
		{	*type = SOAP_TYPE__ngwm__forwardRequest;
			return soap_in__ngwm__forwardRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:executeRuleResponse"))
		{	*type = SOAP_TYPE__ngwm__executeRuleResponse;
			return soap_in__ngwm__executeRuleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:executeRuleRequest"))
		{	*type = SOAP_TYPE__ngwm__executeRuleRequest;
			return soap_in__ngwm__executeRuleRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:destroyCursorResponse"))
		{	*type = SOAP_TYPE__ngwm__destroyCursorResponse;
			return soap_in__ngwm__destroyCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:destroyCursorRequest"))
		{	*type = SOAP_TYPE__ngwm__destroyCursorRequest;
			return soap_in__ngwm__destroyCursorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:delegateResponse"))
		{	*type = SOAP_TYPE__ngwm__delegateResponse;
			return soap_in__ngwm__delegateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:delegateRequest"))
		{	*type = SOAP_TYPE__ngwm__delegateRequest;
			return soap_in__ngwm__delegateRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:declineResponse"))
		{	*type = SOAP_TYPE__ngwm__declineResponse;
			return soap_in__ngwm__declineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:declineRequest"))
		{	*type = SOAP_TYPE__ngwm__declineRequest;
			return soap_in__ngwm__declineRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createSignatureResponse"))
		{	*type = SOAP_TYPE__ngwm__createSignatureResponse;
			return soap_in__ngwm__createSignatureResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createSignatureRequest"))
		{	*type = SOAP_TYPE__ngwm__createSignatureRequest;
			return soap_in__ngwm__createSignatureRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createProxyAccessResponse"))
		{	*type = SOAP_TYPE__ngwm__createProxyAccessResponse;
			return soap_in__ngwm__createProxyAccessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createProxyAccessRequest"))
		{	*type = SOAP_TYPE__ngwm__createProxyAccessRequest;
			return soap_in__ngwm__createProxyAccessRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createJunkEntryResponse"))
		{	*type = SOAP_TYPE__ngwm__createJunkEntryResponse;
			return soap_in__ngwm__createJunkEntryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createJunkEntryRequest"))
		{	*type = SOAP_TYPE__ngwm__createJunkEntryRequest;
			return soap_in__ngwm__createJunkEntryRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createItemsResponse"))
		{	*type = SOAP_TYPE__ngwm__createItemsResponse;
			return soap_in__ngwm__createItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createItemsRequest"))
		{	*type = SOAP_TYPE__ngwm__createItemsRequest;
			return soap_in__ngwm__createItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createItemResponse"))
		{	*type = SOAP_TYPE__ngwm__createItemResponse;
			return soap_in__ngwm__createItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createItemRequest"))
		{	*type = SOAP_TYPE__ngwm__createItemRequest;
			return soap_in__ngwm__createItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createCursorResponse"))
		{	*type = SOAP_TYPE__ngwm__createCursorResponse;
			return soap_in__ngwm__createCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:createCursorRequest"))
		{	*type = SOAP_TYPE__ngwm__createCursorRequest;
			return soap_in__ngwm__createCursorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:completeResponse"))
		{	*type = SOAP_TYPE__ngwm__completeResponse;
			return soap_in__ngwm__completeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:completeRequest"))
		{	*type = SOAP_TYPE__ngwm__completeRequest;
			return soap_in__ngwm__completeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:closeFreeBusySessionResponse"))
		{	*type = SOAP_TYPE__ngwm__closeFreeBusySessionResponse;
			return soap_in__ngwm__closeFreeBusySessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:closeFreeBusySessionRequest"))
		{	*type = SOAP_TYPE__ngwm__closeFreeBusySessionRequest;
			return soap_in__ngwm__closeFreeBusySessionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:addMembersResponse"))
		{	*type = SOAP_TYPE__ngwm__addMembersResponse;
			return soap_in__ngwm__addMembersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:addMembersRequest"))
		{	*type = SOAP_TYPE__ngwm__addMembersRequest;
			return soap_in__ngwm__addMembersRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:addItemsResponse"))
		{	*type = SOAP_TYPE__ngwm__addItemsResponse;
			return soap_in__ngwm__addItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:addItemsRequest"))
		{	*type = SOAP_TYPE__ngwm__addItemsRequest;
			return soap_in__ngwm__addItemsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:addItemResponse"))
		{	*type = SOAP_TYPE__ngwm__addItemResponse;
			return soap_in__ngwm__addItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:addItemRequest"))
		{	*type = SOAP_TYPE__ngwm__addItemRequest;
			return soap_in__ngwm__addItemRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:acceptShareResponse"))
		{	*type = SOAP_TYPE__ngwm__acceptShareResponse;
			return soap_in__ngwm__acceptShareResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:acceptShareRequest"))
		{	*type = SOAP_TYPE__ngwm__acceptShareRequest;
			return soap_in__ngwm__acceptShareRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:acceptResponse"))
		{	*type = SOAP_TYPE__ngwm__acceptResponse;
			return soap_in__ngwm__acceptResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwm:acceptRequest"))
		{	*type = SOAP_TYPE__ngwm__acceptRequest;
			return soap_in__ngwm__acceptRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:VersionEvent"))
		{	*type = SOAP_TYPE_ngwt__VersionEvent;
			return soap_in_ngwt__VersionEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Version"))
		{	*type = SOAP_TYPE_ngwt__Version;
			return soap_in_ngwt__Version(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:UserList"))
		{	*type = SOAP_TYPE_ngwt__UserList;
			return soap_in_ngwt__UserList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:UserInfo"))
		{	*type = SOAP_TYPE_ngwt__UserInfo;
			return soap_in_ngwt__UserInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:TrustedApplication"))
		{	*type = SOAP_TYPE_ngwt__TrustedApplication;
			return soap_in_ngwt__TrustedApplication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:TransferFailedStatus"))
		{	*type = SOAP_TYPE_ngwt__TransferFailedStatus;
			return soap_in_ngwt__TransferFailedStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:TimezoneList"))
		{	*type = SOAP_TYPE_ngwt__TimezoneList;
			return soap_in_ngwt__TimezoneList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:TimezoneComponent"))
		{	*type = SOAP_TYPE_ngwt__TimezoneComponent;
			return soap_in_ngwt__TimezoneComponent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Timezone"))
		{	*type = SOAP_TYPE_ngwt__Timezone;
			return soap_in_ngwt__Timezone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Task"))
		{	*type = SOAP_TYPE_ngwt__Task;
			return soap_in_ngwt__Task(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:SystemFolder"))
		{	*type = SOAP_TYPE_ngwt__SystemFolder;
			return soap_in_ngwt__SystemFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:StatusTracking"))
		{	*type = SOAP_TYPE_ngwt__StatusTracking;
			return soap_in_ngwt__StatusTracking(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Status"))
		{	*type = SOAP_TYPE_ngwt__Status;
			return soap_in_ngwt__Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:SMimeOperation"))
		{	*type = SOAP_TYPE_ngwt__SMimeOperation;
			return soap_in_ngwt__SMimeOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:SignatureData"))
		{	*type = SOAP_TYPE_ngwt__SignatureData;
			return soap_in_ngwt__SignatureData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Signatures"))
		{	*type = SOAP_TYPE_ngwt__Signatures;
			return soap_in_ngwt__Signatures(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Signature"))
		{	*type = SOAP_TYPE_ngwt__Signature;
			return soap_in_ngwt__Signature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:SharedNotification"))
		{	*type = SOAP_TYPE_ngwt__SharedNotification;
			return soap_in_ngwt__SharedNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:SharedFolderNotification"))
		{	*type = SOAP_TYPE_ngwt__SharedFolderNotification;
			return soap_in_ngwt__SharedFolderNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:SharedFolder"))
		{	*type = SOAP_TYPE_ngwt__SharedFolder;
			return soap_in_ngwt__SharedFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:SettingsList"))
		{	*type = SOAP_TYPE_ngwt__SettingsList;
			return soap_in_ngwt__SettingsList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:SettingsGroup"))
		{	*type = SOAP_TYPE_ngwt__SettingsGroup;
			return soap_in_ngwt__SettingsGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Settings"))
		{	*type = SOAP_TYPE_ngwt__Settings;
			return soap_in_ngwt__Settings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:SendOptions"))
		{	*type = SOAP_TYPE_ngwt__SendOptions;
			return soap_in_ngwt__SendOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:SendOptionsRequestReply"))
		{	*type = SOAP_TYPE_ngwt__SendOptionsRequestReply;
			return soap_in_ngwt__SendOptionsRequestReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:RuleList"))
		{	*type = SOAP_TYPE_ngwt__RuleList;
			return soap_in_ngwt__RuleList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:RuleActionList"))
		{	*type = SOAP_TYPE_ngwt__RuleActionList;
			return soap_in_ngwt__RuleActionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:RuleAction"))
		{	*type = SOAP_TYPE_ngwt__RuleAction;
			return soap_in_ngwt__RuleAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Rule"))
		{	*type = SOAP_TYPE_ngwt__Rule;
			return soap_in_ngwt__Rule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Rights"))
		{	*type = SOAP_TYPE_ngwt__Rights;
			return soap_in_ngwt__Rights(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ReturnNotificationOptions"))
		{	*type = SOAP_TYPE_ngwt__ReturnNotificationOptions;
			return soap_in_ngwt__ReturnNotificationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ReturnNotification"))
		{	*type = SOAP_TYPE_ngwt__ReturnNotification;
			return soap_in_ngwt__ReturnNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Resource"))
		{	*type = SOAP_TYPE_ngwt__Resource;
			return soap_in_ngwt__Resource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ReferenceInfo"))
		{	*type = SOAP_TYPE_ngwt__ReferenceInfo;
			return soap_in_ngwt__ReferenceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:RecurrenceRule"))
		{	*type = SOAP_TYPE_ngwt__RecurrenceRule;
			return soap_in_ngwt__RecurrenceRule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:RecurrenceDateType"))
		{	*type = SOAP_TYPE_ngwt__RecurrenceDateType;
			return soap_in_ngwt__RecurrenceDateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:RecipientStatus"))
		{	*type = SOAP_TYPE_ngwt__RecipientStatus;
			return soap_in_ngwt__RecipientStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:RecipientList"))
		{	*type = SOAP_TYPE_ngwt__RecipientList;
			return soap_in_ngwt__RecipientList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Recipient"))
		{	*type = SOAP_TYPE_ngwt__Recipient;
			return soap_in_ngwt__Recipient(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:QueryTarget"))
		{	*type = SOAP_TYPE_ngwt__QueryTarget;
			return soap_in_ngwt__QueryTarget(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:QueryFolder"))
		{	*type = SOAP_TYPE_ngwt__QueryFolder;
			return soap_in_ngwt__QueryFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Query"))
		{	*type = SOAP_TYPE_ngwt__Query;
			return soap_in_ngwt__Query(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ProxyList"))
		{	*type = SOAP_TYPE_ngwt__ProxyList;
			return soap_in_ngwt__ProxyList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ProxyUser"))
		{	*type = SOAP_TYPE_ngwt__ProxyUser;
			return soap_in_ngwt__ProxyUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Proxy"))
		{	*type = SOAP_TYPE_ngwt__Proxy;
			return soap_in_ngwt__Proxy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ProblemList"))
		{	*type = SOAP_TYPE_ngwt__ProblemList;
			return soap_in_ngwt__ProblemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ProblemEntry"))
		{	*type = SOAP_TYPE_ngwt__ProblemEntry;
			return soap_in_ngwt__ProblemEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:PostalAddressList"))
		{	*type = SOAP_TYPE_ngwt__PostalAddressList;
			return soap_in_ngwt__PostalAddressList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:PostalAddress"))
		{	*type = SOAP_TYPE_ngwt__PostalAddress;
			return soap_in_ngwt__PostalAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:PlainText"))
		{	*type = SOAP_TYPE_ngwt__PlainText;
			return soap_in_ngwt__PlainText(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:PhoneNumber"))
		{	*type = SOAP_TYPE_ngwt__PhoneNumber;
			return soap_in_ngwt__PhoneNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:PhoneMessage"))
		{	*type = SOAP_TYPE_ngwt__PhoneMessage;
			return soap_in_ngwt__PhoneMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:PhoneList"))
		{	*type = SOAP_TYPE_ngwt__PhoneList;
			return soap_in_ngwt__PhoneList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:PhoneFlags"))
		{	*type = SOAP_TYPE_ngwt__PhoneFlags;
			return soap_in_ngwt__PhoneFlags(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:PersonalInfo"))
		{	*type = SOAP_TYPE_ngwt__PersonalInfo;
			return soap_in_ngwt__PersonalInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Organization"))
		{	*type = SOAP_TYPE_ngwt__Organization;
			return soap_in_ngwt__Organization(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:OfficeInfo"))
		{	*type = SOAP_TYPE_ngwt__OfficeInfo;
			return soap_in_ngwt__OfficeInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Note"))
		{	*type = SOAP_TYPE_ngwt__Note;
			return soap_in_ngwt__Note(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:NameAndEmail"))
		{	*type = SOAP_TYPE_ngwt__NameAndEmail;
			return soap_in_ngwt__NameAndEmail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:MonthList"))
		{	*type = SOAP_TYPE_ngwt__MonthList;
			return soap_in_ngwt__MonthList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ModifyItem"))
		{	*type = SOAP_TYPE_ngwt__ModifyItem;
			return soap_in_ngwt__ModifyItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:MessagePart"))
		{	*type = SOAP_TYPE_ngwt__MessagePart;
			return soap_in_ngwt__MessagePart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:MessageBody"))
		{	*type = SOAP_TYPE_ngwt__MessageBody;
			return soap_in_ngwt__MessageBody(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Mail"))
		{	*type = SOAP_TYPE_ngwt__Mail;
			return soap_in_ngwt__Mail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:LinkInfo"))
		{	*type = SOAP_TYPE_ngwt__LinkInfo;
			return soap_in_ngwt__LinkInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:LibraryList"))
		{	*type = SOAP_TYPE_ngwt__LibraryList;
			return soap_in_ngwt__LibraryList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Library"))
		{	*type = SOAP_TYPE_ngwt__Library;
			return soap_in_ngwt__Library(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:JunkHandlingList"))
		{	*type = SOAP_TYPE_ngwt__JunkHandlingList;
			return soap_in_ngwt__JunkHandlingList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:JunkEntry"))
		{	*type = SOAP_TYPE_ngwt__JunkEntry;
			return soap_in_ngwt__JunkEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ItemStatus"))
		{	*type = SOAP_TYPE_ngwt__ItemStatus;
			return soap_in_ngwt__ItemStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Items"))
		{	*type = SOAP_TYPE_ngwt__Items;
			return soap_in_ngwt__Items(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ItemRefList"))
		{	*type = SOAP_TYPE_ngwt__ItemRefList;
			return soap_in_ngwt__ItemRefList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ItemRef"))
		{	*type = SOAP_TYPE_ngwt__ItemRef;
			return soap_in_ngwt__ItemRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ItemOptions"))
		{	*type = SOAP_TYPE_ngwt__ItemOptions;
			return soap_in_ngwt__ItemOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ItemList"))
		{	*type = SOAP_TYPE_ngwt__ItemList;
			return soap_in_ngwt__ItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ItemChanges"))
		{	*type = SOAP_TYPE_ngwt__ItemChanges;
			return soap_in_ngwt__ItemChanges(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Item"))
		{	*type = SOAP_TYPE_ngwt__Item;
			return soap_in_ngwt__Item(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ImAddressList"))
		{	*type = SOAP_TYPE_ngwt__ImAddressList;
			return soap_in_ngwt__ImAddressList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ImAddress"))
		{	*type = SOAP_TYPE_ngwt__ImAddress;
			return soap_in_ngwt__ImAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Host"))
		{	*type = SOAP_TYPE_ngwt__Host;
			return soap_in_ngwt__Host(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:GroupMemberList"))
		{	*type = SOAP_TYPE_ngwt__GroupMemberList;
			return soap_in_ngwt__GroupMemberList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:GroupMember"))
		{	*type = SOAP_TYPE_ngwt__GroupMember;
			return soap_in_ngwt__GroupMember(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Group"))
		{	*type = SOAP_TYPE_ngwt__Group;
			return soap_in_ngwt__Group(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FullName"))
		{	*type = SOAP_TYPE_ngwt__FullName;
			return soap_in_ngwt__FullName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:From"))
		{	*type = SOAP_TYPE_ngwt__From;
			return soap_in_ngwt__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FreeBusyStats"))
		{	*type = SOAP_TYPE_ngwt__FreeBusyStats;
			return soap_in_ngwt__FreeBusyStats(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FreeBusyInfoList"))
		{	*type = SOAP_TYPE_ngwt__FreeBusyInfoList;
			return soap_in_ngwt__FreeBusyInfoList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FreeBusyUserList"))
		{	*type = SOAP_TYPE_ngwt__FreeBusyUserList;
			return soap_in_ngwt__FreeBusyUserList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FreeBusyInfo"))
		{	*type = SOAP_TYPE_ngwt__FreeBusyInfo;
			return soap_in_ngwt__FreeBusyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FreeBusyBlock"))
		{	*type = SOAP_TYPE_ngwt__FreeBusyBlock;
			return soap_in_ngwt__FreeBusyBlock(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FreeBusyBlockList"))
		{	*type = SOAP_TYPE_ngwt__FreeBusyBlockList;
			return soap_in_ngwt__FreeBusyBlockList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FolderList"))
		{	*type = SOAP_TYPE_ngwt__FolderList;
			return soap_in_ngwt__FolderList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FolderACLEntry"))
		{	*type = SOAP_TYPE_ngwt__FolderACLEntry;
			return soap_in_ngwt__FolderACLEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FolderACL"))
		{	*type = SOAP_TYPE_ngwt__FolderACL;
			return soap_in_ngwt__FolderACL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Folder"))
		{	*type = SOAP_TYPE_ngwt__Folder;
			return soap_in_ngwt__Folder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FilterGroup"))
		{	*type = SOAP_TYPE_ngwt__FilterGroup;
			return soap_in_ngwt__FilterGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FilterEntry"))
		{	*type = SOAP_TYPE_ngwt__FilterEntry;
			return soap_in_ngwt__FilterEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:FilterElement"))
		{	*type = SOAP_TYPE_ngwt__FilterElement;
			return soap_in_ngwt__FilterElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Filter"))
		{	*type = SOAP_TYPE_ngwt__Filter;
			return soap_in_ngwt__Filter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:EmailAddressList"))
		{	*type = SOAP_TYPE_ngwt__EmailAddressList;
			return soap_in_ngwt__EmailAddressList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DocumentTypeList"))
		{	*type = SOAP_TYPE_ngwt__DocumentTypeList;
			return soap_in_ngwt__DocumentTypeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DocumentType"))
		{	*type = SOAP_TYPE_ngwt__DocumentType;
			return soap_in_ngwt__DocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DocumentRef"))
		{	*type = SOAP_TYPE_ngwt__DocumentRef;
			return soap_in_ngwt__DocumentRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Document"))
		{	*type = SOAP_TYPE_ngwt__Document;
			return soap_in_ngwt__Document(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Distribution"))
		{	*type = SOAP_TYPE_ngwt__Distribution;
			return soap_in_ngwt__Distribution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DeltaInfo"))
		{	*type = SOAP_TYPE_ngwt__DeltaInfo;
			return soap_in_ngwt__DeltaInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DelegateeStatus"))
		{	*type = SOAP_TYPE_ngwt__DelegateeStatus;
			return soap_in_ngwt__DelegateeStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DelegatedStatus"))
		{	*type = SOAP_TYPE_ngwt__DelegatedStatus;
			return soap_in_ngwt__DelegatedStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DayOfYearWeekList"))
		{	*type = SOAP_TYPE_ngwt__DayOfYearWeekList;
			return soap_in_ngwt__DayOfYearWeekList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DayOfYearWeek"))
		{	*type = SOAP_TYPE_ngwt__DayOfYearWeek;
			return soap_in_ngwt__DayOfYearWeek(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DayOfYearList"))
		{	*type = SOAP_TYPE_ngwt__DayOfYearList;
			return soap_in_ngwt__DayOfYearList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DayOfWeek"))
		{	*type = SOAP_TYPE_ngwt__DayOfWeek;
			return soap_in_ngwt__DayOfWeek(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:DayOfMonthList"))
		{	*type = SOAP_TYPE_ngwt__DayOfMonthList;
			return soap_in_ngwt__DayOfMonthList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:CustomList"))
		{	*type = SOAP_TYPE_ngwt__CustomList;
			return soap_in_ngwt__CustomList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Custom"))
		{	*type = SOAP_TYPE_ngwt__Custom;
			return soap_in_ngwt__Custom(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ContainerRef"))
		{	*type = SOAP_TYPE_ngwt__ContainerRef;
			return soap_in_ngwt__ContainerRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ContainerItem"))
		{	*type = SOAP_TYPE_ngwt__ContainerItem;
			return soap_in_ngwt__ContainerItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:ContactFolder"))
		{	*type = SOAP_TYPE_ngwt__ContactFolder;
			return soap_in_ngwt__ContactFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Contact"))
		{	*type = SOAP_TYPE_ngwt__Contact;
			return soap_in_ngwt__Contact(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:CommentStatus"))
		{	*type = SOAP_TYPE_ngwt__CommentStatus;
			return soap_in_ngwt__CommentStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:CategoryRefList"))
		{	*type = SOAP_TYPE_ngwt__CategoryRefList;
			return soap_in_ngwt__CategoryRefList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:CategoryList"))
		{	*type = SOAP_TYPE_ngwt__CategoryList;
			return soap_in_ngwt__CategoryList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Category"))
		{	*type = SOAP_TYPE_ngwt__Category;
			return soap_in_ngwt__Category(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:CalendarItem"))
		{	*type = SOAP_TYPE_ngwt__CalendarItem;
			return soap_in_ngwt__CalendarItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:CalendarFolderAttribute"))
		{	*type = SOAP_TYPE_ngwt__CalendarFolderAttribute;
			return soap_in_ngwt__CalendarFolderAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:BoxEntry"))
		{	*type = SOAP_TYPE_ngwt__BoxEntry;
			return soap_in_ngwt__BoxEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Authentication"))
		{	*type = SOAP_TYPE_ngwt__Authentication;
			return soap_in_ngwt__Authentication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AttachmentItemInfo"))
		{	*type = SOAP_TYPE_ngwt__AttachmentItemInfo;
			return soap_in_ngwt__AttachmentItemInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AttachmentInfo"))
		{	*type = SOAP_TYPE_ngwt__AttachmentInfo;
			return soap_in_ngwt__AttachmentInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AttachmentID"))
		{	*type = SOAP_TYPE_ngwt__AttachmentID;
			return soap_in_ngwt__AttachmentID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Appointment"))
		{	*type = SOAP_TYPE_ngwt__Appointment;
			return soap_in_ngwt__Appointment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:Alarm"))
		{	*type = SOAP_TYPE_ngwt__Alarm;
			return soap_in_ngwt__Alarm(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AddressBookList"))
		{	*type = SOAP_TYPE_ngwt__AddressBookList;
			return soap_in_ngwt__AddressBookList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AddressBookItem"))
		{	*type = SOAP_TYPE_ngwt__AddressBookItem;
			return soap_in_ngwt__AddressBookItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AddressBook"))
		{	*type = SOAP_TYPE_ngwt__AddressBook;
			return soap_in_ngwt__AddressBook(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AccessRightList"))
		{	*type = SOAP_TYPE_ngwt__AccessRightList;
			return soap_in_ngwt__AccessRightList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AccessRightEntry"))
		{	*type = SOAP_TYPE_ngwt__AccessRightEntry;
			return soap_in_ngwt__AccessRightEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AccessRightChanges"))
		{	*type = SOAP_TYPE_ngwt__AccessRightChanges;
			return soap_in_ngwt__AccessRightChanges(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AccessRight"))
		{	*type = SOAP_TYPE_ngwt__AccessRight;
			return soap_in_ngwt__AccessRight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AccessMiscRight"))
		{	*type = SOAP_TYPE_ngwt__AccessMiscRight;
			return soap_in_ngwt__AccessMiscRight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AccessControlList"))
		{	*type = SOAP_TYPE_ngwt__AccessControlList;
			return soap_in_ngwt__AccessControlList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ngwt:AccessControlListEntry"))
		{	*type = SOAP_TYPE_ngwt__AccessControlListEntry;
			return soap_in_ngwt__AccessControlListEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:language"))
		{	*type = SOAP_TYPE_xsd__language;
			return soap_in_xsd__language(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	*type = SOAP_TYPE_xsd__date;
			return soap_in_xsd__date(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
			return soap->error = SOAP_TAG_MISMATCH;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_ngwt__DayOfMonth:
		return soap_out_ngwt__DayOfMonth(soap, tag, id, (const char *)ptr, "ngwt:DayOfMonth");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ngwt__WeekOfYear:
		return soap_out_ngwt__WeekOfYear(soap, tag, id, (const short *)ptr, "ngwt:WeekOfYear");
	case SOAP_TYPE_ngwt__DayOfYear:
		return soap_out_ngwt__DayOfYear(soap, tag, id, (const short *)ptr, "ngwt:DayOfYear");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_ngwt__GMTOffset:
		return soap_out_ngwt__GMTOffset(soap, tag, id, (const int *)ptr, "ngwt:GMTOffset");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_ngwt__Month:
		return soap_out_ngwt__Month(soap, tag, id, (const unsigned char *)ptr, "ngwt:Month");
	case SOAP_TYPE_ngwt__Minute:
		return soap_out_ngwt__Minute(soap, tag, id, (const unsigned char *)ptr, "ngwt:Minute");
	case SOAP_TYPE_ngwt__Hour:
		return soap_out_ngwt__Hour(soap, tag, id, (const unsigned char *)ptr, "ngwt:Hour");
	case SOAP_TYPE_ngwt__Day:
		return soap_out_ngwt__Day(soap, tag, id, (const unsigned char *)ptr, "ngwt:Day");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_out_unsignedLong(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ngwe__ItemType:
		return soap_out_ngwe__ItemType(soap, tag, id, (const enum ngwe__ItemType *)ptr, "ngwe:ItemType");
	case SOAP_TYPE_ngwe__Field:
		return soap_out_ngwe__Field(soap, tag, id, (const enum ngwe__Field *)ptr, "ngwe:Field");
	case SOAP_TYPE_ngwe__EventType:
		return soap_out_ngwe__EventType(soap, tag, id, (const enum ngwe__EventType *)ptr, "ngwe:EventType");
	case SOAP_TYPE_ngwt__WeekDay:
		return soap_out_ngwt__WeekDay(soap, tag, id, (const enum ngwt__WeekDay *)ptr, "ngwt:WeekDay");
	case SOAP_TYPE_ngwt__VersionStatus:
		return soap_out_ngwt__VersionStatus(soap, tag, id, (const enum ngwt__VersionStatus *)ptr, "ngwt:VersionStatus");
	case SOAP_TYPE_ngwt__VersionEventType:
		return soap_out_ngwt__VersionEventType(soap, tag, id, (const enum ngwt__VersionEventType *)ptr, "ngwt:VersionEventType");
	case SOAP_TYPE_ngwt__StatusTrackingOptions:
		return soap_out_ngwt__StatusTrackingOptions(soap, tag, id, (const enum ngwt__StatusTrackingOptions *)ptr, "ngwt:StatusTrackingOptions");
	case SOAP_TYPE_ngwt__RuleActionType:
		return soap_out_ngwt__RuleActionType(soap, tag, id, (const enum ngwt__RuleActionType *)ptr, "ngwt:RuleActionType");
	case SOAP_TYPE_ngwt__RetractType:
		return soap_out_ngwt__RetractType(soap, tag, id, (const enum ngwt__RetractType *)ptr, "ngwt:RetractType");
	case SOAP_TYPE_ngwt__RecipientType:
		return soap_out_ngwt__RecipientType(soap, tag, id, (const enum ngwt__RecipientType *)ptr, "ngwt:RecipientType");
	case SOAP_TYPE_ngwt__PostalAddressType:
		return soap_out_ngwt__PostalAddressType(soap, tag, id, (const enum ngwt__PostalAddressType *)ptr, "ngwt:PostalAddressType");
	case SOAP_TYPE_ngwt__PhoneNumberType:
		return soap_out_ngwt__PhoneNumberType(soap, tag, id, (const enum ngwt__PhoneNumberType *)ptr, "ngwt:PhoneNumberType");
	case SOAP_TYPE_ngwt__OccurrenceType:
		return soap_out_ngwt__OccurrenceType(soap, tag, id, (const enum ngwt__OccurrenceType *)ptr, "ngwt:OccurrenceType");
	case SOAP_TYPE_ngwt__NotificationType:
		return soap_out_ngwt__NotificationType(soap, tag, id, (const enum ngwt__NotificationType *)ptr, "ngwt:NotificationType");
	case SOAP_TYPE_ngwt__MessageType:
		return soap_out_ngwt__MessageType(soap, tag, id, (const enum ngwt__MessageType *)ptr, "ngwt:MessageType");
	case SOAP_TYPE_ngwt__MessageList:
		return soap_out_ngwt__MessageList(soap, tag, id, (const enum ngwt__MessageList *)ptr, "ngwt:MessageList");
	case SOAP_TYPE_ngwt__LinkType:
		return soap_out_ngwt__LinkType(soap, tag, id, (const enum ngwt__LinkType *)ptr, "ngwt:LinkType");
	case SOAP_TYPE_ngwt__JunkMatchType:
		return soap_out_ngwt__JunkMatchType(soap, tag, id, (const enum ngwt__JunkMatchType *)ptr, "ngwt:JunkMatchType");
	case SOAP_TYPE_ngwt__JunkHandlingListType:
		return soap_out_ngwt__JunkHandlingListType(soap, tag, id, (const enum ngwt__JunkHandlingListType *)ptr, "ngwt:JunkHandlingListType");
	case SOAP_TYPE_ngwt__ItemSource:
		return soap_out_ngwt__ItemSource(soap, tag, id, (const enum ngwt__ItemSource *)ptr, "ngwt:ItemSource");
	case SOAP_TYPE_ngwt__ItemSecurity:
		return soap_out_ngwt__ItemSecurity(soap, tag, id, (const enum ngwt__ItemSecurity *)ptr, "ngwt:ItemSecurity");
	case SOAP_TYPE_ngwt__ItemOptionsPriority:
		return soap_out_ngwt__ItemOptionsPriority(soap, tag, id, (const enum ngwt__ItemOptionsPriority *)ptr, "ngwt:ItemOptionsPriority");
	case SOAP_TYPE_ngwt__ItemClass:
		return soap_out_ngwt__ItemClass(soap, tag, id, (const enum ngwt__ItemClass *)ptr, "ngwt:ItemClass");
	case SOAP_TYPE_ngwt__Frequency:
		return soap_out_ngwt__Frequency(soap, tag, id, (const enum ngwt__Frequency *)ptr, "ngwt:Frequency");
	case SOAP_TYPE_ngwt__FolderType:
		return soap_out_ngwt__FolderType(soap, tag, id, (const enum ngwt__FolderType *)ptr, "ngwt:FolderType");
	case SOAP_TYPE_ngwt__FolderACLStatus:
		return soap_out_ngwt__FolderACLStatus(soap, tag, id, (const enum ngwt__FolderACLStatus *)ptr, "ngwt:FolderACLStatus");
	case SOAP_TYPE_ngwt__FilterOp:
		return soap_out_ngwt__FilterOp(soap, tag, id, (const enum ngwt__FilterOp *)ptr, "ngwt:FilterOp");
	case SOAP_TYPE_ngwt__FilterDate:
		return soap_out_ngwt__FilterDate(soap, tag, id, (const enum ngwt__FilterDate *)ptr, "ngwt:FilterDate");
	case SOAP_TYPE_ngwt__Execution:
		return soap_out_ngwt__Execution(soap, tag, id, (const enum ngwt__Execution *)ptr, "ngwt:Execution");
	case SOAP_TYPE_ngwt__DistributionType:
		return soap_out_ngwt__DistributionType(soap, tag, id, (const enum ngwt__DistributionType *)ptr, "ngwt:DistributionType");
	case SOAP_TYPE_ngwt__DeltaSyncType:
		return soap_out_ngwt__DeltaSyncType(soap, tag, id, (const enum ngwt__DeltaSyncType *)ptr, "ngwt:DeltaSyncType");
	case SOAP_TYPE_ngwt__CustomType:
		return soap_out_ngwt__CustomType(soap, tag, id, (const enum ngwt__CustomType *)ptr, "ngwt:CustomType");
	case SOAP_TYPE_ngwt__CursorSeek:
		return soap_out_ngwt__CursorSeek(soap, tag, id, (const enum ngwt__CursorSeek *)ptr, "ngwt:CursorSeek");
	case SOAP_TYPE_ngwt__ContactType:
		return soap_out_ngwt__ContactType(soap, tag, id, (const enum ngwt__ContactType *)ptr, "ngwt:ContactType");
	case SOAP_TYPE_ngwt__CategoryType:
		return soap_out_ngwt__CategoryType(soap, tag, id, (const enum ngwt__CategoryType *)ptr, "ngwt:CategoryType");
	case SOAP_TYPE_ngwt__CalendarFolderFlags:
		return soap_out_ngwt__CalendarFolderFlags(soap, tag, id, (const enum ngwt__CalendarFolderFlags *)ptr, "ngwt:CalendarFolderFlags");
	case SOAP_TYPE_ngwt__AppointmentConflict:
		return soap_out_ngwt__AppointmentConflict(soap, tag, id, (const enum ngwt__AppointmentConflict *)ptr, "ngwt:AppointmentConflict");
	case SOAP_TYPE_ngwt__AgeAction:
		return soap_out_ngwt__AgeAction(soap, tag, id, (const enum ngwt__AgeAction *)ptr, "ngwt:AgeAction");
	case SOAP_TYPE_ngwt__AcceptLevel:
		return soap_out_ngwt__AcceptLevel(soap, tag, id, (const enum ngwt__AcceptLevel *)ptr, "ngwt:AcceptLevel");
	case SOAP_TYPE_ngwe__ItemTypeList:
		return soap_out_ngwe__ItemTypeList(soap, tag, id, (const enum ngwe__ItemTypeList *)ptr, "ngwe:ItemTypeList");
	case SOAP_TYPE_ngwe__FieldList:
		return soap_out_ngwe__FieldList(soap, tag, id, (const enum ngwe__FieldList *)ptr, "ngwe:FieldList");
	case SOAP_TYPE_ngwt__MessageTypeList:
		return soap_out_ngwt__MessageTypeList(soap, tag, id, (const enum ngwt__MessageTypeList *)ptr, "ngwt:MessageTypeList");
	case SOAP_TYPE_ngwt__ItemSourceList:
		return soap_out_ngwt__ItemSourceList(soap, tag, id, (const enum ngwt__ItemSourceList *)ptr, "ngwt:ItemSourceList");
	case SOAP_TYPE_ngwt__UUID:
		return soap_out_ngwt__UUID(soap, tag, id, (const std::string *)ptr, "ngwt:UUID");
	case SOAP_TYPE_ngwt__uid:
		return soap_out_ngwt__uid(soap, tag, id, (const std::string *)ptr, "ngwt:uid");
	case SOAP_TYPE_ngwt__View:
		return soap_out_ngwt__View(soap, tag, id, (const std::string *)ptr, "ngwt:View");
	case SOAP_TYPE__ngwe__removeEventsResponse:
		return ((_ngwe__removeEventsResponse *)ptr)->soap_out(soap, "ngwe:removeEventsResponse", id, NULL);
	case SOAP_TYPE__ngwe__removeEventsRequest:
		return ((_ngwe__removeEventsRequest *)ptr)->soap_out(soap, "ngwe:removeEventsRequest", id, NULL);
	case SOAP_TYPE__ngwe__removeEventConfigurationResponse:
		return ((_ngwe__removeEventConfigurationResponse *)ptr)->soap_out(soap, "ngwe:removeEventConfigurationResponse", id, NULL);
	case SOAP_TYPE__ngwe__removeEventConfigurationRequest:
		return ((_ngwe__removeEventConfigurationRequest *)ptr)->soap_out(soap, "ngwe:removeEventConfigurationRequest", id, NULL);
	case SOAP_TYPE__ngwe__getEventsResponse:
		return ((_ngwe__getEventsResponse *)ptr)->soap_out(soap, "ngwe:getEventsResponse", id, NULL);
	case SOAP_TYPE__ngwe__getEventsRequest:
		return ((_ngwe__getEventsRequest *)ptr)->soap_out(soap, "ngwe:getEventsRequest", id, NULL);
	case SOAP_TYPE__ngwe__getEventConfigurationResponse:
		return ((_ngwe__getEventConfigurationResponse *)ptr)->soap_out(soap, "ngwe:getEventConfigurationResponse", id, NULL);
	case SOAP_TYPE__ngwe__getEventConfigurationRequest:
		return ((_ngwe__getEventConfigurationRequest *)ptr)->soap_out(soap, "ngwe:getEventConfigurationRequest", id, NULL);
	case SOAP_TYPE__ngwe__configureEventsResponse:
		return ((_ngwe__configureEventsResponse *)ptr)->soap_out(soap, "ngwe:configureEventsResponse", id, NULL);
	case SOAP_TYPE__ngwe__configureEventsRequest:
		return ((_ngwe__configureEventsRequest *)ptr)->soap_out(soap, "ngwe:configureEventsRequest", id, NULL);
	case SOAP_TYPE__ngwe__cleanEventConfigurationResponse:
		return ((_ngwe__cleanEventConfigurationResponse *)ptr)->soap_out(soap, "ngwe:cleanEventConfigurationResponse", id, NULL);
	case SOAP_TYPE__ngwe__cleanEventConfigurationRequest:
		return ((_ngwe__cleanEventConfigurationRequest *)ptr)->soap_out(soap, "ngwe:cleanEventConfigurationRequest", id, NULL);
	case SOAP_TYPE_ngwe__Notify:
		return ((ngwe__Notify *)ptr)->soap_out(soap, tag, id, "ngwe:Notify");
	case SOAP_TYPE_ngwe__EventTypeList:
		return ((ngwe__EventTypeList *)ptr)->soap_out(soap, tag, id, "ngwe:EventTypeList");
	case SOAP_TYPE_ngwe__EventsList:
		return ((ngwe__EventsList *)ptr)->soap_out(soap, tag, id, "ngwe:EventsList");
	case SOAP_TYPE_ngwe__Events:
		return ((ngwe__Events *)ptr)->soap_out(soap, tag, id, "ngwe:Events");
	case SOAP_TYPE_ngwe__EventList:
		return ((ngwe__EventList *)ptr)->soap_out(soap, tag, id, "ngwe:EventList");
	case SOAP_TYPE_ngwe__EventDefinition:
		return ((ngwe__EventDefinition *)ptr)->soap_out(soap, tag, id, "ngwe:EventDefinition");
	case SOAP_TYPE_ngwe__Event:
		return ((ngwe__Event *)ptr)->soap_out(soap, tag, id, "ngwe:Event");
	case SOAP_TYPE_ngwe__ContainerList:
		return ((ngwe__ContainerList *)ptr)->soap_out(soap, tag, id, "ngwe:ContainerList");
	case SOAP_TYPE__ngwm__updateVersionStatusResponse:
		return ((_ngwm__updateVersionStatusResponse *)ptr)->soap_out(soap, "ngwm:updateVersionStatusResponse", id, NULL);
	case SOAP_TYPE__ngwm__updateVersionStatusRequest:
		return ((_ngwm__updateVersionStatusRequest *)ptr)->soap_out(soap, "ngwm:updateVersionStatusRequest", id, NULL);
	case SOAP_TYPE__ngwm__uncompleteResponse:
		return ((_ngwm__uncompleteResponse *)ptr)->soap_out(soap, "ngwm:uncompleteResponse", id, NULL);
	case SOAP_TYPE__ngwm__uncompleteRequest:
		return ((_ngwm__uncompleteRequest *)ptr)->soap_out(soap, "ngwm:uncompleteRequest", id, NULL);
	case SOAP_TYPE__ngwm__unacceptResponse:
		return ((_ngwm__unacceptResponse *)ptr)->soap_out(soap, "ngwm:unacceptResponse", id, NULL);
	case SOAP_TYPE__ngwm__unacceptRequest:
		return ((_ngwm__unacceptRequest *)ptr)->soap_out(soap, "ngwm:unacceptRequest", id, NULL);
	case SOAP_TYPE__ngwm__startFreeBusySessionResponse:
		return ((_ngwm__startFreeBusySessionResponse *)ptr)->soap_out(soap, "ngwm:startFreeBusySessionResponse", id, NULL);
	case SOAP_TYPE__ngwm__startFreeBusySessionRequest:
		return ((_ngwm__startFreeBusySessionRequest *)ptr)->soap_out(soap, "ngwm:startFreeBusySessionRequest", id, NULL);
	case SOAP_TYPE__ngwm__setTimestampResponse:
		return ((_ngwm__setTimestampResponse *)ptr)->soap_out(soap, "ngwm:setTimestampResponse", id, NULL);
	case SOAP_TYPE__ngwm__setTimestampRequest:
		return ((_ngwm__setTimestampRequest *)ptr)->soap_out(soap, "ngwm:setTimestampRequest", id, NULL);
	case SOAP_TYPE__ngwm__sendItemResponse:
		return ((_ngwm__sendItemResponse *)ptr)->soap_out(soap, "ngwm:sendItemResponse", id, NULL);
	case SOAP_TYPE__ngwm__sendItemRequest:
		return ((_ngwm__sendItemRequest *)ptr)->soap_out(soap, "ngwm:sendItemRequest", id, NULL);
	case SOAP_TYPE__ngwm__retractResponse:
		return ((_ngwm__retractResponse *)ptr)->soap_out(soap, "ngwm:retractResponse", id, NULL);
	case SOAP_TYPE__ngwm__retractRequest:
		return ((_ngwm__retractRequest *)ptr)->soap_out(soap, "ngwm:retractRequest", id, NULL);
	case SOAP_TYPE__ngwm__replyResponse:
		return ((_ngwm__replyResponse *)ptr)->soap_out(soap, "ngwm:replyResponse", id, NULL);
	case SOAP_TYPE__ngwm__replyRequest:
		return ((_ngwm__replyRequest *)ptr)->soap_out(soap, "ngwm:replyRequest", id, NULL);
	case SOAP_TYPE__ngwm__removeSignatureResponse:
		return ((_ngwm__removeSignatureResponse *)ptr)->soap_out(soap, "ngwm:removeSignatureResponse", id, NULL);
	case SOAP_TYPE__ngwm__removeSignatureRequest:
		return ((_ngwm__removeSignatureRequest *)ptr)->soap_out(soap, "ngwm:removeSignatureRequest", id, NULL);
	case SOAP_TYPE__ngwm__removeProxyUserResponse:
		return ((_ngwm__removeProxyUserResponse *)ptr)->soap_out(soap, "ngwm:removeProxyUserResponse", id, NULL);
	case SOAP_TYPE__ngwm__removeProxyUserRequest:
		return ((_ngwm__removeProxyUserRequest *)ptr)->soap_out(soap, "ngwm:removeProxyUserRequest", id, NULL);
	case SOAP_TYPE__ngwm__removeProxyAccessResponse:
		return ((_ngwm__removeProxyAccessResponse *)ptr)->soap_out(soap, "ngwm:removeProxyAccessResponse", id, NULL);
	case SOAP_TYPE__ngwm__removeProxyAccessRequest:
		return ((_ngwm__removeProxyAccessRequest *)ptr)->soap_out(soap, "ngwm:removeProxyAccessRequest", id, NULL);
	case SOAP_TYPE__ngwm__removeMembersResponse:
		return ((_ngwm__removeMembersResponse *)ptr)->soap_out(soap, "ngwm:removeMembersResponse", id, NULL);
	case SOAP_TYPE__ngwm__removeMembersRequest:
		return ((_ngwm__removeMembersRequest *)ptr)->soap_out(soap, "ngwm:removeMembersRequest", id, NULL);
	case SOAP_TYPE__ngwm__removeJunkEntryResponse:
		return ((_ngwm__removeJunkEntryResponse *)ptr)->soap_out(soap, "ngwm:removeJunkEntryResponse", id, NULL);
	case SOAP_TYPE__ngwm__removeJunkEntryRequest:
		return ((_ngwm__removeJunkEntryRequest *)ptr)->soap_out(soap, "ngwm:removeJunkEntryRequest", id, NULL);
	case SOAP_TYPE__ngwm__removeItemsResponse:
		return ((_ngwm__removeItemsResponse *)ptr)->soap_out(soap, "ngwm:removeItemsResponse", id, NULL);
	case SOAP_TYPE__ngwm__removeItemsRequest:
		return ((_ngwm__removeItemsRequest *)ptr)->soap_out(soap, "ngwm:removeItemsRequest", id, NULL);
	case SOAP_TYPE__ngwm__removeItemResponse:
		return ((_ngwm__removeItemResponse *)ptr)->soap_out(soap, "ngwm:removeItemResponse", id, NULL);
	case SOAP_TYPE__ngwm__removeItemRequest:
		return ((_ngwm__removeItemRequest *)ptr)->soap_out(soap, "ngwm:removeItemRequest", id, NULL);
	case SOAP_TYPE__ngwm__removeCustomDefinitionResponse:
		return ((_ngwm__removeCustomDefinitionResponse *)ptr)->soap_out(soap, "ngwm:removeCustomDefinitionResponse", id, NULL);
	case SOAP_TYPE__ngwm__removeCustomDefinitionRequest:
		return ((_ngwm__removeCustomDefinitionRequest *)ptr)->soap_out(soap, "ngwm:removeCustomDefinitionRequest", id, NULL);
	case SOAP_TYPE__ngwm__readCursorResponse:
		return ((_ngwm__readCursorResponse *)ptr)->soap_out(soap, "ngwm:readCursorResponse", id, NULL);
	case SOAP_TYPE__ngwm__readCursorRequest:
		return ((_ngwm__readCursorRequest *)ptr)->soap_out(soap, "ngwm:readCursorRequest", id, NULL);
	case SOAP_TYPE__ngwm__purgeResponse:
		return ((_ngwm__purgeResponse *)ptr)->soap_out(soap, "ngwm:purgeResponse", id, NULL);
	case SOAP_TYPE__ngwm__purgeRequest:
		return ((_ngwm__purgeRequest *)ptr)->soap_out(soap, "ngwm:purgeRequest", id, NULL);
	case SOAP_TYPE__ngwm__purgeDeletedItemsResponse:
		return ((_ngwm__purgeDeletedItemsResponse *)ptr)->soap_out(soap, "ngwm:purgeDeletedItemsResponse", id, NULL);
	case SOAP_TYPE__ngwm__purgeDeletedItemsRequest:
		return ((_ngwm__purgeDeletedItemsRequest *)ptr)->soap_out(soap, "ngwm:purgeDeletedItemsRequest", id, NULL);
	case SOAP_TYPE__ngwm__positionCursorResponse:
		return ((_ngwm__positionCursorResponse *)ptr)->soap_out(soap, "ngwm:positionCursorResponse", id, NULL);
	case SOAP_TYPE__ngwm__positionCursorRequest:
		return ((_ngwm__positionCursorRequest *)ptr)->soap_out(soap, "ngwm:positionCursorRequest", id, NULL);
	case SOAP_TYPE__ngwm__moveItemResponse:
		return ((_ngwm__moveItemResponse *)ptr)->soap_out(soap, "ngwm:moveItemResponse", id, NULL);
	case SOAP_TYPE__ngwm__moveItemRequest:
		return ((_ngwm__moveItemRequest *)ptr)->soap_out(soap, "ngwm:moveItemRequest", id, NULL);
	case SOAP_TYPE__ngwm__modifySignaturesResponse:
		return ((_ngwm__modifySignaturesResponse *)ptr)->soap_out(soap, "ngwm:modifySignaturesResponse", id, NULL);
	case SOAP_TYPE__ngwm__modifySignaturesRequest:
		return ((_ngwm__modifySignaturesRequest *)ptr)->soap_out(soap, "ngwm:modifySignaturesRequest", id, NULL);
	case SOAP_TYPE__ngwm__modifySettingsResponse:
		return ((_ngwm__modifySettingsResponse *)ptr)->soap_out(soap, "ngwm:modifySettingsResponse", id, NULL);
	case SOAP_TYPE__ngwm__modifySettingsRequest:
		return ((_ngwm__modifySettingsRequest *)ptr)->soap_out(soap, "ngwm:modifySettingsRequest", id, NULL);
	case SOAP_TYPE__ngwm__modifyProxyAccessResponse:
		return ((_ngwm__modifyProxyAccessResponse *)ptr)->soap_out(soap, "ngwm:modifyProxyAccessResponse", id, NULL);
	case SOAP_TYPE__ngwm__modifyProxyAccessRequest:
		return ((_ngwm__modifyProxyAccessRequest *)ptr)->soap_out(soap, "ngwm:modifyProxyAccessRequest", id, NULL);
	case SOAP_TYPE__ngwm__modifyPasswordResponse:
		return ((_ngwm__modifyPasswordResponse *)ptr)->soap_out(soap, "ngwm:modifyPasswordResponse", id, NULL);
	case SOAP_TYPE__ngwm__modifyPasswordRequest:
		return ((_ngwm__modifyPasswordRequest *)ptr)->soap_out(soap, "ngwm:modifyPasswordRequest", id, NULL);
	case SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse:
		return ((_ngwm__modifyJunkMailSettingsResponse *)ptr)->soap_out(soap, "ngwm:modifyJunkMailSettingsResponse", id, NULL);
	case SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest:
		return ((_ngwm__modifyJunkMailSettingsRequest *)ptr)->soap_out(soap, "ngwm:modifyJunkMailSettingsRequest", id, NULL);
	case SOAP_TYPE__ngwm__modifyJunkEntryResponse:
		return ((_ngwm__modifyJunkEntryResponse *)ptr)->soap_out(soap, "ngwm:modifyJunkEntryResponse", id, NULL);
	case SOAP_TYPE__ngwm__modifyJunkEntryRequest:
		return ((_ngwm__modifyJunkEntryRequest *)ptr)->soap_out(soap, "ngwm:modifyJunkEntryRequest", id, NULL);
	case SOAP_TYPE__ngwm__modifyItemsResponse:
		return ((_ngwm__modifyItemsResponse *)ptr)->soap_out(soap, "ngwm:modifyItemsResponse", id, NULL);
	case SOAP_TYPE__ngwm__modifyItemsRequest:
		return ((_ngwm__modifyItemsRequest *)ptr)->soap_out(soap, "ngwm:modifyItemsRequest", id, NULL);
	case SOAP_TYPE__ngwm__modifyItemResponse:
		return ((_ngwm__modifyItemResponse *)ptr)->soap_out(soap, "ngwm:modifyItemResponse", id, NULL);
	case SOAP_TYPE__ngwm__modifyItemRequest:
		return ((_ngwm__modifyItemRequest *)ptr)->soap_out(soap, "ngwm:modifyItemRequest", id, NULL);
	case SOAP_TYPE__ngwm__markUnReadResponse:
		return ((_ngwm__markUnReadResponse *)ptr)->soap_out(soap, "ngwm:markUnReadResponse", id, NULL);
	case SOAP_TYPE__ngwm__markUnReadRequest:
		return ((_ngwm__markUnReadRequest *)ptr)->soap_out(soap, "ngwm:markUnReadRequest", id, NULL);
	case SOAP_TYPE__ngwm__markUnPrivateResponse:
		return ((_ngwm__markUnPrivateResponse *)ptr)->soap_out(soap, "ngwm:markUnPrivateResponse", id, NULL);
	case SOAP_TYPE__ngwm__markUnPrivateRequest:
		return ((_ngwm__markUnPrivateRequest *)ptr)->soap_out(soap, "ngwm:markUnPrivateRequest", id, NULL);
	case SOAP_TYPE__ngwm__markReadResponse:
		return ((_ngwm__markReadResponse *)ptr)->soap_out(soap, "ngwm:markReadResponse", id, NULL);
	case SOAP_TYPE__ngwm__markReadRequest:
		return ((_ngwm__markReadRequest *)ptr)->soap_out(soap, "ngwm:markReadRequest", id, NULL);
	case SOAP_TYPE__ngwm__markPrivateResponse:
		return ((_ngwm__markPrivateResponse *)ptr)->soap_out(soap, "ngwm:markPrivateResponse", id, NULL);
	case SOAP_TYPE__ngwm__markPrivateRequest:
		return ((_ngwm__markPrivateRequest *)ptr)->soap_out(soap, "ngwm:markPrivateRequest", id, NULL);
	case SOAP_TYPE__ngwm__logoutResponse:
		return ((_ngwm__logoutResponse *)ptr)->soap_out(soap, "ngwm:logoutResponse", id, NULL);
	case SOAP_TYPE__ngwm__logoutRequest:
		return ((_ngwm__logoutRequest *)ptr)->soap_out(soap, "ngwm:logoutRequest", id, NULL);
	case SOAP_TYPE__ngwm__loginResponse:
		return ((_ngwm__loginResponse *)ptr)->soap_out(soap, "ngwm:loginResponse", id, NULL);
	case SOAP_TYPE__ngwm__loginRequest:
		return ((_ngwm__loginRequest *)ptr)->soap_out(soap, "ngwm:loginRequest", id, NULL);
	case SOAP_TYPE__ngwm__getUserListResponse:
		return ((_ngwm__getUserListResponse *)ptr)->soap_out(soap, "ngwm:getUserListResponse", id, NULL);
	case SOAP_TYPE__ngwm__getUserListRequest:
		return ((_ngwm__getUserListRequest *)ptr)->soap_out(soap, "ngwm:getUserListRequest", id, NULL);
	case SOAP_TYPE__ngwm__getTimezoneListResponse:
		return ((_ngwm__getTimezoneListResponse *)ptr)->soap_out(soap, "ngwm:getTimezoneListResponse", id, NULL);
	case SOAP_TYPE__ngwm__getTimezoneListRequest:
		return ((_ngwm__getTimezoneListRequest *)ptr)->soap_out(soap, "ngwm:getTimezoneListRequest", id, NULL);
	case SOAP_TYPE__ngwm__getTimestampResponse:
		return ((_ngwm__getTimestampResponse *)ptr)->soap_out(soap, "ngwm:getTimestampResponse", id, NULL);
	case SOAP_TYPE__ngwm__getTimestampRequest:
		return ((_ngwm__getTimestampRequest *)ptr)->soap_out(soap, "ngwm:getTimestampRequest", id, NULL);
	case SOAP_TYPE__ngwm__getSignaturesResponse:
		return ((_ngwm__getSignaturesResponse *)ptr)->soap_out(soap, "ngwm:getSignaturesResponse", id, NULL);
	case SOAP_TYPE__ngwm__getSignaturesRequest:
		return ((_ngwm__getSignaturesRequest *)ptr)->soap_out(soap, "ngwm:getSignaturesRequest", id, NULL);
	case SOAP_TYPE__ngwm__getSettingsResponse:
		return ((_ngwm__getSettingsResponse *)ptr)->soap_out(soap, "ngwm:getSettingsResponse", id, NULL);
	case SOAP_TYPE__ngwm__getSettingsRequest:
		return ((_ngwm__getSettingsRequest *)ptr)->soap_out(soap, "ngwm:getSettingsRequest", id, NULL);
	case SOAP_TYPE__ngwm__getRuleListResponse:
		return ((_ngwm__getRuleListResponse *)ptr)->soap_out(soap, "ngwm:getRuleListResponse", id, NULL);
	case SOAP_TYPE__ngwm__getRuleListRequest:
		return ((_ngwm__getRuleListRequest *)ptr)->soap_out(soap, "ngwm:getRuleListRequest", id, NULL);
	case SOAP_TYPE__ngwm__getProxyListResponse:
		return ((_ngwm__getProxyListResponse *)ptr)->soap_out(soap, "ngwm:getProxyListResponse", id, NULL);
	case SOAP_TYPE__ngwm__getProxyListRequest:
		return ((_ngwm__getProxyListRequest *)ptr)->soap_out(soap, "ngwm:getProxyListRequest", id, NULL);
	case SOAP_TYPE__ngwm__getProxyAccessListResponse:
		return ((_ngwm__getProxyAccessListResponse *)ptr)->soap_out(soap, "ngwm:getProxyAccessListResponse", id, NULL);
	case SOAP_TYPE__ngwm__getProxyAccessListRequest:
		return ((_ngwm__getProxyAccessListRequest *)ptr)->soap_out(soap, "ngwm:getProxyAccessListRequest", id, NULL);
	case SOAP_TYPE__ngwm__getQuickMessagesResponse:
		return ((_ngwm__getQuickMessagesResponse *)ptr)->soap_out(soap, "ngwm:getQuickMessagesResponse", id, NULL);
	case SOAP_TYPE__ngwm__getQuickMessagesRequest:
		return ((_ngwm__getQuickMessagesRequest *)ptr)->soap_out(soap, "ngwm:getQuickMessagesRequest", id, NULL);
	case SOAP_TYPE__ngwm__getLibraryListResponse:
		return ((_ngwm__getLibraryListResponse *)ptr)->soap_out(soap, "ngwm:getLibraryListResponse", id, NULL);
	case SOAP_TYPE__ngwm__getLibraryListRequest:
		return ((_ngwm__getLibraryListRequest *)ptr)->soap_out(soap, "ngwm:getLibraryListRequest", id, NULL);
	case SOAP_TYPE__ngwm__getLibraryItemResponse:
		return ((_ngwm__getLibraryItemResponse *)ptr)->soap_out(soap, "ngwm:getLibraryItemResponse", id, NULL);
	case SOAP_TYPE__ngwm__getLibraryItemRequest:
		return ((_ngwm__getLibraryItemRequest *)ptr)->soap_out(soap, "ngwm:getLibraryItemRequest", id, NULL);
	case SOAP_TYPE__ngwm__getJunkMailSettingsResponse:
		return ((_ngwm__getJunkMailSettingsResponse *)ptr)->soap_out(soap, "ngwm:getJunkMailSettingsResponse", id, NULL);
	case SOAP_TYPE__ngwm__getJunkMailSettingsRequest:
		return ((_ngwm__getJunkMailSettingsRequest *)ptr)->soap_out(soap, "ngwm:getJunkMailSettingsRequest", id, NULL);
	case SOAP_TYPE__ngwm__getJunkEntriesResponse:
		return ((_ngwm__getJunkEntriesResponse *)ptr)->soap_out(soap, "ngwm:getJunkEntriesResponse", id, NULL);
	case SOAP_TYPE__ngwm__getJunkEntriesRequest:
		return ((_ngwm__getJunkEntriesRequest *)ptr)->soap_out(soap, "ngwm:getJunkEntriesRequest", id, NULL);
	case SOAP_TYPE__ngwm__getItemsResponse:
		return ((_ngwm__getItemsResponse *)ptr)->soap_out(soap, "ngwm:getItemsResponse", id, NULL);
	case SOAP_TYPE__ngwm__getItemsRequest:
		return ((_ngwm__getItemsRequest *)ptr)->soap_out(soap, "ngwm:getItemsRequest", id, NULL);
	case SOAP_TYPE__ngwm__getItemResponse:
		return ((_ngwm__getItemResponse *)ptr)->soap_out(soap, "ngwm:getItemResponse", id, NULL);
	case SOAP_TYPE__ngwm__getItemRequest:
		return ((_ngwm__getItemRequest *)ptr)->soap_out(soap, "ngwm:getItemRequest", id, NULL);
	case SOAP_TYPE__ngwm__getFreeBusyResponse:
		return ((_ngwm__getFreeBusyResponse *)ptr)->soap_out(soap, "ngwm:getFreeBusyResponse", id, NULL);
	case SOAP_TYPE__ngwm__getFreeBusyRequest:
		return ((_ngwm__getFreeBusyRequest *)ptr)->soap_out(soap, "ngwm:getFreeBusyRequest", id, NULL);
	case SOAP_TYPE__ngwm__getFolderListResponse:
		return ((_ngwm__getFolderListResponse *)ptr)->soap_out(soap, "ngwm:getFolderListResponse", id, NULL);
	case SOAP_TYPE__ngwm__getFolderListRequest:
		return ((_ngwm__getFolderListRequest *)ptr)->soap_out(soap, "ngwm:getFolderListRequest", id, NULL);
	case SOAP_TYPE__ngwm__getFolderResponse:
		return ((_ngwm__getFolderResponse *)ptr)->soap_out(soap, "ngwm:getFolderResponse", id, NULL);
	case SOAP_TYPE__ngwm__getFolderRequest:
		return ((_ngwm__getFolderRequest *)ptr)->soap_out(soap, "ngwm:getFolderRequest", id, NULL);
	case SOAP_TYPE__ngwm__getDocumentTypeListResponse:
		return ((_ngwm__getDocumentTypeListResponse *)ptr)->soap_out(soap, "ngwm:getDocumentTypeListResponse", id, NULL);
	case SOAP_TYPE__ngwm__getDocumentTypeListRequest:
		return ((_ngwm__getDocumentTypeListRequest *)ptr)->soap_out(soap, "ngwm:getDocumentTypeListRequest", id, NULL);
	case SOAP_TYPE__ngwm__getDeltaInfoResponse:
		return ((_ngwm__getDeltaInfoResponse *)ptr)->soap_out(soap, "ngwm:getDeltaInfoResponse", id, NULL);
	case SOAP_TYPE__ngwm__getDeltaInfoRequest:
		return ((_ngwm__getDeltaInfoRequest *)ptr)->soap_out(soap, "ngwm:getDeltaInfoRequest", id, NULL);
	case SOAP_TYPE__ngwm__getDeltasResponse:
		return ((_ngwm__getDeltasResponse *)ptr)->soap_out(soap, "ngwm:getDeltasResponse", id, NULL);
	case SOAP_TYPE__ngwm__getDeltasRequest:
		return ((_ngwm__getDeltasRequest *)ptr)->soap_out(soap, "ngwm:getDeltasRequest", id, NULL);
	case SOAP_TYPE__ngwm__getCustomListResponse:
		return ((_ngwm__getCustomListResponse *)ptr)->soap_out(soap, "ngwm:getCustomListResponse", id, NULL);
	case SOAP_TYPE__ngwm__getCustomListRequest:
		return ((_ngwm__getCustomListRequest *)ptr)->soap_out(soap, "ngwm:getCustomListRequest", id, NULL);
	case SOAP_TYPE__ngwm__getCategoryListResponse:
		return ((_ngwm__getCategoryListResponse *)ptr)->soap_out(soap, "ngwm:getCategoryListResponse", id, NULL);
	case SOAP_TYPE__ngwm__getCategoryListRequest:
		return ((_ngwm__getCategoryListRequest *)ptr)->soap_out(soap, "ngwm:getCategoryListRequest", id, NULL);
	case SOAP_TYPE__ngwm__getAttachmentResponse:
		return ((_ngwm__getAttachmentResponse *)ptr)->soap_out(soap, "ngwm:getAttachmentResponse", id, NULL);
	case SOAP_TYPE__ngwm__getAttachmentRequest:
		return ((_ngwm__getAttachmentRequest *)ptr)->soap_out(soap, "ngwm:getAttachmentRequest", id, NULL);
	case SOAP_TYPE__ngwm__getAddressBookListResponse:
		return ((_ngwm__getAddressBookListResponse *)ptr)->soap_out(soap, "ngwm:getAddressBookListResponse", id, NULL);
	case SOAP_TYPE__ngwm__getAddressBookListRequest:
		return ((_ngwm__getAddressBookListRequest *)ptr)->soap_out(soap, "ngwm:getAddressBookListRequest", id, NULL);
	case SOAP_TYPE__ngwm__forwardResponse:
		return ((_ngwm__forwardResponse *)ptr)->soap_out(soap, "ngwm:forwardResponse", id, NULL);
	case SOAP_TYPE__ngwm__forwardRequest:
		return ((_ngwm__forwardRequest *)ptr)->soap_out(soap, "ngwm:forwardRequest", id, NULL);
	case SOAP_TYPE__ngwm__executeRuleResponse:
		return ((_ngwm__executeRuleResponse *)ptr)->soap_out(soap, "ngwm:executeRuleResponse", id, NULL);
	case SOAP_TYPE__ngwm__executeRuleRequest:
		return ((_ngwm__executeRuleRequest *)ptr)->soap_out(soap, "ngwm:executeRuleRequest", id, NULL);
	case SOAP_TYPE__ngwm__destroyCursorResponse:
		return ((_ngwm__destroyCursorResponse *)ptr)->soap_out(soap, "ngwm:destroyCursorResponse", id, NULL);
	case SOAP_TYPE__ngwm__destroyCursorRequest:
		return ((_ngwm__destroyCursorRequest *)ptr)->soap_out(soap, "ngwm:destroyCursorRequest", id, NULL);
	case SOAP_TYPE__ngwm__delegateResponse:
		return ((_ngwm__delegateResponse *)ptr)->soap_out(soap, "ngwm:delegateResponse", id, NULL);
	case SOAP_TYPE__ngwm__delegateRequest:
		return ((_ngwm__delegateRequest *)ptr)->soap_out(soap, "ngwm:delegateRequest", id, NULL);
	case SOAP_TYPE__ngwm__declineResponse:
		return ((_ngwm__declineResponse *)ptr)->soap_out(soap, "ngwm:declineResponse", id, NULL);
	case SOAP_TYPE__ngwm__declineRequest:
		return ((_ngwm__declineRequest *)ptr)->soap_out(soap, "ngwm:declineRequest", id, NULL);
	case SOAP_TYPE__ngwm__createSignatureResponse:
		return ((_ngwm__createSignatureResponse *)ptr)->soap_out(soap, "ngwm:createSignatureResponse", id, NULL);
	case SOAP_TYPE__ngwm__createSignatureRequest:
		return ((_ngwm__createSignatureRequest *)ptr)->soap_out(soap, "ngwm:createSignatureRequest", id, NULL);
	case SOAP_TYPE__ngwm__createProxyAccessResponse:
		return ((_ngwm__createProxyAccessResponse *)ptr)->soap_out(soap, "ngwm:createProxyAccessResponse", id, NULL);
	case SOAP_TYPE__ngwm__createProxyAccessRequest:
		return ((_ngwm__createProxyAccessRequest *)ptr)->soap_out(soap, "ngwm:createProxyAccessRequest", id, NULL);
	case SOAP_TYPE__ngwm__createJunkEntryResponse:
		return ((_ngwm__createJunkEntryResponse *)ptr)->soap_out(soap, "ngwm:createJunkEntryResponse", id, NULL);
	case SOAP_TYPE__ngwm__createJunkEntryRequest:
		return ((_ngwm__createJunkEntryRequest *)ptr)->soap_out(soap, "ngwm:createJunkEntryRequest", id, NULL);
	case SOAP_TYPE__ngwm__createItemsResponse:
		return ((_ngwm__createItemsResponse *)ptr)->soap_out(soap, "ngwm:createItemsResponse", id, NULL);
	case SOAP_TYPE__ngwm__createItemsRequest:
		return ((_ngwm__createItemsRequest *)ptr)->soap_out(soap, "ngwm:createItemsRequest", id, NULL);
	case SOAP_TYPE__ngwm__createItemResponse:
		return ((_ngwm__createItemResponse *)ptr)->soap_out(soap, "ngwm:createItemResponse", id, NULL);
	case SOAP_TYPE__ngwm__createItemRequest:
		return ((_ngwm__createItemRequest *)ptr)->soap_out(soap, "ngwm:createItemRequest", id, NULL);
	case SOAP_TYPE__ngwm__createCursorResponse:
		return ((_ngwm__createCursorResponse *)ptr)->soap_out(soap, "ngwm:createCursorResponse", id, NULL);
	case SOAP_TYPE__ngwm__createCursorRequest:
		return ((_ngwm__createCursorRequest *)ptr)->soap_out(soap, "ngwm:createCursorRequest", id, NULL);
	case SOAP_TYPE__ngwm__completeResponse:
		return ((_ngwm__completeResponse *)ptr)->soap_out(soap, "ngwm:completeResponse", id, NULL);
	case SOAP_TYPE__ngwm__completeRequest:
		return ((_ngwm__completeRequest *)ptr)->soap_out(soap, "ngwm:completeRequest", id, NULL);
	case SOAP_TYPE__ngwm__closeFreeBusySessionResponse:
		return ((_ngwm__closeFreeBusySessionResponse *)ptr)->soap_out(soap, "ngwm:closeFreeBusySessionResponse", id, NULL);
	case SOAP_TYPE__ngwm__closeFreeBusySessionRequest:
		return ((_ngwm__closeFreeBusySessionRequest *)ptr)->soap_out(soap, "ngwm:closeFreeBusySessionRequest", id, NULL);
	case SOAP_TYPE__ngwm__addMembersResponse:
		return ((_ngwm__addMembersResponse *)ptr)->soap_out(soap, "ngwm:addMembersResponse", id, NULL);
	case SOAP_TYPE__ngwm__addMembersRequest:
		return ((_ngwm__addMembersRequest *)ptr)->soap_out(soap, "ngwm:addMembersRequest", id, NULL);
	case SOAP_TYPE__ngwm__addItemsResponse:
		return ((_ngwm__addItemsResponse *)ptr)->soap_out(soap, "ngwm:addItemsResponse", id, NULL);
	case SOAP_TYPE__ngwm__addItemsRequest:
		return ((_ngwm__addItemsRequest *)ptr)->soap_out(soap, "ngwm:addItemsRequest", id, NULL);
	case SOAP_TYPE__ngwm__addItemResponse:
		return ((_ngwm__addItemResponse *)ptr)->soap_out(soap, "ngwm:addItemResponse", id, NULL);
	case SOAP_TYPE__ngwm__addItemRequest:
		return ((_ngwm__addItemRequest *)ptr)->soap_out(soap, "ngwm:addItemRequest", id, NULL);
	case SOAP_TYPE__ngwm__acceptShareResponse:
		return ((_ngwm__acceptShareResponse *)ptr)->soap_out(soap, "ngwm:acceptShareResponse", id, NULL);
	case SOAP_TYPE__ngwm__acceptShareRequest:
		return ((_ngwm__acceptShareRequest *)ptr)->soap_out(soap, "ngwm:acceptShareRequest", id, NULL);
	case SOAP_TYPE__ngwm__acceptResponse:
		return ((_ngwm__acceptResponse *)ptr)->soap_out(soap, "ngwm:acceptResponse", id, NULL);
	case SOAP_TYPE__ngwm__acceptRequest:
		return ((_ngwm__acceptRequest *)ptr)->soap_out(soap, "ngwm:acceptRequest", id, NULL);
	case SOAP_TYPE_ngwt__VersionEvent:
		return ((ngwt__VersionEvent *)ptr)->soap_out(soap, tag, id, "ngwt:VersionEvent");
	case SOAP_TYPE_ngwt__Version:
		return ((ngwt__Version *)ptr)->soap_out(soap, tag, id, "ngwt:Version");
	case SOAP_TYPE_ngwt__UserList:
		return ((ngwt__UserList *)ptr)->soap_out(soap, tag, id, "ngwt:UserList");
	case SOAP_TYPE_ngwt__UserInfo:
		return ((ngwt__UserInfo *)ptr)->soap_out(soap, tag, id, "ngwt:UserInfo");
	case SOAP_TYPE_ngwt__TrustedApplication:
		return ((ngwt__TrustedApplication *)ptr)->soap_out(soap, tag, id, "ngwt:TrustedApplication");
	case SOAP_TYPE_ngwt__TransferFailedStatus:
		return ((ngwt__TransferFailedStatus *)ptr)->soap_out(soap, tag, id, "ngwt:TransferFailedStatus");
	case SOAP_TYPE_ngwt__TimezoneList:
		return ((ngwt__TimezoneList *)ptr)->soap_out(soap, tag, id, "ngwt:TimezoneList");
	case SOAP_TYPE_ngwt__TimezoneComponent:
		return ((ngwt__TimezoneComponent *)ptr)->soap_out(soap, tag, id, "ngwt:TimezoneComponent");
	case SOAP_TYPE_ngwt__Timezone:
		return ((ngwt__Timezone *)ptr)->soap_out(soap, tag, id, "ngwt:Timezone");
	case SOAP_TYPE_ngwt__Task:
		return ((ngwt__Task *)ptr)->soap_out(soap, tag, id, "ngwt:Task");
	case SOAP_TYPE_ngwt__SystemFolder:
		return ((ngwt__SystemFolder *)ptr)->soap_out(soap, tag, id, "ngwt:SystemFolder");
	case SOAP_TYPE_ngwt__StatusTracking:
		return ((ngwt__StatusTracking *)ptr)->soap_out(soap, tag, id, "ngwt:StatusTracking");
	case SOAP_TYPE_ngwt__Status:
		return ((ngwt__Status *)ptr)->soap_out(soap, tag, id, "ngwt:Status");
	case SOAP_TYPE_ngwt__SMimeOperation:
		return ((ngwt__SMimeOperation *)ptr)->soap_out(soap, tag, id, "ngwt:SMimeOperation");
	case SOAP_TYPE_ngwt__SignatureData:
		return ((ngwt__SignatureData *)ptr)->soap_out(soap, tag, id, "ngwt:SignatureData");
	case SOAP_TYPE_ngwt__Signatures:
		return ((ngwt__Signatures *)ptr)->soap_out(soap, tag, id, "ngwt:Signatures");
	case SOAP_TYPE_ngwt__Signature:
		return ((ngwt__Signature *)ptr)->soap_out(soap, tag, id, "ngwt:Signature");
	case SOAP_TYPE_ngwt__SharedNotification:
		return ((ngwt__SharedNotification *)ptr)->soap_out(soap, tag, id, "ngwt:SharedNotification");
	case SOAP_TYPE_ngwt__SharedFolderNotification:
		return ((ngwt__SharedFolderNotification *)ptr)->soap_out(soap, tag, id, "ngwt:SharedFolderNotification");
	case SOAP_TYPE_ngwt__SharedFolder:
		return ((ngwt__SharedFolder *)ptr)->soap_out(soap, tag, id, "ngwt:SharedFolder");
	case SOAP_TYPE_ngwt__SettingsList:
		return ((ngwt__SettingsList *)ptr)->soap_out(soap, tag, id, "ngwt:SettingsList");
	case SOAP_TYPE_ngwt__SettingsGroup:
		return ((ngwt__SettingsGroup *)ptr)->soap_out(soap, tag, id, "ngwt:SettingsGroup");
	case SOAP_TYPE_ngwt__Settings:
		return ((ngwt__Settings *)ptr)->soap_out(soap, tag, id, "ngwt:Settings");
	case SOAP_TYPE_ngwt__SendOptions:
		return ((ngwt__SendOptions *)ptr)->soap_out(soap, tag, id, "ngwt:SendOptions");
	case SOAP_TYPE_ngwt__SendOptionsRequestReply:
		return ((ngwt__SendOptionsRequestReply *)ptr)->soap_out(soap, tag, id, "ngwt:SendOptionsRequestReply");
	case SOAP_TYPE_ngwt__RuleList:
		return ((ngwt__RuleList *)ptr)->soap_out(soap, tag, id, "ngwt:RuleList");
	case SOAP_TYPE_ngwt__RuleActionList:
		return ((ngwt__RuleActionList *)ptr)->soap_out(soap, tag, id, "ngwt:RuleActionList");
	case SOAP_TYPE_ngwt__RuleAction:
		return ((ngwt__RuleAction *)ptr)->soap_out(soap, tag, id, "ngwt:RuleAction");
	case SOAP_TYPE_ngwt__Rule:
		return ((ngwt__Rule *)ptr)->soap_out(soap, tag, id, "ngwt:Rule");
	case SOAP_TYPE_ngwt__Rights:
		return ((ngwt__Rights *)ptr)->soap_out(soap, tag, id, "ngwt:Rights");
	case SOAP_TYPE_ngwt__ReturnNotificationOptions:
		return ((ngwt__ReturnNotificationOptions *)ptr)->soap_out(soap, tag, id, "ngwt:ReturnNotificationOptions");
	case SOAP_TYPE_ngwt__ReturnNotification:
		return ((ngwt__ReturnNotification *)ptr)->soap_out(soap, tag, id, "ngwt:ReturnNotification");
	case SOAP_TYPE_ngwt__Resource:
		return ((ngwt__Resource *)ptr)->soap_out(soap, tag, id, "ngwt:Resource");
	case SOAP_TYPE_ngwt__ReferenceInfo:
		return ((ngwt__ReferenceInfo *)ptr)->soap_out(soap, tag, id, "ngwt:ReferenceInfo");
	case SOAP_TYPE_ngwt__RecurrenceRule:
		return ((ngwt__RecurrenceRule *)ptr)->soap_out(soap, tag, id, "ngwt:RecurrenceRule");
	case SOAP_TYPE_ngwt__RecurrenceDateType:
		return ((ngwt__RecurrenceDateType *)ptr)->soap_out(soap, tag, id, "ngwt:RecurrenceDateType");
	case SOAP_TYPE_ngwt__RecipientStatus:
		return ((ngwt__RecipientStatus *)ptr)->soap_out(soap, tag, id, "ngwt:RecipientStatus");
	case SOAP_TYPE_ngwt__RecipientList:
		return ((ngwt__RecipientList *)ptr)->soap_out(soap, tag, id, "ngwt:RecipientList");
	case SOAP_TYPE_ngwt__Recipient:
		return ((ngwt__Recipient *)ptr)->soap_out(soap, tag, id, "ngwt:Recipient");
	case SOAP_TYPE_ngwt__QueryTarget:
		return ((ngwt__QueryTarget *)ptr)->soap_out(soap, tag, id, "ngwt:QueryTarget");
	case SOAP_TYPE_ngwt__QueryFolder:
		return ((ngwt__QueryFolder *)ptr)->soap_out(soap, tag, id, "ngwt:QueryFolder");
	case SOAP_TYPE_ngwt__Query:
		return ((ngwt__Query *)ptr)->soap_out(soap, tag, id, "ngwt:Query");
	case SOAP_TYPE_ngwt__ProxyList:
		return ((ngwt__ProxyList *)ptr)->soap_out(soap, tag, id, "ngwt:ProxyList");
	case SOAP_TYPE_ngwt__ProxyUser:
		return ((ngwt__ProxyUser *)ptr)->soap_out(soap, tag, id, "ngwt:ProxyUser");
	case SOAP_TYPE_ngwt__Proxy:
		return ((ngwt__Proxy *)ptr)->soap_out(soap, tag, id, "ngwt:Proxy");
	case SOAP_TYPE_ngwt__ProblemList:
		return ((ngwt__ProblemList *)ptr)->soap_out(soap, tag, id, "ngwt:ProblemList");
	case SOAP_TYPE_ngwt__ProblemEntry:
		return ((ngwt__ProblemEntry *)ptr)->soap_out(soap, tag, id, "ngwt:ProblemEntry");
	case SOAP_TYPE_ngwt__PostalAddressList:
		return ((ngwt__PostalAddressList *)ptr)->soap_out(soap, tag, id, "ngwt:PostalAddressList");
	case SOAP_TYPE_ngwt__PostalAddress:
		return ((ngwt__PostalAddress *)ptr)->soap_out(soap, tag, id, "ngwt:PostalAddress");
	case SOAP_TYPE_ngwt__PlainText:
		return ((ngwt__PlainText *)ptr)->soap_out(soap, tag, id, "ngwt:PlainText");
	case SOAP_TYPE_ngwt__PhoneNumber:
		return ((ngwt__PhoneNumber *)ptr)->soap_out(soap, tag, id, "ngwt:PhoneNumber");
	case SOAP_TYPE_ngwt__PhoneMessage:
		return ((ngwt__PhoneMessage *)ptr)->soap_out(soap, tag, id, "ngwt:PhoneMessage");
	case SOAP_TYPE_ngwt__PhoneList:
		return ((ngwt__PhoneList *)ptr)->soap_out(soap, tag, id, "ngwt:PhoneList");
	case SOAP_TYPE_ngwt__PhoneFlags:
		return ((ngwt__PhoneFlags *)ptr)->soap_out(soap, tag, id, "ngwt:PhoneFlags");
	case SOAP_TYPE_ngwt__PersonalInfo:
		return ((ngwt__PersonalInfo *)ptr)->soap_out(soap, tag, id, "ngwt:PersonalInfo");
	case SOAP_TYPE_ngwt__Organization:
		return ((ngwt__Organization *)ptr)->soap_out(soap, tag, id, "ngwt:Organization");
	case SOAP_TYPE_ngwt__OfficeInfo:
		return ((ngwt__OfficeInfo *)ptr)->soap_out(soap, tag, id, "ngwt:OfficeInfo");
	case SOAP_TYPE_ngwt__Note:
		return ((ngwt__Note *)ptr)->soap_out(soap, tag, id, "ngwt:Note");
	case SOAP_TYPE_ngwt__NameAndEmail:
		return ((ngwt__NameAndEmail *)ptr)->soap_out(soap, tag, id, "ngwt:NameAndEmail");
	case SOAP_TYPE_ngwt__MonthList:
		return ((ngwt__MonthList *)ptr)->soap_out(soap, tag, id, "ngwt:MonthList");
	case SOAP_TYPE_ngwt__ModifyItem:
		return ((ngwt__ModifyItem *)ptr)->soap_out(soap, tag, id, "ngwt:ModifyItem");
	case SOAP_TYPE_ngwt__MessagePart:
		return ((ngwt__MessagePart *)ptr)->soap_out(soap, tag, id, "ngwt:MessagePart");
	case SOAP_TYPE_ngwt__MessageBody:
		return ((ngwt__MessageBody *)ptr)->soap_out(soap, tag, id, "ngwt:MessageBody");
	case SOAP_TYPE_ngwt__Mail:
		return ((ngwt__Mail *)ptr)->soap_out(soap, tag, id, "ngwt:Mail");
	case SOAP_TYPE_ngwt__LinkInfo:
		return ((ngwt__LinkInfo *)ptr)->soap_out(soap, tag, id, "ngwt:LinkInfo");
	case SOAP_TYPE_ngwt__LibraryList:
		return ((ngwt__LibraryList *)ptr)->soap_out(soap, tag, id, "ngwt:LibraryList");
	case SOAP_TYPE_ngwt__Library:
		return ((ngwt__Library *)ptr)->soap_out(soap, tag, id, "ngwt:Library");
	case SOAP_TYPE_ngwt__JunkHandlingList:
		return ((ngwt__JunkHandlingList *)ptr)->soap_out(soap, tag, id, "ngwt:JunkHandlingList");
	case SOAP_TYPE_ngwt__JunkEntry:
		return ((ngwt__JunkEntry *)ptr)->soap_out(soap, tag, id, "ngwt:JunkEntry");
	case SOAP_TYPE_ngwt__ItemStatus:
		return ((ngwt__ItemStatus *)ptr)->soap_out(soap, tag, id, "ngwt:ItemStatus");
	case SOAP_TYPE_ngwt__Items:
		return ((ngwt__Items *)ptr)->soap_out(soap, tag, id, "ngwt:Items");
	case SOAP_TYPE_ngwt__ItemRefList:
		return ((ngwt__ItemRefList *)ptr)->soap_out(soap, tag, id, "ngwt:ItemRefList");
	case SOAP_TYPE_ngwt__ItemRef:
		return ((ngwt__ItemRef *)ptr)->soap_out(soap, tag, id, "ngwt:ItemRef");
	case SOAP_TYPE_ngwt__ItemOptions:
		return ((ngwt__ItemOptions *)ptr)->soap_out(soap, tag, id, "ngwt:ItemOptions");
	case SOAP_TYPE_ngwt__ItemList:
		return ((ngwt__ItemList *)ptr)->soap_out(soap, tag, id, "ngwt:ItemList");
	case SOAP_TYPE_ngwt__ItemChanges:
		return ((ngwt__ItemChanges *)ptr)->soap_out(soap, tag, id, "ngwt:ItemChanges");
	case SOAP_TYPE_ngwt__Item:
		return ((ngwt__Item *)ptr)->soap_out(soap, tag, id, "ngwt:Item");
	case SOAP_TYPE_ngwt__ImAddressList:
		return ((ngwt__ImAddressList *)ptr)->soap_out(soap, tag, id, "ngwt:ImAddressList");
	case SOAP_TYPE_ngwt__ImAddress:
		return ((ngwt__ImAddress *)ptr)->soap_out(soap, tag, id, "ngwt:ImAddress");
	case SOAP_TYPE_ngwt__Host:
		return ((ngwt__Host *)ptr)->soap_out(soap, tag, id, "ngwt:Host");
	case SOAP_TYPE_ngwt__GroupMemberList:
		return ((ngwt__GroupMemberList *)ptr)->soap_out(soap, tag, id, "ngwt:GroupMemberList");
	case SOAP_TYPE_ngwt__GroupMember:
		return ((ngwt__GroupMember *)ptr)->soap_out(soap, tag, id, "ngwt:GroupMember");
	case SOAP_TYPE_ngwt__Group:
		return ((ngwt__Group *)ptr)->soap_out(soap, tag, id, "ngwt:Group");
	case SOAP_TYPE_ngwt__FullName:
		return ((ngwt__FullName *)ptr)->soap_out(soap, tag, id, "ngwt:FullName");
	case SOAP_TYPE_ngwt__From:
		return ((ngwt__From *)ptr)->soap_out(soap, tag, id, "ngwt:From");
	case SOAP_TYPE_ngwt__FreeBusyStats:
		return ((ngwt__FreeBusyStats *)ptr)->soap_out(soap, tag, id, "ngwt:FreeBusyStats");
	case SOAP_TYPE_ngwt__FreeBusyInfoList:
		return ((ngwt__FreeBusyInfoList *)ptr)->soap_out(soap, tag, id, "ngwt:FreeBusyInfoList");
	case SOAP_TYPE_ngwt__FreeBusyUserList:
		return ((ngwt__FreeBusyUserList *)ptr)->soap_out(soap, tag, id, "ngwt:FreeBusyUserList");
	case SOAP_TYPE_ngwt__FreeBusyInfo:
		return ((ngwt__FreeBusyInfo *)ptr)->soap_out(soap, tag, id, "ngwt:FreeBusyInfo");
	case SOAP_TYPE_ngwt__FreeBusyBlock:
		return ((ngwt__FreeBusyBlock *)ptr)->soap_out(soap, tag, id, "ngwt:FreeBusyBlock");
	case SOAP_TYPE_ngwt__FreeBusyBlockList:
		return ((ngwt__FreeBusyBlockList *)ptr)->soap_out(soap, tag, id, "ngwt:FreeBusyBlockList");
	case SOAP_TYPE_ngwt__FolderList:
		return ((ngwt__FolderList *)ptr)->soap_out(soap, tag, id, "ngwt:FolderList");
	case SOAP_TYPE_ngwt__FolderACLEntry:
		return ((ngwt__FolderACLEntry *)ptr)->soap_out(soap, tag, id, "ngwt:FolderACLEntry");
	case SOAP_TYPE_ngwt__FolderACL:
		return ((ngwt__FolderACL *)ptr)->soap_out(soap, tag, id, "ngwt:FolderACL");
	case SOAP_TYPE_ngwt__Folder:
		return ((ngwt__Folder *)ptr)->soap_out(soap, tag, id, "ngwt:Folder");
	case SOAP_TYPE_ngwt__FilterGroup:
		return ((ngwt__FilterGroup *)ptr)->soap_out(soap, tag, id, "ngwt:FilterGroup");
	case SOAP_TYPE_ngwt__FilterEntry:
		return ((ngwt__FilterEntry *)ptr)->soap_out(soap, tag, id, "ngwt:FilterEntry");
	case SOAP_TYPE_ngwt__FilterElement:
		return ((ngwt__FilterElement *)ptr)->soap_out(soap, tag, id, "ngwt:FilterElement");
	case SOAP_TYPE_ngwt__Filter:
		return ((ngwt__Filter *)ptr)->soap_out(soap, tag, id, "ngwt:Filter");
	case SOAP_TYPE_ngwt__EmailAddressList:
		return ((ngwt__EmailAddressList *)ptr)->soap_out(soap, tag, id, "ngwt:EmailAddressList");
	case SOAP_TYPE_ngwt__DocumentTypeList:
		return ((ngwt__DocumentTypeList *)ptr)->soap_out(soap, tag, id, "ngwt:DocumentTypeList");
	case SOAP_TYPE_ngwt__DocumentType:
		return ((ngwt__DocumentType *)ptr)->soap_out(soap, tag, id, "ngwt:DocumentType");
	case SOAP_TYPE_ngwt__DocumentRef:
		return ((ngwt__DocumentRef *)ptr)->soap_out(soap, tag, id, "ngwt:DocumentRef");
	case SOAP_TYPE_ngwt__Document:
		return ((ngwt__Document *)ptr)->soap_out(soap, tag, id, "ngwt:Document");
	case SOAP_TYPE_ngwt__Distribution:
		return ((ngwt__Distribution *)ptr)->soap_out(soap, tag, id, "ngwt:Distribution");
	case SOAP_TYPE_ngwt__DeltaInfo:
		return ((ngwt__DeltaInfo *)ptr)->soap_out(soap, tag, id, "ngwt:DeltaInfo");
	case SOAP_TYPE_ngwt__DelegateeStatus:
		return ((ngwt__DelegateeStatus *)ptr)->soap_out(soap, tag, id, "ngwt:DelegateeStatus");
	case SOAP_TYPE_ngwt__DelegatedStatus:
		return ((ngwt__DelegatedStatus *)ptr)->soap_out(soap, tag, id, "ngwt:DelegatedStatus");
	case SOAP_TYPE_ngwt__DayOfYearWeekList:
		return ((ngwt__DayOfYearWeekList *)ptr)->soap_out(soap, tag, id, "ngwt:DayOfYearWeekList");
	case SOAP_TYPE_ngwt__DayOfYearWeek:
		return ((ngwt__DayOfYearWeek *)ptr)->soap_out(soap, tag, id, "ngwt:DayOfYearWeek");
	case SOAP_TYPE_ngwt__DayOfYearList:
		return ((ngwt__DayOfYearList *)ptr)->soap_out(soap, tag, id, "ngwt:DayOfYearList");
	case SOAP_TYPE_ngwt__DayOfWeek:
		return ((ngwt__DayOfWeek *)ptr)->soap_out(soap, tag, id, "ngwt:DayOfWeek");
	case SOAP_TYPE_ngwt__DayOfMonthList:
		return ((ngwt__DayOfMonthList *)ptr)->soap_out(soap, tag, id, "ngwt:DayOfMonthList");
	case SOAP_TYPE_ngwt__CustomList:
		return ((ngwt__CustomList *)ptr)->soap_out(soap, tag, id, "ngwt:CustomList");
	case SOAP_TYPE_ngwt__Custom:
		return ((ngwt__Custom *)ptr)->soap_out(soap, tag, id, "ngwt:Custom");
	case SOAP_TYPE_ngwt__ContainerRef:
		return ((ngwt__ContainerRef *)ptr)->soap_out(soap, tag, id, "ngwt:ContainerRef");
	case SOAP_TYPE_ngwt__ContainerItem:
		return ((ngwt__ContainerItem *)ptr)->soap_out(soap, tag, id, "ngwt:ContainerItem");
	case SOAP_TYPE_ngwt__ContactFolder:
		return ((ngwt__ContactFolder *)ptr)->soap_out(soap, tag, id, "ngwt:ContactFolder");
	case SOAP_TYPE_ngwt__Contact:
		return ((ngwt__Contact *)ptr)->soap_out(soap, tag, id, "ngwt:Contact");
	case SOAP_TYPE_ngwt__CommentStatus:
		return ((ngwt__CommentStatus *)ptr)->soap_out(soap, tag, id, "ngwt:CommentStatus");
	case SOAP_TYPE_ngwt__CategoryRefList:
		return ((ngwt__CategoryRefList *)ptr)->soap_out(soap, tag, id, "ngwt:CategoryRefList");
	case SOAP_TYPE_ngwt__CategoryList:
		return ((ngwt__CategoryList *)ptr)->soap_out(soap, tag, id, "ngwt:CategoryList");
	case SOAP_TYPE_ngwt__Category:
		return ((ngwt__Category *)ptr)->soap_out(soap, tag, id, "ngwt:Category");
	case SOAP_TYPE_ngwt__CalendarItem:
		return ((ngwt__CalendarItem *)ptr)->soap_out(soap, tag, id, "ngwt:CalendarItem");
	case SOAP_TYPE_ngwt__CalendarFolderAttribute:
		return ((ngwt__CalendarFolderAttribute *)ptr)->soap_out(soap, tag, id, "ngwt:CalendarFolderAttribute");
	case SOAP_TYPE_ngwt__BoxEntry:
		return ((ngwt__BoxEntry *)ptr)->soap_out(soap, tag, id, "ngwt:BoxEntry");
	case SOAP_TYPE_ngwt__Authentication:
		return ((ngwt__Authentication *)ptr)->soap_out(soap, tag, id, "ngwt:Authentication");
	case SOAP_TYPE_ngwt__AttachmentItemInfo:
		return ((ngwt__AttachmentItemInfo *)ptr)->soap_out(soap, tag, id, "ngwt:AttachmentItemInfo");
	case SOAP_TYPE_ngwt__AttachmentInfo:
		return ((ngwt__AttachmentInfo *)ptr)->soap_out(soap, tag, id, "ngwt:AttachmentInfo");
	case SOAP_TYPE_ngwt__AttachmentID:
		return ((ngwt__AttachmentID *)ptr)->soap_out(soap, tag, id, "ngwt:AttachmentID");
	case SOAP_TYPE_ngwt__Appointment:
		return ((ngwt__Appointment *)ptr)->soap_out(soap, tag, id, "ngwt:Appointment");
	case SOAP_TYPE_ngwt__Alarm:
		return ((ngwt__Alarm *)ptr)->soap_out(soap, tag, id, "ngwt:Alarm");
	case SOAP_TYPE_ngwt__AddressBookList:
		return ((ngwt__AddressBookList *)ptr)->soap_out(soap, tag, id, "ngwt:AddressBookList");
	case SOAP_TYPE_ngwt__AddressBookItem:
		return ((ngwt__AddressBookItem *)ptr)->soap_out(soap, tag, id, "ngwt:AddressBookItem");
	case SOAP_TYPE_ngwt__AddressBook:
		return ((ngwt__AddressBook *)ptr)->soap_out(soap, tag, id, "ngwt:AddressBook");
	case SOAP_TYPE_ngwt__AccessRightList:
		return ((ngwt__AccessRightList *)ptr)->soap_out(soap, tag, id, "ngwt:AccessRightList");
	case SOAP_TYPE_ngwt__AccessRightEntry:
		return ((ngwt__AccessRightEntry *)ptr)->soap_out(soap, tag, id, "ngwt:AccessRightEntry");
	case SOAP_TYPE_ngwt__AccessRightChanges:
		return ((ngwt__AccessRightChanges *)ptr)->soap_out(soap, tag, id, "ngwt:AccessRightChanges");
	case SOAP_TYPE_ngwt__AccessRight:
		return ((ngwt__AccessRight *)ptr)->soap_out(soap, tag, id, "ngwt:AccessRight");
	case SOAP_TYPE_ngwt__AccessMiscRight:
		return ((ngwt__AccessMiscRight *)ptr)->soap_out(soap, tag, id, "ngwt:AccessMiscRight");
	case SOAP_TYPE_ngwt__AccessControlList:
		return ((ngwt__AccessControlList *)ptr)->soap_out(soap, tag, id, "ngwt:AccessControlList");
	case SOAP_TYPE_ngwt__AccessControlListEntry:
		return ((ngwt__AccessControlListEntry *)ptr)->soap_out(soap, tag, id, "ngwt:AccessControlListEntry");
	case SOAP_TYPE_xsd__language:
		return soap_out_xsd__language(soap, tag, id, (const std::string *)ptr, "xsd:language");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const std::string *)ptr, "xsd:duration");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_out_xsd__date(soap, tag, id, (const std::string *)ptr, "xsd:date");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ngwe__removeEventsResponse:
		return soap_out_PointerTo_ngwe__removeEventsResponse(soap, tag, id, (_ngwe__removeEventsResponse *const*)ptr, "ngwe:removeEventsResponse");
	case SOAP_TYPE_PointerTo_ngwe__removeEventsRequest:
		return soap_out_PointerTo_ngwe__removeEventsRequest(soap, tag, id, (_ngwe__removeEventsRequest *const*)ptr, "ngwe:removeEventsRequest");
	case SOAP_TYPE_PointerTo_ngwe__removeEventConfigurationResponse:
		return soap_out_PointerTo_ngwe__removeEventConfigurationResponse(soap, tag, id, (_ngwe__removeEventConfigurationResponse *const*)ptr, "ngwe:removeEventConfigurationResponse");
	case SOAP_TYPE_PointerTo_ngwe__removeEventConfigurationRequest:
		return soap_out_PointerTo_ngwe__removeEventConfigurationRequest(soap, tag, id, (_ngwe__removeEventConfigurationRequest *const*)ptr, "ngwe:removeEventConfigurationRequest");
	case SOAP_TYPE_PointerTo_ngwe__getEventsResponse:
		return soap_out_PointerTo_ngwe__getEventsResponse(soap, tag, id, (_ngwe__getEventsResponse *const*)ptr, "ngwe:getEventsResponse");
	case SOAP_TYPE_PointerTo_ngwe__getEventsRequest:
		return soap_out_PointerTo_ngwe__getEventsRequest(soap, tag, id, (_ngwe__getEventsRequest *const*)ptr, "ngwe:getEventsRequest");
	case SOAP_TYPE_PointerTo_ngwe__getEventConfigurationResponse:
		return soap_out_PointerTo_ngwe__getEventConfigurationResponse(soap, tag, id, (_ngwe__getEventConfigurationResponse *const*)ptr, "ngwe:getEventConfigurationResponse");
	case SOAP_TYPE_PointerTo_ngwe__getEventConfigurationRequest:
		return soap_out_PointerTo_ngwe__getEventConfigurationRequest(soap, tag, id, (_ngwe__getEventConfigurationRequest *const*)ptr, "ngwe:getEventConfigurationRequest");
	case SOAP_TYPE_PointerTo_ngwe__configureEventsResponse:
		return soap_out_PointerTo_ngwe__configureEventsResponse(soap, tag, id, (_ngwe__configureEventsResponse *const*)ptr, "ngwe:configureEventsResponse");
	case SOAP_TYPE_PointerTo_ngwe__configureEventsRequest:
		return soap_out_PointerTo_ngwe__configureEventsRequest(soap, tag, id, (_ngwe__configureEventsRequest *const*)ptr, "ngwe:configureEventsRequest");
	case SOAP_TYPE_PointerTo_ngwe__cleanEventConfigurationResponse:
		return soap_out_PointerTo_ngwe__cleanEventConfigurationResponse(soap, tag, id, (_ngwe__cleanEventConfigurationResponse *const*)ptr, "ngwe:cleanEventConfigurationResponse");
	case SOAP_TYPE_PointerTo_ngwe__cleanEventConfigurationRequest:
		return soap_out_PointerTo_ngwe__cleanEventConfigurationRequest(soap, tag, id, (_ngwe__cleanEventConfigurationRequest *const*)ptr, "ngwe:cleanEventConfigurationRequest");
	case SOAP_TYPE_PointerTo_ngwm__updateVersionStatusResponse:
		return soap_out_PointerTo_ngwm__updateVersionStatusResponse(soap, tag, id, (_ngwm__updateVersionStatusResponse *const*)ptr, "ngwm:updateVersionStatusResponse");
	case SOAP_TYPE_PointerTo_ngwm__updateVersionStatusRequest:
		return soap_out_PointerTo_ngwm__updateVersionStatusRequest(soap, tag, id, (_ngwm__updateVersionStatusRequest *const*)ptr, "ngwm:updateVersionStatusRequest");
	case SOAP_TYPE_PointerTo_ngwm__uncompleteResponse:
		return soap_out_PointerTo_ngwm__uncompleteResponse(soap, tag, id, (_ngwm__uncompleteResponse *const*)ptr, "ngwm:uncompleteResponse");
	case SOAP_TYPE_PointerTo_ngwm__uncompleteRequest:
		return soap_out_PointerTo_ngwm__uncompleteRequest(soap, tag, id, (_ngwm__uncompleteRequest *const*)ptr, "ngwm:uncompleteRequest");
	case SOAP_TYPE_PointerTo_ngwm__unacceptResponse:
		return soap_out_PointerTo_ngwm__unacceptResponse(soap, tag, id, (_ngwm__unacceptResponse *const*)ptr, "ngwm:unacceptResponse");
	case SOAP_TYPE_PointerTo_ngwm__unacceptRequest:
		return soap_out_PointerTo_ngwm__unacceptRequest(soap, tag, id, (_ngwm__unacceptRequest *const*)ptr, "ngwm:unacceptRequest");
	case SOAP_TYPE_PointerTo_ngwm__startFreeBusySessionResponse:
		return soap_out_PointerTo_ngwm__startFreeBusySessionResponse(soap, tag, id, (_ngwm__startFreeBusySessionResponse *const*)ptr, "ngwm:startFreeBusySessionResponse");
	case SOAP_TYPE_PointerTo_ngwm__startFreeBusySessionRequest:
		return soap_out_PointerTo_ngwm__startFreeBusySessionRequest(soap, tag, id, (_ngwm__startFreeBusySessionRequest *const*)ptr, "ngwm:startFreeBusySessionRequest");
	case SOAP_TYPE_PointerTo_ngwm__setTimestampResponse:
		return soap_out_PointerTo_ngwm__setTimestampResponse(soap, tag, id, (_ngwm__setTimestampResponse *const*)ptr, "ngwm:setTimestampResponse");
	case SOAP_TYPE_PointerTo_ngwm__setTimestampRequest:
		return soap_out_PointerTo_ngwm__setTimestampRequest(soap, tag, id, (_ngwm__setTimestampRequest *const*)ptr, "ngwm:setTimestampRequest");
	case SOAP_TYPE_PointerTo_ngwm__sendItemResponse:
		return soap_out_PointerTo_ngwm__sendItemResponse(soap, tag, id, (_ngwm__sendItemResponse *const*)ptr, "ngwm:sendItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__sendItemRequest:
		return soap_out_PointerTo_ngwm__sendItemRequest(soap, tag, id, (_ngwm__sendItemRequest *const*)ptr, "ngwm:sendItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__retractResponse:
		return soap_out_PointerTo_ngwm__retractResponse(soap, tag, id, (_ngwm__retractResponse *const*)ptr, "ngwm:retractResponse");
	case SOAP_TYPE_PointerTo_ngwm__retractRequest:
		return soap_out_PointerTo_ngwm__retractRequest(soap, tag, id, (_ngwm__retractRequest *const*)ptr, "ngwm:retractRequest");
	case SOAP_TYPE_PointerTo_ngwm__replyResponse:
		return soap_out_PointerTo_ngwm__replyResponse(soap, tag, id, (_ngwm__replyResponse *const*)ptr, "ngwm:replyResponse");
	case SOAP_TYPE_PointerTo_ngwm__replyRequest:
		return soap_out_PointerTo_ngwm__replyRequest(soap, tag, id, (_ngwm__replyRequest *const*)ptr, "ngwm:replyRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeSignatureResponse:
		return soap_out_PointerTo_ngwm__removeSignatureResponse(soap, tag, id, (_ngwm__removeSignatureResponse *const*)ptr, "ngwm:removeSignatureResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeSignatureRequest:
		return soap_out_PointerTo_ngwm__removeSignatureRequest(soap, tag, id, (_ngwm__removeSignatureRequest *const*)ptr, "ngwm:removeSignatureRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeProxyUserResponse:
		return soap_out_PointerTo_ngwm__removeProxyUserResponse(soap, tag, id, (_ngwm__removeProxyUserResponse *const*)ptr, "ngwm:removeProxyUserResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeProxyUserRequest:
		return soap_out_PointerTo_ngwm__removeProxyUserRequest(soap, tag, id, (_ngwm__removeProxyUserRequest *const*)ptr, "ngwm:removeProxyUserRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeProxyAccessResponse:
		return soap_out_PointerTo_ngwm__removeProxyAccessResponse(soap, tag, id, (_ngwm__removeProxyAccessResponse *const*)ptr, "ngwm:removeProxyAccessResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeProxyAccessRequest:
		return soap_out_PointerTo_ngwm__removeProxyAccessRequest(soap, tag, id, (_ngwm__removeProxyAccessRequest *const*)ptr, "ngwm:removeProxyAccessRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeMembersResponse:
		return soap_out_PointerTo_ngwm__removeMembersResponse(soap, tag, id, (_ngwm__removeMembersResponse *const*)ptr, "ngwm:removeMembersResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeMembersRequest:
		return soap_out_PointerTo_ngwm__removeMembersRequest(soap, tag, id, (_ngwm__removeMembersRequest *const*)ptr, "ngwm:removeMembersRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeJunkEntryResponse:
		return soap_out_PointerTo_ngwm__removeJunkEntryResponse(soap, tag, id, (_ngwm__removeJunkEntryResponse *const*)ptr, "ngwm:removeJunkEntryResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeJunkEntryRequest:
		return soap_out_PointerTo_ngwm__removeJunkEntryRequest(soap, tag, id, (_ngwm__removeJunkEntryRequest *const*)ptr, "ngwm:removeJunkEntryRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeItemsResponse:
		return soap_out_PointerTo_ngwm__removeItemsResponse(soap, tag, id, (_ngwm__removeItemsResponse *const*)ptr, "ngwm:removeItemsResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeItemsRequest:
		return soap_out_PointerTo_ngwm__removeItemsRequest(soap, tag, id, (_ngwm__removeItemsRequest *const*)ptr, "ngwm:removeItemsRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeItemResponse:
		return soap_out_PointerTo_ngwm__removeItemResponse(soap, tag, id, (_ngwm__removeItemResponse *const*)ptr, "ngwm:removeItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeItemRequest:
		return soap_out_PointerTo_ngwm__removeItemRequest(soap, tag, id, (_ngwm__removeItemRequest *const*)ptr, "ngwm:removeItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__removeCustomDefinitionResponse:
		return soap_out_PointerTo_ngwm__removeCustomDefinitionResponse(soap, tag, id, (_ngwm__removeCustomDefinitionResponse *const*)ptr, "ngwm:removeCustomDefinitionResponse");
	case SOAP_TYPE_PointerTo_ngwm__removeCustomDefinitionRequest:
		return soap_out_PointerTo_ngwm__removeCustomDefinitionRequest(soap, tag, id, (_ngwm__removeCustomDefinitionRequest *const*)ptr, "ngwm:removeCustomDefinitionRequest");
	case SOAP_TYPE_PointerTo_ngwm__readCursorResponse:
		return soap_out_PointerTo_ngwm__readCursorResponse(soap, tag, id, (_ngwm__readCursorResponse *const*)ptr, "ngwm:readCursorResponse");
	case SOAP_TYPE_PointerTo_ngwm__readCursorRequest:
		return soap_out_PointerTo_ngwm__readCursorRequest(soap, tag, id, (_ngwm__readCursorRequest *const*)ptr, "ngwm:readCursorRequest");
	case SOAP_TYPE_PointerTo_ngwm__purgeResponse:
		return soap_out_PointerTo_ngwm__purgeResponse(soap, tag, id, (_ngwm__purgeResponse *const*)ptr, "ngwm:purgeResponse");
	case SOAP_TYPE_PointerTo_ngwm__purgeRequest:
		return soap_out_PointerTo_ngwm__purgeRequest(soap, tag, id, (_ngwm__purgeRequest *const*)ptr, "ngwm:purgeRequest");
	case SOAP_TYPE_PointerTo_ngwm__purgeDeletedItemsResponse:
		return soap_out_PointerTo_ngwm__purgeDeletedItemsResponse(soap, tag, id, (_ngwm__purgeDeletedItemsResponse *const*)ptr, "ngwm:purgeDeletedItemsResponse");
	case SOAP_TYPE_PointerTo_ngwm__purgeDeletedItemsRequest:
		return soap_out_PointerTo_ngwm__purgeDeletedItemsRequest(soap, tag, id, (_ngwm__purgeDeletedItemsRequest *const*)ptr, "ngwm:purgeDeletedItemsRequest");
	case SOAP_TYPE_PointerTo_ngwm__positionCursorResponse:
		return soap_out_PointerTo_ngwm__positionCursorResponse(soap, tag, id, (_ngwm__positionCursorResponse *const*)ptr, "ngwm:positionCursorResponse");
	case SOAP_TYPE_PointerTo_ngwm__positionCursorRequest:
		return soap_out_PointerTo_ngwm__positionCursorRequest(soap, tag, id, (_ngwm__positionCursorRequest *const*)ptr, "ngwm:positionCursorRequest");
	case SOAP_TYPE_PointerTo_ngwm__moveItemResponse:
		return soap_out_PointerTo_ngwm__moveItemResponse(soap, tag, id, (_ngwm__moveItemResponse *const*)ptr, "ngwm:moveItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__moveItemRequest:
		return soap_out_PointerTo_ngwm__moveItemRequest(soap, tag, id, (_ngwm__moveItemRequest *const*)ptr, "ngwm:moveItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifySignaturesResponse:
		return soap_out_PointerTo_ngwm__modifySignaturesResponse(soap, tag, id, (_ngwm__modifySignaturesResponse *const*)ptr, "ngwm:modifySignaturesResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifySignaturesRequest:
		return soap_out_PointerTo_ngwm__modifySignaturesRequest(soap, tag, id, (_ngwm__modifySignaturesRequest *const*)ptr, "ngwm:modifySignaturesRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifySettingsResponse:
		return soap_out_PointerTo_ngwm__modifySettingsResponse(soap, tag, id, (_ngwm__modifySettingsResponse *const*)ptr, "ngwm:modifySettingsResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifySettingsRequest:
		return soap_out_PointerTo_ngwm__modifySettingsRequest(soap, tag, id, (_ngwm__modifySettingsRequest *const*)ptr, "ngwm:modifySettingsRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifyProxyAccessResponse:
		return soap_out_PointerTo_ngwm__modifyProxyAccessResponse(soap, tag, id, (_ngwm__modifyProxyAccessResponse *const*)ptr, "ngwm:modifyProxyAccessResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifyProxyAccessRequest:
		return soap_out_PointerTo_ngwm__modifyProxyAccessRequest(soap, tag, id, (_ngwm__modifyProxyAccessRequest *const*)ptr, "ngwm:modifyProxyAccessRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifyPasswordResponse:
		return soap_out_PointerTo_ngwm__modifyPasswordResponse(soap, tag, id, (_ngwm__modifyPasswordResponse *const*)ptr, "ngwm:modifyPasswordResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifyPasswordRequest:
		return soap_out_PointerTo_ngwm__modifyPasswordRequest(soap, tag, id, (_ngwm__modifyPasswordRequest *const*)ptr, "ngwm:modifyPasswordRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkMailSettingsResponse:
		return soap_out_PointerTo_ngwm__modifyJunkMailSettingsResponse(soap, tag, id, (_ngwm__modifyJunkMailSettingsResponse *const*)ptr, "ngwm:modifyJunkMailSettingsResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkMailSettingsRequest:
		return soap_out_PointerTo_ngwm__modifyJunkMailSettingsRequest(soap, tag, id, (_ngwm__modifyJunkMailSettingsRequest *const*)ptr, "ngwm:modifyJunkMailSettingsRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkEntryResponse:
		return soap_out_PointerTo_ngwm__modifyJunkEntryResponse(soap, tag, id, (_ngwm__modifyJunkEntryResponse *const*)ptr, "ngwm:modifyJunkEntryResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkEntryRequest:
		return soap_out_PointerTo_ngwm__modifyJunkEntryRequest(soap, tag, id, (_ngwm__modifyJunkEntryRequest *const*)ptr, "ngwm:modifyJunkEntryRequest");
	case SOAP_TYPE_PointerTo_ngwm__modifyItemResponse:
		return soap_out_PointerTo_ngwm__modifyItemResponse(soap, tag, id, (_ngwm__modifyItemResponse *const*)ptr, "ngwm:modifyItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__modifyItemRequest:
		return soap_out_PointerTo_ngwm__modifyItemRequest(soap, tag, id, (_ngwm__modifyItemRequest *const*)ptr, "ngwm:modifyItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__markUnReadResponse:
		return soap_out_PointerTo_ngwm__markUnReadResponse(soap, tag, id, (_ngwm__markUnReadResponse *const*)ptr, "ngwm:markUnReadResponse");
	case SOAP_TYPE_PointerTo_ngwm__markUnReadRequest:
		return soap_out_PointerTo_ngwm__markUnReadRequest(soap, tag, id, (_ngwm__markUnReadRequest *const*)ptr, "ngwm:markUnReadRequest");
	case SOAP_TYPE_PointerTo_ngwm__markUnPrivateResponse:
		return soap_out_PointerTo_ngwm__markUnPrivateResponse(soap, tag, id, (_ngwm__markUnPrivateResponse *const*)ptr, "ngwm:markUnPrivateResponse");
	case SOAP_TYPE_PointerTo_ngwm__markUnPrivateRequest:
		return soap_out_PointerTo_ngwm__markUnPrivateRequest(soap, tag, id, (_ngwm__markUnPrivateRequest *const*)ptr, "ngwm:markUnPrivateRequest");
	case SOAP_TYPE_PointerTo_ngwm__markReadResponse:
		return soap_out_PointerTo_ngwm__markReadResponse(soap, tag, id, (_ngwm__markReadResponse *const*)ptr, "ngwm:markReadResponse");
	case SOAP_TYPE_PointerTo_ngwm__markReadRequest:
		return soap_out_PointerTo_ngwm__markReadRequest(soap, tag, id, (_ngwm__markReadRequest *const*)ptr, "ngwm:markReadRequest");
	case SOAP_TYPE_PointerTo_ngwm__markPrivateResponse:
		return soap_out_PointerTo_ngwm__markPrivateResponse(soap, tag, id, (_ngwm__markPrivateResponse *const*)ptr, "ngwm:markPrivateResponse");
	case SOAP_TYPE_PointerTo_ngwm__markPrivateRequest:
		return soap_out_PointerTo_ngwm__markPrivateRequest(soap, tag, id, (_ngwm__markPrivateRequest *const*)ptr, "ngwm:markPrivateRequest");
	case SOAP_TYPE_PointerTo_ngwm__logoutResponse:
		return soap_out_PointerTo_ngwm__logoutResponse(soap, tag, id, (_ngwm__logoutResponse *const*)ptr, "ngwm:logoutResponse");
	case SOAP_TYPE_PointerTo_ngwm__logoutRequest:
		return soap_out_PointerTo_ngwm__logoutRequest(soap, tag, id, (_ngwm__logoutRequest *const*)ptr, "ngwm:logoutRequest");
	case SOAP_TYPE_PointerTo_ngwm__loginResponse:
		return soap_out_PointerTo_ngwm__loginResponse(soap, tag, id, (_ngwm__loginResponse *const*)ptr, "ngwm:loginResponse");
	case SOAP_TYPE_PointerTo_ngwm__loginRequest:
		return soap_out_PointerTo_ngwm__loginRequest(soap, tag, id, (_ngwm__loginRequest *const*)ptr, "ngwm:loginRequest");
	case SOAP_TYPE_PointerTo_ngwm__getUserListResponse:
		return soap_out_PointerTo_ngwm__getUserListResponse(soap, tag, id, (_ngwm__getUserListResponse *const*)ptr, "ngwm:getUserListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getUserListRequest:
		return soap_out_PointerTo_ngwm__getUserListRequest(soap, tag, id, (_ngwm__getUserListRequest *const*)ptr, "ngwm:getUserListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getTimezoneListResponse:
		return soap_out_PointerTo_ngwm__getTimezoneListResponse(soap, tag, id, (_ngwm__getTimezoneListResponse *const*)ptr, "ngwm:getTimezoneListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getTimezoneListRequest:
		return soap_out_PointerTo_ngwm__getTimezoneListRequest(soap, tag, id, (_ngwm__getTimezoneListRequest *const*)ptr, "ngwm:getTimezoneListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getTimestampResponse:
		return soap_out_PointerTo_ngwm__getTimestampResponse(soap, tag, id, (_ngwm__getTimestampResponse *const*)ptr, "ngwm:getTimestampResponse");
	case SOAP_TYPE_PointerTo_ngwm__getTimestampRequest:
		return soap_out_PointerTo_ngwm__getTimestampRequest(soap, tag, id, (_ngwm__getTimestampRequest *const*)ptr, "ngwm:getTimestampRequest");
	case SOAP_TYPE_PointerTo_ngwm__getSignaturesResponse:
		return soap_out_PointerTo_ngwm__getSignaturesResponse(soap, tag, id, (_ngwm__getSignaturesResponse *const*)ptr, "ngwm:getSignaturesResponse");
	case SOAP_TYPE_PointerTo_ngwm__getSignaturesRequest:
		return soap_out_PointerTo_ngwm__getSignaturesRequest(soap, tag, id, (_ngwm__getSignaturesRequest *const*)ptr, "ngwm:getSignaturesRequest");
	case SOAP_TYPE_PointerTo_ngwm__getSettingsResponse:
		return soap_out_PointerTo_ngwm__getSettingsResponse(soap, tag, id, (_ngwm__getSettingsResponse *const*)ptr, "ngwm:getSettingsResponse");
	case SOAP_TYPE_PointerTo_ngwm__getSettingsRequest:
		return soap_out_PointerTo_ngwm__getSettingsRequest(soap, tag, id, (_ngwm__getSettingsRequest *const*)ptr, "ngwm:getSettingsRequest");
	case SOAP_TYPE_PointerTo_ngwm__getRuleListResponse:
		return soap_out_PointerTo_ngwm__getRuleListResponse(soap, tag, id, (_ngwm__getRuleListResponse *const*)ptr, "ngwm:getRuleListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getRuleListRequest:
		return soap_out_PointerTo_ngwm__getRuleListRequest(soap, tag, id, (_ngwm__getRuleListRequest *const*)ptr, "ngwm:getRuleListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getProxyListResponse:
		return soap_out_PointerTo_ngwm__getProxyListResponse(soap, tag, id, (_ngwm__getProxyListResponse *const*)ptr, "ngwm:getProxyListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getProxyListRequest:
		return soap_out_PointerTo_ngwm__getProxyListRequest(soap, tag, id, (_ngwm__getProxyListRequest *const*)ptr, "ngwm:getProxyListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getProxyAccessListResponse:
		return soap_out_PointerTo_ngwm__getProxyAccessListResponse(soap, tag, id, (_ngwm__getProxyAccessListResponse *const*)ptr, "ngwm:getProxyAccessListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getProxyAccessListRequest:
		return soap_out_PointerTo_ngwm__getProxyAccessListRequest(soap, tag, id, (_ngwm__getProxyAccessListRequest *const*)ptr, "ngwm:getProxyAccessListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getQuickMessagesResponse:
		return soap_out_PointerTo_ngwm__getQuickMessagesResponse(soap, tag, id, (_ngwm__getQuickMessagesResponse *const*)ptr, "ngwm:getQuickMessagesResponse");
	case SOAP_TYPE_PointerTo_ngwm__getQuickMessagesRequest:
		return soap_out_PointerTo_ngwm__getQuickMessagesRequest(soap, tag, id, (_ngwm__getQuickMessagesRequest *const*)ptr, "ngwm:getQuickMessagesRequest");
	case SOAP_TYPE_PointerTo_ngwm__getLibraryListResponse:
		return soap_out_PointerTo_ngwm__getLibraryListResponse(soap, tag, id, (_ngwm__getLibraryListResponse *const*)ptr, "ngwm:getLibraryListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getLibraryListRequest:
		return soap_out_PointerTo_ngwm__getLibraryListRequest(soap, tag, id, (_ngwm__getLibraryListRequest *const*)ptr, "ngwm:getLibraryListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getLibraryItemResponse:
		return soap_out_PointerTo_ngwm__getLibraryItemResponse(soap, tag, id, (_ngwm__getLibraryItemResponse *const*)ptr, "ngwm:getLibraryItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__getLibraryItemRequest:
		return soap_out_PointerTo_ngwm__getLibraryItemRequest(soap, tag, id, (_ngwm__getLibraryItemRequest *const*)ptr, "ngwm:getLibraryItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__getJunkMailSettingsResponse:
		return soap_out_PointerTo_ngwm__getJunkMailSettingsResponse(soap, tag, id, (_ngwm__getJunkMailSettingsResponse *const*)ptr, "ngwm:getJunkMailSettingsResponse");
	case SOAP_TYPE_PointerTo_ngwm__getJunkMailSettingsRequest:
		return soap_out_PointerTo_ngwm__getJunkMailSettingsRequest(soap, tag, id, (_ngwm__getJunkMailSettingsRequest *const*)ptr, "ngwm:getJunkMailSettingsRequest");
	case SOAP_TYPE_PointerTo_ngwm__getJunkEntriesResponse:
		return soap_out_PointerTo_ngwm__getJunkEntriesResponse(soap, tag, id, (_ngwm__getJunkEntriesResponse *const*)ptr, "ngwm:getJunkEntriesResponse");
	case SOAP_TYPE_PointerTo_ngwm__getJunkEntriesRequest:
		return soap_out_PointerTo_ngwm__getJunkEntriesRequest(soap, tag, id, (_ngwm__getJunkEntriesRequest *const*)ptr, "ngwm:getJunkEntriesRequest");
	case SOAP_TYPE_PointerTo_ngwm__getItemsResponse:
		return soap_out_PointerTo_ngwm__getItemsResponse(soap, tag, id, (_ngwm__getItemsResponse *const*)ptr, "ngwm:getItemsResponse");
	case SOAP_TYPE_PointerTo_ngwm__getItemsRequest:
		return soap_out_PointerTo_ngwm__getItemsRequest(soap, tag, id, (_ngwm__getItemsRequest *const*)ptr, "ngwm:getItemsRequest");
	case SOAP_TYPE_PointerTo_ngwm__getItemResponse:
		return soap_out_PointerTo_ngwm__getItemResponse(soap, tag, id, (_ngwm__getItemResponse *const*)ptr, "ngwm:getItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__getItemRequest:
		return soap_out_PointerTo_ngwm__getItemRequest(soap, tag, id, (_ngwm__getItemRequest *const*)ptr, "ngwm:getItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__getFreeBusyResponse:
		return soap_out_PointerTo_ngwm__getFreeBusyResponse(soap, tag, id, (_ngwm__getFreeBusyResponse *const*)ptr, "ngwm:getFreeBusyResponse");
	case SOAP_TYPE_PointerTo_ngwm__getFreeBusyRequest:
		return soap_out_PointerTo_ngwm__getFreeBusyRequest(soap, tag, id, (_ngwm__getFreeBusyRequest *const*)ptr, "ngwm:getFreeBusyRequest");
	case SOAP_TYPE_PointerTo_ngwm__getFolderListResponse:
		return soap_out_PointerTo_ngwm__getFolderListResponse(soap, tag, id, (_ngwm__getFolderListResponse *const*)ptr, "ngwm:getFolderListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getFolderListRequest:
		return soap_out_PointerTo_ngwm__getFolderListRequest(soap, tag, id, (_ngwm__getFolderListRequest *const*)ptr, "ngwm:getFolderListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getFolderResponse:
		return soap_out_PointerTo_ngwm__getFolderResponse(soap, tag, id, (_ngwm__getFolderResponse *const*)ptr, "ngwm:getFolderResponse");
	case SOAP_TYPE_PointerTo_ngwm__getFolderRequest:
		return soap_out_PointerTo_ngwm__getFolderRequest(soap, tag, id, (_ngwm__getFolderRequest *const*)ptr, "ngwm:getFolderRequest");
	case SOAP_TYPE_PointerTo_ngwm__getDocumentTypeListResponse:
		return soap_out_PointerTo_ngwm__getDocumentTypeListResponse(soap, tag, id, (_ngwm__getDocumentTypeListResponse *const*)ptr, "ngwm:getDocumentTypeListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getDocumentTypeListRequest:
		return soap_out_PointerTo_ngwm__getDocumentTypeListRequest(soap, tag, id, (_ngwm__getDocumentTypeListRequest *const*)ptr, "ngwm:getDocumentTypeListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getDeltaInfoResponse:
		return soap_out_PointerTo_ngwm__getDeltaInfoResponse(soap, tag, id, (_ngwm__getDeltaInfoResponse *const*)ptr, "ngwm:getDeltaInfoResponse");
	case SOAP_TYPE_PointerTo_ngwm__getDeltaInfoRequest:
		return soap_out_PointerTo_ngwm__getDeltaInfoRequest(soap, tag, id, (_ngwm__getDeltaInfoRequest *const*)ptr, "ngwm:getDeltaInfoRequest");
	case SOAP_TYPE_PointerTo_ngwm__getDeltasResponse:
		return soap_out_PointerTo_ngwm__getDeltasResponse(soap, tag, id, (_ngwm__getDeltasResponse *const*)ptr, "ngwm:getDeltasResponse");
	case SOAP_TYPE_PointerTo_ngwm__getDeltasRequest:
		return soap_out_PointerTo_ngwm__getDeltasRequest(soap, tag, id, (_ngwm__getDeltasRequest *const*)ptr, "ngwm:getDeltasRequest");
	case SOAP_TYPE_PointerTo_ngwm__getCustomListResponse:
		return soap_out_PointerTo_ngwm__getCustomListResponse(soap, tag, id, (_ngwm__getCustomListResponse *const*)ptr, "ngwm:getCustomListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getCustomListRequest:
		return soap_out_PointerTo_ngwm__getCustomListRequest(soap, tag, id, (_ngwm__getCustomListRequest *const*)ptr, "ngwm:getCustomListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getCategoryListResponse:
		return soap_out_PointerTo_ngwm__getCategoryListResponse(soap, tag, id, (_ngwm__getCategoryListResponse *const*)ptr, "ngwm:getCategoryListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getCategoryListRequest:
		return soap_out_PointerTo_ngwm__getCategoryListRequest(soap, tag, id, (_ngwm__getCategoryListRequest *const*)ptr, "ngwm:getCategoryListRequest");
	case SOAP_TYPE_PointerTo_ngwm__getAttachmentResponse:
		return soap_out_PointerTo_ngwm__getAttachmentResponse(soap, tag, id, (_ngwm__getAttachmentResponse *const*)ptr, "ngwm:getAttachmentResponse");
	case SOAP_TYPE_PointerTo_ngwm__getAttachmentRequest:
		return soap_out_PointerTo_ngwm__getAttachmentRequest(soap, tag, id, (_ngwm__getAttachmentRequest *const*)ptr, "ngwm:getAttachmentRequest");
	case SOAP_TYPE_PointerTo_ngwm__getAddressBookListResponse:
		return soap_out_PointerTo_ngwm__getAddressBookListResponse(soap, tag, id, (_ngwm__getAddressBookListResponse *const*)ptr, "ngwm:getAddressBookListResponse");
	case SOAP_TYPE_PointerTo_ngwm__getAddressBookListRequest:
		return soap_out_PointerTo_ngwm__getAddressBookListRequest(soap, tag, id, (_ngwm__getAddressBookListRequest *const*)ptr, "ngwm:getAddressBookListRequest");
	case SOAP_TYPE_PointerTo_ngwm__forwardResponse:
		return soap_out_PointerTo_ngwm__forwardResponse(soap, tag, id, (_ngwm__forwardResponse *const*)ptr, "ngwm:forwardResponse");
	case SOAP_TYPE_PointerTo_ngwm__forwardRequest:
		return soap_out_PointerTo_ngwm__forwardRequest(soap, tag, id, (_ngwm__forwardRequest *const*)ptr, "ngwm:forwardRequest");
	case SOAP_TYPE_PointerTo_ngwm__executeRuleResponse:
		return soap_out_PointerTo_ngwm__executeRuleResponse(soap, tag, id, (_ngwm__executeRuleResponse *const*)ptr, "ngwm:executeRuleResponse");
	case SOAP_TYPE_PointerTo_ngwm__executeRuleRequest:
		return soap_out_PointerTo_ngwm__executeRuleRequest(soap, tag, id, (_ngwm__executeRuleRequest *const*)ptr, "ngwm:executeRuleRequest");
	case SOAP_TYPE_PointerTo_ngwm__destroyCursorResponse:
		return soap_out_PointerTo_ngwm__destroyCursorResponse(soap, tag, id, (_ngwm__destroyCursorResponse *const*)ptr, "ngwm:destroyCursorResponse");
	case SOAP_TYPE_PointerTo_ngwm__destroyCursorRequest:
		return soap_out_PointerTo_ngwm__destroyCursorRequest(soap, tag, id, (_ngwm__destroyCursorRequest *const*)ptr, "ngwm:destroyCursorRequest");
	case SOAP_TYPE_PointerTo_ngwm__delegateResponse:
		return soap_out_PointerTo_ngwm__delegateResponse(soap, tag, id, (_ngwm__delegateResponse *const*)ptr, "ngwm:delegateResponse");
	case SOAP_TYPE_PointerTo_ngwm__delegateRequest:
		return soap_out_PointerTo_ngwm__delegateRequest(soap, tag, id, (_ngwm__delegateRequest *const*)ptr, "ngwm:delegateRequest");
	case SOAP_TYPE_PointerTo_ngwm__declineResponse:
		return soap_out_PointerTo_ngwm__declineResponse(soap, tag, id, (_ngwm__declineResponse *const*)ptr, "ngwm:declineResponse");
	case SOAP_TYPE_PointerTo_ngwm__declineRequest:
		return soap_out_PointerTo_ngwm__declineRequest(soap, tag, id, (_ngwm__declineRequest *const*)ptr, "ngwm:declineRequest");
	case SOAP_TYPE_PointerTo_ngwm__createSignatureResponse:
		return soap_out_PointerTo_ngwm__createSignatureResponse(soap, tag, id, (_ngwm__createSignatureResponse *const*)ptr, "ngwm:createSignatureResponse");
	case SOAP_TYPE_PointerTo_ngwm__createSignatureRequest:
		return soap_out_PointerTo_ngwm__createSignatureRequest(soap, tag, id, (_ngwm__createSignatureRequest *const*)ptr, "ngwm:createSignatureRequest");
	case SOAP_TYPE_PointerTo_ngwm__createProxyAccessResponse:
		return soap_out_PointerTo_ngwm__createProxyAccessResponse(soap, tag, id, (_ngwm__createProxyAccessResponse *const*)ptr, "ngwm:createProxyAccessResponse");
	case SOAP_TYPE_PointerTo_ngwm__createProxyAccessRequest:
		return soap_out_PointerTo_ngwm__createProxyAccessRequest(soap, tag, id, (_ngwm__createProxyAccessRequest *const*)ptr, "ngwm:createProxyAccessRequest");
	case SOAP_TYPE_PointerTo_ngwm__createJunkEntryResponse:
		return soap_out_PointerTo_ngwm__createJunkEntryResponse(soap, tag, id, (_ngwm__createJunkEntryResponse *const*)ptr, "ngwm:createJunkEntryResponse");
	case SOAP_TYPE_PointerTo_ngwm__createJunkEntryRequest:
		return soap_out_PointerTo_ngwm__createJunkEntryRequest(soap, tag, id, (_ngwm__createJunkEntryRequest *const*)ptr, "ngwm:createJunkEntryRequest");
	case SOAP_TYPE_PointerTo_ngwm__createItemsResponse:
		return soap_out_PointerTo_ngwm__createItemsResponse(soap, tag, id, (_ngwm__createItemsResponse *const*)ptr, "ngwm:createItemsResponse");
	case SOAP_TYPE_PointerTo_ngwm__createItemsRequest:
		return soap_out_PointerTo_ngwm__createItemsRequest(soap, tag, id, (_ngwm__createItemsRequest *const*)ptr, "ngwm:createItemsRequest");
	case SOAP_TYPE_PointerTo_ngwm__createItemResponse:
		return soap_out_PointerTo_ngwm__createItemResponse(soap, tag, id, (_ngwm__createItemResponse *const*)ptr, "ngwm:createItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__createItemRequest:
		return soap_out_PointerTo_ngwm__createItemRequest(soap, tag, id, (_ngwm__createItemRequest *const*)ptr, "ngwm:createItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__createCursorResponse:
		return soap_out_PointerTo_ngwm__createCursorResponse(soap, tag, id, (_ngwm__createCursorResponse *const*)ptr, "ngwm:createCursorResponse");
	case SOAP_TYPE_PointerTo_ngwm__createCursorRequest:
		return soap_out_PointerTo_ngwm__createCursorRequest(soap, tag, id, (_ngwm__createCursorRequest *const*)ptr, "ngwm:createCursorRequest");
	case SOAP_TYPE_PointerTo_ngwm__completeResponse:
		return soap_out_PointerTo_ngwm__completeResponse(soap, tag, id, (_ngwm__completeResponse *const*)ptr, "ngwm:completeResponse");
	case SOAP_TYPE_PointerTo_ngwm__completeRequest:
		return soap_out_PointerTo_ngwm__completeRequest(soap, tag, id, (_ngwm__completeRequest *const*)ptr, "ngwm:completeRequest");
	case SOAP_TYPE_PointerTo_ngwm__closeFreeBusySessionResponse:
		return soap_out_PointerTo_ngwm__closeFreeBusySessionResponse(soap, tag, id, (_ngwm__closeFreeBusySessionResponse *const*)ptr, "ngwm:closeFreeBusySessionResponse");
	case SOAP_TYPE_PointerTo_ngwm__closeFreeBusySessionRequest:
		return soap_out_PointerTo_ngwm__closeFreeBusySessionRequest(soap, tag, id, (_ngwm__closeFreeBusySessionRequest *const*)ptr, "ngwm:closeFreeBusySessionRequest");
	case SOAP_TYPE_PointerTo_ngwm__addMembersResponse:
		return soap_out_PointerTo_ngwm__addMembersResponse(soap, tag, id, (_ngwm__addMembersResponse *const*)ptr, "ngwm:addMembersResponse");
	case SOAP_TYPE_PointerTo_ngwm__addMembersRequest:
		return soap_out_PointerTo_ngwm__addMembersRequest(soap, tag, id, (_ngwm__addMembersRequest *const*)ptr, "ngwm:addMembersRequest");
	case SOAP_TYPE_PointerTo_ngwm__addItemsResponse:
		return soap_out_PointerTo_ngwm__addItemsResponse(soap, tag, id, (_ngwm__addItemsResponse *const*)ptr, "ngwm:addItemsResponse");
	case SOAP_TYPE_PointerTo_ngwm__addItemsRequest:
		return soap_out_PointerTo_ngwm__addItemsRequest(soap, tag, id, (_ngwm__addItemsRequest *const*)ptr, "ngwm:addItemsRequest");
	case SOAP_TYPE_PointerTo_ngwm__addItemResponse:
		return soap_out_PointerTo_ngwm__addItemResponse(soap, tag, id, (_ngwm__addItemResponse *const*)ptr, "ngwm:addItemResponse");
	case SOAP_TYPE_PointerTo_ngwm__addItemRequest:
		return soap_out_PointerTo_ngwm__addItemRequest(soap, tag, id, (_ngwm__addItemRequest *const*)ptr, "ngwm:addItemRequest");
	case SOAP_TYPE_PointerTo_ngwm__acceptShareResponse:
		return soap_out_PointerTo_ngwm__acceptShareResponse(soap, tag, id, (_ngwm__acceptShareResponse *const*)ptr, "ngwm:acceptShareResponse");
	case SOAP_TYPE_PointerTo_ngwm__acceptShareRequest:
		return soap_out_PointerTo_ngwm__acceptShareRequest(soap, tag, id, (_ngwm__acceptShareRequest *const*)ptr, "ngwm:acceptShareRequest");
	case SOAP_TYPE_PointerTo_ngwm__acceptResponse:
		return soap_out_PointerTo_ngwm__acceptResponse(soap, tag, id, (_ngwm__acceptResponse *const*)ptr, "ngwm:acceptResponse");
	case SOAP_TYPE_PointerTo_ngwm__acceptRequest:
		return soap_out_PointerTo_ngwm__acceptRequest(soap, tag, id, (_ngwm__acceptRequest *const*)ptr, "ngwm:acceptRequest");
	case SOAP_TYPE_PointerTongwt__Alarm:
		return soap_out_PointerTongwt__Alarm(soap, tag, id, (ngwt__Alarm *const*)ptr, "ngwt:Alarm");
	case SOAP_TYPE_PointerTongwt__PhoneFlags:
		return soap_out_PointerTongwt__PhoneFlags(soap, tag, id, (ngwt__PhoneFlags *const*)ptr, "ngwt:PhoneFlags");
	case SOAP_TYPE_PointerTongwt__RecurrenceRule:
		return soap_out_PointerTongwt__RecurrenceRule(soap, tag, id, (ngwt__RecurrenceRule *const*)ptr, "ngwt:RecurrenceRule");
	case SOAP_TYPE_PointerTongwt__RecurrenceDateType:
		return soap_out_PointerTongwt__RecurrenceDateType(soap, tag, id, (ngwt__RecurrenceDateType *const*)ptr, "ngwt:RecurrenceDateType");
	case SOAP_TYPE_PointerTongwt__SMimeOperation:
		return soap_out_PointerTongwt__SMimeOperation(soap, tag, id, (ngwt__SMimeOperation *const*)ptr, "ngwt:SMimeOperation");
	case SOAP_TYPE_PointerTongwt__LinkInfo:
		return soap_out_PointerTongwt__LinkInfo(soap, tag, id, (ngwt__LinkInfo *const*)ptr, "ngwt:LinkInfo");
	case SOAP_TYPE_PointerTongwt__ItemOptions:
		return soap_out_PointerTongwt__ItemOptions(soap, tag, id, (ngwt__ItemOptions *const*)ptr, "ngwt:ItemOptions");
	case SOAP_TYPE_PointerTongwt__AttachmentInfo:
		return soap_out_PointerTongwt__AttachmentInfo(soap, tag, id, (ngwt__AttachmentInfo *const*)ptr, "ngwt:AttachmentInfo");
	case SOAP_TYPE_PointerTongwt__MessageBody:
		return soap_out_PointerTongwt__MessageBody(soap, tag, id, (ngwt__MessageBody *const*)ptr, "ngwt:MessageBody");
	case SOAP_TYPE_PointerTongwt__ReferenceInfo:
		return soap_out_PointerTongwt__ReferenceInfo(soap, tag, id, (ngwt__ReferenceInfo *const*)ptr, "ngwt:ReferenceInfo");
	case SOAP_TYPE_PointerTongwt__PersonalInfo:
		return soap_out_PointerTongwt__PersonalInfo(soap, tag, id, (ngwt__PersonalInfo *const*)ptr, "ngwt:PersonalInfo");
	case SOAP_TYPE_PointerTongwt__OfficeInfo:
		return soap_out_PointerTongwt__OfficeInfo(soap, tag, id, (ngwt__OfficeInfo *const*)ptr, "ngwt:OfficeInfo");
	case SOAP_TYPE_PointerTongwt__PostalAddressList:
		return soap_out_PointerTongwt__PostalAddressList(soap, tag, id, (ngwt__PostalAddressList *const*)ptr, "ngwt:PostalAddressList");
	case SOAP_TYPE_PointerTongwt__PhoneList:
		return soap_out_PointerTongwt__PhoneList(soap, tag, id, (ngwt__PhoneList *const*)ptr, "ngwt:PhoneList");
	case SOAP_TYPE_PointerTongwt__ImAddressList:
		return soap_out_PointerTongwt__ImAddressList(soap, tag, id, (ngwt__ImAddressList *const*)ptr, "ngwt:ImAddressList");
	case SOAP_TYPE_PointerTongwt__EmailAddressList:
		return soap_out_PointerTongwt__EmailAddressList(soap, tag, id, (ngwt__EmailAddressList *const*)ptr, "ngwt:EmailAddressList");
	case SOAP_TYPE_PointerTongwt__FullName:
		return soap_out_PointerTongwt__FullName(soap, tag, id, (ngwt__FullName *const*)ptr, "ngwt:FullName");
	case SOAP_TYPE_PointerTongwt__VersionStatus:
		return soap_out_PointerTongwt__VersionStatus(soap, tag, id, (enum ngwt__VersionStatus *const*)ptr, "ngwt:VersionStatus");
	case SOAP_TYPE_PointerTongwt__FolderACL:
		return soap_out_PointerTongwt__FolderACL(soap, tag, id, (ngwt__FolderACL *const*)ptr, "ngwt:FolderACL");
	case SOAP_TYPE_PointerTongwt__RuleActionList:
		return soap_out_PointerTongwt__RuleActionList(soap, tag, id, (ngwt__RuleActionList *const*)ptr, "ngwt:RuleActionList");
	case SOAP_TYPE_PointerTongwt__Execution:
		return soap_out_PointerTongwt__Execution(soap, tag, id, (enum ngwt__Execution *const*)ptr, "ngwt:Execution");
	case SOAP_TYPE_PointerTongwt__Query:
		return soap_out_PointerTongwt__Query(soap, tag, id, (ngwt__Query *const*)ptr, "ngwt:Query");
	case SOAP_TYPE_PointerTongwt__FolderACLStatus:
		return soap_out_PointerTongwt__FolderACLStatus(soap, tag, id, (enum ngwt__FolderACLStatus *const*)ptr, "ngwt:FolderACLStatus");
	case SOAP_TYPE_PointerTongwt__AccessControlList:
		return soap_out_PointerTongwt__AccessControlList(soap, tag, id, (ngwt__AccessControlList *const*)ptr, "ngwt:AccessControlList");
	case SOAP_TYPE_PointerTongwt__WeekOfYear:
		return soap_out_PointerTongwt__WeekOfYear(soap, tag, id, (short *const*)ptr, "ngwt:WeekOfYear");
	case SOAP_TYPE_PointerTongwt__OccurrenceType:
		return soap_out_PointerTongwt__OccurrenceType(soap, tag, id, (enum ngwt__OccurrenceType *const*)ptr, "ngwt:OccurrenceType");
	case SOAP_TYPE_PointerTongwt__ItemSecurity:
		return soap_out_PointerTongwt__ItemSecurity(soap, tag, id, (enum ngwt__ItemSecurity *const*)ptr, "ngwt:ItemSecurity");
	case SOAP_TYPE_PointerTongwt__ItemClass:
		return soap_out_PointerTongwt__ItemClass(soap, tag, id, (enum ngwt__ItemClass *const*)ptr, "ngwt:ItemClass");
	case SOAP_TYPE_PointerTongwt__ItemSource:
		return soap_out_PointerTongwt__ItemSource(soap, tag, id, (enum ngwt__ItemSource *const*)ptr, "ngwt:ItemSource");
	case SOAP_TYPE_PointerTongwt__ItemStatus:
		return soap_out_PointerTongwt__ItemStatus(soap, tag, id, (ngwt__ItemStatus *const*)ptr, "ngwt:ItemStatus");
	case SOAP_TYPE_PointerTongwt__DeltaSyncType:
		return soap_out_PointerTongwt__DeltaSyncType(soap, tag, id, (enum ngwt__DeltaSyncType *const*)ptr, "ngwt:DeltaSyncType");
	case SOAP_TYPE_PointerTongwt__RecipientStatus:
		return soap_out_PointerTongwt__RecipientStatus(soap, tag, id, (ngwt__RecipientStatus *const*)ptr, "ngwt:RecipientStatus");
	case SOAP_TYPE_PointerTongwt__FreeBusyBlockList:
		return soap_out_PointerTongwt__FreeBusyBlockList(soap, tag, id, (ngwt__FreeBusyBlockList *const*)ptr, "ngwt:FreeBusyBlockList");
	case SOAP_TYPE_PointerTongwt__CalendarFolderAttribute:
		return soap_out_PointerTongwt__CalendarFolderAttribute(soap, tag, id, (ngwt__CalendarFolderAttribute *const*)ptr, "ngwt:CalendarFolderAttribute");
	case SOAP_TYPE_PointerTongwt__FilterDate:
		return soap_out_PointerTongwt__FilterDate(soap, tag, id, (enum ngwt__FilterDate *const*)ptr, "ngwt:FilterDate");
	case SOAP_TYPE_PointerTongwt__ContainerRef:
		return soap_out_PointerTongwt__ContainerRef(soap, tag, id, (ngwt__ContainerRef *const*)ptr, "ngwt:ContainerRef");
	case SOAP_TYPE_PointerTongwt__CategoryType:
		return soap_out_PointerTongwt__CategoryType(soap, tag, id, (enum ngwt__CategoryType *const*)ptr, "ngwt:CategoryType");
	case SOAP_TYPE_PointerTongwt__AccessMiscRight:
		return soap_out_PointerTongwt__AccessMiscRight(soap, tag, id, (ngwt__AccessMiscRight *const*)ptr, "ngwt:AccessMiscRight");
	case SOAP_TYPE_PointerTongwt__AccessRight:
		return soap_out_PointerTongwt__AccessRight(soap, tag, id, (ngwt__AccessRight *const*)ptr, "ngwt:AccessRight");
	case SOAP_TYPE_PointerTongwt__Rights:
		return soap_out_PointerTongwt__Rights(soap, tag, id, (ngwt__Rights *const*)ptr, "ngwt:Rights");
	case SOAP_TYPE_PointerTongwe__EventList:
		return soap_out_PointerTongwe__EventList(soap, tag, id, (ngwe__EventList *const*)ptr, "ngwe:EventList");
	case SOAP_TYPE_PointerTongwe__EventsList:
		return soap_out_PointerTongwe__EventsList(soap, tag, id, (ngwe__EventsList *const*)ptr, "ngwe:EventsList");
	case SOAP_TYPE_PointerTongwe__Events:
		return soap_out_PointerTongwe__Events(soap, tag, id, (ngwe__Events *const*)ptr, "ngwe:Events");
	case SOAP_TYPE_PointerTongwe__EventDefinition:
		return soap_out_PointerTongwe__EventDefinition(soap, tag, id, (ngwe__EventDefinition *const*)ptr, "ngwe:EventDefinition");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (std::string *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTongwe__Event:
		return soap_out_PointerTongwe__Event(soap, tag, id, (ngwe__Event *const*)ptr, "ngwe:Event");
	case SOAP_TYPE_PointerTongwe__ContainerList:
		return soap_out_PointerTongwe__ContainerList(soap, tag, id, (ngwe__ContainerList *const*)ptr, "ngwe:ContainerList");
	case SOAP_TYPE_PointerTongwe__ItemTypeList:
		return soap_out_PointerTongwe__ItemTypeList(soap, tag, id, (enum ngwe__ItemTypeList *const*)ptr, "ngwe:ItemTypeList");
	case SOAP_TYPE_PointerTongwe__EventTypeList:
		return soap_out_PointerTongwe__EventTypeList(soap, tag, id, (ngwe__EventTypeList *const*)ptr, "ngwe:EventTypeList");
	case SOAP_TYPE_PointerTongwe__ItemType:
		return soap_out_PointerTongwe__ItemType(soap, tag, id, (enum ngwe__ItemType *const*)ptr, "ngwe:ItemType");
	case SOAP_TYPE_PointerTongwe__FieldList:
		return soap_out_PointerTongwe__FieldList(soap, tag, id, (enum ngwe__FieldList *const*)ptr, "ngwe:FieldList");
	case SOAP_TYPE_PointerTongwt__FreeBusyUserList:
		return soap_out_PointerTongwt__FreeBusyUserList(soap, tag, id, (ngwt__FreeBusyUserList *const*)ptr, "ngwt:FreeBusyUserList");
	case SOAP_TYPE_PointerTongwt__RetractType:
		return soap_out_PointerTongwt__RetractType(soap, tag, id, (enum ngwt__RetractType *const*)ptr, "ngwt:RetractType");
	case SOAP_TYPE_PointerTongwt__ItemList:
		return soap_out_PointerTongwt__ItemList(soap, tag, id, (ngwt__ItemList *const*)ptr, "ngwt:ItemList");
	case SOAP_TYPE_PointerTongwt__CursorSeek:
		return soap_out_PointerTongwt__CursorSeek(soap, tag, id, (enum ngwt__CursorSeek *const*)ptr, "ngwt:CursorSeek");
	case SOAP_TYPE_PointerTongwt__AccessRightChanges:
		return soap_out_PointerTongwt__AccessRightChanges(soap, tag, id, (ngwt__AccessRightChanges *const*)ptr, "ngwt:AccessRightChanges");
	case SOAP_TYPE_PointerTongwt__ModifyItem:
		return soap_out_PointerTongwt__ModifyItem(soap, tag, id, (ngwt__ModifyItem *const*)ptr, "ngwt:ModifyItem");
	case SOAP_TYPE_PointerTongwt__Host:
		return soap_out_PointerTongwt__Host(soap, tag, id, (ngwt__Host *const*)ptr, "ngwt:Host");
	case SOAP_TYPE_PointerTongwt__Authentication:
		return soap_out_PointerTongwt__Authentication(soap, tag, id, (ngwt__Authentication *const*)ptr, "ngwt:Authentication");
	case SOAP_TYPE_PointerTongwt__UserList:
		return soap_out_PointerTongwt__UserList(soap, tag, id, (ngwt__UserList *const*)ptr, "ngwt:UserList");
	case SOAP_TYPE_PointerTongwt__TimezoneList:
		return soap_out_PointerTongwt__TimezoneList(soap, tag, id, (ngwt__TimezoneList *const*)ptr, "ngwt:TimezoneList");
	case SOAP_TYPE_PointerTongwt__Signatures:
		return soap_out_PointerTongwt__Signatures(soap, tag, id, (ngwt__Signatures *const*)ptr, "ngwt:Signatures");
	case SOAP_TYPE_PointerTongwt__Settings:
		return soap_out_PointerTongwt__Settings(soap, tag, id, (ngwt__Settings *const*)ptr, "ngwt:Settings");
	case SOAP_TYPE_PointerTongwt__RuleList:
		return soap_out_PointerTongwt__RuleList(soap, tag, id, (ngwt__RuleList *const*)ptr, "ngwt:RuleList");
	case SOAP_TYPE_PointerTongwt__ProxyList:
		return soap_out_PointerTongwt__ProxyList(soap, tag, id, (ngwt__ProxyList *const*)ptr, "ngwt:ProxyList");
	case SOAP_TYPE_PointerTongwt__AccessRightList:
		return soap_out_PointerTongwt__AccessRightList(soap, tag, id, (ngwt__AccessRightList *const*)ptr, "ngwt:AccessRightList");
	case SOAP_TYPE_PointerTongwt__LibraryList:
		return soap_out_PointerTongwt__LibraryList(soap, tag, id, (ngwt__LibraryList *const*)ptr, "ngwt:LibraryList");
	case SOAP_TYPE_PointerTongwt__SettingsList:
		return soap_out_PointerTongwt__SettingsList(soap, tag, id, (ngwt__SettingsList *const*)ptr, "ngwt:SettingsList");
	case SOAP_TYPE_PointerTongwt__JunkHandlingList:
		return soap_out_PointerTongwt__JunkHandlingList(soap, tag, id, (ngwt__JunkHandlingList *const*)ptr, "ngwt:JunkHandlingList");
	case SOAP_TYPE_PointerTongwt__FreeBusyInfoList:
		return soap_out_PointerTongwt__FreeBusyInfoList(soap, tag, id, (ngwt__FreeBusyInfoList *const*)ptr, "ngwt:FreeBusyInfoList");
	case SOAP_TYPE_PointerTongwt__FreeBusyStats:
		return soap_out_PointerTongwt__FreeBusyStats(soap, tag, id, (ngwt__FreeBusyStats *const*)ptr, "ngwt:FreeBusyStats");
	case SOAP_TYPE_PointerTongwt__FolderList:
		return soap_out_PointerTongwt__FolderList(soap, tag, id, (ngwt__FolderList *const*)ptr, "ngwt:FolderList");
	case SOAP_TYPE_PointerTongwt__ItemSourceList:
		return soap_out_PointerTongwt__ItemSourceList(soap, tag, id, (enum ngwt__ItemSourceList *const*)ptr, "ngwt:ItemSourceList");
	case SOAP_TYPE_PointerTongwt__MessageTypeList:
		return soap_out_PointerTongwt__MessageTypeList(soap, tag, id, (enum ngwt__MessageTypeList *const*)ptr, "ngwt:MessageTypeList");
	case SOAP_TYPE_PointerTongwt__FolderType:
		return soap_out_PointerTongwt__FolderType(soap, tag, id, (enum ngwt__FolderType *const*)ptr, "ngwt:FolderType");
	case SOAP_TYPE_PointerTongwt__DocumentTypeList:
		return soap_out_PointerTongwt__DocumentTypeList(soap, tag, id, (ngwt__DocumentTypeList *const*)ptr, "ngwt:DocumentTypeList");
	case SOAP_TYPE_PointerTongwt__Items:
		return soap_out_PointerTongwt__Items(soap, tag, id, (ngwt__Items *const*)ptr, "ngwt:Items");
	case SOAP_TYPE_PointerTongwt__DeltaInfo:
		return soap_out_PointerTongwt__DeltaInfo(soap, tag, id, (ngwt__DeltaInfo *const*)ptr, "ngwt:DeltaInfo");
	case SOAP_TYPE_PointerTongwt__CustomList:
		return soap_out_PointerTongwt__CustomList(soap, tag, id, (ngwt__CustomList *const*)ptr, "ngwt:CustomList");
	case SOAP_TYPE_PointerTongwt__CategoryList:
		return soap_out_PointerTongwt__CategoryList(soap, tag, id, (ngwt__CategoryList *const*)ptr, "ngwt:CategoryList");
	case SOAP_TYPE_PointerTongwt__AddressBookList:
		return soap_out_PointerTongwt__AddressBookList(soap, tag, id, (ngwt__AddressBookList *const*)ptr, "ngwt:AddressBookList");
	case SOAP_TYPE_PointerTongwt__Distribution:
		return soap_out_PointerTongwt__Distribution(soap, tag, id, (ngwt__Distribution *const*)ptr, "ngwt:Distribution");
	case SOAP_TYPE_PointerTongwt__View:
		return soap_out_PointerTongwt__View(soap, tag, id, (std::string *const*)ptr, "ngwt:View");
	case SOAP_TYPE_PointerTongwt__Status:
		return soap_out_PointerTongwt__Status(soap, tag, id, (ngwt__Status *const*)ptr, "ngwt:Status");
	case SOAP_TYPE_PointerTongwt__ItemRefList:
		return soap_out_PointerTongwt__ItemRefList(soap, tag, id, (ngwt__ItemRefList *const*)ptr, "ngwt:ItemRefList");
	case SOAP_TYPE_PointerTongwt__UserInfo:
		return soap_out_PointerTongwt__UserInfo(soap, tag, id, (ngwt__UserInfo *const*)ptr, "ngwt:UserInfo");
	case SOAP_TYPE_PointerTongwt__RecipientType:
		return soap_out_PointerTongwt__RecipientType(soap, tag, id, (enum ngwt__RecipientType *const*)ptr, "ngwt:RecipientType");
	case SOAP_TYPE_PointerTongwt__Timezone:
		return soap_out_PointerTongwt__Timezone(soap, tag, id, (ngwt__Timezone *const*)ptr, "ngwt:Timezone");
	case SOAP_TYPE_PointerTongwt__Minute:
		return soap_out_PointerTongwt__Minute(soap, tag, id, (unsigned char *const*)ptr, "ngwt:Minute");
	case SOAP_TYPE_PointerTongwt__Hour:
		return soap_out_PointerTongwt__Hour(soap, tag, id, (unsigned char *const*)ptr, "ngwt:Hour");
	case SOAP_TYPE_PointerTongwt__DayOfWeek:
		return soap_out_PointerTongwt__DayOfWeek(soap, tag, id, (ngwt__DayOfWeek *const*)ptr, "ngwt:DayOfWeek");
	case SOAP_TYPE_PointerTongwt__Day:
		return soap_out_PointerTongwt__Day(soap, tag, id, (unsigned char *const*)ptr, "ngwt:Day");
	case SOAP_TYPE_PointerTongwt__Month:
		return soap_out_PointerTongwt__Month(soap, tag, id, (unsigned char *const*)ptr, "ngwt:Month");
	case SOAP_TYPE_PointerTongwt__TimezoneComponent:
		return soap_out_PointerTongwt__TimezoneComponent(soap, tag, id, (ngwt__TimezoneComponent *const*)ptr, "ngwt:TimezoneComponent");
	case SOAP_TYPE_PointerTongwt__ProblemList:
		return soap_out_PointerTongwt__ProblemList(soap, tag, id, (ngwt__ProblemList *const*)ptr, "ngwt:ProblemList");
	case SOAP_TYPE_PointerTongwt__Signature:
		return soap_out_PointerTongwt__Signature(soap, tag, id, (ngwt__Signature *const*)ptr, "ngwt:Signature");
	case SOAP_TYPE_PointerTongwt__SignatureData:
		return soap_out_PointerTongwt__SignatureData(soap, tag, id, (ngwt__SignatureData *const*)ptr, "ngwt:SignatureData");
	case SOAP_TYPE_PointerTongwt__SettingsGroup:
		return soap_out_PointerTongwt__SettingsGroup(soap, tag, id, (ngwt__SettingsGroup *const*)ptr, "ngwt:SettingsGroup");
	case SOAP_TYPE_PointerTongwt__ReturnNotification:
		return soap_out_PointerTongwt__ReturnNotification(soap, tag, id, (ngwt__ReturnNotification *const*)ptr, "ngwt:ReturnNotification");
	case SOAP_TYPE_PointerTongwt__StatusTracking:
		return soap_out_PointerTongwt__StatusTracking(soap, tag, id, (ngwt__StatusTracking *const*)ptr, "ngwt:StatusTracking");
	case SOAP_TYPE_PointerTongwt__SendOptionsRequestReply:
		return soap_out_PointerTongwt__SendOptionsRequestReply(soap, tag, id, (ngwt__SendOptionsRequestReply *const*)ptr, "ngwt:SendOptionsRequestReply");
	case SOAP_TYPE_PointerTongwt__Rule:
		return soap_out_PointerTongwt__Rule(soap, tag, id, (ngwt__Rule *const*)ptr, "ngwt:Rule");
	case SOAP_TYPE_PointerTongwt__RuleAction:
		return soap_out_PointerTongwt__RuleAction(soap, tag, id, (ngwt__RuleAction *const*)ptr, "ngwt:RuleAction");
	case SOAP_TYPE_PointerTongwt__CategoryRefList:
		return soap_out_PointerTongwt__CategoryRefList(soap, tag, id, (ngwt__CategoryRefList *const*)ptr, "ngwt:CategoryRefList");
	case SOAP_TYPE_PointerTongwt__Mail:
		return soap_out_PointerTongwt__Mail(soap, tag, id, (ngwt__Mail *const*)ptr, "ngwt:Mail");
	case SOAP_TYPE_PointerTongwt__ReturnNotificationOptions:
		return soap_out_PointerTongwt__ReturnNotificationOptions(soap, tag, id, (ngwt__ReturnNotificationOptions *const*)ptr, "ngwt:ReturnNotificationOptions");
	case SOAP_TYPE_PointerTongwt__MonthList:
		return soap_out_PointerTongwt__MonthList(soap, tag, id, (ngwt__MonthList *const*)ptr, "ngwt:MonthList");
	case SOAP_TYPE_PointerTongwt__DayOfYearList:
		return soap_out_PointerTongwt__DayOfYearList(soap, tag, id, (ngwt__DayOfYearList *const*)ptr, "ngwt:DayOfYearList");
	case SOAP_TYPE_PointerTongwt__DayOfMonthList:
		return soap_out_PointerTongwt__DayOfMonthList(soap, tag, id, (ngwt__DayOfMonthList *const*)ptr, "ngwt:DayOfMonthList");
	case SOAP_TYPE_PointerTongwt__DayOfYearWeekList:
		return soap_out_PointerTongwt__DayOfYearWeekList(soap, tag, id, (ngwt__DayOfYearWeekList *const*)ptr, "ngwt:DayOfYearWeekList");
	case SOAP_TYPE_PointerTongwt__Frequency:
		return soap_out_PointerTongwt__Frequency(soap, tag, id, (enum ngwt__Frequency *const*)ptr, "ngwt:Frequency");
	case SOAP_TYPE_PointerTongwt__DelegateeStatus:
		return soap_out_PointerTongwt__DelegateeStatus(soap, tag, id, (ngwt__DelegateeStatus *const*)ptr, "ngwt:DelegateeStatus");
	case SOAP_TYPE_PointerTongwt__DelegatedStatus:
		return soap_out_PointerTongwt__DelegatedStatus(soap, tag, id, (ngwt__DelegatedStatus *const*)ptr, "ngwt:DelegatedStatus");
	case SOAP_TYPE_PointerTongwt__CommentStatus:
		return soap_out_PointerTongwt__CommentStatus(soap, tag, id, (ngwt__CommentStatus *const*)ptr, "ngwt:CommentStatus");
	case SOAP_TYPE_PointerTongwt__TransferFailedStatus:
		return soap_out_PointerTongwt__TransferFailedStatus(soap, tag, id, (ngwt__TransferFailedStatus *const*)ptr, "ngwt:TransferFailedStatus");
	case SOAP_TYPE_PointerTongwt__Recipient:
		return soap_out_PointerTongwt__Recipient(soap, tag, id, (ngwt__Recipient *const*)ptr, "ngwt:Recipient");
	case SOAP_TYPE_PointerTongwt__Filter:
		return soap_out_PointerTongwt__Filter(soap, tag, id, (ngwt__Filter *const*)ptr, "ngwt:Filter");
	case SOAP_TYPE_PointerTongwt__QueryTarget:
		return soap_out_PointerTongwt__QueryTarget(soap, tag, id, (ngwt__QueryTarget *const*)ptr, "ngwt:QueryTarget");
	case SOAP_TYPE_PointerTongwt__ProxyUser:
		return soap_out_PointerTongwt__ProxyUser(soap, tag, id, (ngwt__ProxyUser *const*)ptr, "ngwt:ProxyUser");
	case SOAP_TYPE_PointerTongwt__ProblemEntry:
		return soap_out_PointerTongwt__ProblemEntry(soap, tag, id, (ngwt__ProblemEntry *const*)ptr, "ngwt:ProblemEntry");
	case SOAP_TYPE_PointerTongwt__PostalAddress:
		return soap_out_PointerTongwt__PostalAddress(soap, tag, id, (ngwt__PostalAddress *const*)ptr, "ngwt:PostalAddress");
	case SOAP_TYPE_PointerTongwt__PhoneNumber:
		return soap_out_PointerTongwt__PhoneNumber(soap, tag, id, (ngwt__PhoneNumber *const*)ptr, "ngwt:PhoneNumber");
	case SOAP_TYPE_PointerToxsd__date:
		return soap_out_PointerToxsd__date(soap, tag, id, (std::string *const*)ptr, "xsd:date");
	case SOAP_TYPE_PointerTongwt__ItemRef:
		return soap_out_PointerTongwt__ItemRef(soap, tag, id, (ngwt__ItemRef *const*)ptr, "ngwt:ItemRef");
	case SOAP_TYPE_PointerTongwt__UUID:
		return soap_out_PointerTongwt__UUID(soap, tag, id, (std::string *const*)ptr, "ngwt:UUID");
	case SOAP_TYPE_PointerTongwt__SharedFolderNotification:
		return soap_out_PointerTongwt__SharedFolderNotification(soap, tag, id, (ngwt__SharedFolderNotification *const*)ptr, "ngwt:SharedFolderNotification");
	case SOAP_TYPE_PointerTongwt__MessagePart:
		return soap_out_PointerTongwt__MessagePart(soap, tag, id, (ngwt__MessagePart *const*)ptr, "ngwt:MessagePart");
	case SOAP_TYPE_PointerTongwt__Library:
		return soap_out_PointerTongwt__Library(soap, tag, id, (ngwt__Library *const*)ptr, "ngwt:Library");
	case SOAP_TYPE_PointerTongwt__JunkEntry:
		return soap_out_PointerTongwt__JunkEntry(soap, tag, id, (ngwt__JunkEntry *const*)ptr, "ngwt:JunkEntry");
	case SOAP_TYPE_PointerTongwt__JunkHandlingListType:
		return soap_out_PointerTongwt__JunkHandlingListType(soap, tag, id, (enum ngwt__JunkHandlingListType *const*)ptr, "ngwt:JunkHandlingListType");
	case SOAP_TYPE_PointerTongwt__Item:
		return soap_out_PointerTongwt__Item(soap, tag, id, (ngwt__Item *const*)ptr, "ngwt:Item");
	case SOAP_TYPE_PointerTongwt__ItemChanges:
		return soap_out_PointerTongwt__ItemChanges(soap, tag, id, (ngwt__ItemChanges *const*)ptr, "ngwt:ItemChanges");
	case SOAP_TYPE_PointerTongwt__ImAddress:
		return soap_out_PointerTongwt__ImAddress(soap, tag, id, (ngwt__ImAddress *const*)ptr, "ngwt:ImAddress");
	case SOAP_TYPE_PointerTongwt__GroupMember:
		return soap_out_PointerTongwt__GroupMember(soap, tag, id, (ngwt__GroupMember *const*)ptr, "ngwt:GroupMember");
	case SOAP_TYPE_PointerTongwt__GroupMemberList:
		return soap_out_PointerTongwt__GroupMemberList(soap, tag, id, (ngwt__GroupMemberList *const*)ptr, "ngwt:GroupMemberList");
	case SOAP_TYPE_PointerTongwt__FreeBusyInfo:
		return soap_out_PointerTongwt__FreeBusyInfo(soap, tag, id, (ngwt__FreeBusyInfo *const*)ptr, "ngwt:FreeBusyInfo");
	case SOAP_TYPE_PointerTongwt__NameAndEmail:
		return soap_out_PointerTongwt__NameAndEmail(soap, tag, id, (ngwt__NameAndEmail *const*)ptr, "ngwt:NameAndEmail");
	case SOAP_TYPE_PointerTongwt__AcceptLevel:
		return soap_out_PointerTongwt__AcceptLevel(soap, tag, id, (enum ngwt__AcceptLevel *const*)ptr, "ngwt:AcceptLevel");
	case SOAP_TYPE_PointerTongwt__FreeBusyBlock:
		return soap_out_PointerTongwt__FreeBusyBlock(soap, tag, id, (ngwt__FreeBusyBlock *const*)ptr, "ngwt:FreeBusyBlock");
	case SOAP_TYPE_PointerTongwt__Folder:
		return soap_out_PointerTongwt__Folder(soap, tag, id, (ngwt__Folder *const*)ptr, "ngwt:Folder");
	case SOAP_TYPE_PointerTongwt__FolderACLEntry:
		return soap_out_PointerTongwt__FolderACLEntry(soap, tag, id, (ngwt__FolderACLEntry *const*)ptr, "ngwt:FolderACLEntry");
	case SOAP_TYPE_PointerTongwt__FilterElement:
		return soap_out_PointerTongwt__FilterElement(soap, tag, id, (ngwt__FilterElement *const*)ptr, "ngwt:FilterElement");
	case SOAP_TYPE_PointerTongwt__DocumentType:
		return soap_out_PointerTongwt__DocumentType(soap, tag, id, (ngwt__DocumentType *const*)ptr, "ngwt:DocumentType");
	case SOAP_TYPE_PointerTongwt__AgeAction:
		return soap_out_PointerTongwt__AgeAction(soap, tag, id, (enum ngwt__AgeAction *const*)ptr, "ngwt:AgeAction");
	case SOAP_TYPE_PointerTongwt__SendOptions:
		return soap_out_PointerTongwt__SendOptions(soap, tag, id, (ngwt__SendOptions *const*)ptr, "ngwt:SendOptions");
	case SOAP_TYPE_PointerTongwt__RecipientList:
		return soap_out_PointerTongwt__RecipientList(soap, tag, id, (ngwt__RecipientList *const*)ptr, "ngwt:RecipientList");
	case SOAP_TYPE_PointerTongwt__From:
		return soap_out_PointerTongwt__From(soap, tag, id, (ngwt__From *const*)ptr, "ngwt:From");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTongwt__DayOfYearWeek:
		return soap_out_PointerTongwt__DayOfYearWeek(soap, tag, id, (ngwt__DayOfYearWeek *const*)ptr, "ngwt:DayOfYearWeek");
	case SOAP_TYPE_PointerTongwt__Custom:
		return soap_out_PointerTongwt__Custom(soap, tag, id, (ngwt__Custom *const*)ptr, "ngwt:Custom");
	case SOAP_TYPE_PointerTongwt__CustomType:
		return soap_out_PointerTongwt__CustomType(soap, tag, id, (enum ngwt__CustomType *const*)ptr, "ngwt:CustomType");
	case SOAP_TYPE_PointerTongwt__uid:
		return soap_out_PointerTongwt__uid(soap, tag, id, (std::string *const*)ptr, "ngwt:uid");
	case SOAP_TYPE_PointerTongwt__Category:
		return soap_out_PointerTongwt__Category(soap, tag, id, (ngwt__Category *const*)ptr, "ngwt:Category");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTounsignedLong:
		return soap_out_PointerTounsignedLong(soap, tag, id, (unsigned long *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTongwt__AttachmentID:
		return soap_out_PointerTongwt__AttachmentID(soap, tag, id, (ngwt__AttachmentID *const*)ptr, "ngwt:AttachmentID");
	case SOAP_TYPE_PointerTongwt__AttachmentItemInfo:
		return soap_out_PointerTongwt__AttachmentItemInfo(soap, tag, id, (ngwt__AttachmentItemInfo *const*)ptr, "ngwt:AttachmentItemInfo");
	case SOAP_TYPE_PointerTongwt__AddressBook:
		return soap_out_PointerTongwt__AddressBook(soap, tag, id, (ngwt__AddressBook *const*)ptr, "ngwt:AddressBook");
	case SOAP_TYPE_PointerTongwt__AccessRightEntry:
		return soap_out_PointerTongwt__AccessRightEntry(soap, tag, id, (ngwt__AccessRightEntry *const*)ptr, "ngwt:AccessRightEntry");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTongwt__AccessControlListEntry:
		return soap_out_PointerTongwt__AccessControlListEntry(soap, tag, id, (ngwt__AccessControlListEntry *const*)ptr, "ngwt:AccessControlListEntry");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ngwt__UUID:
		soap_serialize_ngwt__UUID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ngwt__uid:
		soap_serialize_ngwt__uid(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ngwt__View:
		soap_serialize_ngwt__View(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ngwe__removeEventsResponse:
		((_ngwe__removeEventsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwe__removeEventsRequest:
		((_ngwe__removeEventsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwe__removeEventConfigurationResponse:
		((_ngwe__removeEventConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwe__removeEventConfigurationRequest:
		((_ngwe__removeEventConfigurationRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwe__getEventsResponse:
		((_ngwe__getEventsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwe__getEventsRequest:
		((_ngwe__getEventsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwe__getEventConfigurationResponse:
		((_ngwe__getEventConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwe__getEventConfigurationRequest:
		((_ngwe__getEventConfigurationRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwe__configureEventsResponse:
		((_ngwe__configureEventsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwe__configureEventsRequest:
		((_ngwe__configureEventsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwe__cleanEventConfigurationResponse:
		((_ngwe__cleanEventConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwe__cleanEventConfigurationRequest:
		((_ngwe__cleanEventConfigurationRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwe__Notify:
		((ngwe__Notify *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwe__EventTypeList:
		((ngwe__EventTypeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwe__EventsList:
		((ngwe__EventsList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwe__Events:
		((ngwe__Events *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwe__EventList:
		((ngwe__EventList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwe__EventDefinition:
		((ngwe__EventDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwe__Event:
		((ngwe__Event *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwe__ContainerList:
		((ngwe__ContainerList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__updateVersionStatusResponse:
		((_ngwm__updateVersionStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__updateVersionStatusRequest:
		((_ngwm__updateVersionStatusRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__uncompleteResponse:
		((_ngwm__uncompleteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__uncompleteRequest:
		((_ngwm__uncompleteRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__unacceptResponse:
		((_ngwm__unacceptResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__unacceptRequest:
		((_ngwm__unacceptRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__startFreeBusySessionResponse:
		((_ngwm__startFreeBusySessionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__startFreeBusySessionRequest:
		((_ngwm__startFreeBusySessionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__setTimestampResponse:
		((_ngwm__setTimestampResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__setTimestampRequest:
		((_ngwm__setTimestampRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__sendItemResponse:
		((_ngwm__sendItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__sendItemRequest:
		((_ngwm__sendItemRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__retractResponse:
		((_ngwm__retractResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__retractRequest:
		((_ngwm__retractRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__replyResponse:
		((_ngwm__replyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__replyRequest:
		((_ngwm__replyRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeSignatureResponse:
		((_ngwm__removeSignatureResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeSignatureRequest:
		((_ngwm__removeSignatureRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeProxyUserResponse:
		((_ngwm__removeProxyUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeProxyUserRequest:
		((_ngwm__removeProxyUserRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeProxyAccessResponse:
		((_ngwm__removeProxyAccessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeProxyAccessRequest:
		((_ngwm__removeProxyAccessRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeMembersResponse:
		((_ngwm__removeMembersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeMembersRequest:
		((_ngwm__removeMembersRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeJunkEntryResponse:
		((_ngwm__removeJunkEntryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeJunkEntryRequest:
		((_ngwm__removeJunkEntryRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeItemsResponse:
		((_ngwm__removeItemsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeItemsRequest:
		((_ngwm__removeItemsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeItemResponse:
		((_ngwm__removeItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeItemRequest:
		((_ngwm__removeItemRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeCustomDefinitionResponse:
		((_ngwm__removeCustomDefinitionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__removeCustomDefinitionRequest:
		((_ngwm__removeCustomDefinitionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__readCursorResponse:
		((_ngwm__readCursorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__readCursorRequest:
		((_ngwm__readCursorRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__purgeResponse:
		((_ngwm__purgeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__purgeRequest:
		((_ngwm__purgeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__purgeDeletedItemsResponse:
		((_ngwm__purgeDeletedItemsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__purgeDeletedItemsRequest:
		((_ngwm__purgeDeletedItemsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__positionCursorResponse:
		((_ngwm__positionCursorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__positionCursorRequest:
		((_ngwm__positionCursorRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__moveItemResponse:
		((_ngwm__moveItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__moveItemRequest:
		((_ngwm__moveItemRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifySignaturesResponse:
		((_ngwm__modifySignaturesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifySignaturesRequest:
		((_ngwm__modifySignaturesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifySettingsResponse:
		((_ngwm__modifySettingsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifySettingsRequest:
		((_ngwm__modifySettingsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyProxyAccessResponse:
		((_ngwm__modifyProxyAccessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyProxyAccessRequest:
		((_ngwm__modifyProxyAccessRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyPasswordResponse:
		((_ngwm__modifyPasswordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyPasswordRequest:
		((_ngwm__modifyPasswordRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse:
		((_ngwm__modifyJunkMailSettingsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest:
		((_ngwm__modifyJunkMailSettingsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyJunkEntryResponse:
		((_ngwm__modifyJunkEntryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyJunkEntryRequest:
		((_ngwm__modifyJunkEntryRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyItemsResponse:
		((_ngwm__modifyItemsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyItemsRequest:
		((_ngwm__modifyItemsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyItemResponse:
		((_ngwm__modifyItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__modifyItemRequest:
		((_ngwm__modifyItemRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__markUnReadResponse:
		((_ngwm__markUnReadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__markUnReadRequest:
		((_ngwm__markUnReadRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__markUnPrivateResponse:
		((_ngwm__markUnPrivateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__markUnPrivateRequest:
		((_ngwm__markUnPrivateRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__markReadResponse:
		((_ngwm__markReadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__markReadRequest:
		((_ngwm__markReadRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__markPrivateResponse:
		((_ngwm__markPrivateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__markPrivateRequest:
		((_ngwm__markPrivateRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__logoutResponse:
		((_ngwm__logoutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__logoutRequest:
		((_ngwm__logoutRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__loginResponse:
		((_ngwm__loginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__loginRequest:
		((_ngwm__loginRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getUserListResponse:
		((_ngwm__getUserListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getUserListRequest:
		((_ngwm__getUserListRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getTimezoneListResponse:
		((_ngwm__getTimezoneListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getTimezoneListRequest:
		((_ngwm__getTimezoneListRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getTimestampResponse:
		((_ngwm__getTimestampResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getTimestampRequest:
		((_ngwm__getTimestampRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getSignaturesResponse:
		((_ngwm__getSignaturesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getSignaturesRequest:
		((_ngwm__getSignaturesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getSettingsResponse:
		((_ngwm__getSettingsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getSettingsRequest:
		((_ngwm__getSettingsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getRuleListResponse:
		((_ngwm__getRuleListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getRuleListRequest:
		((_ngwm__getRuleListRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getProxyListResponse:
		((_ngwm__getProxyListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getProxyListRequest:
		((_ngwm__getProxyListRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getProxyAccessListResponse:
		((_ngwm__getProxyAccessListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getProxyAccessListRequest:
		((_ngwm__getProxyAccessListRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getQuickMessagesResponse:
		((_ngwm__getQuickMessagesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getQuickMessagesRequest:
		((_ngwm__getQuickMessagesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getLibraryListResponse:
		((_ngwm__getLibraryListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getLibraryListRequest:
		((_ngwm__getLibraryListRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getLibraryItemResponse:
		((_ngwm__getLibraryItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getLibraryItemRequest:
		((_ngwm__getLibraryItemRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getJunkMailSettingsResponse:
		((_ngwm__getJunkMailSettingsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getJunkMailSettingsRequest:
		((_ngwm__getJunkMailSettingsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getJunkEntriesResponse:
		((_ngwm__getJunkEntriesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getJunkEntriesRequest:
		((_ngwm__getJunkEntriesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getItemsResponse:
		((_ngwm__getItemsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getItemsRequest:
		((_ngwm__getItemsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getItemResponse:
		((_ngwm__getItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getItemRequest:
		((_ngwm__getItemRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getFreeBusyResponse:
		((_ngwm__getFreeBusyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getFreeBusyRequest:
		((_ngwm__getFreeBusyRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getFolderListResponse:
		((_ngwm__getFolderListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getFolderListRequest:
		((_ngwm__getFolderListRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getFolderResponse:
		((_ngwm__getFolderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getFolderRequest:
		((_ngwm__getFolderRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getDocumentTypeListResponse:
		((_ngwm__getDocumentTypeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getDocumentTypeListRequest:
		((_ngwm__getDocumentTypeListRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getDeltaInfoResponse:
		((_ngwm__getDeltaInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getDeltaInfoRequest:
		((_ngwm__getDeltaInfoRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getDeltasResponse:
		((_ngwm__getDeltasResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getDeltasRequest:
		((_ngwm__getDeltasRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getCustomListResponse:
		((_ngwm__getCustomListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getCustomListRequest:
		((_ngwm__getCustomListRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getCategoryListResponse:
		((_ngwm__getCategoryListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getCategoryListRequest:
		((_ngwm__getCategoryListRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getAttachmentResponse:
		((_ngwm__getAttachmentResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getAttachmentRequest:
		((_ngwm__getAttachmentRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getAddressBookListResponse:
		((_ngwm__getAddressBookListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__getAddressBookListRequest:
		((_ngwm__getAddressBookListRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__forwardResponse:
		((_ngwm__forwardResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__forwardRequest:
		((_ngwm__forwardRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__executeRuleResponse:
		((_ngwm__executeRuleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__executeRuleRequest:
		((_ngwm__executeRuleRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__destroyCursorResponse:
		((_ngwm__destroyCursorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__destroyCursorRequest:
		((_ngwm__destroyCursorRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__delegateResponse:
		((_ngwm__delegateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__delegateRequest:
		((_ngwm__delegateRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__declineResponse:
		((_ngwm__declineResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__declineRequest:
		((_ngwm__declineRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createSignatureResponse:
		((_ngwm__createSignatureResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createSignatureRequest:
		((_ngwm__createSignatureRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createProxyAccessResponse:
		((_ngwm__createProxyAccessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createProxyAccessRequest:
		((_ngwm__createProxyAccessRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createJunkEntryResponse:
		((_ngwm__createJunkEntryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createJunkEntryRequest:
		((_ngwm__createJunkEntryRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createItemsResponse:
		((_ngwm__createItemsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createItemsRequest:
		((_ngwm__createItemsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createItemResponse:
		((_ngwm__createItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createItemRequest:
		((_ngwm__createItemRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createCursorResponse:
		((_ngwm__createCursorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__createCursorRequest:
		((_ngwm__createCursorRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__completeResponse:
		((_ngwm__completeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__completeRequest:
		((_ngwm__completeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__closeFreeBusySessionResponse:
		((_ngwm__closeFreeBusySessionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__closeFreeBusySessionRequest:
		((_ngwm__closeFreeBusySessionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__addMembersResponse:
		((_ngwm__addMembersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__addMembersRequest:
		((_ngwm__addMembersRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__addItemsResponse:
		((_ngwm__addItemsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__addItemsRequest:
		((_ngwm__addItemsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__addItemResponse:
		((_ngwm__addItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__addItemRequest:
		((_ngwm__addItemRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__acceptShareResponse:
		((_ngwm__acceptShareResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__acceptShareRequest:
		((_ngwm__acceptShareRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__acceptResponse:
		((_ngwm__acceptResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ngwm__acceptRequest:
		((_ngwm__acceptRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__VersionEvent:
		((ngwt__VersionEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Version:
		((ngwt__Version *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__UserList:
		((ngwt__UserList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__UserInfo:
		((ngwt__UserInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__TrustedApplication:
		((ngwt__TrustedApplication *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__TransferFailedStatus:
		((ngwt__TransferFailedStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__TimezoneList:
		((ngwt__TimezoneList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__TimezoneComponent:
		((ngwt__TimezoneComponent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Timezone:
		((ngwt__Timezone *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Task:
		((ngwt__Task *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__SystemFolder:
		((ngwt__SystemFolder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__StatusTracking:
		((ngwt__StatusTracking *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Status:
		((ngwt__Status *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__SMimeOperation:
		((ngwt__SMimeOperation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__SignatureData:
		((ngwt__SignatureData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Signatures:
		((ngwt__Signatures *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Signature:
		((ngwt__Signature *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__SharedNotification:
		((ngwt__SharedNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__SharedFolderNotification:
		((ngwt__SharedFolderNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__SharedFolder:
		((ngwt__SharedFolder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__SettingsList:
		((ngwt__SettingsList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__SettingsGroup:
		((ngwt__SettingsGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Settings:
		((ngwt__Settings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__SendOptions:
		((ngwt__SendOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__SendOptionsRequestReply:
		((ngwt__SendOptionsRequestReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__RuleList:
		((ngwt__RuleList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__RuleActionList:
		((ngwt__RuleActionList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__RuleAction:
		((ngwt__RuleAction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Rule:
		((ngwt__Rule *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Rights:
		((ngwt__Rights *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ReturnNotificationOptions:
		((ngwt__ReturnNotificationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ReturnNotification:
		((ngwt__ReturnNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Resource:
		((ngwt__Resource *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ReferenceInfo:
		((ngwt__ReferenceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__RecurrenceRule:
		((ngwt__RecurrenceRule *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__RecurrenceDateType:
		((ngwt__RecurrenceDateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__RecipientStatus:
		((ngwt__RecipientStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__RecipientList:
		((ngwt__RecipientList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Recipient:
		((ngwt__Recipient *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__QueryTarget:
		((ngwt__QueryTarget *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__QueryFolder:
		((ngwt__QueryFolder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Query:
		((ngwt__Query *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ProxyList:
		((ngwt__ProxyList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ProxyUser:
		((ngwt__ProxyUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Proxy:
		((ngwt__Proxy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ProblemList:
		((ngwt__ProblemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ProblemEntry:
		((ngwt__ProblemEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__PostalAddressList:
		((ngwt__PostalAddressList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__PostalAddress:
		((ngwt__PostalAddress *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__PlainText:
		((ngwt__PlainText *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__PhoneNumber:
		((ngwt__PhoneNumber *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__PhoneMessage:
		((ngwt__PhoneMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__PhoneList:
		((ngwt__PhoneList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__PhoneFlags:
		((ngwt__PhoneFlags *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__PersonalInfo:
		((ngwt__PersonalInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Organization:
		((ngwt__Organization *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__OfficeInfo:
		((ngwt__OfficeInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Note:
		((ngwt__Note *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__NameAndEmail:
		((ngwt__NameAndEmail *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__MonthList:
		((ngwt__MonthList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ModifyItem:
		((ngwt__ModifyItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__MessagePart:
		((ngwt__MessagePart *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__MessageBody:
		((ngwt__MessageBody *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Mail:
		((ngwt__Mail *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__LinkInfo:
		((ngwt__LinkInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__LibraryList:
		((ngwt__LibraryList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Library:
		((ngwt__Library *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__JunkHandlingList:
		((ngwt__JunkHandlingList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__JunkEntry:
		((ngwt__JunkEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ItemStatus:
		((ngwt__ItemStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Items:
		((ngwt__Items *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ItemRefList:
		((ngwt__ItemRefList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ItemRef:
		((ngwt__ItemRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ItemOptions:
		((ngwt__ItemOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ItemList:
		((ngwt__ItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ItemChanges:
		((ngwt__ItemChanges *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Item:
		((ngwt__Item *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ImAddressList:
		((ngwt__ImAddressList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ImAddress:
		((ngwt__ImAddress *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Host:
		((ngwt__Host *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__GroupMemberList:
		((ngwt__GroupMemberList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__GroupMember:
		((ngwt__GroupMember *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Group:
		((ngwt__Group *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FullName:
		((ngwt__FullName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__From:
		((ngwt__From *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FreeBusyStats:
		((ngwt__FreeBusyStats *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FreeBusyInfoList:
		((ngwt__FreeBusyInfoList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FreeBusyUserList:
		((ngwt__FreeBusyUserList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FreeBusyInfo:
		((ngwt__FreeBusyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FreeBusyBlock:
		((ngwt__FreeBusyBlock *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FreeBusyBlockList:
		((ngwt__FreeBusyBlockList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FolderList:
		((ngwt__FolderList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FolderACLEntry:
		((ngwt__FolderACLEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FolderACL:
		((ngwt__FolderACL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Folder:
		((ngwt__Folder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FilterGroup:
		((ngwt__FilterGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FilterEntry:
		((ngwt__FilterEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__FilterElement:
		((ngwt__FilterElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Filter:
		((ngwt__Filter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__EmailAddressList:
		((ngwt__EmailAddressList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__DocumentTypeList:
		((ngwt__DocumentTypeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__DocumentType:
		((ngwt__DocumentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__DocumentRef:
		((ngwt__DocumentRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Document:
		((ngwt__Document *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Distribution:
		((ngwt__Distribution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__DeltaInfo:
		((ngwt__DeltaInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__DelegateeStatus:
		((ngwt__DelegateeStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__DelegatedStatus:
		((ngwt__DelegatedStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__DayOfYearWeekList:
		((ngwt__DayOfYearWeekList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__DayOfYearWeek:
		((ngwt__DayOfYearWeek *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__DayOfYearList:
		((ngwt__DayOfYearList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__DayOfWeek:
		((ngwt__DayOfWeek *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__DayOfMonthList:
		((ngwt__DayOfMonthList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__CustomList:
		((ngwt__CustomList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Custom:
		((ngwt__Custom *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ContainerRef:
		((ngwt__ContainerRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ContainerItem:
		((ngwt__ContainerItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__ContactFolder:
		((ngwt__ContactFolder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Contact:
		((ngwt__Contact *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__CommentStatus:
		((ngwt__CommentStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__CategoryRefList:
		((ngwt__CategoryRefList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__CategoryList:
		((ngwt__CategoryList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Category:
		((ngwt__Category *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__CalendarItem:
		((ngwt__CalendarItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__CalendarFolderAttribute:
		((ngwt__CalendarFolderAttribute *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__BoxEntry:
		((ngwt__BoxEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Authentication:
		((ngwt__Authentication *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AttachmentItemInfo:
		((ngwt__AttachmentItemInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AttachmentInfo:
		((ngwt__AttachmentInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AttachmentID:
		((ngwt__AttachmentID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Appointment:
		((ngwt__Appointment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__Alarm:
		((ngwt__Alarm *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AddressBookList:
		((ngwt__AddressBookList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AddressBookItem:
		((ngwt__AddressBookItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AddressBook:
		((ngwt__AddressBook *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AccessRightList:
		((ngwt__AccessRightList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AccessRightEntry:
		((ngwt__AccessRightEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AccessRightChanges:
		((ngwt__AccessRightChanges *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AccessRight:
		((ngwt__AccessRight *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AccessMiscRight:
		((ngwt__AccessMiscRight *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AccessControlList:
		((ngwt__AccessControlList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ngwt__AccessControlListEntry:
		((ngwt__AccessControlListEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__language:
		soap_serialize_xsd__language(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_serialize_xsd__duration(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_xsd__date(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ngw__removeEventsRequest:
		soap_serialize___ngw__removeEventsRequest(soap, (const struct __ngw__removeEventsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__removeEventConfigurationRequest:
		soap_serialize___ngw__removeEventConfigurationRequest(soap, (const struct __ngw__removeEventConfigurationRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getEventsRequest:
		soap_serialize___ngw__getEventsRequest(soap, (const struct __ngw__getEventsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getEventConfigurationRequest:
		soap_serialize___ngw__getEventConfigurationRequest(soap, (const struct __ngw__getEventConfigurationRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__configureEventsRequest:
		soap_serialize___ngw__configureEventsRequest(soap, (const struct __ngw__configureEventsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__cleanEventConfigurationRequest:
		soap_serialize___ngw__cleanEventConfigurationRequest(soap, (const struct __ngw__cleanEventConfigurationRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__updateVersionStatusRequest:
		soap_serialize___ngw__updateVersionStatusRequest(soap, (const struct __ngw__updateVersionStatusRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__uncompleteRequest:
		soap_serialize___ngw__uncompleteRequest(soap, (const struct __ngw__uncompleteRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__unacceptRequest:
		soap_serialize___ngw__unacceptRequest(soap, (const struct __ngw__unacceptRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__startFreeBusySessionRequest:
		soap_serialize___ngw__startFreeBusySessionRequest(soap, (const struct __ngw__startFreeBusySessionRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__setTimestampRequest:
		soap_serialize___ngw__setTimestampRequest(soap, (const struct __ngw__setTimestampRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__sendItemRequest:
		soap_serialize___ngw__sendItemRequest(soap, (const struct __ngw__sendItemRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__retractRequest:
		soap_serialize___ngw__retractRequest(soap, (const struct __ngw__retractRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__replyRequest:
		soap_serialize___ngw__replyRequest(soap, (const struct __ngw__replyRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__removeSignatureRequest:
		soap_serialize___ngw__removeSignatureRequest(soap, (const struct __ngw__removeSignatureRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__removeProxyUserRequest:
		soap_serialize___ngw__removeProxyUserRequest(soap, (const struct __ngw__removeProxyUserRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__removeProxyAccessRequest:
		soap_serialize___ngw__removeProxyAccessRequest(soap, (const struct __ngw__removeProxyAccessRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__removeMembersRequest:
		soap_serialize___ngw__removeMembersRequest(soap, (const struct __ngw__removeMembersRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__removeJunkEntryRequest:
		soap_serialize___ngw__removeJunkEntryRequest(soap, (const struct __ngw__removeJunkEntryRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__removeItemsRequest:
		soap_serialize___ngw__removeItemsRequest(soap, (const struct __ngw__removeItemsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__removeItemRequest:
		soap_serialize___ngw__removeItemRequest(soap, (const struct __ngw__removeItemRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__removeCustomDefinitionRequest:
		soap_serialize___ngw__removeCustomDefinitionRequest(soap, (const struct __ngw__removeCustomDefinitionRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__readCursorRequest:
		soap_serialize___ngw__readCursorRequest(soap, (const struct __ngw__readCursorRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__purgeRequest:
		soap_serialize___ngw__purgeRequest(soap, (const struct __ngw__purgeRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__purgeDeletedItemsRequest:
		soap_serialize___ngw__purgeDeletedItemsRequest(soap, (const struct __ngw__purgeDeletedItemsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__positionCursorRequest:
		soap_serialize___ngw__positionCursorRequest(soap, (const struct __ngw__positionCursorRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__moveItemRequest:
		soap_serialize___ngw__moveItemRequest(soap, (const struct __ngw__moveItemRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__modifySignaturesRequest:
		soap_serialize___ngw__modifySignaturesRequest(soap, (const struct __ngw__modifySignaturesRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__modifySettingsRequest:
		soap_serialize___ngw__modifySettingsRequest(soap, (const struct __ngw__modifySettingsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__modifyProxyAccessRequest:
		soap_serialize___ngw__modifyProxyAccessRequest(soap, (const struct __ngw__modifyProxyAccessRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__modifyPasswordRequest:
		soap_serialize___ngw__modifyPasswordRequest(soap, (const struct __ngw__modifyPasswordRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__modifyJunkMailSettingsRequest:
		soap_serialize___ngw__modifyJunkMailSettingsRequest(soap, (const struct __ngw__modifyJunkMailSettingsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__modifyJunkEntryRequest:
		soap_serialize___ngw__modifyJunkEntryRequest(soap, (const struct __ngw__modifyJunkEntryRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__modifyItemRequest:
		soap_serialize___ngw__modifyItemRequest(soap, (const struct __ngw__modifyItemRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__markUnReadRequest:
		soap_serialize___ngw__markUnReadRequest(soap, (const struct __ngw__markUnReadRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__markUnPrivateRequest:
		soap_serialize___ngw__markUnPrivateRequest(soap, (const struct __ngw__markUnPrivateRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__markReadRequest:
		soap_serialize___ngw__markReadRequest(soap, (const struct __ngw__markReadRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__markPrivateRequest:
		soap_serialize___ngw__markPrivateRequest(soap, (const struct __ngw__markPrivateRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__logoutRequest:
		soap_serialize___ngw__logoutRequest(soap, (const struct __ngw__logoutRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__loginRequest:
		soap_serialize___ngw__loginRequest(soap, (const struct __ngw__loginRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getUserListRequest:
		soap_serialize___ngw__getUserListRequest(soap, (const struct __ngw__getUserListRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getTimezoneListRequest:
		soap_serialize___ngw__getTimezoneListRequest(soap, (const struct __ngw__getTimezoneListRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getTimestampRequest:
		soap_serialize___ngw__getTimestampRequest(soap, (const struct __ngw__getTimestampRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getSignaturesRequest:
		soap_serialize___ngw__getSignaturesRequest(soap, (const struct __ngw__getSignaturesRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getSettingsRequest:
		soap_serialize___ngw__getSettingsRequest(soap, (const struct __ngw__getSettingsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getRuleListRequest:
		soap_serialize___ngw__getRuleListRequest(soap, (const struct __ngw__getRuleListRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getProxyListRequest:
		soap_serialize___ngw__getProxyListRequest(soap, (const struct __ngw__getProxyListRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getProxyAccessListRequest:
		soap_serialize___ngw__getProxyAccessListRequest(soap, (const struct __ngw__getProxyAccessListRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getQuickMessagesRequest:
		soap_serialize___ngw__getQuickMessagesRequest(soap, (const struct __ngw__getQuickMessagesRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getLibraryListRequest:
		soap_serialize___ngw__getLibraryListRequest(soap, (const struct __ngw__getLibraryListRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getLibraryItemRequest:
		soap_serialize___ngw__getLibraryItemRequest(soap, (const struct __ngw__getLibraryItemRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getJunkMailSettingsRequest:
		soap_serialize___ngw__getJunkMailSettingsRequest(soap, (const struct __ngw__getJunkMailSettingsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getJunkEntriesRequest:
		soap_serialize___ngw__getJunkEntriesRequest(soap, (const struct __ngw__getJunkEntriesRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getItemsRequest:
		soap_serialize___ngw__getItemsRequest(soap, (const struct __ngw__getItemsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getItemRequest:
		soap_serialize___ngw__getItemRequest(soap, (const struct __ngw__getItemRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getFreeBusyRequest:
		soap_serialize___ngw__getFreeBusyRequest(soap, (const struct __ngw__getFreeBusyRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getFolderListRequest:
		soap_serialize___ngw__getFolderListRequest(soap, (const struct __ngw__getFolderListRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getFolderRequest:
		soap_serialize___ngw__getFolderRequest(soap, (const struct __ngw__getFolderRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getDocumentTypeListRequest:
		soap_serialize___ngw__getDocumentTypeListRequest(soap, (const struct __ngw__getDocumentTypeListRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getDeltaInfoRequest:
		soap_serialize___ngw__getDeltaInfoRequest(soap, (const struct __ngw__getDeltaInfoRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getDeltasRequest:
		soap_serialize___ngw__getDeltasRequest(soap, (const struct __ngw__getDeltasRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getCustomListRequest:
		soap_serialize___ngw__getCustomListRequest(soap, (const struct __ngw__getCustomListRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getCategoryListRequest:
		soap_serialize___ngw__getCategoryListRequest(soap, (const struct __ngw__getCategoryListRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__getAttachmentRequestMessage:
		soap_serialize___ngw__getAttachmentRequestMessage(soap, (const struct __ngw__getAttachmentRequestMessage *)ptr);
		break;
	case SOAP_TYPE___ngw__getAddressBookListRequest:
		soap_serialize___ngw__getAddressBookListRequest(soap, (const struct __ngw__getAddressBookListRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__forwardRequest:
		soap_serialize___ngw__forwardRequest(soap, (const struct __ngw__forwardRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__executeRuleRequest:
		soap_serialize___ngw__executeRuleRequest(soap, (const struct __ngw__executeRuleRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__destroyCursorRequest:
		soap_serialize___ngw__destroyCursorRequest(soap, (const struct __ngw__destroyCursorRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__delegateRequest:
		soap_serialize___ngw__delegateRequest(soap, (const struct __ngw__delegateRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__declineRequest:
		soap_serialize___ngw__declineRequest(soap, (const struct __ngw__declineRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__createSignatureRequest:
		soap_serialize___ngw__createSignatureRequest(soap, (const struct __ngw__createSignatureRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__createProxyAccessRequest:
		soap_serialize___ngw__createProxyAccessRequest(soap, (const struct __ngw__createProxyAccessRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__createJunkEntryRequest:
		soap_serialize___ngw__createJunkEntryRequest(soap, (const struct __ngw__createJunkEntryRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__createItemsRequest:
		soap_serialize___ngw__createItemsRequest(soap, (const struct __ngw__createItemsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__createItemRequest:
		soap_serialize___ngw__createItemRequest(soap, (const struct __ngw__createItemRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__createCursorRequest:
		soap_serialize___ngw__createCursorRequest(soap, (const struct __ngw__createCursorRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__completeRequest:
		soap_serialize___ngw__completeRequest(soap, (const struct __ngw__completeRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__closeFreeBusySessionRequest:
		soap_serialize___ngw__closeFreeBusySessionRequest(soap, (const struct __ngw__closeFreeBusySessionRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__addMembersRequest:
		soap_serialize___ngw__addMembersRequest(soap, (const struct __ngw__addMembersRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__addItemsRequest:
		soap_serialize___ngw__addItemsRequest(soap, (const struct __ngw__addItemsRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__addItemRequest:
		soap_serialize___ngw__addItemRequest(soap, (const struct __ngw__addItemRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__acceptShareRequest:
		soap_serialize___ngw__acceptShareRequest(soap, (const struct __ngw__acceptShareRequest *)ptr);
		break;
	case SOAP_TYPE___ngw__acceptRequest:
		soap_serialize___ngw__acceptRequest(soap, (const struct __ngw__acceptRequest *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__removeEventsResponse:
		soap_serialize_PointerTo_ngwe__removeEventsResponse(soap, (_ngwe__removeEventsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__removeEventsRequest:
		soap_serialize_PointerTo_ngwe__removeEventsRequest(soap, (_ngwe__removeEventsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__removeEventConfigurationResponse:
		soap_serialize_PointerTo_ngwe__removeEventConfigurationResponse(soap, (_ngwe__removeEventConfigurationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__removeEventConfigurationRequest:
		soap_serialize_PointerTo_ngwe__removeEventConfigurationRequest(soap, (_ngwe__removeEventConfigurationRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__getEventsResponse:
		soap_serialize_PointerTo_ngwe__getEventsResponse(soap, (_ngwe__getEventsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__getEventsRequest:
		soap_serialize_PointerTo_ngwe__getEventsRequest(soap, (_ngwe__getEventsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__getEventConfigurationResponse:
		soap_serialize_PointerTo_ngwe__getEventConfigurationResponse(soap, (_ngwe__getEventConfigurationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__getEventConfigurationRequest:
		soap_serialize_PointerTo_ngwe__getEventConfigurationRequest(soap, (_ngwe__getEventConfigurationRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__configureEventsResponse:
		soap_serialize_PointerTo_ngwe__configureEventsResponse(soap, (_ngwe__configureEventsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__configureEventsRequest:
		soap_serialize_PointerTo_ngwe__configureEventsRequest(soap, (_ngwe__configureEventsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__cleanEventConfigurationResponse:
		soap_serialize_PointerTo_ngwe__cleanEventConfigurationResponse(soap, (_ngwe__cleanEventConfigurationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwe__cleanEventConfigurationRequest:
		soap_serialize_PointerTo_ngwe__cleanEventConfigurationRequest(soap, (_ngwe__cleanEventConfigurationRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__updateVersionStatusResponse:
		soap_serialize_PointerTo_ngwm__updateVersionStatusResponse(soap, (_ngwm__updateVersionStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__updateVersionStatusRequest:
		soap_serialize_PointerTo_ngwm__updateVersionStatusRequest(soap, (_ngwm__updateVersionStatusRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__uncompleteResponse:
		soap_serialize_PointerTo_ngwm__uncompleteResponse(soap, (_ngwm__uncompleteResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__uncompleteRequest:
		soap_serialize_PointerTo_ngwm__uncompleteRequest(soap, (_ngwm__uncompleteRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__unacceptResponse:
		soap_serialize_PointerTo_ngwm__unacceptResponse(soap, (_ngwm__unacceptResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__unacceptRequest:
		soap_serialize_PointerTo_ngwm__unacceptRequest(soap, (_ngwm__unacceptRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__startFreeBusySessionResponse:
		soap_serialize_PointerTo_ngwm__startFreeBusySessionResponse(soap, (_ngwm__startFreeBusySessionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__startFreeBusySessionRequest:
		soap_serialize_PointerTo_ngwm__startFreeBusySessionRequest(soap, (_ngwm__startFreeBusySessionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__setTimestampResponse:
		soap_serialize_PointerTo_ngwm__setTimestampResponse(soap, (_ngwm__setTimestampResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__setTimestampRequest:
		soap_serialize_PointerTo_ngwm__setTimestampRequest(soap, (_ngwm__setTimestampRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__sendItemResponse:
		soap_serialize_PointerTo_ngwm__sendItemResponse(soap, (_ngwm__sendItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__sendItemRequest:
		soap_serialize_PointerTo_ngwm__sendItemRequest(soap, (_ngwm__sendItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__retractResponse:
		soap_serialize_PointerTo_ngwm__retractResponse(soap, (_ngwm__retractResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__retractRequest:
		soap_serialize_PointerTo_ngwm__retractRequest(soap, (_ngwm__retractRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__replyResponse:
		soap_serialize_PointerTo_ngwm__replyResponse(soap, (_ngwm__replyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__replyRequest:
		soap_serialize_PointerTo_ngwm__replyRequest(soap, (_ngwm__replyRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeSignatureResponse:
		soap_serialize_PointerTo_ngwm__removeSignatureResponse(soap, (_ngwm__removeSignatureResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeSignatureRequest:
		soap_serialize_PointerTo_ngwm__removeSignatureRequest(soap, (_ngwm__removeSignatureRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeProxyUserResponse:
		soap_serialize_PointerTo_ngwm__removeProxyUserResponse(soap, (_ngwm__removeProxyUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeProxyUserRequest:
		soap_serialize_PointerTo_ngwm__removeProxyUserRequest(soap, (_ngwm__removeProxyUserRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeProxyAccessResponse:
		soap_serialize_PointerTo_ngwm__removeProxyAccessResponse(soap, (_ngwm__removeProxyAccessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeProxyAccessRequest:
		soap_serialize_PointerTo_ngwm__removeProxyAccessRequest(soap, (_ngwm__removeProxyAccessRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeMembersResponse:
		soap_serialize_PointerTo_ngwm__removeMembersResponse(soap, (_ngwm__removeMembersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeMembersRequest:
		soap_serialize_PointerTo_ngwm__removeMembersRequest(soap, (_ngwm__removeMembersRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeJunkEntryResponse:
		soap_serialize_PointerTo_ngwm__removeJunkEntryResponse(soap, (_ngwm__removeJunkEntryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeJunkEntryRequest:
		soap_serialize_PointerTo_ngwm__removeJunkEntryRequest(soap, (_ngwm__removeJunkEntryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeItemsResponse:
		soap_serialize_PointerTo_ngwm__removeItemsResponse(soap, (_ngwm__removeItemsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeItemsRequest:
		soap_serialize_PointerTo_ngwm__removeItemsRequest(soap, (_ngwm__removeItemsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeItemResponse:
		soap_serialize_PointerTo_ngwm__removeItemResponse(soap, (_ngwm__removeItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeItemRequest:
		soap_serialize_PointerTo_ngwm__removeItemRequest(soap, (_ngwm__removeItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeCustomDefinitionResponse:
		soap_serialize_PointerTo_ngwm__removeCustomDefinitionResponse(soap, (_ngwm__removeCustomDefinitionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__removeCustomDefinitionRequest:
		soap_serialize_PointerTo_ngwm__removeCustomDefinitionRequest(soap, (_ngwm__removeCustomDefinitionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__readCursorResponse:
		soap_serialize_PointerTo_ngwm__readCursorResponse(soap, (_ngwm__readCursorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__readCursorRequest:
		soap_serialize_PointerTo_ngwm__readCursorRequest(soap, (_ngwm__readCursorRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__purgeResponse:
		soap_serialize_PointerTo_ngwm__purgeResponse(soap, (_ngwm__purgeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__purgeRequest:
		soap_serialize_PointerTo_ngwm__purgeRequest(soap, (_ngwm__purgeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__purgeDeletedItemsResponse:
		soap_serialize_PointerTo_ngwm__purgeDeletedItemsResponse(soap, (_ngwm__purgeDeletedItemsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__purgeDeletedItemsRequest:
		soap_serialize_PointerTo_ngwm__purgeDeletedItemsRequest(soap, (_ngwm__purgeDeletedItemsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__positionCursorResponse:
		soap_serialize_PointerTo_ngwm__positionCursorResponse(soap, (_ngwm__positionCursorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__positionCursorRequest:
		soap_serialize_PointerTo_ngwm__positionCursorRequest(soap, (_ngwm__positionCursorRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__moveItemResponse:
		soap_serialize_PointerTo_ngwm__moveItemResponse(soap, (_ngwm__moveItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__moveItemRequest:
		soap_serialize_PointerTo_ngwm__moveItemRequest(soap, (_ngwm__moveItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifySignaturesResponse:
		soap_serialize_PointerTo_ngwm__modifySignaturesResponse(soap, (_ngwm__modifySignaturesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifySignaturesRequest:
		soap_serialize_PointerTo_ngwm__modifySignaturesRequest(soap, (_ngwm__modifySignaturesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifySettingsResponse:
		soap_serialize_PointerTo_ngwm__modifySettingsResponse(soap, (_ngwm__modifySettingsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifySettingsRequest:
		soap_serialize_PointerTo_ngwm__modifySettingsRequest(soap, (_ngwm__modifySettingsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifyProxyAccessResponse:
		soap_serialize_PointerTo_ngwm__modifyProxyAccessResponse(soap, (_ngwm__modifyProxyAccessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifyProxyAccessRequest:
		soap_serialize_PointerTo_ngwm__modifyProxyAccessRequest(soap, (_ngwm__modifyProxyAccessRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifyPasswordResponse:
		soap_serialize_PointerTo_ngwm__modifyPasswordResponse(soap, (_ngwm__modifyPasswordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifyPasswordRequest:
		soap_serialize_PointerTo_ngwm__modifyPasswordRequest(soap, (_ngwm__modifyPasswordRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkMailSettingsResponse:
		soap_serialize_PointerTo_ngwm__modifyJunkMailSettingsResponse(soap, (_ngwm__modifyJunkMailSettingsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkMailSettingsRequest:
		soap_serialize_PointerTo_ngwm__modifyJunkMailSettingsRequest(soap, (_ngwm__modifyJunkMailSettingsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkEntryResponse:
		soap_serialize_PointerTo_ngwm__modifyJunkEntryResponse(soap, (_ngwm__modifyJunkEntryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifyJunkEntryRequest:
		soap_serialize_PointerTo_ngwm__modifyJunkEntryRequest(soap, (_ngwm__modifyJunkEntryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifyItemResponse:
		soap_serialize_PointerTo_ngwm__modifyItemResponse(soap, (_ngwm__modifyItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__modifyItemRequest:
		soap_serialize_PointerTo_ngwm__modifyItemRequest(soap, (_ngwm__modifyItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__markUnReadResponse:
		soap_serialize_PointerTo_ngwm__markUnReadResponse(soap, (_ngwm__markUnReadResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__markUnReadRequest:
		soap_serialize_PointerTo_ngwm__markUnReadRequest(soap, (_ngwm__markUnReadRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__markUnPrivateResponse:
		soap_serialize_PointerTo_ngwm__markUnPrivateResponse(soap, (_ngwm__markUnPrivateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__markUnPrivateRequest:
		soap_serialize_PointerTo_ngwm__markUnPrivateRequest(soap, (_ngwm__markUnPrivateRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__markReadResponse:
		soap_serialize_PointerTo_ngwm__markReadResponse(soap, (_ngwm__markReadResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__markReadRequest:
		soap_serialize_PointerTo_ngwm__markReadRequest(soap, (_ngwm__markReadRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__markPrivateResponse:
		soap_serialize_PointerTo_ngwm__markPrivateResponse(soap, (_ngwm__markPrivateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__markPrivateRequest:
		soap_serialize_PointerTo_ngwm__markPrivateRequest(soap, (_ngwm__markPrivateRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__logoutResponse:
		soap_serialize_PointerTo_ngwm__logoutResponse(soap, (_ngwm__logoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__logoutRequest:
		soap_serialize_PointerTo_ngwm__logoutRequest(soap, (_ngwm__logoutRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__loginResponse:
		soap_serialize_PointerTo_ngwm__loginResponse(soap, (_ngwm__loginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__loginRequest:
		soap_serialize_PointerTo_ngwm__loginRequest(soap, (_ngwm__loginRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getUserListResponse:
		soap_serialize_PointerTo_ngwm__getUserListResponse(soap, (_ngwm__getUserListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getUserListRequest:
		soap_serialize_PointerTo_ngwm__getUserListRequest(soap, (_ngwm__getUserListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getTimezoneListResponse:
		soap_serialize_PointerTo_ngwm__getTimezoneListResponse(soap, (_ngwm__getTimezoneListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getTimezoneListRequest:
		soap_serialize_PointerTo_ngwm__getTimezoneListRequest(soap, (_ngwm__getTimezoneListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getTimestampResponse:
		soap_serialize_PointerTo_ngwm__getTimestampResponse(soap, (_ngwm__getTimestampResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getTimestampRequest:
		soap_serialize_PointerTo_ngwm__getTimestampRequest(soap, (_ngwm__getTimestampRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getSignaturesResponse:
		soap_serialize_PointerTo_ngwm__getSignaturesResponse(soap, (_ngwm__getSignaturesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getSignaturesRequest:
		soap_serialize_PointerTo_ngwm__getSignaturesRequest(soap, (_ngwm__getSignaturesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getSettingsResponse:
		soap_serialize_PointerTo_ngwm__getSettingsResponse(soap, (_ngwm__getSettingsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getSettingsRequest:
		soap_serialize_PointerTo_ngwm__getSettingsRequest(soap, (_ngwm__getSettingsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getRuleListResponse:
		soap_serialize_PointerTo_ngwm__getRuleListResponse(soap, (_ngwm__getRuleListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getRuleListRequest:
		soap_serialize_PointerTo_ngwm__getRuleListRequest(soap, (_ngwm__getRuleListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getProxyListResponse:
		soap_serialize_PointerTo_ngwm__getProxyListResponse(soap, (_ngwm__getProxyListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getProxyListRequest:
		soap_serialize_PointerTo_ngwm__getProxyListRequest(soap, (_ngwm__getProxyListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getProxyAccessListResponse:
		soap_serialize_PointerTo_ngwm__getProxyAccessListResponse(soap, (_ngwm__getProxyAccessListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getProxyAccessListRequest:
		soap_serialize_PointerTo_ngwm__getProxyAccessListRequest(soap, (_ngwm__getProxyAccessListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getQuickMessagesResponse:
		soap_serialize_PointerTo_ngwm__getQuickMessagesResponse(soap, (_ngwm__getQuickMessagesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getQuickMessagesRequest:
		soap_serialize_PointerTo_ngwm__getQuickMessagesRequest(soap, (_ngwm__getQuickMessagesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getLibraryListResponse:
		soap_serialize_PointerTo_ngwm__getLibraryListResponse(soap, (_ngwm__getLibraryListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getLibraryListRequest:
		soap_serialize_PointerTo_ngwm__getLibraryListRequest(soap, (_ngwm__getLibraryListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getLibraryItemResponse:
		soap_serialize_PointerTo_ngwm__getLibraryItemResponse(soap, (_ngwm__getLibraryItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getLibraryItemRequest:
		soap_serialize_PointerTo_ngwm__getLibraryItemRequest(soap, (_ngwm__getLibraryItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getJunkMailSettingsResponse:
		soap_serialize_PointerTo_ngwm__getJunkMailSettingsResponse(soap, (_ngwm__getJunkMailSettingsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getJunkMailSettingsRequest:
		soap_serialize_PointerTo_ngwm__getJunkMailSettingsRequest(soap, (_ngwm__getJunkMailSettingsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getJunkEntriesResponse:
		soap_serialize_PointerTo_ngwm__getJunkEntriesResponse(soap, (_ngwm__getJunkEntriesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getJunkEntriesRequest:
		soap_serialize_PointerTo_ngwm__getJunkEntriesRequest(soap, (_ngwm__getJunkEntriesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getItemsResponse:
		soap_serialize_PointerTo_ngwm__getItemsResponse(soap, (_ngwm__getItemsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getItemsRequest:
		soap_serialize_PointerTo_ngwm__getItemsRequest(soap, (_ngwm__getItemsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getItemResponse:
		soap_serialize_PointerTo_ngwm__getItemResponse(soap, (_ngwm__getItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getItemRequest:
		soap_serialize_PointerTo_ngwm__getItemRequest(soap, (_ngwm__getItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getFreeBusyResponse:
		soap_serialize_PointerTo_ngwm__getFreeBusyResponse(soap, (_ngwm__getFreeBusyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getFreeBusyRequest:
		soap_serialize_PointerTo_ngwm__getFreeBusyRequest(soap, (_ngwm__getFreeBusyRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getFolderListResponse:
		soap_serialize_PointerTo_ngwm__getFolderListResponse(soap, (_ngwm__getFolderListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getFolderListRequest:
		soap_serialize_PointerTo_ngwm__getFolderListRequest(soap, (_ngwm__getFolderListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getFolderResponse:
		soap_serialize_PointerTo_ngwm__getFolderResponse(soap, (_ngwm__getFolderResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getFolderRequest:
		soap_serialize_PointerTo_ngwm__getFolderRequest(soap, (_ngwm__getFolderRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getDocumentTypeListResponse:
		soap_serialize_PointerTo_ngwm__getDocumentTypeListResponse(soap, (_ngwm__getDocumentTypeListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getDocumentTypeListRequest:
		soap_serialize_PointerTo_ngwm__getDocumentTypeListRequest(soap, (_ngwm__getDocumentTypeListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getDeltaInfoResponse:
		soap_serialize_PointerTo_ngwm__getDeltaInfoResponse(soap, (_ngwm__getDeltaInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getDeltaInfoRequest:
		soap_serialize_PointerTo_ngwm__getDeltaInfoRequest(soap, (_ngwm__getDeltaInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getDeltasResponse:
		soap_serialize_PointerTo_ngwm__getDeltasResponse(soap, (_ngwm__getDeltasResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getDeltasRequest:
		soap_serialize_PointerTo_ngwm__getDeltasRequest(soap, (_ngwm__getDeltasRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getCustomListResponse:
		soap_serialize_PointerTo_ngwm__getCustomListResponse(soap, (_ngwm__getCustomListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getCustomListRequest:
		soap_serialize_PointerTo_ngwm__getCustomListRequest(soap, (_ngwm__getCustomListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getCategoryListResponse:
		soap_serialize_PointerTo_ngwm__getCategoryListResponse(soap, (_ngwm__getCategoryListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getCategoryListRequest:
		soap_serialize_PointerTo_ngwm__getCategoryListRequest(soap, (_ngwm__getCategoryListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getAttachmentResponse:
		soap_serialize_PointerTo_ngwm__getAttachmentResponse(soap, (_ngwm__getAttachmentResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getAttachmentRequest:
		soap_serialize_PointerTo_ngwm__getAttachmentRequest(soap, (_ngwm__getAttachmentRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getAddressBookListResponse:
		soap_serialize_PointerTo_ngwm__getAddressBookListResponse(soap, (_ngwm__getAddressBookListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__getAddressBookListRequest:
		soap_serialize_PointerTo_ngwm__getAddressBookListRequest(soap, (_ngwm__getAddressBookListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__forwardResponse:
		soap_serialize_PointerTo_ngwm__forwardResponse(soap, (_ngwm__forwardResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__forwardRequest:
		soap_serialize_PointerTo_ngwm__forwardRequest(soap, (_ngwm__forwardRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__executeRuleResponse:
		soap_serialize_PointerTo_ngwm__executeRuleResponse(soap, (_ngwm__executeRuleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__executeRuleRequest:
		soap_serialize_PointerTo_ngwm__executeRuleRequest(soap, (_ngwm__executeRuleRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__destroyCursorResponse:
		soap_serialize_PointerTo_ngwm__destroyCursorResponse(soap, (_ngwm__destroyCursorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__destroyCursorRequest:
		soap_serialize_PointerTo_ngwm__destroyCursorRequest(soap, (_ngwm__destroyCursorRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__delegateResponse:
		soap_serialize_PointerTo_ngwm__delegateResponse(soap, (_ngwm__delegateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__delegateRequest:
		soap_serialize_PointerTo_ngwm__delegateRequest(soap, (_ngwm__delegateRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__declineResponse:
		soap_serialize_PointerTo_ngwm__declineResponse(soap, (_ngwm__declineResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__declineRequest:
		soap_serialize_PointerTo_ngwm__declineRequest(soap, (_ngwm__declineRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createSignatureResponse:
		soap_serialize_PointerTo_ngwm__createSignatureResponse(soap, (_ngwm__createSignatureResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createSignatureRequest:
		soap_serialize_PointerTo_ngwm__createSignatureRequest(soap, (_ngwm__createSignatureRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createProxyAccessResponse:
		soap_serialize_PointerTo_ngwm__createProxyAccessResponse(soap, (_ngwm__createProxyAccessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createProxyAccessRequest:
		soap_serialize_PointerTo_ngwm__createProxyAccessRequest(soap, (_ngwm__createProxyAccessRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createJunkEntryResponse:
		soap_serialize_PointerTo_ngwm__createJunkEntryResponse(soap, (_ngwm__createJunkEntryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createJunkEntryRequest:
		soap_serialize_PointerTo_ngwm__createJunkEntryRequest(soap, (_ngwm__createJunkEntryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createItemsResponse:
		soap_serialize_PointerTo_ngwm__createItemsResponse(soap, (_ngwm__createItemsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createItemsRequest:
		soap_serialize_PointerTo_ngwm__createItemsRequest(soap, (_ngwm__createItemsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createItemResponse:
		soap_serialize_PointerTo_ngwm__createItemResponse(soap, (_ngwm__createItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createItemRequest:
		soap_serialize_PointerTo_ngwm__createItemRequest(soap, (_ngwm__createItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createCursorResponse:
		soap_serialize_PointerTo_ngwm__createCursorResponse(soap, (_ngwm__createCursorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__createCursorRequest:
		soap_serialize_PointerTo_ngwm__createCursorRequest(soap, (_ngwm__createCursorRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__completeResponse:
		soap_serialize_PointerTo_ngwm__completeResponse(soap, (_ngwm__completeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__completeRequest:
		soap_serialize_PointerTo_ngwm__completeRequest(soap, (_ngwm__completeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__closeFreeBusySessionResponse:
		soap_serialize_PointerTo_ngwm__closeFreeBusySessionResponse(soap, (_ngwm__closeFreeBusySessionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__closeFreeBusySessionRequest:
		soap_serialize_PointerTo_ngwm__closeFreeBusySessionRequest(soap, (_ngwm__closeFreeBusySessionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__addMembersResponse:
		soap_serialize_PointerTo_ngwm__addMembersResponse(soap, (_ngwm__addMembersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__addMembersRequest:
		soap_serialize_PointerTo_ngwm__addMembersRequest(soap, (_ngwm__addMembersRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__addItemsResponse:
		soap_serialize_PointerTo_ngwm__addItemsResponse(soap, (_ngwm__addItemsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__addItemsRequest:
		soap_serialize_PointerTo_ngwm__addItemsRequest(soap, (_ngwm__addItemsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__addItemResponse:
		soap_serialize_PointerTo_ngwm__addItemResponse(soap, (_ngwm__addItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__addItemRequest:
		soap_serialize_PointerTo_ngwm__addItemRequest(soap, (_ngwm__addItemRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__acceptShareResponse:
		soap_serialize_PointerTo_ngwm__acceptShareResponse(soap, (_ngwm__acceptShareResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__acceptShareRequest:
		soap_serialize_PointerTo_ngwm__acceptShareRequest(soap, (_ngwm__acceptShareRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__acceptResponse:
		soap_serialize_PointerTo_ngwm__acceptResponse(soap, (_ngwm__acceptResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ngwm__acceptRequest:
		soap_serialize_PointerTo_ngwm__acceptRequest(soap, (_ngwm__acceptRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Alarm:
		soap_serialize_PointerTongwt__Alarm(soap, (ngwt__Alarm *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__PhoneFlags:
		soap_serialize_PointerTongwt__PhoneFlags(soap, (ngwt__PhoneFlags *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__RecurrenceRule:
		soap_serialize_PointerTongwt__RecurrenceRule(soap, (ngwt__RecurrenceRule *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__RecurrenceDateType:
		soap_serialize_PointerTongwt__RecurrenceDateType(soap, (ngwt__RecurrenceDateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__SMimeOperation:
		soap_serialize_PointerTongwt__SMimeOperation(soap, (ngwt__SMimeOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__LinkInfo:
		soap_serialize_PointerTongwt__LinkInfo(soap, (ngwt__LinkInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ItemOptions:
		soap_serialize_PointerTongwt__ItemOptions(soap, (ngwt__ItemOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AttachmentInfo:
		soap_serialize_PointerTongwt__AttachmentInfo(soap, (ngwt__AttachmentInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__MessageBody:
		soap_serialize_PointerTongwt__MessageBody(soap, (ngwt__MessageBody *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ReferenceInfo:
		soap_serialize_PointerTongwt__ReferenceInfo(soap, (ngwt__ReferenceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__PersonalInfo:
		soap_serialize_PointerTongwt__PersonalInfo(soap, (ngwt__PersonalInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__OfficeInfo:
		soap_serialize_PointerTongwt__OfficeInfo(soap, (ngwt__OfficeInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__PostalAddressList:
		soap_serialize_PointerTongwt__PostalAddressList(soap, (ngwt__PostalAddressList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__PhoneList:
		soap_serialize_PointerTongwt__PhoneList(soap, (ngwt__PhoneList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ImAddressList:
		soap_serialize_PointerTongwt__ImAddressList(soap, (ngwt__ImAddressList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__EmailAddressList:
		soap_serialize_PointerTongwt__EmailAddressList(soap, (ngwt__EmailAddressList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FullName:
		soap_serialize_PointerTongwt__FullName(soap, (ngwt__FullName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__VersionStatus:
		soap_serialize_PointerTongwt__VersionStatus(soap, (enum ngwt__VersionStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FolderACL:
		soap_serialize_PointerTongwt__FolderACL(soap, (ngwt__FolderACL *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__RuleActionList:
		soap_serialize_PointerTongwt__RuleActionList(soap, (ngwt__RuleActionList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Execution:
		soap_serialize_PointerTongwt__Execution(soap, (enum ngwt__Execution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Query:
		soap_serialize_PointerTongwt__Query(soap, (ngwt__Query *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FolderACLStatus:
		soap_serialize_PointerTongwt__FolderACLStatus(soap, (enum ngwt__FolderACLStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AccessControlList:
		soap_serialize_PointerTongwt__AccessControlList(soap, (ngwt__AccessControlList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__WeekOfYear:
		soap_serialize_PointerTongwt__WeekOfYear(soap, (short *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__OccurrenceType:
		soap_serialize_PointerTongwt__OccurrenceType(soap, (enum ngwt__OccurrenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ItemSecurity:
		soap_serialize_PointerTongwt__ItemSecurity(soap, (enum ngwt__ItemSecurity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ItemClass:
		soap_serialize_PointerTongwt__ItemClass(soap, (enum ngwt__ItemClass *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ItemSource:
		soap_serialize_PointerTongwt__ItemSource(soap, (enum ngwt__ItemSource *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ItemStatus:
		soap_serialize_PointerTongwt__ItemStatus(soap, (ngwt__ItemStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__DeltaSyncType:
		soap_serialize_PointerTongwt__DeltaSyncType(soap, (enum ngwt__DeltaSyncType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__RecipientStatus:
		soap_serialize_PointerTongwt__RecipientStatus(soap, (ngwt__RecipientStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FreeBusyBlockList:
		soap_serialize_PointerTongwt__FreeBusyBlockList(soap, (ngwt__FreeBusyBlockList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__CalendarFolderAttribute:
		soap_serialize_PointerTongwt__CalendarFolderAttribute(soap, (ngwt__CalendarFolderAttribute *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FilterDate:
		soap_serialize_PointerTongwt__FilterDate(soap, (enum ngwt__FilterDate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ContainerRef:
		soap_serialize_PointerTongwt__ContainerRef(soap, (ngwt__ContainerRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__CategoryType:
		soap_serialize_PointerTongwt__CategoryType(soap, (enum ngwt__CategoryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AccessMiscRight:
		soap_serialize_PointerTongwt__AccessMiscRight(soap, (ngwt__AccessMiscRight *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AccessRight:
		soap_serialize_PointerTongwt__AccessRight(soap, (ngwt__AccessRight *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Rights:
		soap_serialize_PointerTongwt__Rights(soap, (ngwt__Rights *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwe__EventList:
		soap_serialize_PointerTongwe__EventList(soap, (ngwe__EventList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwe__EventsList:
		soap_serialize_PointerTongwe__EventsList(soap, (ngwe__EventsList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwe__Events:
		soap_serialize_PointerTongwe__Events(soap, (ngwe__Events *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwe__EventDefinition:
		soap_serialize_PointerTongwe__EventDefinition(soap, (ngwe__EventDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwe__Event:
		soap_serialize_PointerTongwe__Event(soap, (ngwe__Event *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwe__ContainerList:
		soap_serialize_PointerTongwe__ContainerList(soap, (ngwe__ContainerList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwe__ItemTypeList:
		soap_serialize_PointerTongwe__ItemTypeList(soap, (enum ngwe__ItemTypeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwe__EventTypeList:
		soap_serialize_PointerTongwe__EventTypeList(soap, (ngwe__EventTypeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwe__ItemType:
		soap_serialize_PointerTongwe__ItemType(soap, (enum ngwe__ItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwe__FieldList:
		soap_serialize_PointerTongwe__FieldList(soap, (enum ngwe__FieldList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FreeBusyUserList:
		soap_serialize_PointerTongwt__FreeBusyUserList(soap, (ngwt__FreeBusyUserList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__RetractType:
		soap_serialize_PointerTongwt__RetractType(soap, (enum ngwt__RetractType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ItemList:
		soap_serialize_PointerTongwt__ItemList(soap, (ngwt__ItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__CursorSeek:
		soap_serialize_PointerTongwt__CursorSeek(soap, (enum ngwt__CursorSeek *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AccessRightChanges:
		soap_serialize_PointerTongwt__AccessRightChanges(soap, (ngwt__AccessRightChanges *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ModifyItem:
		soap_serialize_PointerTongwt__ModifyItem(soap, (ngwt__ModifyItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Host:
		soap_serialize_PointerTongwt__Host(soap, (ngwt__Host *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Authentication:
		soap_serialize_PointerTongwt__Authentication(soap, (ngwt__Authentication *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__UserList:
		soap_serialize_PointerTongwt__UserList(soap, (ngwt__UserList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__TimezoneList:
		soap_serialize_PointerTongwt__TimezoneList(soap, (ngwt__TimezoneList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Signatures:
		soap_serialize_PointerTongwt__Signatures(soap, (ngwt__Signatures *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Settings:
		soap_serialize_PointerTongwt__Settings(soap, (ngwt__Settings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__RuleList:
		soap_serialize_PointerTongwt__RuleList(soap, (ngwt__RuleList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ProxyList:
		soap_serialize_PointerTongwt__ProxyList(soap, (ngwt__ProxyList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AccessRightList:
		soap_serialize_PointerTongwt__AccessRightList(soap, (ngwt__AccessRightList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__LibraryList:
		soap_serialize_PointerTongwt__LibraryList(soap, (ngwt__LibraryList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__SettingsList:
		soap_serialize_PointerTongwt__SettingsList(soap, (ngwt__SettingsList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__JunkHandlingList:
		soap_serialize_PointerTongwt__JunkHandlingList(soap, (ngwt__JunkHandlingList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FreeBusyInfoList:
		soap_serialize_PointerTongwt__FreeBusyInfoList(soap, (ngwt__FreeBusyInfoList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FreeBusyStats:
		soap_serialize_PointerTongwt__FreeBusyStats(soap, (ngwt__FreeBusyStats *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FolderList:
		soap_serialize_PointerTongwt__FolderList(soap, (ngwt__FolderList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ItemSourceList:
		soap_serialize_PointerTongwt__ItemSourceList(soap, (enum ngwt__ItemSourceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__MessageTypeList:
		soap_serialize_PointerTongwt__MessageTypeList(soap, (enum ngwt__MessageTypeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FolderType:
		soap_serialize_PointerTongwt__FolderType(soap, (enum ngwt__FolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__DocumentTypeList:
		soap_serialize_PointerTongwt__DocumentTypeList(soap, (ngwt__DocumentTypeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Items:
		soap_serialize_PointerTongwt__Items(soap, (ngwt__Items *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__DeltaInfo:
		soap_serialize_PointerTongwt__DeltaInfo(soap, (ngwt__DeltaInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__CustomList:
		soap_serialize_PointerTongwt__CustomList(soap, (ngwt__CustomList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__CategoryList:
		soap_serialize_PointerTongwt__CategoryList(soap, (ngwt__CategoryList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AddressBookList:
		soap_serialize_PointerTongwt__AddressBookList(soap, (ngwt__AddressBookList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Distribution:
		soap_serialize_PointerTongwt__Distribution(soap, (ngwt__Distribution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__View:
		soap_serialize_PointerTongwt__View(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Status:
		soap_serialize_PointerTongwt__Status(soap, (ngwt__Status *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ItemRefList:
		soap_serialize_PointerTongwt__ItemRefList(soap, (ngwt__ItemRefList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__UserInfo:
		soap_serialize_PointerTongwt__UserInfo(soap, (ngwt__UserInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__RecipientType:
		soap_serialize_PointerTongwt__RecipientType(soap, (enum ngwt__RecipientType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Timezone:
		soap_serialize_PointerTongwt__Timezone(soap, (ngwt__Timezone *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Minute:
		soap_serialize_PointerTongwt__Minute(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Hour:
		soap_serialize_PointerTongwt__Hour(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__DayOfWeek:
		soap_serialize_PointerTongwt__DayOfWeek(soap, (ngwt__DayOfWeek *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Day:
		soap_serialize_PointerTongwt__Day(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Month:
		soap_serialize_PointerTongwt__Month(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__TimezoneComponent:
		soap_serialize_PointerTongwt__TimezoneComponent(soap, (ngwt__TimezoneComponent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ProblemList:
		soap_serialize_PointerTongwt__ProblemList(soap, (ngwt__ProblemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Signature:
		soap_serialize_PointerTongwt__Signature(soap, (ngwt__Signature *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__SignatureData:
		soap_serialize_PointerTongwt__SignatureData(soap, (ngwt__SignatureData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__SettingsGroup:
		soap_serialize_PointerTongwt__SettingsGroup(soap, (ngwt__SettingsGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ReturnNotification:
		soap_serialize_PointerTongwt__ReturnNotification(soap, (ngwt__ReturnNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__StatusTracking:
		soap_serialize_PointerTongwt__StatusTracking(soap, (ngwt__StatusTracking *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__SendOptionsRequestReply:
		soap_serialize_PointerTongwt__SendOptionsRequestReply(soap, (ngwt__SendOptionsRequestReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Rule:
		soap_serialize_PointerTongwt__Rule(soap, (ngwt__Rule *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__RuleAction:
		soap_serialize_PointerTongwt__RuleAction(soap, (ngwt__RuleAction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__CategoryRefList:
		soap_serialize_PointerTongwt__CategoryRefList(soap, (ngwt__CategoryRefList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Mail:
		soap_serialize_PointerTongwt__Mail(soap, (ngwt__Mail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ReturnNotificationOptions:
		soap_serialize_PointerTongwt__ReturnNotificationOptions(soap, (ngwt__ReturnNotificationOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__MonthList:
		soap_serialize_PointerTongwt__MonthList(soap, (ngwt__MonthList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__DayOfYearList:
		soap_serialize_PointerTongwt__DayOfYearList(soap, (ngwt__DayOfYearList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__DayOfMonthList:
		soap_serialize_PointerTongwt__DayOfMonthList(soap, (ngwt__DayOfMonthList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__DayOfYearWeekList:
		soap_serialize_PointerTongwt__DayOfYearWeekList(soap, (ngwt__DayOfYearWeekList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Frequency:
		soap_serialize_PointerTongwt__Frequency(soap, (enum ngwt__Frequency *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__DelegateeStatus:
		soap_serialize_PointerTongwt__DelegateeStatus(soap, (ngwt__DelegateeStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__DelegatedStatus:
		soap_serialize_PointerTongwt__DelegatedStatus(soap, (ngwt__DelegatedStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__CommentStatus:
		soap_serialize_PointerTongwt__CommentStatus(soap, (ngwt__CommentStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__TransferFailedStatus:
		soap_serialize_PointerTongwt__TransferFailedStatus(soap, (ngwt__TransferFailedStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Recipient:
		soap_serialize_PointerTongwt__Recipient(soap, (ngwt__Recipient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Filter:
		soap_serialize_PointerTongwt__Filter(soap, (ngwt__Filter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__QueryTarget:
		soap_serialize_PointerTongwt__QueryTarget(soap, (ngwt__QueryTarget *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ProxyUser:
		soap_serialize_PointerTongwt__ProxyUser(soap, (ngwt__ProxyUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ProblemEntry:
		soap_serialize_PointerTongwt__ProblemEntry(soap, (ngwt__ProblemEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__PostalAddress:
		soap_serialize_PointerTongwt__PostalAddress(soap, (ngwt__PostalAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__PhoneNumber:
		soap_serialize_PointerTongwt__PhoneNumber(soap, (ngwt__PhoneNumber *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__date:
		soap_serialize_PointerToxsd__date(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ItemRef:
		soap_serialize_PointerTongwt__ItemRef(soap, (ngwt__ItemRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__UUID:
		soap_serialize_PointerTongwt__UUID(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__SharedFolderNotification:
		soap_serialize_PointerTongwt__SharedFolderNotification(soap, (ngwt__SharedFolderNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__MessagePart:
		soap_serialize_PointerTongwt__MessagePart(soap, (ngwt__MessagePart *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Library:
		soap_serialize_PointerTongwt__Library(soap, (ngwt__Library *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__JunkEntry:
		soap_serialize_PointerTongwt__JunkEntry(soap, (ngwt__JunkEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__JunkHandlingListType:
		soap_serialize_PointerTongwt__JunkHandlingListType(soap, (enum ngwt__JunkHandlingListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Item:
		soap_serialize_PointerTongwt__Item(soap, (ngwt__Item *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ItemChanges:
		soap_serialize_PointerTongwt__ItemChanges(soap, (ngwt__ItemChanges *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__ImAddress:
		soap_serialize_PointerTongwt__ImAddress(soap, (ngwt__ImAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__GroupMember:
		soap_serialize_PointerTongwt__GroupMember(soap, (ngwt__GroupMember *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__GroupMemberList:
		soap_serialize_PointerTongwt__GroupMemberList(soap, (ngwt__GroupMemberList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FreeBusyInfo:
		soap_serialize_PointerTongwt__FreeBusyInfo(soap, (ngwt__FreeBusyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__NameAndEmail:
		soap_serialize_PointerTongwt__NameAndEmail(soap, (ngwt__NameAndEmail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AcceptLevel:
		soap_serialize_PointerTongwt__AcceptLevel(soap, (enum ngwt__AcceptLevel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FreeBusyBlock:
		soap_serialize_PointerTongwt__FreeBusyBlock(soap, (ngwt__FreeBusyBlock *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Folder:
		soap_serialize_PointerTongwt__Folder(soap, (ngwt__Folder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FolderACLEntry:
		soap_serialize_PointerTongwt__FolderACLEntry(soap, (ngwt__FolderACLEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__FilterElement:
		soap_serialize_PointerTongwt__FilterElement(soap, (ngwt__FilterElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__DocumentType:
		soap_serialize_PointerTongwt__DocumentType(soap, (ngwt__DocumentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AgeAction:
		soap_serialize_PointerTongwt__AgeAction(soap, (enum ngwt__AgeAction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__SendOptions:
		soap_serialize_PointerTongwt__SendOptions(soap, (ngwt__SendOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__RecipientList:
		soap_serialize_PointerTongwt__RecipientList(soap, (ngwt__RecipientList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__From:
		soap_serialize_PointerTongwt__From(soap, (ngwt__From *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__DayOfYearWeek:
		soap_serialize_PointerTongwt__DayOfYearWeek(soap, (ngwt__DayOfYearWeek *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Custom:
		soap_serialize_PointerTongwt__Custom(soap, (ngwt__Custom *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__CustomType:
		soap_serialize_PointerTongwt__CustomType(soap, (enum ngwt__CustomType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__uid:
		soap_serialize_PointerTongwt__uid(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__Category:
		soap_serialize_PointerTongwt__Category(soap, (ngwt__Category *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedLong:
		soap_serialize_PointerTounsignedLong(soap, (unsigned long *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AttachmentID:
		soap_serialize_PointerTongwt__AttachmentID(soap, (ngwt__AttachmentID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AttachmentItemInfo:
		soap_serialize_PointerTongwt__AttachmentItemInfo(soap, (ngwt__AttachmentItemInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AddressBook:
		soap_serialize_PointerTongwt__AddressBook(soap, (ngwt__AddressBook *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AccessRightEntry:
		soap_serialize_PointerTongwt__AccessRightEntry(soap, (ngwt__AccessRightEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTongwt__AccessControlListEntry:
		soap_serialize_PointerTongwt__AccessControlListEntry(soap, (ngwt__AccessControlListEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AccessControlList:
		return (void*)soap_instantiate_ngwt__AccessControlList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AccessMiscRight:
		return (void*)soap_instantiate_ngwt__AccessMiscRight(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AccessRight:
		return (void*)soap_instantiate_ngwt__AccessRight(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AccessRightChanges:
		return (void*)soap_instantiate_ngwt__AccessRightChanges(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AccessRightList:
		return (void*)soap_instantiate_ngwt__AccessRightList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AddressBookList:
		return (void*)soap_instantiate_ngwt__AddressBookList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AttachmentInfo:
		return (void*)soap_instantiate_ngwt__AttachmentInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AttachmentItemInfo:
		return (void*)soap_instantiate_ngwt__AttachmentItemInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Authentication:
		return (void*)soap_instantiate_ngwt__Authentication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__CalendarFolderAttribute:
		return (void*)soap_instantiate_ngwt__CalendarFolderAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__CategoryList:
		return (void*)soap_instantiate_ngwt__CategoryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__CategoryRefList:
		return (void*)soap_instantiate_ngwt__CategoryRefList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Custom:
		return (void*)soap_instantiate_ngwt__Custom(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__CustomList:
		return (void*)soap_instantiate_ngwt__CustomList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__DayOfMonthList:
		return (void*)soap_instantiate_ngwt__DayOfMonthList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__DayOfYearList:
		return (void*)soap_instantiate_ngwt__DayOfYearList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__DayOfYearWeekList:
		return (void*)soap_instantiate_ngwt__DayOfYearWeekList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__DeltaInfo:
		return (void*)soap_instantiate_ngwt__DeltaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Distribution:
		return (void*)soap_instantiate_ngwt__Distribution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__DocumentType:
		return (void*)soap_instantiate_ngwt__DocumentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__DocumentTypeList:
		return (void*)soap_instantiate_ngwt__DocumentTypeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__EmailAddressList:
		return (void*)soap_instantiate_ngwt__EmailAddressList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Filter:
		return (void*)soap_instantiate_ngwt__Filter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FilterElement:
		return (void*)soap_instantiate_ngwt__FilterElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FolderACL:
		return (void*)soap_instantiate_ngwt__FolderACL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FolderList:
		return (void*)soap_instantiate_ngwt__FolderList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FreeBusyBlockList:
		return (void*)soap_instantiate_ngwt__FreeBusyBlockList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FreeBusyBlock:
		return (void*)soap_instantiate_ngwt__FreeBusyBlock(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FreeBusyUserList:
		return (void*)soap_instantiate_ngwt__FreeBusyUserList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FreeBusyInfoList:
		return (void*)soap_instantiate_ngwt__FreeBusyInfoList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FreeBusyStats:
		return (void*)soap_instantiate_ngwt__FreeBusyStats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FullName:
		return (void*)soap_instantiate_ngwt__FullName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__GroupMember:
		return (void*)soap_instantiate_ngwt__GroupMember(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__GroupMemberList:
		return (void*)soap_instantiate_ngwt__GroupMemberList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Host:
		return (void*)soap_instantiate_ngwt__Host(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ImAddress:
		return (void*)soap_instantiate_ngwt__ImAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ImAddressList:
		return (void*)soap_instantiate_ngwt__ImAddressList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Item:
		return (void*)soap_instantiate_ngwt__Item(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ItemChanges:
		return (void*)soap_instantiate_ngwt__ItemChanges(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ItemList:
		return (void*)soap_instantiate_ngwt__ItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ItemOptions:
		return (void*)soap_instantiate_ngwt__ItemOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ItemRefList:
		return (void*)soap_instantiate_ngwt__ItemRefList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Items:
		return (void*)soap_instantiate_ngwt__Items(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ItemStatus:
		return (void*)soap_instantiate_ngwt__ItemStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__JunkEntry:
		return (void*)soap_instantiate_ngwt__JunkEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__JunkHandlingList:
		return (void*)soap_instantiate_ngwt__JunkHandlingList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__LibraryList:
		return (void*)soap_instantiate_ngwt__LibraryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__LinkInfo:
		return (void*)soap_instantiate_ngwt__LinkInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__MessageBody:
		return (void*)soap_instantiate_ngwt__MessageBody(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ModifyItem:
		return (void*)soap_instantiate_ngwt__ModifyItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__MonthList:
		return (void*)soap_instantiate_ngwt__MonthList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__NameAndEmail:
		return (void*)soap_instantiate_ngwt__NameAndEmail(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__OfficeInfo:
		return (void*)soap_instantiate_ngwt__OfficeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__PersonalInfo:
		return (void*)soap_instantiate_ngwt__PersonalInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__PhoneFlags:
		return (void*)soap_instantiate_ngwt__PhoneFlags(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__PhoneList:
		return (void*)soap_instantiate_ngwt__PhoneList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__PostalAddress:
		return (void*)soap_instantiate_ngwt__PostalAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__PostalAddressList:
		return (void*)soap_instantiate_ngwt__PostalAddressList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ProblemEntry:
		return (void*)soap_instantiate_ngwt__ProblemEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ProblemList:
		return (void*)soap_instantiate_ngwt__ProblemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ProxyList:
		return (void*)soap_instantiate_ngwt__ProxyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Query:
		return (void*)soap_instantiate_ngwt__Query(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__QueryTarget:
		return (void*)soap_instantiate_ngwt__QueryTarget(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__RecipientList:
		return (void*)soap_instantiate_ngwt__RecipientList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__RecipientStatus:
		return (void*)soap_instantiate_ngwt__RecipientStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__RecurrenceDateType:
		return (void*)soap_instantiate_ngwt__RecurrenceDateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__RecurrenceRule:
		return (void*)soap_instantiate_ngwt__RecurrenceRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ReferenceInfo:
		return (void*)soap_instantiate_ngwt__ReferenceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ReturnNotification:
		return (void*)soap_instantiate_ngwt__ReturnNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ReturnNotificationOptions:
		return (void*)soap_instantiate_ngwt__ReturnNotificationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Rights:
		return (void*)soap_instantiate_ngwt__Rights(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__RuleAction:
		return (void*)soap_instantiate_ngwt__RuleAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__RuleActionList:
		return (void*)soap_instantiate_ngwt__RuleActionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__RuleList:
		return (void*)soap_instantiate_ngwt__RuleList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__SendOptionsRequestReply:
		return (void*)soap_instantiate_ngwt__SendOptionsRequestReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__SendOptions:
		return (void*)soap_instantiate_ngwt__SendOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Settings:
		return (void*)soap_instantiate_ngwt__Settings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__SettingsGroup:
		return (void*)soap_instantiate_ngwt__SettingsGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__SettingsList:
		return (void*)soap_instantiate_ngwt__SettingsList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__SharedFolderNotification:
		return (void*)soap_instantiate_ngwt__SharedFolderNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Signature:
		return (void*)soap_instantiate_ngwt__Signature(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Signatures:
		return (void*)soap_instantiate_ngwt__Signatures(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__SignatureData:
		return (void*)soap_instantiate_ngwt__SignatureData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__SMimeOperation:
		return (void*)soap_instantiate_ngwt__SMimeOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Status:
		return (void*)soap_instantiate_ngwt__Status(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Timezone:
		return (void*)soap_instantiate_ngwt__Timezone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__TimezoneComponent:
		return (void*)soap_instantiate_ngwt__TimezoneComponent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__TimezoneList:
		return (void*)soap_instantiate_ngwt__TimezoneList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__UserInfo:
		return (void*)soap_instantiate_ngwt__UserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__UserList:
		return (void*)soap_instantiate_ngwt__UserList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__acceptRequest:
		return (void*)soap_instantiate__ngwm__acceptRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__acceptResponse:
		return (void*)soap_instantiate__ngwm__acceptResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__acceptShareRequest:
		return (void*)soap_instantiate__ngwm__acceptShareRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__acceptShareResponse:
		return (void*)soap_instantiate__ngwm__acceptShareResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__addItemRequest:
		return (void*)soap_instantiate__ngwm__addItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__addItemResponse:
		return (void*)soap_instantiate__ngwm__addItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__addItemsRequest:
		return (void*)soap_instantiate__ngwm__addItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__addItemsResponse:
		return (void*)soap_instantiate__ngwm__addItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__addMembersRequest:
		return (void*)soap_instantiate__ngwm__addMembersRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__addMembersResponse:
		return (void*)soap_instantiate__ngwm__addMembersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__closeFreeBusySessionRequest:
		return (void*)soap_instantiate__ngwm__closeFreeBusySessionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__closeFreeBusySessionResponse:
		return (void*)soap_instantiate__ngwm__closeFreeBusySessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__completeRequest:
		return (void*)soap_instantiate__ngwm__completeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__completeResponse:
		return (void*)soap_instantiate__ngwm__completeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createCursorRequest:
		return (void*)soap_instantiate__ngwm__createCursorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createCursorResponse:
		return (void*)soap_instantiate__ngwm__createCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createItemRequest:
		return (void*)soap_instantiate__ngwm__createItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createItemResponse:
		return (void*)soap_instantiate__ngwm__createItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createItemsRequest:
		return (void*)soap_instantiate__ngwm__createItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createItemsResponse:
		return (void*)soap_instantiate__ngwm__createItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createJunkEntryRequest:
		return (void*)soap_instantiate__ngwm__createJunkEntryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createJunkEntryResponse:
		return (void*)soap_instantiate__ngwm__createJunkEntryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createProxyAccessRequest:
		return (void*)soap_instantiate__ngwm__createProxyAccessRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createProxyAccessResponse:
		return (void*)soap_instantiate__ngwm__createProxyAccessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createSignatureRequest:
		return (void*)soap_instantiate__ngwm__createSignatureRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__createSignatureResponse:
		return (void*)soap_instantiate__ngwm__createSignatureResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__declineRequest:
		return (void*)soap_instantiate__ngwm__declineRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__declineResponse:
		return (void*)soap_instantiate__ngwm__declineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__delegateRequest:
		return (void*)soap_instantiate__ngwm__delegateRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__delegateResponse:
		return (void*)soap_instantiate__ngwm__delegateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__destroyCursorRequest:
		return (void*)soap_instantiate__ngwm__destroyCursorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__destroyCursorResponse:
		return (void*)soap_instantiate__ngwm__destroyCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__executeRuleRequest:
		return (void*)soap_instantiate__ngwm__executeRuleRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__executeRuleResponse:
		return (void*)soap_instantiate__ngwm__executeRuleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__forwardRequest:
		return (void*)soap_instantiate__ngwm__forwardRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__forwardResponse:
		return (void*)soap_instantiate__ngwm__forwardResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getAddressBookListRequest:
		return (void*)soap_instantiate__ngwm__getAddressBookListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getAddressBookListResponse:
		return (void*)soap_instantiate__ngwm__getAddressBookListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getAttachmentRequest:
		return (void*)soap_instantiate__ngwm__getAttachmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getAttachmentResponse:
		return (void*)soap_instantiate__ngwm__getAttachmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getCategoryListRequest:
		return (void*)soap_instantiate__ngwm__getCategoryListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getCategoryListResponse:
		return (void*)soap_instantiate__ngwm__getCategoryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getCustomListRequest:
		return (void*)soap_instantiate__ngwm__getCustomListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getCustomListResponse:
		return (void*)soap_instantiate__ngwm__getCustomListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getDeltasRequest:
		return (void*)soap_instantiate__ngwm__getDeltasRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getDeltasResponse:
		return (void*)soap_instantiate__ngwm__getDeltasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getDeltaInfoRequest:
		return (void*)soap_instantiate__ngwm__getDeltaInfoRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getDeltaInfoResponse:
		return (void*)soap_instantiate__ngwm__getDeltaInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getDocumentTypeListRequest:
		return (void*)soap_instantiate__ngwm__getDocumentTypeListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getDocumentTypeListResponse:
		return (void*)soap_instantiate__ngwm__getDocumentTypeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getFolderRequest:
		return (void*)soap_instantiate__ngwm__getFolderRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getFolderResponse:
		return (void*)soap_instantiate__ngwm__getFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getFolderListRequest:
		return (void*)soap_instantiate__ngwm__getFolderListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getFolderListResponse:
		return (void*)soap_instantiate__ngwm__getFolderListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getFreeBusyRequest:
		return (void*)soap_instantiate__ngwm__getFreeBusyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getFreeBusyResponse:
		return (void*)soap_instantiate__ngwm__getFreeBusyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getItemRequest:
		return (void*)soap_instantiate__ngwm__getItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getItemResponse:
		return (void*)soap_instantiate__ngwm__getItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getItemsRequest:
		return (void*)soap_instantiate__ngwm__getItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getItemsResponse:
		return (void*)soap_instantiate__ngwm__getItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getJunkEntriesRequest:
		return (void*)soap_instantiate__ngwm__getJunkEntriesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getJunkEntriesResponse:
		return (void*)soap_instantiate__ngwm__getJunkEntriesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getJunkMailSettingsRequest:
		return (void*)soap_instantiate__ngwm__getJunkMailSettingsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getJunkMailSettingsResponse:
		return (void*)soap_instantiate__ngwm__getJunkMailSettingsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getLibraryItemRequest:
		return (void*)soap_instantiate__ngwm__getLibraryItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getLibraryItemResponse:
		return (void*)soap_instantiate__ngwm__getLibraryItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getLibraryListRequest:
		return (void*)soap_instantiate__ngwm__getLibraryListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getLibraryListResponse:
		return (void*)soap_instantiate__ngwm__getLibraryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getQuickMessagesRequest:
		return (void*)soap_instantiate__ngwm__getQuickMessagesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getQuickMessagesResponse:
		return (void*)soap_instantiate__ngwm__getQuickMessagesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getProxyAccessListRequest:
		return (void*)soap_instantiate__ngwm__getProxyAccessListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getProxyAccessListResponse:
		return (void*)soap_instantiate__ngwm__getProxyAccessListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getProxyListRequest:
		return (void*)soap_instantiate__ngwm__getProxyListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getProxyListResponse:
		return (void*)soap_instantiate__ngwm__getProxyListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getRuleListRequest:
		return (void*)soap_instantiate__ngwm__getRuleListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getRuleListResponse:
		return (void*)soap_instantiate__ngwm__getRuleListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getSettingsRequest:
		return (void*)soap_instantiate__ngwm__getSettingsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getSettingsResponse:
		return (void*)soap_instantiate__ngwm__getSettingsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getSignaturesRequest:
		return (void*)soap_instantiate__ngwm__getSignaturesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getSignaturesResponse:
		return (void*)soap_instantiate__ngwm__getSignaturesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getTimestampRequest:
		return (void*)soap_instantiate__ngwm__getTimestampRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getTimestampResponse:
		return (void*)soap_instantiate__ngwm__getTimestampResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getTimezoneListRequest:
		return (void*)soap_instantiate__ngwm__getTimezoneListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getTimezoneListResponse:
		return (void*)soap_instantiate__ngwm__getTimezoneListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getUserListRequest:
		return (void*)soap_instantiate__ngwm__getUserListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__getUserListResponse:
		return (void*)soap_instantiate__ngwm__getUserListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__loginRequest:
		return (void*)soap_instantiate__ngwm__loginRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__loginResponse:
		return (void*)soap_instantiate__ngwm__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__logoutRequest:
		return (void*)soap_instantiate__ngwm__logoutRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__logoutResponse:
		return (void*)soap_instantiate__ngwm__logoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__markPrivateRequest:
		return (void*)soap_instantiate__ngwm__markPrivateRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__markPrivateResponse:
		return (void*)soap_instantiate__ngwm__markPrivateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__markReadRequest:
		return (void*)soap_instantiate__ngwm__markReadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__markReadResponse:
		return (void*)soap_instantiate__ngwm__markReadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__markUnPrivateRequest:
		return (void*)soap_instantiate__ngwm__markUnPrivateRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__markUnPrivateResponse:
		return (void*)soap_instantiate__ngwm__markUnPrivateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__markUnReadRequest:
		return (void*)soap_instantiate__ngwm__markUnReadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__markUnReadResponse:
		return (void*)soap_instantiate__ngwm__markUnReadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyItemRequest:
		return (void*)soap_instantiate__ngwm__modifyItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyItemResponse:
		return (void*)soap_instantiate__ngwm__modifyItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyItemsRequest:
		return (void*)soap_instantiate__ngwm__modifyItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyItemsResponse:
		return (void*)soap_instantiate__ngwm__modifyItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyJunkEntryRequest:
		return (void*)soap_instantiate__ngwm__modifyJunkEntryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyJunkEntryResponse:
		return (void*)soap_instantiate__ngwm__modifyJunkEntryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest:
		return (void*)soap_instantiate__ngwm__modifyJunkMailSettingsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse:
		return (void*)soap_instantiate__ngwm__modifyJunkMailSettingsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyPasswordRequest:
		return (void*)soap_instantiate__ngwm__modifyPasswordRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyPasswordResponse:
		return (void*)soap_instantiate__ngwm__modifyPasswordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyProxyAccessRequest:
		return (void*)soap_instantiate__ngwm__modifyProxyAccessRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifyProxyAccessResponse:
		return (void*)soap_instantiate__ngwm__modifyProxyAccessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifySettingsRequest:
		return (void*)soap_instantiate__ngwm__modifySettingsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifySettingsResponse:
		return (void*)soap_instantiate__ngwm__modifySettingsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifySignaturesRequest:
		return (void*)soap_instantiate__ngwm__modifySignaturesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__modifySignaturesResponse:
		return (void*)soap_instantiate__ngwm__modifySignaturesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__moveItemRequest:
		return (void*)soap_instantiate__ngwm__moveItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__moveItemResponse:
		return (void*)soap_instantiate__ngwm__moveItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__positionCursorRequest:
		return (void*)soap_instantiate__ngwm__positionCursorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__positionCursorResponse:
		return (void*)soap_instantiate__ngwm__positionCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__purgeDeletedItemsRequest:
		return (void*)soap_instantiate__ngwm__purgeDeletedItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__purgeDeletedItemsResponse:
		return (void*)soap_instantiate__ngwm__purgeDeletedItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__purgeRequest:
		return (void*)soap_instantiate__ngwm__purgeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__purgeResponse:
		return (void*)soap_instantiate__ngwm__purgeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__readCursorRequest:
		return (void*)soap_instantiate__ngwm__readCursorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__readCursorResponse:
		return (void*)soap_instantiate__ngwm__readCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeCustomDefinitionRequest:
		return (void*)soap_instantiate__ngwm__removeCustomDefinitionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeCustomDefinitionResponse:
		return (void*)soap_instantiate__ngwm__removeCustomDefinitionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeItemRequest:
		return (void*)soap_instantiate__ngwm__removeItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeItemResponse:
		return (void*)soap_instantiate__ngwm__removeItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeItemsRequest:
		return (void*)soap_instantiate__ngwm__removeItemsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeItemsResponse:
		return (void*)soap_instantiate__ngwm__removeItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeJunkEntryRequest:
		return (void*)soap_instantiate__ngwm__removeJunkEntryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeJunkEntryResponse:
		return (void*)soap_instantiate__ngwm__removeJunkEntryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeMembersRequest:
		return (void*)soap_instantiate__ngwm__removeMembersRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeMembersResponse:
		return (void*)soap_instantiate__ngwm__removeMembersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeProxyAccessRequest:
		return (void*)soap_instantiate__ngwm__removeProxyAccessRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeProxyAccessResponse:
		return (void*)soap_instantiate__ngwm__removeProxyAccessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeProxyUserRequest:
		return (void*)soap_instantiate__ngwm__removeProxyUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeProxyUserResponse:
		return (void*)soap_instantiate__ngwm__removeProxyUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeSignatureRequest:
		return (void*)soap_instantiate__ngwm__removeSignatureRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__removeSignatureResponse:
		return (void*)soap_instantiate__ngwm__removeSignatureResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__replyRequest:
		return (void*)soap_instantiate__ngwm__replyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__replyResponse:
		return (void*)soap_instantiate__ngwm__replyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__retractRequest:
		return (void*)soap_instantiate__ngwm__retractRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__retractResponse:
		return (void*)soap_instantiate__ngwm__retractResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__sendItemRequest:
		return (void*)soap_instantiate__ngwm__sendItemRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__sendItemResponse:
		return (void*)soap_instantiate__ngwm__sendItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__setTimestampRequest:
		return (void*)soap_instantiate__ngwm__setTimestampRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__setTimestampResponse:
		return (void*)soap_instantiate__ngwm__setTimestampResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__startFreeBusySessionRequest:
		return (void*)soap_instantiate__ngwm__startFreeBusySessionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__startFreeBusySessionResponse:
		return (void*)soap_instantiate__ngwm__startFreeBusySessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__unacceptRequest:
		return (void*)soap_instantiate__ngwm__unacceptRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__unacceptResponse:
		return (void*)soap_instantiate__ngwm__unacceptResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__uncompleteRequest:
		return (void*)soap_instantiate__ngwm__uncompleteRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__uncompleteResponse:
		return (void*)soap_instantiate__ngwm__uncompleteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__updateVersionStatusRequest:
		return (void*)soap_instantiate__ngwm__updateVersionStatusRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwm__updateVersionStatusResponse:
		return (void*)soap_instantiate__ngwm__updateVersionStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwe__ContainerList:
		return (void*)soap_instantiate_ngwe__ContainerList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwe__Event:
		return (void*)soap_instantiate_ngwe__Event(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwe__EventDefinition:
		return (void*)soap_instantiate_ngwe__EventDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwe__EventList:
		return (void*)soap_instantiate_ngwe__EventList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwe__Events:
		return (void*)soap_instantiate_ngwe__Events(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwe__EventsList:
		return (void*)soap_instantiate_ngwe__EventsList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwe__EventTypeList:
		return (void*)soap_instantiate_ngwe__EventTypeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwe__Notify:
		return (void*)soap_instantiate_ngwe__Notify(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__cleanEventConfigurationRequest:
		return (void*)soap_instantiate__ngwe__cleanEventConfigurationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__cleanEventConfigurationResponse:
		return (void*)soap_instantiate__ngwe__cleanEventConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__configureEventsRequest:
		return (void*)soap_instantiate__ngwe__configureEventsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__configureEventsResponse:
		return (void*)soap_instantiate__ngwe__configureEventsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__getEventConfigurationRequest:
		return (void*)soap_instantiate__ngwe__getEventConfigurationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__getEventConfigurationResponse:
		return (void*)soap_instantiate__ngwe__getEventConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__getEventsRequest:
		return (void*)soap_instantiate__ngwe__getEventsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__getEventsResponse:
		return (void*)soap_instantiate__ngwe__getEventsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__removeEventConfigurationRequest:
		return (void*)soap_instantiate__ngwe__removeEventConfigurationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__removeEventConfigurationResponse:
		return (void*)soap_instantiate__ngwe__removeEventConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__removeEventsRequest:
		return (void*)soap_instantiate__ngwe__removeEventsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ngwe__removeEventsResponse:
		return (void*)soap_instantiate__ngwe__removeEventsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AccessControlListEntry:
		return (void*)soap_instantiate_ngwt__AccessControlListEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AccessRightEntry:
		return (void*)soap_instantiate_ngwt__AccessRightEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AddressBook:
		return (void*)soap_instantiate_ngwt__AddressBook(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Alarm:
		return (void*)soap_instantiate_ngwt__Alarm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Category:
		return (void*)soap_instantiate_ngwt__Category(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__CommentStatus:
		return (void*)soap_instantiate_ngwt__CommentStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ContainerItem:
		return (void*)soap_instantiate_ngwt__ContainerItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ContainerRef:
		return (void*)soap_instantiate_ngwt__ContainerRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__DelegatedStatus:
		return (void*)soap_instantiate_ngwt__DelegatedStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__DelegateeStatus:
		return (void*)soap_instantiate_ngwt__DelegateeStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FilterEntry:
		return (void*)soap_instantiate_ngwt__FilterEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FilterGroup:
		return (void*)soap_instantiate_ngwt__FilterGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Folder:
		return (void*)soap_instantiate_ngwt__Folder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FreeBusyInfo:
		return (void*)soap_instantiate_ngwt__FreeBusyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__From:
		return (void*)soap_instantiate_ngwt__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ItemRef:
		return (void*)soap_instantiate_ngwt__ItemRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Library:
		return (void*)soap_instantiate_ngwt__Library(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__MessagePart:
		return (void*)soap_instantiate_ngwt__MessagePart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__PhoneNumber:
		return (void*)soap_instantiate_ngwt__PhoneNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__PlainText:
		return (void*)soap_instantiate_ngwt__PlainText(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Proxy:
		return (void*)soap_instantiate_ngwt__Proxy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ProxyUser:
		return (void*)soap_instantiate_ngwt__ProxyUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Recipient:
		return (void*)soap_instantiate_ngwt__Recipient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__TransferFailedStatus:
		return (void*)soap_instantiate_ngwt__TransferFailedStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__TrustedApplication:
		return (void*)soap_instantiate_ngwt__TrustedApplication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AddressBookItem:
		return (void*)soap_instantiate_ngwt__AddressBookItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__AttachmentID:
		return (void*)soap_instantiate_ngwt__AttachmentID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__BoxEntry:
		return (void*)soap_instantiate_ngwt__BoxEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__DayOfWeek:
		return (void*)soap_instantiate_ngwt__DayOfWeek(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__DayOfYearWeek:
		return (void*)soap_instantiate_ngwt__DayOfYearWeek(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Document:
		return (void*)soap_instantiate_ngwt__Document(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__FolderACLEntry:
		return (void*)soap_instantiate_ngwt__FolderACLEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__QueryFolder:
		return (void*)soap_instantiate_ngwt__QueryFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Rule:
		return (void*)soap_instantiate_ngwt__Rule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__SharedFolder:
		return (void*)soap_instantiate_ngwt__SharedFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__StatusTracking:
		return (void*)soap_instantiate_ngwt__StatusTracking(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__SystemFolder:
		return (void*)soap_instantiate_ngwt__SystemFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Version:
		return (void*)soap_instantiate_ngwt__Version(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__VersionEvent:
		return (void*)soap_instantiate_ngwt__VersionEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Contact:
		return (void*)soap_instantiate_ngwt__Contact(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__ContactFolder:
		return (void*)soap_instantiate_ngwt__ContactFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Group:
		return (void*)soap_instantiate_ngwt__Group(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Mail:
		return (void*)soap_instantiate_ngwt__Mail(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Organization:
		return (void*)soap_instantiate_ngwt__Organization(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Resource:
		return (void*)soap_instantiate_ngwt__Resource(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__CalendarItem:
		return (void*)soap_instantiate_ngwt__CalendarItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__DocumentRef:
		return (void*)soap_instantiate_ngwt__DocumentRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__PhoneMessage:
		return (void*)soap_instantiate_ngwt__PhoneMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__SharedNotification:
		return (void*)soap_instantiate_ngwt__SharedNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Appointment:
		return (void*)soap_instantiate_ngwt__Appointment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Note:
		return (void*)soap_instantiate_ngwt__Note(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__Task:
		return (void*)soap_instantiate_ngwt__Task(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__date:
		return (void*)soap_instantiate_xsd__date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration:
		return (void*)soap_instantiate_xsd__duration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__language:
		return (void*)soap_instantiate_xsd__language(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__View:
		return (void*)soap_instantiate_ngwt__View(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__uid:
		return (void*)soap_instantiate_ngwt__uid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ngwt__UUID:
		return (void*)soap_instantiate_ngwt__UUID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FilterElement:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__FilterElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ContainerRef:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfngwe__EventType:
		return (void*)soap_instantiate_std__vectorTemplateOfngwe__EventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Events:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwe__Events(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Event:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwe__Event(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstring:
		return (void*)soap_instantiate_std__vectorTemplateOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ModifyItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__ModifyItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Host:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__Host(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__UserInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__UserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Timezone:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__Timezone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Signature:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__Signature(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__SettingsGroup:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__SettingsGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Rule:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__Rule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__RuleAction:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__RuleAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__date:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DelegateeStatus:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Recipient:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__Recipient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProxyUser:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__ProxyUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProblemEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__ProblemEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PostalAddress:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__PostalAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PhoneNumber:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__PhoneNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfngwt__Month:
		return (void*)soap_instantiate_std__vectorTemplateOfngwt__Month(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__MessagePart:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__MessagePart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Library:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__Library(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__JunkEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__JunkEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Item:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__Item(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ImAddress:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__ImAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__GroupMember:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__GroupMember(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__NameAndEmail:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__NameAndEmail(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyBlock:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Folder:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__Folder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FolderACLEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__FolderACLEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DocumentType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__DocumentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DayOfYearWeek:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfngwt__DayOfYear:
		return (void*)soap_instantiate_std__vectorTemplateOfngwt__DayOfYear(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfngwt__DayOfMonth:
		return (void*)soap_instantiate_std__vectorTemplateOfngwt__DayOfMonth(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Custom:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__Custom(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfngwt__uid:
		return (void*)soap_instantiate_std__vectorTemplateOfngwt__uid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Category:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__Category(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfngwt__CalendarFolderFlags:
		return (void*)soap_instantiate_std__vectorTemplateOfngwt__CalendarFolderFlags(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AddressBook:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__AddressBook(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessRightEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__AccessRightEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessControlListEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			delete (xsd__base64Binary*)p->ptr;
		else
			delete[] (xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AccessControlList:
		if (p->size < 0)
			delete (ngwt__AccessControlList*)p->ptr;
		else
			delete[] (ngwt__AccessControlList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AccessMiscRight:
		if (p->size < 0)
			delete (ngwt__AccessMiscRight*)p->ptr;
		else
			delete[] (ngwt__AccessMiscRight*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AccessRight:
		if (p->size < 0)
			delete (ngwt__AccessRight*)p->ptr;
		else
			delete[] (ngwt__AccessRight*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AccessRightChanges:
		if (p->size < 0)
			delete (ngwt__AccessRightChanges*)p->ptr;
		else
			delete[] (ngwt__AccessRightChanges*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AccessRightList:
		if (p->size < 0)
			delete (ngwt__AccessRightList*)p->ptr;
		else
			delete[] (ngwt__AccessRightList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AddressBookList:
		if (p->size < 0)
			delete (ngwt__AddressBookList*)p->ptr;
		else
			delete[] (ngwt__AddressBookList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AttachmentInfo:
		if (p->size < 0)
			delete (ngwt__AttachmentInfo*)p->ptr;
		else
			delete[] (ngwt__AttachmentInfo*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AttachmentItemInfo:
		if (p->size < 0)
			delete (ngwt__AttachmentItemInfo*)p->ptr;
		else
			delete[] (ngwt__AttachmentItemInfo*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Authentication:
		if (p->size < 0)
			delete (ngwt__Authentication*)p->ptr;
		else
			delete[] (ngwt__Authentication*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__CalendarFolderAttribute:
		if (p->size < 0)
			delete (ngwt__CalendarFolderAttribute*)p->ptr;
		else
			delete[] (ngwt__CalendarFolderAttribute*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__CategoryList:
		if (p->size < 0)
			delete (ngwt__CategoryList*)p->ptr;
		else
			delete[] (ngwt__CategoryList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__CategoryRefList:
		if (p->size < 0)
			delete (ngwt__CategoryRefList*)p->ptr;
		else
			delete[] (ngwt__CategoryRefList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Custom:
		if (p->size < 0)
			delete (ngwt__Custom*)p->ptr;
		else
			delete[] (ngwt__Custom*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__CustomList:
		if (p->size < 0)
			delete (ngwt__CustomList*)p->ptr;
		else
			delete[] (ngwt__CustomList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__DayOfMonthList:
		if (p->size < 0)
			delete (ngwt__DayOfMonthList*)p->ptr;
		else
			delete[] (ngwt__DayOfMonthList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__DayOfYearList:
		if (p->size < 0)
			delete (ngwt__DayOfYearList*)p->ptr;
		else
			delete[] (ngwt__DayOfYearList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__DayOfYearWeekList:
		if (p->size < 0)
			delete (ngwt__DayOfYearWeekList*)p->ptr;
		else
			delete[] (ngwt__DayOfYearWeekList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__DeltaInfo:
		if (p->size < 0)
			delete (ngwt__DeltaInfo*)p->ptr;
		else
			delete[] (ngwt__DeltaInfo*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Distribution:
		if (p->size < 0)
			delete (ngwt__Distribution*)p->ptr;
		else
			delete[] (ngwt__Distribution*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__DocumentType:
		if (p->size < 0)
			delete (ngwt__DocumentType*)p->ptr;
		else
			delete[] (ngwt__DocumentType*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__DocumentTypeList:
		if (p->size < 0)
			delete (ngwt__DocumentTypeList*)p->ptr;
		else
			delete[] (ngwt__DocumentTypeList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__EmailAddressList:
		if (p->size < 0)
			delete (ngwt__EmailAddressList*)p->ptr;
		else
			delete[] (ngwt__EmailAddressList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Filter:
		if (p->size < 0)
			delete (ngwt__Filter*)p->ptr;
		else
			delete[] (ngwt__Filter*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FilterElement:
		if (p->size < 0)
			delete (ngwt__FilterElement*)p->ptr;
		else
			delete[] (ngwt__FilterElement*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FolderACL:
		if (p->size < 0)
			delete (ngwt__FolderACL*)p->ptr;
		else
			delete[] (ngwt__FolderACL*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FolderList:
		if (p->size < 0)
			delete (ngwt__FolderList*)p->ptr;
		else
			delete[] (ngwt__FolderList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FreeBusyBlockList:
		if (p->size < 0)
			delete (ngwt__FreeBusyBlockList*)p->ptr;
		else
			delete[] (ngwt__FreeBusyBlockList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FreeBusyBlock:
		if (p->size < 0)
			delete (ngwt__FreeBusyBlock*)p->ptr;
		else
			delete[] (ngwt__FreeBusyBlock*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FreeBusyUserList:
		if (p->size < 0)
			delete (ngwt__FreeBusyUserList*)p->ptr;
		else
			delete[] (ngwt__FreeBusyUserList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FreeBusyInfoList:
		if (p->size < 0)
			delete (ngwt__FreeBusyInfoList*)p->ptr;
		else
			delete[] (ngwt__FreeBusyInfoList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FreeBusyStats:
		if (p->size < 0)
			delete (ngwt__FreeBusyStats*)p->ptr;
		else
			delete[] (ngwt__FreeBusyStats*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FullName:
		if (p->size < 0)
			delete (ngwt__FullName*)p->ptr;
		else
			delete[] (ngwt__FullName*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__GroupMember:
		if (p->size < 0)
			delete (ngwt__GroupMember*)p->ptr;
		else
			delete[] (ngwt__GroupMember*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__GroupMemberList:
		if (p->size < 0)
			delete (ngwt__GroupMemberList*)p->ptr;
		else
			delete[] (ngwt__GroupMemberList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Host:
		if (p->size < 0)
			delete (ngwt__Host*)p->ptr;
		else
			delete[] (ngwt__Host*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ImAddress:
		if (p->size < 0)
			delete (ngwt__ImAddress*)p->ptr;
		else
			delete[] (ngwt__ImAddress*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ImAddressList:
		if (p->size < 0)
			delete (ngwt__ImAddressList*)p->ptr;
		else
			delete[] (ngwt__ImAddressList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Item:
		if (p->size < 0)
			delete (ngwt__Item*)p->ptr;
		else
			delete[] (ngwt__Item*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ItemChanges:
		if (p->size < 0)
			delete (ngwt__ItemChanges*)p->ptr;
		else
			delete[] (ngwt__ItemChanges*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ItemList:
		if (p->size < 0)
			delete (ngwt__ItemList*)p->ptr;
		else
			delete[] (ngwt__ItemList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ItemOptions:
		if (p->size < 0)
			delete (ngwt__ItemOptions*)p->ptr;
		else
			delete[] (ngwt__ItemOptions*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ItemRefList:
		if (p->size < 0)
			delete (ngwt__ItemRefList*)p->ptr;
		else
			delete[] (ngwt__ItemRefList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Items:
		if (p->size < 0)
			delete (ngwt__Items*)p->ptr;
		else
			delete[] (ngwt__Items*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ItemStatus:
		if (p->size < 0)
			delete (ngwt__ItemStatus*)p->ptr;
		else
			delete[] (ngwt__ItemStatus*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__JunkEntry:
		if (p->size < 0)
			delete (ngwt__JunkEntry*)p->ptr;
		else
			delete[] (ngwt__JunkEntry*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__JunkHandlingList:
		if (p->size < 0)
			delete (ngwt__JunkHandlingList*)p->ptr;
		else
			delete[] (ngwt__JunkHandlingList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__LibraryList:
		if (p->size < 0)
			delete (ngwt__LibraryList*)p->ptr;
		else
			delete[] (ngwt__LibraryList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__LinkInfo:
		if (p->size < 0)
			delete (ngwt__LinkInfo*)p->ptr;
		else
			delete[] (ngwt__LinkInfo*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__MessageBody:
		if (p->size < 0)
			delete (ngwt__MessageBody*)p->ptr;
		else
			delete[] (ngwt__MessageBody*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ModifyItem:
		if (p->size < 0)
			delete (ngwt__ModifyItem*)p->ptr;
		else
			delete[] (ngwt__ModifyItem*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__MonthList:
		if (p->size < 0)
			delete (ngwt__MonthList*)p->ptr;
		else
			delete[] (ngwt__MonthList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__NameAndEmail:
		if (p->size < 0)
			delete (ngwt__NameAndEmail*)p->ptr;
		else
			delete[] (ngwt__NameAndEmail*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__OfficeInfo:
		if (p->size < 0)
			delete (ngwt__OfficeInfo*)p->ptr;
		else
			delete[] (ngwt__OfficeInfo*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__PersonalInfo:
		if (p->size < 0)
			delete (ngwt__PersonalInfo*)p->ptr;
		else
			delete[] (ngwt__PersonalInfo*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__PhoneFlags:
		if (p->size < 0)
			delete (ngwt__PhoneFlags*)p->ptr;
		else
			delete[] (ngwt__PhoneFlags*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__PhoneList:
		if (p->size < 0)
			delete (ngwt__PhoneList*)p->ptr;
		else
			delete[] (ngwt__PhoneList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__PostalAddress:
		if (p->size < 0)
			delete (ngwt__PostalAddress*)p->ptr;
		else
			delete[] (ngwt__PostalAddress*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__PostalAddressList:
		if (p->size < 0)
			delete (ngwt__PostalAddressList*)p->ptr;
		else
			delete[] (ngwt__PostalAddressList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ProblemEntry:
		if (p->size < 0)
			delete (ngwt__ProblemEntry*)p->ptr;
		else
			delete[] (ngwt__ProblemEntry*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ProblemList:
		if (p->size < 0)
			delete (ngwt__ProblemList*)p->ptr;
		else
			delete[] (ngwt__ProblemList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ProxyList:
		if (p->size < 0)
			delete (ngwt__ProxyList*)p->ptr;
		else
			delete[] (ngwt__ProxyList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Query:
		if (p->size < 0)
			delete (ngwt__Query*)p->ptr;
		else
			delete[] (ngwt__Query*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__QueryTarget:
		if (p->size < 0)
			delete (ngwt__QueryTarget*)p->ptr;
		else
			delete[] (ngwt__QueryTarget*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__RecipientList:
		if (p->size < 0)
			delete (ngwt__RecipientList*)p->ptr;
		else
			delete[] (ngwt__RecipientList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__RecipientStatus:
		if (p->size < 0)
			delete (ngwt__RecipientStatus*)p->ptr;
		else
			delete[] (ngwt__RecipientStatus*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__RecurrenceDateType:
		if (p->size < 0)
			delete (ngwt__RecurrenceDateType*)p->ptr;
		else
			delete[] (ngwt__RecurrenceDateType*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__RecurrenceRule:
		if (p->size < 0)
			delete (ngwt__RecurrenceRule*)p->ptr;
		else
			delete[] (ngwt__RecurrenceRule*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ReferenceInfo:
		if (p->size < 0)
			delete (ngwt__ReferenceInfo*)p->ptr;
		else
			delete[] (ngwt__ReferenceInfo*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ReturnNotification:
		if (p->size < 0)
			delete (ngwt__ReturnNotification*)p->ptr;
		else
			delete[] (ngwt__ReturnNotification*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ReturnNotificationOptions:
		if (p->size < 0)
			delete (ngwt__ReturnNotificationOptions*)p->ptr;
		else
			delete[] (ngwt__ReturnNotificationOptions*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Rights:
		if (p->size < 0)
			delete (ngwt__Rights*)p->ptr;
		else
			delete[] (ngwt__Rights*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__RuleAction:
		if (p->size < 0)
			delete (ngwt__RuleAction*)p->ptr;
		else
			delete[] (ngwt__RuleAction*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__RuleActionList:
		if (p->size < 0)
			delete (ngwt__RuleActionList*)p->ptr;
		else
			delete[] (ngwt__RuleActionList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__RuleList:
		if (p->size < 0)
			delete (ngwt__RuleList*)p->ptr;
		else
			delete[] (ngwt__RuleList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__SendOptionsRequestReply:
		if (p->size < 0)
			delete (ngwt__SendOptionsRequestReply*)p->ptr;
		else
			delete[] (ngwt__SendOptionsRequestReply*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__SendOptions:
		if (p->size < 0)
			delete (ngwt__SendOptions*)p->ptr;
		else
			delete[] (ngwt__SendOptions*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Settings:
		if (p->size < 0)
			delete (ngwt__Settings*)p->ptr;
		else
			delete[] (ngwt__Settings*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__SettingsGroup:
		if (p->size < 0)
			delete (ngwt__SettingsGroup*)p->ptr;
		else
			delete[] (ngwt__SettingsGroup*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__SettingsList:
		if (p->size < 0)
			delete (ngwt__SettingsList*)p->ptr;
		else
			delete[] (ngwt__SettingsList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__SharedFolderNotification:
		if (p->size < 0)
			delete (ngwt__SharedFolderNotification*)p->ptr;
		else
			delete[] (ngwt__SharedFolderNotification*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Signature:
		if (p->size < 0)
			delete (ngwt__Signature*)p->ptr;
		else
			delete[] (ngwt__Signature*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Signatures:
		if (p->size < 0)
			delete (ngwt__Signatures*)p->ptr;
		else
			delete[] (ngwt__Signatures*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__SignatureData:
		if (p->size < 0)
			delete (ngwt__SignatureData*)p->ptr;
		else
			delete[] (ngwt__SignatureData*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__SMimeOperation:
		if (p->size < 0)
			delete (ngwt__SMimeOperation*)p->ptr;
		else
			delete[] (ngwt__SMimeOperation*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Status:
		if (p->size < 0)
			delete (ngwt__Status*)p->ptr;
		else
			delete[] (ngwt__Status*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Timezone:
		if (p->size < 0)
			delete (ngwt__Timezone*)p->ptr;
		else
			delete[] (ngwt__Timezone*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__TimezoneComponent:
		if (p->size < 0)
			delete (ngwt__TimezoneComponent*)p->ptr;
		else
			delete[] (ngwt__TimezoneComponent*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__TimezoneList:
		if (p->size < 0)
			delete (ngwt__TimezoneList*)p->ptr;
		else
			delete[] (ngwt__TimezoneList*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__UserInfo:
		if (p->size < 0)
			delete (ngwt__UserInfo*)p->ptr;
		else
			delete[] (ngwt__UserInfo*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__UserList:
		if (p->size < 0)
			delete (ngwt__UserList*)p->ptr;
		else
			delete[] (ngwt__UserList*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__acceptRequest:
		if (p->size < 0)
			delete (_ngwm__acceptRequest*)p->ptr;
		else
			delete[] (_ngwm__acceptRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__acceptResponse:
		if (p->size < 0)
			delete (_ngwm__acceptResponse*)p->ptr;
		else
			delete[] (_ngwm__acceptResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__acceptShareRequest:
		if (p->size < 0)
			delete (_ngwm__acceptShareRequest*)p->ptr;
		else
			delete[] (_ngwm__acceptShareRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__acceptShareResponse:
		if (p->size < 0)
			delete (_ngwm__acceptShareResponse*)p->ptr;
		else
			delete[] (_ngwm__acceptShareResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__addItemRequest:
		if (p->size < 0)
			delete (_ngwm__addItemRequest*)p->ptr;
		else
			delete[] (_ngwm__addItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__addItemResponse:
		if (p->size < 0)
			delete (_ngwm__addItemResponse*)p->ptr;
		else
			delete[] (_ngwm__addItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__addItemsRequest:
		if (p->size < 0)
			delete (_ngwm__addItemsRequest*)p->ptr;
		else
			delete[] (_ngwm__addItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__addItemsResponse:
		if (p->size < 0)
			delete (_ngwm__addItemsResponse*)p->ptr;
		else
			delete[] (_ngwm__addItemsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__addMembersRequest:
		if (p->size < 0)
			delete (_ngwm__addMembersRequest*)p->ptr;
		else
			delete[] (_ngwm__addMembersRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__addMembersResponse:
		if (p->size < 0)
			delete (_ngwm__addMembersResponse*)p->ptr;
		else
			delete[] (_ngwm__addMembersResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__closeFreeBusySessionRequest:
		if (p->size < 0)
			delete (_ngwm__closeFreeBusySessionRequest*)p->ptr;
		else
			delete[] (_ngwm__closeFreeBusySessionRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__closeFreeBusySessionResponse:
		if (p->size < 0)
			delete (_ngwm__closeFreeBusySessionResponse*)p->ptr;
		else
			delete[] (_ngwm__closeFreeBusySessionResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__completeRequest:
		if (p->size < 0)
			delete (_ngwm__completeRequest*)p->ptr;
		else
			delete[] (_ngwm__completeRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__completeResponse:
		if (p->size < 0)
			delete (_ngwm__completeResponse*)p->ptr;
		else
			delete[] (_ngwm__completeResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createCursorRequest:
		if (p->size < 0)
			delete (_ngwm__createCursorRequest*)p->ptr;
		else
			delete[] (_ngwm__createCursorRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createCursorResponse:
		if (p->size < 0)
			delete (_ngwm__createCursorResponse*)p->ptr;
		else
			delete[] (_ngwm__createCursorResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createItemRequest:
		if (p->size < 0)
			delete (_ngwm__createItemRequest*)p->ptr;
		else
			delete[] (_ngwm__createItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createItemResponse:
		if (p->size < 0)
			delete (_ngwm__createItemResponse*)p->ptr;
		else
			delete[] (_ngwm__createItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createItemsRequest:
		if (p->size < 0)
			delete (_ngwm__createItemsRequest*)p->ptr;
		else
			delete[] (_ngwm__createItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createItemsResponse:
		if (p->size < 0)
			delete (_ngwm__createItemsResponse*)p->ptr;
		else
			delete[] (_ngwm__createItemsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createJunkEntryRequest:
		if (p->size < 0)
			delete (_ngwm__createJunkEntryRequest*)p->ptr;
		else
			delete[] (_ngwm__createJunkEntryRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createJunkEntryResponse:
		if (p->size < 0)
			delete (_ngwm__createJunkEntryResponse*)p->ptr;
		else
			delete[] (_ngwm__createJunkEntryResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createProxyAccessRequest:
		if (p->size < 0)
			delete (_ngwm__createProxyAccessRequest*)p->ptr;
		else
			delete[] (_ngwm__createProxyAccessRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createProxyAccessResponse:
		if (p->size < 0)
			delete (_ngwm__createProxyAccessResponse*)p->ptr;
		else
			delete[] (_ngwm__createProxyAccessResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createSignatureRequest:
		if (p->size < 0)
			delete (_ngwm__createSignatureRequest*)p->ptr;
		else
			delete[] (_ngwm__createSignatureRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__createSignatureResponse:
		if (p->size < 0)
			delete (_ngwm__createSignatureResponse*)p->ptr;
		else
			delete[] (_ngwm__createSignatureResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__declineRequest:
		if (p->size < 0)
			delete (_ngwm__declineRequest*)p->ptr;
		else
			delete[] (_ngwm__declineRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__declineResponse:
		if (p->size < 0)
			delete (_ngwm__declineResponse*)p->ptr;
		else
			delete[] (_ngwm__declineResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__delegateRequest:
		if (p->size < 0)
			delete (_ngwm__delegateRequest*)p->ptr;
		else
			delete[] (_ngwm__delegateRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__delegateResponse:
		if (p->size < 0)
			delete (_ngwm__delegateResponse*)p->ptr;
		else
			delete[] (_ngwm__delegateResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__destroyCursorRequest:
		if (p->size < 0)
			delete (_ngwm__destroyCursorRequest*)p->ptr;
		else
			delete[] (_ngwm__destroyCursorRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__destroyCursorResponse:
		if (p->size < 0)
			delete (_ngwm__destroyCursorResponse*)p->ptr;
		else
			delete[] (_ngwm__destroyCursorResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__executeRuleRequest:
		if (p->size < 0)
			delete (_ngwm__executeRuleRequest*)p->ptr;
		else
			delete[] (_ngwm__executeRuleRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__executeRuleResponse:
		if (p->size < 0)
			delete (_ngwm__executeRuleResponse*)p->ptr;
		else
			delete[] (_ngwm__executeRuleResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__forwardRequest:
		if (p->size < 0)
			delete (_ngwm__forwardRequest*)p->ptr;
		else
			delete[] (_ngwm__forwardRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__forwardResponse:
		if (p->size < 0)
			delete (_ngwm__forwardResponse*)p->ptr;
		else
			delete[] (_ngwm__forwardResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getAddressBookListRequest:
		if (p->size < 0)
			delete (_ngwm__getAddressBookListRequest*)p->ptr;
		else
			delete[] (_ngwm__getAddressBookListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getAddressBookListResponse:
		if (p->size < 0)
			delete (_ngwm__getAddressBookListResponse*)p->ptr;
		else
			delete[] (_ngwm__getAddressBookListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getAttachmentRequest:
		if (p->size < 0)
			delete (_ngwm__getAttachmentRequest*)p->ptr;
		else
			delete[] (_ngwm__getAttachmentRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getAttachmentResponse:
		if (p->size < 0)
			delete (_ngwm__getAttachmentResponse*)p->ptr;
		else
			delete[] (_ngwm__getAttachmentResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getCategoryListRequest:
		if (p->size < 0)
			delete (_ngwm__getCategoryListRequest*)p->ptr;
		else
			delete[] (_ngwm__getCategoryListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getCategoryListResponse:
		if (p->size < 0)
			delete (_ngwm__getCategoryListResponse*)p->ptr;
		else
			delete[] (_ngwm__getCategoryListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getCustomListRequest:
		if (p->size < 0)
			delete (_ngwm__getCustomListRequest*)p->ptr;
		else
			delete[] (_ngwm__getCustomListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getCustomListResponse:
		if (p->size < 0)
			delete (_ngwm__getCustomListResponse*)p->ptr;
		else
			delete[] (_ngwm__getCustomListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getDeltasRequest:
		if (p->size < 0)
			delete (_ngwm__getDeltasRequest*)p->ptr;
		else
			delete[] (_ngwm__getDeltasRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getDeltasResponse:
		if (p->size < 0)
			delete (_ngwm__getDeltasResponse*)p->ptr;
		else
			delete[] (_ngwm__getDeltasResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getDeltaInfoRequest:
		if (p->size < 0)
			delete (_ngwm__getDeltaInfoRequest*)p->ptr;
		else
			delete[] (_ngwm__getDeltaInfoRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getDeltaInfoResponse:
		if (p->size < 0)
			delete (_ngwm__getDeltaInfoResponse*)p->ptr;
		else
			delete[] (_ngwm__getDeltaInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getDocumentTypeListRequest:
		if (p->size < 0)
			delete (_ngwm__getDocumentTypeListRequest*)p->ptr;
		else
			delete[] (_ngwm__getDocumentTypeListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getDocumentTypeListResponse:
		if (p->size < 0)
			delete (_ngwm__getDocumentTypeListResponse*)p->ptr;
		else
			delete[] (_ngwm__getDocumentTypeListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getFolderRequest:
		if (p->size < 0)
			delete (_ngwm__getFolderRequest*)p->ptr;
		else
			delete[] (_ngwm__getFolderRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getFolderResponse:
		if (p->size < 0)
			delete (_ngwm__getFolderResponse*)p->ptr;
		else
			delete[] (_ngwm__getFolderResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getFolderListRequest:
		if (p->size < 0)
			delete (_ngwm__getFolderListRequest*)p->ptr;
		else
			delete[] (_ngwm__getFolderListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getFolderListResponse:
		if (p->size < 0)
			delete (_ngwm__getFolderListResponse*)p->ptr;
		else
			delete[] (_ngwm__getFolderListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getFreeBusyRequest:
		if (p->size < 0)
			delete (_ngwm__getFreeBusyRequest*)p->ptr;
		else
			delete[] (_ngwm__getFreeBusyRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getFreeBusyResponse:
		if (p->size < 0)
			delete (_ngwm__getFreeBusyResponse*)p->ptr;
		else
			delete[] (_ngwm__getFreeBusyResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getItemRequest:
		if (p->size < 0)
			delete (_ngwm__getItemRequest*)p->ptr;
		else
			delete[] (_ngwm__getItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getItemResponse:
		if (p->size < 0)
			delete (_ngwm__getItemResponse*)p->ptr;
		else
			delete[] (_ngwm__getItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getItemsRequest:
		if (p->size < 0)
			delete (_ngwm__getItemsRequest*)p->ptr;
		else
			delete[] (_ngwm__getItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getItemsResponse:
		if (p->size < 0)
			delete (_ngwm__getItemsResponse*)p->ptr;
		else
			delete[] (_ngwm__getItemsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getJunkEntriesRequest:
		if (p->size < 0)
			delete (_ngwm__getJunkEntriesRequest*)p->ptr;
		else
			delete[] (_ngwm__getJunkEntriesRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getJunkEntriesResponse:
		if (p->size < 0)
			delete (_ngwm__getJunkEntriesResponse*)p->ptr;
		else
			delete[] (_ngwm__getJunkEntriesResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getJunkMailSettingsRequest:
		if (p->size < 0)
			delete (_ngwm__getJunkMailSettingsRequest*)p->ptr;
		else
			delete[] (_ngwm__getJunkMailSettingsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getJunkMailSettingsResponse:
		if (p->size < 0)
			delete (_ngwm__getJunkMailSettingsResponse*)p->ptr;
		else
			delete[] (_ngwm__getJunkMailSettingsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getLibraryItemRequest:
		if (p->size < 0)
			delete (_ngwm__getLibraryItemRequest*)p->ptr;
		else
			delete[] (_ngwm__getLibraryItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getLibraryItemResponse:
		if (p->size < 0)
			delete (_ngwm__getLibraryItemResponse*)p->ptr;
		else
			delete[] (_ngwm__getLibraryItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getLibraryListRequest:
		if (p->size < 0)
			delete (_ngwm__getLibraryListRequest*)p->ptr;
		else
			delete[] (_ngwm__getLibraryListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getLibraryListResponse:
		if (p->size < 0)
			delete (_ngwm__getLibraryListResponse*)p->ptr;
		else
			delete[] (_ngwm__getLibraryListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getQuickMessagesRequest:
		if (p->size < 0)
			delete (_ngwm__getQuickMessagesRequest*)p->ptr;
		else
			delete[] (_ngwm__getQuickMessagesRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getQuickMessagesResponse:
		if (p->size < 0)
			delete (_ngwm__getQuickMessagesResponse*)p->ptr;
		else
			delete[] (_ngwm__getQuickMessagesResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getProxyAccessListRequest:
		if (p->size < 0)
			delete (_ngwm__getProxyAccessListRequest*)p->ptr;
		else
			delete[] (_ngwm__getProxyAccessListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getProxyAccessListResponse:
		if (p->size < 0)
			delete (_ngwm__getProxyAccessListResponse*)p->ptr;
		else
			delete[] (_ngwm__getProxyAccessListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getProxyListRequest:
		if (p->size < 0)
			delete (_ngwm__getProxyListRequest*)p->ptr;
		else
			delete[] (_ngwm__getProxyListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getProxyListResponse:
		if (p->size < 0)
			delete (_ngwm__getProxyListResponse*)p->ptr;
		else
			delete[] (_ngwm__getProxyListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getRuleListRequest:
		if (p->size < 0)
			delete (_ngwm__getRuleListRequest*)p->ptr;
		else
			delete[] (_ngwm__getRuleListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getRuleListResponse:
		if (p->size < 0)
			delete (_ngwm__getRuleListResponse*)p->ptr;
		else
			delete[] (_ngwm__getRuleListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getSettingsRequest:
		if (p->size < 0)
			delete (_ngwm__getSettingsRequest*)p->ptr;
		else
			delete[] (_ngwm__getSettingsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getSettingsResponse:
		if (p->size < 0)
			delete (_ngwm__getSettingsResponse*)p->ptr;
		else
			delete[] (_ngwm__getSettingsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getSignaturesRequest:
		if (p->size < 0)
			delete (_ngwm__getSignaturesRequest*)p->ptr;
		else
			delete[] (_ngwm__getSignaturesRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getSignaturesResponse:
		if (p->size < 0)
			delete (_ngwm__getSignaturesResponse*)p->ptr;
		else
			delete[] (_ngwm__getSignaturesResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getTimestampRequest:
		if (p->size < 0)
			delete (_ngwm__getTimestampRequest*)p->ptr;
		else
			delete[] (_ngwm__getTimestampRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getTimestampResponse:
		if (p->size < 0)
			delete (_ngwm__getTimestampResponse*)p->ptr;
		else
			delete[] (_ngwm__getTimestampResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getTimezoneListRequest:
		if (p->size < 0)
			delete (_ngwm__getTimezoneListRequest*)p->ptr;
		else
			delete[] (_ngwm__getTimezoneListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getTimezoneListResponse:
		if (p->size < 0)
			delete (_ngwm__getTimezoneListResponse*)p->ptr;
		else
			delete[] (_ngwm__getTimezoneListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getUserListRequest:
		if (p->size < 0)
			delete (_ngwm__getUserListRequest*)p->ptr;
		else
			delete[] (_ngwm__getUserListRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__getUserListResponse:
		if (p->size < 0)
			delete (_ngwm__getUserListResponse*)p->ptr;
		else
			delete[] (_ngwm__getUserListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__loginRequest:
		if (p->size < 0)
			delete (_ngwm__loginRequest*)p->ptr;
		else
			delete[] (_ngwm__loginRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__loginResponse:
		if (p->size < 0)
			delete (_ngwm__loginResponse*)p->ptr;
		else
			delete[] (_ngwm__loginResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__logoutRequest:
		if (p->size < 0)
			delete (_ngwm__logoutRequest*)p->ptr;
		else
			delete[] (_ngwm__logoutRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__logoutResponse:
		if (p->size < 0)
			delete (_ngwm__logoutResponse*)p->ptr;
		else
			delete[] (_ngwm__logoutResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__markPrivateRequest:
		if (p->size < 0)
			delete (_ngwm__markPrivateRequest*)p->ptr;
		else
			delete[] (_ngwm__markPrivateRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__markPrivateResponse:
		if (p->size < 0)
			delete (_ngwm__markPrivateResponse*)p->ptr;
		else
			delete[] (_ngwm__markPrivateResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__markReadRequest:
		if (p->size < 0)
			delete (_ngwm__markReadRequest*)p->ptr;
		else
			delete[] (_ngwm__markReadRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__markReadResponse:
		if (p->size < 0)
			delete (_ngwm__markReadResponse*)p->ptr;
		else
			delete[] (_ngwm__markReadResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__markUnPrivateRequest:
		if (p->size < 0)
			delete (_ngwm__markUnPrivateRequest*)p->ptr;
		else
			delete[] (_ngwm__markUnPrivateRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__markUnPrivateResponse:
		if (p->size < 0)
			delete (_ngwm__markUnPrivateResponse*)p->ptr;
		else
			delete[] (_ngwm__markUnPrivateResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__markUnReadRequest:
		if (p->size < 0)
			delete (_ngwm__markUnReadRequest*)p->ptr;
		else
			delete[] (_ngwm__markUnReadRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__markUnReadResponse:
		if (p->size < 0)
			delete (_ngwm__markUnReadResponse*)p->ptr;
		else
			delete[] (_ngwm__markUnReadResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyItemRequest:
		if (p->size < 0)
			delete (_ngwm__modifyItemRequest*)p->ptr;
		else
			delete[] (_ngwm__modifyItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyItemResponse:
		if (p->size < 0)
			delete (_ngwm__modifyItemResponse*)p->ptr;
		else
			delete[] (_ngwm__modifyItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyItemsRequest:
		if (p->size < 0)
			delete (_ngwm__modifyItemsRequest*)p->ptr;
		else
			delete[] (_ngwm__modifyItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyItemsResponse:
		if (p->size < 0)
			delete (_ngwm__modifyItemsResponse*)p->ptr;
		else
			delete[] (_ngwm__modifyItemsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyJunkEntryRequest:
		if (p->size < 0)
			delete (_ngwm__modifyJunkEntryRequest*)p->ptr;
		else
			delete[] (_ngwm__modifyJunkEntryRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyJunkEntryResponse:
		if (p->size < 0)
			delete (_ngwm__modifyJunkEntryResponse*)p->ptr;
		else
			delete[] (_ngwm__modifyJunkEntryResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest:
		if (p->size < 0)
			delete (_ngwm__modifyJunkMailSettingsRequest*)p->ptr;
		else
			delete[] (_ngwm__modifyJunkMailSettingsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse:
		if (p->size < 0)
			delete (_ngwm__modifyJunkMailSettingsResponse*)p->ptr;
		else
			delete[] (_ngwm__modifyJunkMailSettingsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyPasswordRequest:
		if (p->size < 0)
			delete (_ngwm__modifyPasswordRequest*)p->ptr;
		else
			delete[] (_ngwm__modifyPasswordRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyPasswordResponse:
		if (p->size < 0)
			delete (_ngwm__modifyPasswordResponse*)p->ptr;
		else
			delete[] (_ngwm__modifyPasswordResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyProxyAccessRequest:
		if (p->size < 0)
			delete (_ngwm__modifyProxyAccessRequest*)p->ptr;
		else
			delete[] (_ngwm__modifyProxyAccessRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifyProxyAccessResponse:
		if (p->size < 0)
			delete (_ngwm__modifyProxyAccessResponse*)p->ptr;
		else
			delete[] (_ngwm__modifyProxyAccessResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifySettingsRequest:
		if (p->size < 0)
			delete (_ngwm__modifySettingsRequest*)p->ptr;
		else
			delete[] (_ngwm__modifySettingsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifySettingsResponse:
		if (p->size < 0)
			delete (_ngwm__modifySettingsResponse*)p->ptr;
		else
			delete[] (_ngwm__modifySettingsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifySignaturesRequest:
		if (p->size < 0)
			delete (_ngwm__modifySignaturesRequest*)p->ptr;
		else
			delete[] (_ngwm__modifySignaturesRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__modifySignaturesResponse:
		if (p->size < 0)
			delete (_ngwm__modifySignaturesResponse*)p->ptr;
		else
			delete[] (_ngwm__modifySignaturesResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__moveItemRequest:
		if (p->size < 0)
			delete (_ngwm__moveItemRequest*)p->ptr;
		else
			delete[] (_ngwm__moveItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__moveItemResponse:
		if (p->size < 0)
			delete (_ngwm__moveItemResponse*)p->ptr;
		else
			delete[] (_ngwm__moveItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__positionCursorRequest:
		if (p->size < 0)
			delete (_ngwm__positionCursorRequest*)p->ptr;
		else
			delete[] (_ngwm__positionCursorRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__positionCursorResponse:
		if (p->size < 0)
			delete (_ngwm__positionCursorResponse*)p->ptr;
		else
			delete[] (_ngwm__positionCursorResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__purgeDeletedItemsRequest:
		if (p->size < 0)
			delete (_ngwm__purgeDeletedItemsRequest*)p->ptr;
		else
			delete[] (_ngwm__purgeDeletedItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__purgeDeletedItemsResponse:
		if (p->size < 0)
			delete (_ngwm__purgeDeletedItemsResponse*)p->ptr;
		else
			delete[] (_ngwm__purgeDeletedItemsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__purgeRequest:
		if (p->size < 0)
			delete (_ngwm__purgeRequest*)p->ptr;
		else
			delete[] (_ngwm__purgeRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__purgeResponse:
		if (p->size < 0)
			delete (_ngwm__purgeResponse*)p->ptr;
		else
			delete[] (_ngwm__purgeResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__readCursorRequest:
		if (p->size < 0)
			delete (_ngwm__readCursorRequest*)p->ptr;
		else
			delete[] (_ngwm__readCursorRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__readCursorResponse:
		if (p->size < 0)
			delete (_ngwm__readCursorResponse*)p->ptr;
		else
			delete[] (_ngwm__readCursorResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeCustomDefinitionRequest:
		if (p->size < 0)
			delete (_ngwm__removeCustomDefinitionRequest*)p->ptr;
		else
			delete[] (_ngwm__removeCustomDefinitionRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeCustomDefinitionResponse:
		if (p->size < 0)
			delete (_ngwm__removeCustomDefinitionResponse*)p->ptr;
		else
			delete[] (_ngwm__removeCustomDefinitionResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeItemRequest:
		if (p->size < 0)
			delete (_ngwm__removeItemRequest*)p->ptr;
		else
			delete[] (_ngwm__removeItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeItemResponse:
		if (p->size < 0)
			delete (_ngwm__removeItemResponse*)p->ptr;
		else
			delete[] (_ngwm__removeItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeItemsRequest:
		if (p->size < 0)
			delete (_ngwm__removeItemsRequest*)p->ptr;
		else
			delete[] (_ngwm__removeItemsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeItemsResponse:
		if (p->size < 0)
			delete (_ngwm__removeItemsResponse*)p->ptr;
		else
			delete[] (_ngwm__removeItemsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeJunkEntryRequest:
		if (p->size < 0)
			delete (_ngwm__removeJunkEntryRequest*)p->ptr;
		else
			delete[] (_ngwm__removeJunkEntryRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeJunkEntryResponse:
		if (p->size < 0)
			delete (_ngwm__removeJunkEntryResponse*)p->ptr;
		else
			delete[] (_ngwm__removeJunkEntryResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeMembersRequest:
		if (p->size < 0)
			delete (_ngwm__removeMembersRequest*)p->ptr;
		else
			delete[] (_ngwm__removeMembersRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeMembersResponse:
		if (p->size < 0)
			delete (_ngwm__removeMembersResponse*)p->ptr;
		else
			delete[] (_ngwm__removeMembersResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeProxyAccessRequest:
		if (p->size < 0)
			delete (_ngwm__removeProxyAccessRequest*)p->ptr;
		else
			delete[] (_ngwm__removeProxyAccessRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeProxyAccessResponse:
		if (p->size < 0)
			delete (_ngwm__removeProxyAccessResponse*)p->ptr;
		else
			delete[] (_ngwm__removeProxyAccessResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeProxyUserRequest:
		if (p->size < 0)
			delete (_ngwm__removeProxyUserRequest*)p->ptr;
		else
			delete[] (_ngwm__removeProxyUserRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeProxyUserResponse:
		if (p->size < 0)
			delete (_ngwm__removeProxyUserResponse*)p->ptr;
		else
			delete[] (_ngwm__removeProxyUserResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeSignatureRequest:
		if (p->size < 0)
			delete (_ngwm__removeSignatureRequest*)p->ptr;
		else
			delete[] (_ngwm__removeSignatureRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__removeSignatureResponse:
		if (p->size < 0)
			delete (_ngwm__removeSignatureResponse*)p->ptr;
		else
			delete[] (_ngwm__removeSignatureResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__replyRequest:
		if (p->size < 0)
			delete (_ngwm__replyRequest*)p->ptr;
		else
			delete[] (_ngwm__replyRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__replyResponse:
		if (p->size < 0)
			delete (_ngwm__replyResponse*)p->ptr;
		else
			delete[] (_ngwm__replyResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__retractRequest:
		if (p->size < 0)
			delete (_ngwm__retractRequest*)p->ptr;
		else
			delete[] (_ngwm__retractRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__retractResponse:
		if (p->size < 0)
			delete (_ngwm__retractResponse*)p->ptr;
		else
			delete[] (_ngwm__retractResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__sendItemRequest:
		if (p->size < 0)
			delete (_ngwm__sendItemRequest*)p->ptr;
		else
			delete[] (_ngwm__sendItemRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__sendItemResponse:
		if (p->size < 0)
			delete (_ngwm__sendItemResponse*)p->ptr;
		else
			delete[] (_ngwm__sendItemResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__setTimestampRequest:
		if (p->size < 0)
			delete (_ngwm__setTimestampRequest*)p->ptr;
		else
			delete[] (_ngwm__setTimestampRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__setTimestampResponse:
		if (p->size < 0)
			delete (_ngwm__setTimestampResponse*)p->ptr;
		else
			delete[] (_ngwm__setTimestampResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__startFreeBusySessionRequest:
		if (p->size < 0)
			delete (_ngwm__startFreeBusySessionRequest*)p->ptr;
		else
			delete[] (_ngwm__startFreeBusySessionRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__startFreeBusySessionResponse:
		if (p->size < 0)
			delete (_ngwm__startFreeBusySessionResponse*)p->ptr;
		else
			delete[] (_ngwm__startFreeBusySessionResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__unacceptRequest:
		if (p->size < 0)
			delete (_ngwm__unacceptRequest*)p->ptr;
		else
			delete[] (_ngwm__unacceptRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__unacceptResponse:
		if (p->size < 0)
			delete (_ngwm__unacceptResponse*)p->ptr;
		else
			delete[] (_ngwm__unacceptResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__uncompleteRequest:
		if (p->size < 0)
			delete (_ngwm__uncompleteRequest*)p->ptr;
		else
			delete[] (_ngwm__uncompleteRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__uncompleteResponse:
		if (p->size < 0)
			delete (_ngwm__uncompleteResponse*)p->ptr;
		else
			delete[] (_ngwm__uncompleteResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__updateVersionStatusRequest:
		if (p->size < 0)
			delete (_ngwm__updateVersionStatusRequest*)p->ptr;
		else
			delete[] (_ngwm__updateVersionStatusRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwm__updateVersionStatusResponse:
		if (p->size < 0)
			delete (_ngwm__updateVersionStatusResponse*)p->ptr;
		else
			delete[] (_ngwm__updateVersionStatusResponse*)p->ptr;
		break;
	case SOAP_TYPE_ngwe__ContainerList:
		if (p->size < 0)
			delete (ngwe__ContainerList*)p->ptr;
		else
			delete[] (ngwe__ContainerList*)p->ptr;
		break;
	case SOAP_TYPE_ngwe__Event:
		if (p->size < 0)
			delete (ngwe__Event*)p->ptr;
		else
			delete[] (ngwe__Event*)p->ptr;
		break;
	case SOAP_TYPE_ngwe__EventDefinition:
		if (p->size < 0)
			delete (ngwe__EventDefinition*)p->ptr;
		else
			delete[] (ngwe__EventDefinition*)p->ptr;
		break;
	case SOAP_TYPE_ngwe__EventList:
		if (p->size < 0)
			delete (ngwe__EventList*)p->ptr;
		else
			delete[] (ngwe__EventList*)p->ptr;
		break;
	case SOAP_TYPE_ngwe__Events:
		if (p->size < 0)
			delete (ngwe__Events*)p->ptr;
		else
			delete[] (ngwe__Events*)p->ptr;
		break;
	case SOAP_TYPE_ngwe__EventsList:
		if (p->size < 0)
			delete (ngwe__EventsList*)p->ptr;
		else
			delete[] (ngwe__EventsList*)p->ptr;
		break;
	case SOAP_TYPE_ngwe__EventTypeList:
		if (p->size < 0)
			delete (ngwe__EventTypeList*)p->ptr;
		else
			delete[] (ngwe__EventTypeList*)p->ptr;
		break;
	case SOAP_TYPE_ngwe__Notify:
		if (p->size < 0)
			delete (ngwe__Notify*)p->ptr;
		else
			delete[] (ngwe__Notify*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__cleanEventConfigurationRequest:
		if (p->size < 0)
			delete (_ngwe__cleanEventConfigurationRequest*)p->ptr;
		else
			delete[] (_ngwe__cleanEventConfigurationRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__cleanEventConfigurationResponse:
		if (p->size < 0)
			delete (_ngwe__cleanEventConfigurationResponse*)p->ptr;
		else
			delete[] (_ngwe__cleanEventConfigurationResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__configureEventsRequest:
		if (p->size < 0)
			delete (_ngwe__configureEventsRequest*)p->ptr;
		else
			delete[] (_ngwe__configureEventsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__configureEventsResponse:
		if (p->size < 0)
			delete (_ngwe__configureEventsResponse*)p->ptr;
		else
			delete[] (_ngwe__configureEventsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__getEventConfigurationRequest:
		if (p->size < 0)
			delete (_ngwe__getEventConfigurationRequest*)p->ptr;
		else
			delete[] (_ngwe__getEventConfigurationRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__getEventConfigurationResponse:
		if (p->size < 0)
			delete (_ngwe__getEventConfigurationResponse*)p->ptr;
		else
			delete[] (_ngwe__getEventConfigurationResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__getEventsRequest:
		if (p->size < 0)
			delete (_ngwe__getEventsRequest*)p->ptr;
		else
			delete[] (_ngwe__getEventsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__getEventsResponse:
		if (p->size < 0)
			delete (_ngwe__getEventsResponse*)p->ptr;
		else
			delete[] (_ngwe__getEventsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__removeEventConfigurationRequest:
		if (p->size < 0)
			delete (_ngwe__removeEventConfigurationRequest*)p->ptr;
		else
			delete[] (_ngwe__removeEventConfigurationRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__removeEventConfigurationResponse:
		if (p->size < 0)
			delete (_ngwe__removeEventConfigurationResponse*)p->ptr;
		else
			delete[] (_ngwe__removeEventConfigurationResponse*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__removeEventsRequest:
		if (p->size < 0)
			delete (_ngwe__removeEventsRequest*)p->ptr;
		else
			delete[] (_ngwe__removeEventsRequest*)p->ptr;
		break;
	case SOAP_TYPE__ngwe__removeEventsResponse:
		if (p->size < 0)
			delete (_ngwe__removeEventsResponse*)p->ptr;
		else
			delete[] (_ngwe__removeEventsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AccessControlListEntry:
		if (p->size < 0)
			delete (ngwt__AccessControlListEntry*)p->ptr;
		else
			delete[] (ngwt__AccessControlListEntry*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AccessRightEntry:
		if (p->size < 0)
			delete (ngwt__AccessRightEntry*)p->ptr;
		else
			delete[] (ngwt__AccessRightEntry*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AddressBook:
		if (p->size < 0)
			delete (ngwt__AddressBook*)p->ptr;
		else
			delete[] (ngwt__AddressBook*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Alarm:
		if (p->size < 0)
			delete (ngwt__Alarm*)p->ptr;
		else
			delete[] (ngwt__Alarm*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Category:
		if (p->size < 0)
			delete (ngwt__Category*)p->ptr;
		else
			delete[] (ngwt__Category*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__CommentStatus:
		if (p->size < 0)
			delete (ngwt__CommentStatus*)p->ptr;
		else
			delete[] (ngwt__CommentStatus*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ContainerItem:
		if (p->size < 0)
			delete (ngwt__ContainerItem*)p->ptr;
		else
			delete[] (ngwt__ContainerItem*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ContainerRef:
		if (p->size < 0)
			delete (ngwt__ContainerRef*)p->ptr;
		else
			delete[] (ngwt__ContainerRef*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__DelegatedStatus:
		if (p->size < 0)
			delete (ngwt__DelegatedStatus*)p->ptr;
		else
			delete[] (ngwt__DelegatedStatus*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__DelegateeStatus:
		if (p->size < 0)
			delete (ngwt__DelegateeStatus*)p->ptr;
		else
			delete[] (ngwt__DelegateeStatus*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FilterEntry:
		if (p->size < 0)
			delete (ngwt__FilterEntry*)p->ptr;
		else
			delete[] (ngwt__FilterEntry*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FilterGroup:
		if (p->size < 0)
			delete (ngwt__FilterGroup*)p->ptr;
		else
			delete[] (ngwt__FilterGroup*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Folder:
		if (p->size < 0)
			delete (ngwt__Folder*)p->ptr;
		else
			delete[] (ngwt__Folder*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FreeBusyInfo:
		if (p->size < 0)
			delete (ngwt__FreeBusyInfo*)p->ptr;
		else
			delete[] (ngwt__FreeBusyInfo*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__From:
		if (p->size < 0)
			delete (ngwt__From*)p->ptr;
		else
			delete[] (ngwt__From*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ItemRef:
		if (p->size < 0)
			delete (ngwt__ItemRef*)p->ptr;
		else
			delete[] (ngwt__ItemRef*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Library:
		if (p->size < 0)
			delete (ngwt__Library*)p->ptr;
		else
			delete[] (ngwt__Library*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__MessagePart:
		if (p->size < 0)
			delete (ngwt__MessagePart*)p->ptr;
		else
			delete[] (ngwt__MessagePart*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__PhoneNumber:
		if (p->size < 0)
			delete (ngwt__PhoneNumber*)p->ptr;
		else
			delete[] (ngwt__PhoneNumber*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__PlainText:
		if (p->size < 0)
			delete (ngwt__PlainText*)p->ptr;
		else
			delete[] (ngwt__PlainText*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Proxy:
		if (p->size < 0)
			delete (ngwt__Proxy*)p->ptr;
		else
			delete[] (ngwt__Proxy*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ProxyUser:
		if (p->size < 0)
			delete (ngwt__ProxyUser*)p->ptr;
		else
			delete[] (ngwt__ProxyUser*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Recipient:
		if (p->size < 0)
			delete (ngwt__Recipient*)p->ptr;
		else
			delete[] (ngwt__Recipient*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__TransferFailedStatus:
		if (p->size < 0)
			delete (ngwt__TransferFailedStatus*)p->ptr;
		else
			delete[] (ngwt__TransferFailedStatus*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__TrustedApplication:
		if (p->size < 0)
			delete (ngwt__TrustedApplication*)p->ptr;
		else
			delete[] (ngwt__TrustedApplication*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AddressBookItem:
		if (p->size < 0)
			delete (ngwt__AddressBookItem*)p->ptr;
		else
			delete[] (ngwt__AddressBookItem*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__AttachmentID:
		if (p->size < 0)
			delete (ngwt__AttachmentID*)p->ptr;
		else
			delete[] (ngwt__AttachmentID*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__BoxEntry:
		if (p->size < 0)
			delete (ngwt__BoxEntry*)p->ptr;
		else
			delete[] (ngwt__BoxEntry*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__DayOfWeek:
		if (p->size < 0)
			delete (ngwt__DayOfWeek*)p->ptr;
		else
			delete[] (ngwt__DayOfWeek*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__DayOfYearWeek:
		if (p->size < 0)
			delete (ngwt__DayOfYearWeek*)p->ptr;
		else
			delete[] (ngwt__DayOfYearWeek*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Document:
		if (p->size < 0)
			delete (ngwt__Document*)p->ptr;
		else
			delete[] (ngwt__Document*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__FolderACLEntry:
		if (p->size < 0)
			delete (ngwt__FolderACLEntry*)p->ptr;
		else
			delete[] (ngwt__FolderACLEntry*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__QueryFolder:
		if (p->size < 0)
			delete (ngwt__QueryFolder*)p->ptr;
		else
			delete[] (ngwt__QueryFolder*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Rule:
		if (p->size < 0)
			delete (ngwt__Rule*)p->ptr;
		else
			delete[] (ngwt__Rule*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__SharedFolder:
		if (p->size < 0)
			delete (ngwt__SharedFolder*)p->ptr;
		else
			delete[] (ngwt__SharedFolder*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__StatusTracking:
		if (p->size < 0)
			delete (ngwt__StatusTracking*)p->ptr;
		else
			delete[] (ngwt__StatusTracking*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__SystemFolder:
		if (p->size < 0)
			delete (ngwt__SystemFolder*)p->ptr;
		else
			delete[] (ngwt__SystemFolder*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Version:
		if (p->size < 0)
			delete (ngwt__Version*)p->ptr;
		else
			delete[] (ngwt__Version*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__VersionEvent:
		if (p->size < 0)
			delete (ngwt__VersionEvent*)p->ptr;
		else
			delete[] (ngwt__VersionEvent*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Contact:
		if (p->size < 0)
			delete (ngwt__Contact*)p->ptr;
		else
			delete[] (ngwt__Contact*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__ContactFolder:
		if (p->size < 0)
			delete (ngwt__ContactFolder*)p->ptr;
		else
			delete[] (ngwt__ContactFolder*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Group:
		if (p->size < 0)
			delete (ngwt__Group*)p->ptr;
		else
			delete[] (ngwt__Group*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Mail:
		if (p->size < 0)
			delete (ngwt__Mail*)p->ptr;
		else
			delete[] (ngwt__Mail*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Organization:
		if (p->size < 0)
			delete (ngwt__Organization*)p->ptr;
		else
			delete[] (ngwt__Organization*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Resource:
		if (p->size < 0)
			delete (ngwt__Resource*)p->ptr;
		else
			delete[] (ngwt__Resource*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__CalendarItem:
		if (p->size < 0)
			delete (ngwt__CalendarItem*)p->ptr;
		else
			delete[] (ngwt__CalendarItem*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__DocumentRef:
		if (p->size < 0)
			delete (ngwt__DocumentRef*)p->ptr;
		else
			delete[] (ngwt__DocumentRef*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__PhoneMessage:
		if (p->size < 0)
			delete (ngwt__PhoneMessage*)p->ptr;
		else
			delete[] (ngwt__PhoneMessage*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__SharedNotification:
		if (p->size < 0)
			delete (ngwt__SharedNotification*)p->ptr;
		else
			delete[] (ngwt__SharedNotification*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Appointment:
		if (p->size < 0)
			delete (ngwt__Appointment*)p->ptr;
		else
			delete[] (ngwt__Appointment*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Note:
		if (p->size < 0)
			delete (ngwt__Note*)p->ptr;
		else
			delete[] (ngwt__Note*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__Task:
		if (p->size < 0)
			delete (ngwt__Task*)p->ptr;
		else
			delete[] (ngwt__Task*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_xsd__date:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__duration:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__language:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__View:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__uid:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ngwt__UUID:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FilterElement:
		if (p->size < 0)
			delete (std::vector<ngwt__FilterElement * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__FilterElement * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ContainerRef:
		if (p->size < 0)
			delete (std::vector<ngwt__ContainerRef * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__ContainerRef * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwe__EventType:
		if (p->size < 0)
			delete (std::vector<enum ngwe__EventType >*)p->ptr;
		else
			delete[] (std::vector<enum ngwe__EventType >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Events:
		if (p->size < 0)
			delete (std::vector<ngwe__Events * >*)p->ptr;
		else
			delete[] (std::vector<ngwe__Events * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Event:
		if (p->size < 0)
			delete (std::vector<ngwe__Event * >*)p->ptr;
		else
			delete[] (std::vector<ngwe__Event * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstring:
		if (p->size < 0)
			delete (std::vector<char * >*)p->ptr;
		else
			delete[] (std::vector<char * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ModifyItem:
		if (p->size < 0)
			delete (std::vector<ngwt__ModifyItem * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__ModifyItem * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Host:
		if (p->size < 0)
			delete (std::vector<ngwt__Host * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__Host * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__UserInfo:
		if (p->size < 0)
			delete (std::vector<ngwt__UserInfo * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__UserInfo * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Timezone:
		if (p->size < 0)
			delete (std::vector<ngwt__Timezone * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__Timezone * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Signature:
		if (p->size < 0)
			delete (std::vector<ngwt__Signature * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__Signature * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__SettingsGroup:
		if (p->size < 0)
			delete (std::vector<ngwt__SettingsGroup * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__SettingsGroup * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Rule:
		if (p->size < 0)
			delete (std::vector<ngwt__Rule * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__Rule * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__RuleAction:
		if (p->size < 0)
			delete (std::vector<ngwt__RuleAction * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__RuleAction * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__date:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DelegateeStatus:
		if (p->size < 0)
			delete (std::vector<ngwt__DelegateeStatus * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__DelegateeStatus * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Recipient:
		if (p->size < 0)
			delete (std::vector<ngwt__Recipient * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__Recipient * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProxyUser:
		if (p->size < 0)
			delete (std::vector<ngwt__ProxyUser * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__ProxyUser * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProblemEntry:
		if (p->size < 0)
			delete (std::vector<ngwt__ProblemEntry * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__ProblemEntry * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PostalAddress:
		if (p->size < 0)
			delete (std::vector<ngwt__PostalAddress * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__PostalAddress * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PhoneNumber:
		if (p->size < 0)
			delete (std::vector<ngwt__PhoneNumber * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__PhoneNumber * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwt__Month:
		if (p->size < 0)
			delete (std::vector<unsigned char >*)p->ptr;
		else
			delete[] (std::vector<unsigned char >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__MessagePart:
		if (p->size < 0)
			delete (std::vector<ngwt__MessagePart * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__MessagePart * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Library:
		if (p->size < 0)
			delete (std::vector<ngwt__Library * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__Library * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__JunkEntry:
		if (p->size < 0)
			delete (std::vector<ngwt__JunkEntry * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__JunkEntry * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Item:
		if (p->size < 0)
			delete (std::vector<ngwt__Item * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__Item * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ImAddress:
		if (p->size < 0)
			delete (std::vector<ngwt__ImAddress * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__ImAddress * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__GroupMember:
		if (p->size < 0)
			delete (std::vector<ngwt__GroupMember * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__GroupMember * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyInfo:
		if (p->size < 0)
			delete (std::vector<ngwt__FreeBusyInfo * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__FreeBusyInfo * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__NameAndEmail:
		if (p->size < 0)
			delete (std::vector<ngwt__NameAndEmail * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__NameAndEmail * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyBlock:
		if (p->size < 0)
			delete (std::vector<ngwt__FreeBusyBlock * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__FreeBusyBlock * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Folder:
		if (p->size < 0)
			delete (std::vector<ngwt__Folder * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__Folder * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FolderACLEntry:
		if (p->size < 0)
			delete (std::vector<ngwt__FolderACLEntry * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__FolderACLEntry * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DocumentType:
		if (p->size < 0)
			delete (std::vector<ngwt__DocumentType * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__DocumentType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DayOfYearWeek:
		if (p->size < 0)
			delete (std::vector<ngwt__DayOfYearWeek * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__DayOfYearWeek * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwt__DayOfYear:
		if (p->size < 0)
			delete (std::vector<short >*)p->ptr;
		else
			delete[] (std::vector<short >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwt__DayOfMonth:
		if (p->size < 0)
			delete (std::vector<char >*)p->ptr;
		else
			delete[] (std::vector<char >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Custom:
		if (p->size < 0)
			delete (std::vector<ngwt__Custom * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__Custom * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwt__uid:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Category:
		if (p->size < 0)
			delete (std::vector<ngwt__Category * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__Category * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwt__CalendarFolderFlags:
		if (p->size < 0)
			delete (std::vector<enum ngwt__CalendarFolderFlags >*)p->ptr;
		else
			delete[] (std::vector<enum ngwt__CalendarFolderFlags >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo:
		if (p->size < 0)
			delete (std::vector<ngwt__AttachmentItemInfo * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__AttachmentItemInfo * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AddressBook:
		if (p->size < 0)
			delete (std::vector<ngwt__AddressBook * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__AddressBook * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessRightEntry:
		if (p->size < 0)
			delete (std::vector<ngwt__AccessRightEntry * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__AccessRightEntry * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessControlListEntry:
		if (p->size < 0)
			delete (std::vector<ngwt__AccessControlListEntry * >*)p->ptr;
		else
			delete[] (std::vector<ngwt__AccessControlListEntry * >*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FilterElement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__FilterElement * >*)p)->insert(((std::vector<ngwt__FilterElement * >*)p)->end(), *(ngwt__FilterElement **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ContainerRef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__ContainerRef * >*)p)->insert(((std::vector<ngwt__ContainerRef * >*)p)->end(), *(ngwt__ContainerRef **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwe__EventType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<enum ngwe__EventType >*)p)->insert(((std::vector<enum ngwe__EventType >*)p)->end(), *(enum ngwe__EventType *)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Events:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwe__Events * >*)p)->insert(((std::vector<ngwe__Events * >*)p)->end(), *(ngwe__Events **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Event:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwe__Event * >*)p)->insert(((std::vector<ngwe__Event * >*)p)->end(), *(ngwe__Event **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstring:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<char * >*)p)->insert(((std::vector<char * >*)p)->end(), *(char **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ModifyItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__ModifyItem * >*)p)->insert(((std::vector<ngwt__ModifyItem * >*)p)->end(), *(ngwt__ModifyItem **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Host:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__Host * >*)p)->insert(((std::vector<ngwt__Host * >*)p)->end(), *(ngwt__Host **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__UserInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__UserInfo * >*)p)->insert(((std::vector<ngwt__UserInfo * >*)p)->end(), *(ngwt__UserInfo **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Timezone:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__Timezone * >*)p)->insert(((std::vector<ngwt__Timezone * >*)p)->end(), *(ngwt__Timezone **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Signature:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__Signature * >*)p)->insert(((std::vector<ngwt__Signature * >*)p)->end(), *(ngwt__Signature **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__SettingsGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__SettingsGroup * >*)p)->insert(((std::vector<ngwt__SettingsGroup * >*)p)->end(), *(ngwt__SettingsGroup **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Rule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__Rule * >*)p)->insert(((std::vector<ngwt__Rule * >*)p)->end(), *(ngwt__Rule **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__RuleAction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__RuleAction * >*)p)->insert(((std::vector<ngwt__RuleAction * >*)p)->end(), *(ngwt__RuleAction **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__date:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<std::string >*)p)->insert(((std::vector<std::string >*)p)->end(), *(std::string *)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DelegateeStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__DelegateeStatus * >*)p)->insert(((std::vector<ngwt__DelegateeStatus * >*)p)->end(), *(ngwt__DelegateeStatus **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Recipient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__Recipient * >*)p)->insert(((std::vector<ngwt__Recipient * >*)p)->end(), *(ngwt__Recipient **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProxyUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__ProxyUser * >*)p)->insert(((std::vector<ngwt__ProxyUser * >*)p)->end(), *(ngwt__ProxyUser **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProblemEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__ProblemEntry * >*)p)->insert(((std::vector<ngwt__ProblemEntry * >*)p)->end(), *(ngwt__ProblemEntry **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PostalAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__PostalAddress * >*)p)->insert(((std::vector<ngwt__PostalAddress * >*)p)->end(), *(ngwt__PostalAddress **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PhoneNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__PhoneNumber * >*)p)->insert(((std::vector<ngwt__PhoneNumber * >*)p)->end(), *(ngwt__PhoneNumber **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwt__Month:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<unsigned char >*)p)->insert(((std::vector<unsigned char >*)p)->end(), *(unsigned char *)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__MessagePart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__MessagePart * >*)p)->insert(((std::vector<ngwt__MessagePart * >*)p)->end(), *(ngwt__MessagePart **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Library:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__Library * >*)p)->insert(((std::vector<ngwt__Library * >*)p)->end(), *(ngwt__Library **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__JunkEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__JunkEntry * >*)p)->insert(((std::vector<ngwt__JunkEntry * >*)p)->end(), *(ngwt__JunkEntry **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Item:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__Item * >*)p)->insert(((std::vector<ngwt__Item * >*)p)->end(), *(ngwt__Item **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ImAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__ImAddress * >*)p)->insert(((std::vector<ngwt__ImAddress * >*)p)->end(), *(ngwt__ImAddress **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__GroupMember:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__GroupMember * >*)p)->insert(((std::vector<ngwt__GroupMember * >*)p)->end(), *(ngwt__GroupMember **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__FreeBusyInfo * >*)p)->insert(((std::vector<ngwt__FreeBusyInfo * >*)p)->end(), *(ngwt__FreeBusyInfo **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__NameAndEmail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__NameAndEmail * >*)p)->insert(((std::vector<ngwt__NameAndEmail * >*)p)->end(), *(ngwt__NameAndEmail **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyBlock:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__FreeBusyBlock * >*)p)->insert(((std::vector<ngwt__FreeBusyBlock * >*)p)->end(), *(ngwt__FreeBusyBlock **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Folder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__Folder * >*)p)->insert(((std::vector<ngwt__Folder * >*)p)->end(), *(ngwt__Folder **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FolderACLEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__FolderACLEntry * >*)p)->insert(((std::vector<ngwt__FolderACLEntry * >*)p)->end(), *(ngwt__FolderACLEntry **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<std::string >*)p)->insert(((std::vector<std::string >*)p)->end(), *(std::string *)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DocumentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__DocumentType * >*)p)->insert(((std::vector<ngwt__DocumentType * >*)p)->end(), *(ngwt__DocumentType **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DayOfYearWeek:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__DayOfYearWeek * >*)p)->insert(((std::vector<ngwt__DayOfYearWeek * >*)p)->end(), *(ngwt__DayOfYearWeek **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwt__DayOfYear:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<short >*)p)->insert(((std::vector<short >*)p)->end(), *(short *)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwt__DayOfMonth:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<char >*)p)->insert(((std::vector<char >*)p)->end(), *(char *)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Custom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__Custom * >*)p)->insert(((std::vector<ngwt__Custom * >*)p)->end(), *(ngwt__Custom **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwt__uid:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<std::string >*)p)->insert(((std::vector<std::string >*)p)->end(), *(std::string *)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Category:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__Category * >*)p)->insert(((std::vector<ngwt__Category * >*)p)->end(), *(ngwt__Category **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfngwt__CalendarFolderFlags:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<enum ngwt__CalendarFolderFlags >*)p)->insert(((std::vector<enum ngwt__CalendarFolderFlags >*)p)->end(), *(enum ngwt__CalendarFolderFlags *)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__AttachmentItemInfo * >*)p)->insert(((std::vector<ngwt__AttachmentItemInfo * >*)p)->end(), *(ngwt__AttachmentItemInfo **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AddressBook:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__AddressBook * >*)p)->insert(((std::vector<ngwt__AddressBook * >*)p)->end(), *(ngwt__AddressBook **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessRightEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__AccessRightEntry * >*)p)->insert(((std::vector<ngwt__AccessRightEntry * >*)p)->end(), *(ngwt__AccessRightEntry **)q);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessControlListEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p\n", st, tt, p, q));
		((std::vector<ngwt__AccessControlListEntry * >*)p)->insert(((std::vector<ngwt__AccessControlListEntry * >*)p)->end(), *(ngwt__AccessControlListEntry **)q);
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__DayOfMonth(struct soap *soap, char *a)
{	soap_default_byte(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__DayOfMonth(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__DayOfMonth);
	if (soap_out_ngwt__DayOfMonth(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DayOfMonth(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_ngwt__DayOfMonth);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_ngwt__DayOfMonth(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DayOfMonth(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_ngwt__DayOfMonth(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_ngwt__DayOfMonth);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__WeekOfYear(struct soap *soap, short *a)
{	soap_default_short(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__WeekOfYear(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__WeekOfYear);
	if (soap_out_ngwt__WeekOfYear(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__WeekOfYear(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_ngwt__WeekOfYear);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_ngwt__WeekOfYear(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__WeekOfYear(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_ngwt__WeekOfYear(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_ngwt__WeekOfYear);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__DayOfYear(struct soap *soap, short *a)
{	soap_default_short(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__DayOfYear(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__DayOfYear);
	if (soap_out_ngwt__DayOfYear(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DayOfYear(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_ngwt__DayOfYear);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_ngwt__DayOfYear(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DayOfYear(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_ngwt__DayOfYear(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_ngwt__DayOfYear);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__GMTOffset(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__GMTOffset(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__GMTOffset);
	if (soap_out_ngwt__GMTOffset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__GMTOffset(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ngwt__GMTOffset);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ngwt__GMTOffset(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__GMTOffset(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_ngwt__GMTOffset(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_ngwt__GMTOffset);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{
	return soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__Month(struct soap *soap, unsigned char *a)
{	soap_default_unsignedByte(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__Month(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__Month);
	if (soap_out_ngwt__Month(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Month(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_ngwt__Month);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_ngwt__Month(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Month(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_ngwt__Month(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_ngwt__Month);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__Minute(struct soap *soap, unsigned char *a)
{	soap_default_unsignedByte(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__Minute(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__Minute);
	if (soap_out_ngwt__Minute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Minute(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_ngwt__Minute);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_ngwt__Minute(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Minute(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_ngwt__Minute(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_ngwt__Minute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__Hour(struct soap *soap, unsigned char *a)
{	soap_default_unsignedByte(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__Hour(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__Hour);
	if (soap_out_ngwt__Hour(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Hour(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_ngwt__Hour);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_ngwt__Hour(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Hour(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_ngwt__Hour(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_ngwt__Hour);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__Day(struct soap *soap, unsigned char *a)
{	soap_default_unsignedByte(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__Day(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__Day);
	if (soap_out_ngwt__Day(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Day(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_ngwt__Day);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_ngwt__Day(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Day(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_ngwt__Day(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_ngwt__Day);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLong(struct soap *soap, unsigned long *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLong
	*a = SOAP_DEFAULT_unsignedLong;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLong(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLong);
	if (soap_out_unsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLong(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_unsignedLong(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_unsignedLong(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	const char *s = soap_str_code(soap_codes_bool, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (bool)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwe__ItemType(struct soap *soap, enum ngwe__ItemType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwe__ItemType
	*a = SOAP_DEFAULT_ngwe__ItemType;
#else
	*a = (enum ngwe__ItemType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwe__ItemType(struct soap *soap, const enum ngwe__ItemType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwe__ItemType);
	if (soap_out_ngwe__ItemType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwe__ItemType[] =
{	{ (long)AddressBookItem_, "AddressBookItem" },
	{ (long)Appointment___, "Appointment" },
	{ (long)CalendarItem___, "CalendarItem" },
	{ (long)Contact____, "Contact" },
	{ (long)Group__, "Group" },
	{ (long)Mail___, "Mail" },
	{ (long)Note___, "Note" },
	{ (long)Organization____, "Organization" },
	{ (long)PhoneMessage___, "PhoneMessage" },
	{ (long)Resource___, "Resource" },
	{ (long)Task___, "Task" },
	{ (long)DocumentRef_, "DocumentRef" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwe__ItemType2s(struct soap *soap, enum ngwe__ItemType n)
{	const char *s = soap_str_code(soap_codes_ngwe__ItemType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__ItemType(struct soap *soap, const char *tag, int id, const enum ngwe__ItemType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__ItemType), type);
	soap_send(soap, soap_ngwe__ItemType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwe__ItemType * SOAP_FMAC4 soap_get_ngwe__ItemType(struct soap *soap, enum ngwe__ItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__ItemType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwe__ItemType(struct soap *soap, const char *s, enum ngwe__ItemType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwe__ItemType, s);
	if (map)
		*a = (enum ngwe__ItemType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwe__ItemType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwe__ItemType * SOAP_FMAC4 soap_in_ngwe__ItemType(struct soap *soap, const char *tag, enum ngwe__ItemType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwe__ItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__ItemType, sizeof(enum ngwe__ItemType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwe__ItemType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwe__ItemType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__ItemType, 0, sizeof(enum ngwe__ItemType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwe__Field(struct soap *soap, enum ngwe__Field *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwe__Field
	*a = SOAP_DEFAULT_ngwe__Field;
#else
	*a = (enum ngwe__Field)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwe__Field(struct soap *soap, const enum ngwe__Field *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwe__Field);
	if (soap_out_ngwe__Field(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwe__Field[] =
{	{ (long)AcceptLevel_, "AcceptLevel" },
	{ (long)Alarm_, "Alarm" },
	{ (long)AllDayEvent_, "AllDayEvent" },
	{ (long)Attachment_, "Attachment" },
	{ (long)Category__, "Category" },
	{ (long)Classification_, "Classification" },
	{ (long)Contact___, "Contact" },
	{ (long)DueDate_, "DueDate" },
	{ (long)Duration_, "Duration" },
	{ (long)EmailAddress_, "EmailAddress" },
	{ (long)ExpirationDate_, "ExpirationDate" },
	{ (long)Hidden_, "Hidden" },
	{ (long)IMAddress_, "IMAddress" },
	{ (long)MessageBody_, "MessageBody" },
	{ (long)Name_, "Name" },
	{ (long)Organization___, "Organization" },
	{ (long)Owner_, "Owner" },
	{ (long)PersonalSubject_, "PersonalSubject" },
	{ (long)PhoneNumber_, "PhoneNumber" },
	{ (long)Place_, "Place" },
	{ (long)PostalAddress_, "PostalAddress" },
	{ (long)RecipientStatus_, "RecipientStatus" },
	{ (long)Rights_, "Rights" },
	{ (long)Security_, "Security" },
	{ (long)SendPriority_, "SendPriority" },
	{ (long)StartDate_, "StartDate" },
	{ (long)Subject_, "Subject" },
	{ (long)TaskCategory_, "TaskCategory" },
	{ (long)TaskPriority_, "TaskPriority" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwe__Field2s(struct soap *soap, enum ngwe__Field n)
{	const char *s = soap_str_code(soap_codes_ngwe__Field, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__Field(struct soap *soap, const char *tag, int id, const enum ngwe__Field *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__Field), type);
	soap_send(soap, soap_ngwe__Field2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwe__Field * SOAP_FMAC4 soap_get_ngwe__Field(struct soap *soap, enum ngwe__Field *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__Field(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwe__Field(struct soap *soap, const char *s, enum ngwe__Field *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwe__Field, s);
	if (map)
		*a = (enum ngwe__Field)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwe__Field)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwe__Field * SOAP_FMAC4 soap_in_ngwe__Field(struct soap *soap, const char *tag, enum ngwe__Field *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwe__Field *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__Field, sizeof(enum ngwe__Field), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwe__Field(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwe__Field *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__Field, 0, sizeof(enum ngwe__Field), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwe__EventType(struct soap *soap, enum ngwe__EventType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwe__EventType
	*a = SOAP_DEFAULT_ngwe__EventType;
#else
	*a = (enum ngwe__EventType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwe__EventType(struct soap *soap, const enum ngwe__EventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwe__EventType);
	if (soap_out_ngwe__EventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwe__EventType[] =
{	{ (long)AddressBookAdd, "AddressBookAdd" },
	{ (long)AddressBookDelete, "AddressBookDelete" },
	{ (long)AddressBookModify, "AddressBookModify" },
	{ (long)AddressBookItemAdd, "AddressBookItemAdd" },
	{ (long)AddressBookItemDelete, "AddressBookItemDelete" },
	{ (long)AddressBookItemModify, "AddressBookItemModify" },
	{ (long)FolderAccept, "FolderAccept" },
	{ (long)FolderAdd, "FolderAdd" },
	{ (long)FolderDelete, "FolderDelete" },
	{ (long)FolderItemAdd, "FolderItemAdd" },
	{ (long)FolderItemDelete, "FolderItemDelete" },
	{ (long)FolderItemMove, "FolderItemMove" },
	{ (long)FolderModify, "FolderModify" },
	{ (long)ItemAccept, "ItemAccept" },
	{ (long)ItemArchive, "ItemArchive" },
	{ (long)ItemComplete, "ItemComplete" },
	{ (long)ItemDecline, "ItemDecline" },
	{ (long)ItemDelete, "ItemDelete" },
	{ (long)ItemMarkPrivate, "ItemMarkPrivate" },
	{ (long)ItemMarkRead, "ItemMarkRead" },
	{ (long)ItemMarkUnread, "ItemMarkUnread" },
	{ (long)ItemModify, "ItemModify" },
	{ (long)ItemPurge, "ItemPurge" },
	{ (long)ItemUnarchive, "ItemUnarchive" },
	{ (long)ItemUndelete, "ItemUndelete" },
	{ (long)Login, "Login" },
	{ (long)Logout, "Logout" },
	{ (long)ProxyAccessAdd, "ProxyAccessAdd" },
	{ (long)ProxyAccessModify, "ProxyAccessModify" },
	{ (long)ProxyAccessDelete, "ProxyAccessDelete" },
	{ (long)ProxyLogin, "ProxyLogin" },
	{ (long)SessionTimedOut, "SessionTimedOut" },
	{ (long)TrustedApplicationLogin, "TrustedApplicationLogin" },
	{ (long)ItemMarkUnprivate, "ItemMarkUnprivate" },
	{ (long)ItemUnaccept, "ItemUnaccept" },
	{ (long)ItemUncomplete, "ItemUncomplete" },
	{ (long)PersonalGroupItemAdd, "PersonalGroupItemAdd" },
	{ (long)PersonalGroupItemDelete, "PersonalGroupItemDelete" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwe__EventType2s(struct soap *soap, enum ngwe__EventType n)
{	const char *s = soap_str_code(soap_codes_ngwe__EventType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__EventType(struct soap *soap, const char *tag, int id, const enum ngwe__EventType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__EventType), type);
	soap_send(soap, soap_ngwe__EventType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwe__EventType * SOAP_FMAC4 soap_get_ngwe__EventType(struct soap *soap, enum ngwe__EventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__EventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwe__EventType(struct soap *soap, const char *s, enum ngwe__EventType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwe__EventType, s);
	if (map)
		*a = (enum ngwe__EventType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwe__EventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwe__EventType * SOAP_FMAC4 soap_in_ngwe__EventType(struct soap *soap, const char *tag, enum ngwe__EventType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwe__EventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__EventType, sizeof(enum ngwe__EventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwe__EventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwe__EventType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__EventType, 0, sizeof(enum ngwe__EventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__WeekDay(struct soap *soap, enum ngwt__WeekDay *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__WeekDay
	*a = SOAP_DEFAULT_ngwt__WeekDay;
#else
	*a = (enum ngwt__WeekDay)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__WeekDay(struct soap *soap, const enum ngwt__WeekDay *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__WeekDay);
	if (soap_out_ngwt__WeekDay(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__WeekDay[] =
{	{ (long)Sunday, "Sunday" },
	{ (long)Monday, "Monday" },
	{ (long)Tuesday, "Tuesday" },
	{ (long)Wednesday, "Wednesday" },
	{ (long)Thursday, "Thursday" },
	{ (long)Friday, "Friday" },
	{ (long)Saturday, "Saturday" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__WeekDay2s(struct soap *soap, enum ngwt__WeekDay n)
{	const char *s = soap_str_code(soap_codes_ngwt__WeekDay, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__WeekDay(struct soap *soap, const char *tag, int id, const enum ngwt__WeekDay *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__WeekDay), type);
	soap_send(soap, soap_ngwt__WeekDay2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__WeekDay * SOAP_FMAC4 soap_get_ngwt__WeekDay(struct soap *soap, enum ngwt__WeekDay *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__WeekDay(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__WeekDay(struct soap *soap, const char *s, enum ngwt__WeekDay *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__WeekDay, s);
	if (map)
		*a = (enum ngwt__WeekDay)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__WeekDay)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__WeekDay * SOAP_FMAC4 soap_in_ngwt__WeekDay(struct soap *soap, const char *tag, enum ngwt__WeekDay *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__WeekDay *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__WeekDay, sizeof(enum ngwt__WeekDay), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__WeekDay(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__WeekDay *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__WeekDay, 0, sizeof(enum ngwt__WeekDay), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__VersionStatus(struct soap *soap, enum ngwt__VersionStatus *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__VersionStatus
	*a = SOAP_DEFAULT_ngwt__VersionStatus;
#else
	*a = (enum ngwt__VersionStatus)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__VersionStatus(struct soap *soap, const enum ngwt__VersionStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__VersionStatus);
	if (soap_out_ngwt__VersionStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__VersionStatus[] =
{	{ (long)available, "available" },
	{ (long)checkedOut, "checkedOut" },
	{ (long)inUse, "inUse" },
	{ (long)deleted_, "deleted" },
	{ (long)archived, "archived" },
	{ (long)massInUse, "massInUse" },
	{ (long)unavailable, "unavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__VersionStatus2s(struct soap *soap, enum ngwt__VersionStatus n)
{	const char *s = soap_str_code(soap_codes_ngwt__VersionStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__VersionStatus(struct soap *soap, const char *tag, int id, const enum ngwt__VersionStatus *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__VersionStatus), type);
	soap_send(soap, soap_ngwt__VersionStatus2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__VersionStatus * SOAP_FMAC4 soap_get_ngwt__VersionStatus(struct soap *soap, enum ngwt__VersionStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__VersionStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__VersionStatus(struct soap *soap, const char *s, enum ngwt__VersionStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__VersionStatus, s);
	if (map)
		*a = (enum ngwt__VersionStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__VersionStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__VersionStatus * SOAP_FMAC4 soap_in_ngwt__VersionStatus(struct soap *soap, const char *tag, enum ngwt__VersionStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__VersionStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__VersionStatus, sizeof(enum ngwt__VersionStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__VersionStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__VersionStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__VersionStatus, 0, sizeof(enum ngwt__VersionStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__VersionEventType(struct soap *soap, enum ngwt__VersionEventType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__VersionEventType
	*a = SOAP_DEFAULT_ngwt__VersionEventType;
#else
	*a = (enum ngwt__VersionEventType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__VersionEventType(struct soap *soap, const enum ngwt__VersionEventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__VersionEventType);
	if (soap_out_ngwt__VersionEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__VersionEventType[] =
{	{ (long)archive_, "archive" },
	{ (long)checkIn, "checkIn" },
	{ (long)checkOut, "checkOut" },
	{ (long)copyIn, "copyIn" },
	{ (long)copyOut, "copyOut" },
	{ (long)copyVersion, "copyVersion" },
	{ (long)created, "created" },
	{ (long)deleteVersion, "deleteVersion" },
	{ (long)endAccess, "endAccess" },
	{ (long)resetStatus, "resetStatus" },
	{ (long)restore, "restore" },
	{ (long)retrieve, "retrieve" },
	{ (long)securityModified, "securityModified" },
	{ (long)versionDownloaded, "versionDownloaded" },
	{ (long)viewed, "viewed" },
	{ (long)unknown, "unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__VersionEventType2s(struct soap *soap, enum ngwt__VersionEventType n)
{	const char *s = soap_str_code(soap_codes_ngwt__VersionEventType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__VersionEventType(struct soap *soap, const char *tag, int id, const enum ngwt__VersionEventType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__VersionEventType), type);
	soap_send(soap, soap_ngwt__VersionEventType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__VersionEventType * SOAP_FMAC4 soap_get_ngwt__VersionEventType(struct soap *soap, enum ngwt__VersionEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__VersionEventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__VersionEventType(struct soap *soap, const char *s, enum ngwt__VersionEventType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__VersionEventType, s);
	if (map)
		*a = (enum ngwt__VersionEventType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__VersionEventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__VersionEventType * SOAP_FMAC4 soap_in_ngwt__VersionEventType(struct soap *soap, const char *tag, enum ngwt__VersionEventType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__VersionEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__VersionEventType, sizeof(enum ngwt__VersionEventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__VersionEventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__VersionEventType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__VersionEventType, 0, sizeof(enum ngwt__VersionEventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__StatusTrackingOptions(struct soap *soap, enum ngwt__StatusTrackingOptions *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__StatusTrackingOptions
	*a = SOAP_DEFAULT_ngwt__StatusTrackingOptions;
#else
	*a = (enum ngwt__StatusTrackingOptions)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__StatusTrackingOptions(struct soap *soap, const enum ngwt__StatusTrackingOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__StatusTrackingOptions);
	if (soap_out_ngwt__StatusTrackingOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__StatusTrackingOptions[] =
{	{ (long)None, "None" },
	{ (long)Delivered, "Delivered" },
	{ (long)DeliveredAndOpened, "DeliveredAndOpened" },
	{ (long)All_, "All" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__StatusTrackingOptions2s(struct soap *soap, enum ngwt__StatusTrackingOptions n)
{	const char *s = soap_str_code(soap_codes_ngwt__StatusTrackingOptions, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__StatusTrackingOptions(struct soap *soap, const char *tag, int id, const enum ngwt__StatusTrackingOptions *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__StatusTrackingOptions), type);
	soap_send(soap, soap_ngwt__StatusTrackingOptions2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__StatusTrackingOptions * SOAP_FMAC4 soap_get_ngwt__StatusTrackingOptions(struct soap *soap, enum ngwt__StatusTrackingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__StatusTrackingOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__StatusTrackingOptions(struct soap *soap, const char *s, enum ngwt__StatusTrackingOptions *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__StatusTrackingOptions, s);
	if (map)
		*a = (enum ngwt__StatusTrackingOptions)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__StatusTrackingOptions)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__StatusTrackingOptions * SOAP_FMAC4 soap_in_ngwt__StatusTrackingOptions(struct soap *soap, const char *tag, enum ngwt__StatusTrackingOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__StatusTrackingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__StatusTrackingOptions, sizeof(enum ngwt__StatusTrackingOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__StatusTrackingOptions(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__StatusTrackingOptions *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__StatusTrackingOptions, 0, sizeof(enum ngwt__StatusTrackingOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__RuleActionType(struct soap *soap, enum ngwt__RuleActionType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__RuleActionType
	*a = SOAP_DEFAULT_ngwt__RuleActionType;
#else
	*a = (enum ngwt__RuleActionType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__RuleActionType(struct soap *soap, const enum ngwt__RuleActionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__RuleActionType);
	if (soap_out_ngwt__RuleActionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__RuleActionType[] =
{	{ (long)Accept, "Accept" },
	{ (long)Archive, "Archive" },
	{ (long)Category_, "Category" },
	{ (long)Delegate, "Delegate" },
	{ (long)Delete, "Delete" },
	{ (long)Forward, "Forward" },
	{ (long)Link, "Link" },
	{ (long)MarkPrivate, "MarkPrivate" },
	{ (long)MarkRead, "MarkRead" },
	{ (long)MarkUnread, "MarkUnread" },
	{ (long)Move, "Move" },
	{ (long)Purge, "Purge" },
	{ (long)Reply, "Reply" },
	{ (long)Send, "Send" },
	{ (long)StopRules, "StopRules" },
	{ (long)Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__RuleActionType2s(struct soap *soap, enum ngwt__RuleActionType n)
{	const char *s = soap_str_code(soap_codes_ngwt__RuleActionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__RuleActionType(struct soap *soap, const char *tag, int id, const enum ngwt__RuleActionType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__RuleActionType), type);
	soap_send(soap, soap_ngwt__RuleActionType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__RuleActionType * SOAP_FMAC4 soap_get_ngwt__RuleActionType(struct soap *soap, enum ngwt__RuleActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__RuleActionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__RuleActionType(struct soap *soap, const char *s, enum ngwt__RuleActionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__RuleActionType, s);
	if (map)
		*a = (enum ngwt__RuleActionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__RuleActionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__RuleActionType * SOAP_FMAC4 soap_in_ngwt__RuleActionType(struct soap *soap, const char *tag, enum ngwt__RuleActionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__RuleActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__RuleActionType, sizeof(enum ngwt__RuleActionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__RuleActionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__RuleActionType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RuleActionType, 0, sizeof(enum ngwt__RuleActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__RetractType(struct soap *soap, enum ngwt__RetractType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__RetractType
	*a = SOAP_DEFAULT_ngwt__RetractType;
#else
	*a = (enum ngwt__RetractType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__RetractType(struct soap *soap, const enum ngwt__RetractType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__RetractType);
	if (soap_out_ngwt__RetractType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__RetractType[] =
{	{ (long)myMailbox, "myMailbox" },
	{ (long)recipientMailboxes, "recipientMailboxes" },
	{ (long)allMailboxes, "allMailboxes" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__RetractType2s(struct soap *soap, enum ngwt__RetractType n)
{	const char *s = soap_str_code(soap_codes_ngwt__RetractType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__RetractType(struct soap *soap, const char *tag, int id, const enum ngwt__RetractType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__RetractType), type);
	soap_send(soap, soap_ngwt__RetractType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__RetractType * SOAP_FMAC4 soap_get_ngwt__RetractType(struct soap *soap, enum ngwt__RetractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__RetractType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__RetractType(struct soap *soap, const char *s, enum ngwt__RetractType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__RetractType, s);
	if (map)
		*a = (enum ngwt__RetractType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__RetractType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__RetractType * SOAP_FMAC4 soap_in_ngwt__RetractType(struct soap *soap, const char *tag, enum ngwt__RetractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__RetractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__RetractType, sizeof(enum ngwt__RetractType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__RetractType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__RetractType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RetractType, 0, sizeof(enum ngwt__RetractType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__RecipientType(struct soap *soap, enum ngwt__RecipientType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__RecipientType
	*a = SOAP_DEFAULT_ngwt__RecipientType;
#else
	*a = (enum ngwt__RecipientType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__RecipientType(struct soap *soap, const enum ngwt__RecipientType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__RecipientType);
	if (soap_out_ngwt__RecipientType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__RecipientType[] =
{	{ (long)User_, "User" },
	{ (long)Resource__, "Resource" },
	{ (long)PersonalGroup, "PersonalGroup" },
	{ (long)SystemGroup, "SystemGroup" },
	{ (long)PersonalGroupMember, "PersonalGroupMember" },
	{ (long)SystemGroupMember, "SystemGroupMember" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__RecipientType2s(struct soap *soap, enum ngwt__RecipientType n)
{	const char *s = soap_str_code(soap_codes_ngwt__RecipientType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__RecipientType(struct soap *soap, const char *tag, int id, const enum ngwt__RecipientType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__RecipientType), type);
	soap_send(soap, soap_ngwt__RecipientType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__RecipientType * SOAP_FMAC4 soap_get_ngwt__RecipientType(struct soap *soap, enum ngwt__RecipientType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__RecipientType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__RecipientType(struct soap *soap, const char *s, enum ngwt__RecipientType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__RecipientType, s);
	if (map)
		*a = (enum ngwt__RecipientType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__RecipientType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__RecipientType * SOAP_FMAC4 soap_in_ngwt__RecipientType(struct soap *soap, const char *tag, enum ngwt__RecipientType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__RecipientType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__RecipientType, sizeof(enum ngwt__RecipientType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__RecipientType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__RecipientType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RecipientType, 0, sizeof(enum ngwt__RecipientType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__PostalAddressType(struct soap *soap, enum ngwt__PostalAddressType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__PostalAddressType
	*a = SOAP_DEFAULT_ngwt__PostalAddressType;
#else
	*a = (enum ngwt__PostalAddressType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__PostalAddressType(struct soap *soap, const enum ngwt__PostalAddressType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__PostalAddressType);
	if (soap_out_ngwt__PostalAddressType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__PostalAddressType[] =
{	{ (long)Home_, "Home" },
	{ (long)Office_, "Office" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__PostalAddressType2s(struct soap *soap, enum ngwt__PostalAddressType n)
{	const char *s = soap_str_code(soap_codes_ngwt__PostalAddressType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__PostalAddressType(struct soap *soap, const char *tag, int id, const enum ngwt__PostalAddressType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__PostalAddressType), type);
	soap_send(soap, soap_ngwt__PostalAddressType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__PostalAddressType * SOAP_FMAC4 soap_get_ngwt__PostalAddressType(struct soap *soap, enum ngwt__PostalAddressType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__PostalAddressType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__PostalAddressType(struct soap *soap, const char *s, enum ngwt__PostalAddressType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__PostalAddressType, s);
	if (map)
		*a = (enum ngwt__PostalAddressType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__PostalAddressType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__PostalAddressType * SOAP_FMAC4 soap_in_ngwt__PostalAddressType(struct soap *soap, const char *tag, enum ngwt__PostalAddressType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__PostalAddressType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__PostalAddressType, sizeof(enum ngwt__PostalAddressType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__PostalAddressType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__PostalAddressType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PostalAddressType, 0, sizeof(enum ngwt__PostalAddressType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__PhoneNumberType(struct soap *soap, enum ngwt__PhoneNumberType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__PhoneNumberType
	*a = SOAP_DEFAULT_ngwt__PhoneNumberType;
#else
	*a = (enum ngwt__PhoneNumberType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__PhoneNumberType(struct soap *soap, const enum ngwt__PhoneNumberType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__PhoneNumberType);
	if (soap_out_ngwt__PhoneNumberType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__PhoneNumberType[] =
{	{ (long)Fax, "Fax" },
	{ (long)Home, "Home" },
	{ (long)Mobile, "Mobile" },
	{ (long)Office, "Office" },
	{ (long)Pager, "Pager" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__PhoneNumberType2s(struct soap *soap, enum ngwt__PhoneNumberType n)
{	const char *s = soap_str_code(soap_codes_ngwt__PhoneNumberType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__PhoneNumberType(struct soap *soap, const char *tag, int id, const enum ngwt__PhoneNumberType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__PhoneNumberType), type);
	soap_send(soap, soap_ngwt__PhoneNumberType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__PhoneNumberType * SOAP_FMAC4 soap_get_ngwt__PhoneNumberType(struct soap *soap, enum ngwt__PhoneNumberType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__PhoneNumberType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__PhoneNumberType(struct soap *soap, const char *s, enum ngwt__PhoneNumberType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__PhoneNumberType, s);
	if (map)
		*a = (enum ngwt__PhoneNumberType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__PhoneNumberType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__PhoneNumberType * SOAP_FMAC4 soap_in_ngwt__PhoneNumberType(struct soap *soap, const char *tag, enum ngwt__PhoneNumberType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__PhoneNumberType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__PhoneNumberType, sizeof(enum ngwt__PhoneNumberType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__PhoneNumberType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__PhoneNumberType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PhoneNumberType, 0, sizeof(enum ngwt__PhoneNumberType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__OccurrenceType(struct soap *soap, enum ngwt__OccurrenceType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__OccurrenceType
	*a = SOAP_DEFAULT_ngwt__OccurrenceType;
#else
	*a = (enum ngwt__OccurrenceType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__OccurrenceType(struct soap *soap, const enum ngwt__OccurrenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__OccurrenceType);
	if (soap_out_ngwt__OccurrenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__OccurrenceType[] =
{	{ (long)First, "First" },
	{ (long)Second, "Second" },
	{ (long)Third, "Third" },
	{ (long)Fourth, "Fourth" },
	{ (long)Fifth, "Fifth" },
	{ (long)Last, "Last" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__OccurrenceType2s(struct soap *soap, enum ngwt__OccurrenceType n)
{	const char *s = soap_str_code(soap_codes_ngwt__OccurrenceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__OccurrenceType(struct soap *soap, const char *tag, int id, const enum ngwt__OccurrenceType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__OccurrenceType), type);
	soap_send(soap, soap_ngwt__OccurrenceType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__OccurrenceType * SOAP_FMAC4 soap_get_ngwt__OccurrenceType(struct soap *soap, enum ngwt__OccurrenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__OccurrenceType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__OccurrenceType(struct soap *soap, const char *s, enum ngwt__OccurrenceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__OccurrenceType, s);
	if (map)
		*a = (enum ngwt__OccurrenceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__OccurrenceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__OccurrenceType * SOAP_FMAC4 soap_in_ngwt__OccurrenceType(struct soap *soap, const char *tag, enum ngwt__OccurrenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__OccurrenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__OccurrenceType, sizeof(enum ngwt__OccurrenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__OccurrenceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__OccurrenceType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__OccurrenceType, 0, sizeof(enum ngwt__OccurrenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__NotificationType(struct soap *soap, enum ngwt__NotificationType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__NotificationType
	*a = SOAP_DEFAULT_ngwt__NotificationType;
#else
	*a = (enum ngwt__NotificationType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__NotificationType(struct soap *soap, const enum ngwt__NotificationType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__NotificationType);
	if (soap_out_ngwt__NotificationType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__NotificationType[] =
{	{ (long)SharedAddressBook, "SharedAddressBook" },
	{ (long)SharedFolder, "SharedFolder" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__NotificationType2s(struct soap *soap, enum ngwt__NotificationType n)
{	const char *s = soap_str_code(soap_codes_ngwt__NotificationType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__NotificationType(struct soap *soap, const char *tag, int id, const enum ngwt__NotificationType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__NotificationType), type);
	soap_send(soap, soap_ngwt__NotificationType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__NotificationType * SOAP_FMAC4 soap_get_ngwt__NotificationType(struct soap *soap, enum ngwt__NotificationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__NotificationType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__NotificationType(struct soap *soap, const char *s, enum ngwt__NotificationType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__NotificationType, s);
	if (map)
		*a = (enum ngwt__NotificationType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__NotificationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__NotificationType * SOAP_FMAC4 soap_in_ngwt__NotificationType(struct soap *soap, const char *tag, enum ngwt__NotificationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__NotificationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__NotificationType, sizeof(enum ngwt__NotificationType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__NotificationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__NotificationType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__NotificationType, 0, sizeof(enum ngwt__NotificationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__MessageType(struct soap *soap, enum ngwt__MessageType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__MessageType
	*a = SOAP_DEFAULT_ngwt__MessageType;
#else
	*a = (enum ngwt__MessageType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__MessageType(struct soap *soap, const enum ngwt__MessageType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__MessageType);
	if (soap_out_ngwt__MessageType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__MessageType[] =
{	{ (long)Appointment__, "Appointment" },
	{ (long)CalendarItem__, "CalendarItem" },
	{ (long)DocumentReference_, "DocumentReference" },
	{ (long)Mail__, "Mail" },
	{ (long)Note__, "Note" },
	{ (long)PhoneMessage__, "PhoneMessage" },
	{ (long)Task__, "Task" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__MessageType2s(struct soap *soap, enum ngwt__MessageType n)
{	const char *s = soap_str_code(soap_codes_ngwt__MessageType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__MessageType(struct soap *soap, const char *tag, int id, const enum ngwt__MessageType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__MessageType), type);
	soap_send(soap, soap_ngwt__MessageType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__MessageType * SOAP_FMAC4 soap_get_ngwt__MessageType(struct soap *soap, enum ngwt__MessageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__MessageType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__MessageType(struct soap *soap, const char *s, enum ngwt__MessageType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_ngwt__MessageType, t);
	if (map)
		*a = (enum ngwt__MessageType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__MessageType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__MessageType * SOAP_FMAC4 soap_in_ngwt__MessageType(struct soap *soap, const char *tag, enum ngwt__MessageType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__MessageType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__MessageType, sizeof(enum ngwt__MessageType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__MessageType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__MessageType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__MessageType, 0, sizeof(enum ngwt__MessageType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__MessageList(struct soap *soap, enum ngwt__MessageList *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__MessageList
	*a = SOAP_DEFAULT_ngwt__MessageList;
#else
	*a = (enum ngwt__MessageList)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__MessageList(struct soap *soap, const enum ngwt__MessageList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__MessageList);
	if (soap_out_ngwt__MessageList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__MessageList[] =
{	{ (long)All, "All" },
	{ (long)Modified, "Modified" },
	{ (long)New_, "New" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__MessageList2s(struct soap *soap, enum ngwt__MessageList n)
{	const char *s = soap_str_code(soap_codes_ngwt__MessageList, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__MessageList(struct soap *soap, const char *tag, int id, const enum ngwt__MessageList *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__MessageList), type);
	soap_send(soap, soap_ngwt__MessageList2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__MessageList * SOAP_FMAC4 soap_get_ngwt__MessageList(struct soap *soap, enum ngwt__MessageList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__MessageList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__MessageList(struct soap *soap, const char *s, enum ngwt__MessageList *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__MessageList, s);
	if (map)
		*a = (enum ngwt__MessageList)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__MessageList)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__MessageList * SOAP_FMAC4 soap_in_ngwt__MessageList(struct soap *soap, const char *tag, enum ngwt__MessageList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__MessageList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__MessageList, sizeof(enum ngwt__MessageList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__MessageList(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__MessageList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__MessageList, 0, sizeof(enum ngwt__MessageList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__LinkType(struct soap *soap, enum ngwt__LinkType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__LinkType
	*a = SOAP_DEFAULT_ngwt__LinkType;
#else
	*a = (enum ngwt__LinkType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__LinkType(struct soap *soap, const enum ngwt__LinkType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__LinkType);
	if (soap_out_ngwt__LinkType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__LinkType[] =
{	{ (long)forward, "forward" },
	{ (long)reply, "reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__LinkType2s(struct soap *soap, enum ngwt__LinkType n)
{	const char *s = soap_str_code(soap_codes_ngwt__LinkType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__LinkType(struct soap *soap, const char *tag, int id, const enum ngwt__LinkType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__LinkType), type);
	soap_send(soap, soap_ngwt__LinkType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__LinkType * SOAP_FMAC4 soap_get_ngwt__LinkType(struct soap *soap, enum ngwt__LinkType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__LinkType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__LinkType(struct soap *soap, const char *s, enum ngwt__LinkType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__LinkType, s);
	if (map)
		*a = (enum ngwt__LinkType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__LinkType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__LinkType * SOAP_FMAC4 soap_in_ngwt__LinkType(struct soap *soap, const char *tag, enum ngwt__LinkType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__LinkType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__LinkType, sizeof(enum ngwt__LinkType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__LinkType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__LinkType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__LinkType, 0, sizeof(enum ngwt__LinkType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__JunkMatchType(struct soap *soap, enum ngwt__JunkMatchType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__JunkMatchType
	*a = SOAP_DEFAULT_ngwt__JunkMatchType;
#else
	*a = (enum ngwt__JunkMatchType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__JunkMatchType(struct soap *soap, const enum ngwt__JunkMatchType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__JunkMatchType);
	if (soap_out_ngwt__JunkMatchType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__JunkMatchType[] =
{	{ (long)email, "email" },
	{ (long)domain, "domain" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__JunkMatchType2s(struct soap *soap, enum ngwt__JunkMatchType n)
{	const char *s = soap_str_code(soap_codes_ngwt__JunkMatchType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__JunkMatchType(struct soap *soap, const char *tag, int id, const enum ngwt__JunkMatchType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__JunkMatchType), type);
	soap_send(soap, soap_ngwt__JunkMatchType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__JunkMatchType * SOAP_FMAC4 soap_get_ngwt__JunkMatchType(struct soap *soap, enum ngwt__JunkMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__JunkMatchType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__JunkMatchType(struct soap *soap, const char *s, enum ngwt__JunkMatchType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__JunkMatchType, s);
	if (map)
		*a = (enum ngwt__JunkMatchType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__JunkMatchType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__JunkMatchType * SOAP_FMAC4 soap_in_ngwt__JunkMatchType(struct soap *soap, const char *tag, enum ngwt__JunkMatchType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__JunkMatchType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__JunkMatchType, sizeof(enum ngwt__JunkMatchType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__JunkMatchType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__JunkMatchType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__JunkMatchType, 0, sizeof(enum ngwt__JunkMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__JunkHandlingListType(struct soap *soap, enum ngwt__JunkHandlingListType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__JunkHandlingListType
	*a = SOAP_DEFAULT_ngwt__JunkHandlingListType;
#else
	*a = (enum ngwt__JunkHandlingListType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__JunkHandlingListType(struct soap *soap, const enum ngwt__JunkHandlingListType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__JunkHandlingListType);
	if (soap_out_ngwt__JunkHandlingListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__JunkHandlingListType[] =
{	{ (long)junk, "junk" },
	{ (long)block, "block" },
	{ (long)trust, "trust" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__JunkHandlingListType2s(struct soap *soap, enum ngwt__JunkHandlingListType n)
{	const char *s = soap_str_code(soap_codes_ngwt__JunkHandlingListType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__JunkHandlingListType(struct soap *soap, const char *tag, int id, const enum ngwt__JunkHandlingListType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__JunkHandlingListType), type);
	soap_send(soap, soap_ngwt__JunkHandlingListType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__JunkHandlingListType * SOAP_FMAC4 soap_get_ngwt__JunkHandlingListType(struct soap *soap, enum ngwt__JunkHandlingListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__JunkHandlingListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__JunkHandlingListType(struct soap *soap, const char *s, enum ngwt__JunkHandlingListType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__JunkHandlingListType, s);
	if (map)
		*a = (enum ngwt__JunkHandlingListType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__JunkHandlingListType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__JunkHandlingListType * SOAP_FMAC4 soap_in_ngwt__JunkHandlingListType(struct soap *soap, const char *tag, enum ngwt__JunkHandlingListType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__JunkHandlingListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__JunkHandlingListType, sizeof(enum ngwt__JunkHandlingListType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__JunkHandlingListType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__JunkHandlingListType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__JunkHandlingListType, 0, sizeof(enum ngwt__JunkHandlingListType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__ItemSource(struct soap *soap, enum ngwt__ItemSource *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__ItemSource
	*a = SOAP_DEFAULT_ngwt__ItemSource;
#else
	*a = (enum ngwt__ItemSource)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__ItemSource(struct soap *soap, const enum ngwt__ItemSource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__ItemSource);
	if (soap_out_ngwt__ItemSource(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__ItemSource[] =
{	{ (long)received_, "received" },
	{ (long)sent_, "sent" },
	{ (long)draft_, "draft" },
	{ (long)personal_, "personal" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__ItemSource2s(struct soap *soap, enum ngwt__ItemSource n)
{	const char *s = soap_str_code(soap_codes_ngwt__ItemSource, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ItemSource(struct soap *soap, const char *tag, int id, const enum ngwt__ItemSource *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ItemSource), type);
	soap_send(soap, soap_ngwt__ItemSource2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__ItemSource * SOAP_FMAC4 soap_get_ngwt__ItemSource(struct soap *soap, enum ngwt__ItemSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ItemSource(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__ItemSource(struct soap *soap, const char *s, enum ngwt__ItemSource *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__ItemSource, s);
	if (map)
		*a = (enum ngwt__ItemSource)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__ItemSource)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__ItemSource * SOAP_FMAC4 soap_in_ngwt__ItemSource(struct soap *soap, const char *tag, enum ngwt__ItemSource *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__ItemSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ItemSource, sizeof(enum ngwt__ItemSource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__ItemSource(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__ItemSource *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemSource, 0, sizeof(enum ngwt__ItemSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__ItemSecurity(struct soap *soap, enum ngwt__ItemSecurity *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__ItemSecurity
	*a = SOAP_DEFAULT_ngwt__ItemSecurity;
#else
	*a = (enum ngwt__ItemSecurity)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__ItemSecurity(struct soap *soap, const enum ngwt__ItemSecurity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__ItemSecurity);
	if (soap_out_ngwt__ItemSecurity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__ItemSecurity[] =
{	{ (long)Normal__, "Normal" },
	{ (long)Proprietary, "Proprietary" },
	{ (long)Confidential, "Confidential" },
	{ (long)Secret, "Secret" },
	{ (long)TopSecret, "TopSecret" },
	{ (long)ForYourEyesOnly, "ForYourEyesOnly" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__ItemSecurity2s(struct soap *soap, enum ngwt__ItemSecurity n)
{	const char *s = soap_str_code(soap_codes_ngwt__ItemSecurity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ItemSecurity(struct soap *soap, const char *tag, int id, const enum ngwt__ItemSecurity *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ItemSecurity), type);
	soap_send(soap, soap_ngwt__ItemSecurity2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__ItemSecurity * SOAP_FMAC4 soap_get_ngwt__ItemSecurity(struct soap *soap, enum ngwt__ItemSecurity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ItemSecurity(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__ItemSecurity(struct soap *soap, const char *s, enum ngwt__ItemSecurity *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	//soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_ngwt__ItemSecurity, s);
	if (map)
		*a = (enum ngwt__ItemSecurity)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__ItemSecurity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__ItemSecurity * SOAP_FMAC4 soap_in_ngwt__ItemSecurity(struct soap *soap, const char *tag, enum ngwt__ItemSecurity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__ItemSecurity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ItemSecurity, sizeof(enum ngwt__ItemSecurity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__ItemSecurity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__ItemSecurity *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemSecurity, 0, sizeof(enum ngwt__ItemSecurity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__ItemOptionsPriority(struct soap *soap, enum ngwt__ItemOptionsPriority *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__ItemOptionsPriority
	*a = SOAP_DEFAULT_ngwt__ItemOptionsPriority;
#else
	*a = (enum ngwt__ItemOptionsPriority)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__ItemOptionsPriority(struct soap *soap, const enum ngwt__ItemOptionsPriority *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__ItemOptionsPriority);
	if (soap_out_ngwt__ItemOptionsPriority(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__ItemOptionsPriority[] =
{	{ (long)High, "High" },
	{ (long)Standard, "Standard" },
	{ (long)Low, "Low" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__ItemOptionsPriority2s(struct soap *soap, enum ngwt__ItemOptionsPriority n)
{	const char *s = soap_str_code(soap_codes_ngwt__ItemOptionsPriority, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ItemOptionsPriority(struct soap *soap, const char *tag, int id, const enum ngwt__ItemOptionsPriority *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ItemOptionsPriority), type);
	soap_send(soap, soap_ngwt__ItemOptionsPriority2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__ItemOptionsPriority * SOAP_FMAC4 soap_get_ngwt__ItemOptionsPriority(struct soap *soap, enum ngwt__ItemOptionsPriority *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ItemOptionsPriority(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__ItemOptionsPriority(struct soap *soap, const char *s, enum ngwt__ItemOptionsPriority *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__ItemOptionsPriority, s);
	if (map)
		*a = (enum ngwt__ItemOptionsPriority)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__ItemOptionsPriority)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__ItemOptionsPriority * SOAP_FMAC4 soap_in_ngwt__ItemOptionsPriority(struct soap *soap, const char *tag, enum ngwt__ItemOptionsPriority *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__ItemOptionsPriority *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ItemOptionsPriority, sizeof(enum ngwt__ItemOptionsPriority), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__ItemOptionsPriority(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__ItemOptionsPriority *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemOptionsPriority, 0, sizeof(enum ngwt__ItemOptionsPriority), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__ItemClass(struct soap *soap, enum ngwt__ItemClass *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__ItemClass
	*a = SOAP_DEFAULT_ngwt__ItemClass;
#else
	*a = (enum ngwt__ItemClass)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__ItemClass(struct soap *soap, const enum ngwt__ItemClass *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__ItemClass);
	if (soap_out_ngwt__ItemClass(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__ItemClass[] =
{	{ (long)Public, "Public" },
	{ (long)Private, "Private" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__ItemClass2s(struct soap *soap, enum ngwt__ItemClass n)
{	const char *s = soap_str_code(soap_codes_ngwt__ItemClass, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ItemClass(struct soap *soap, const char *tag, int id, const enum ngwt__ItemClass *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ItemClass), type);
	soap_send(soap, soap_ngwt__ItemClass2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__ItemClass * SOAP_FMAC4 soap_get_ngwt__ItemClass(struct soap *soap, enum ngwt__ItemClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ItemClass(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__ItemClass(struct soap *soap, const char *s, enum ngwt__ItemClass *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__ItemClass, s);
	if (map)
		*a = (enum ngwt__ItemClass)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__ItemClass)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__ItemClass * SOAP_FMAC4 soap_in_ngwt__ItemClass(struct soap *soap, const char *tag, enum ngwt__ItemClass *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__ItemClass *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ItemClass, sizeof(enum ngwt__ItemClass), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__ItemClass(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__ItemClass *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemClass, 0, sizeof(enum ngwt__ItemClass), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__Frequency(struct soap *soap, enum ngwt__Frequency *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__Frequency
	*a = SOAP_DEFAULT_ngwt__Frequency;
#else
	*a = (enum ngwt__Frequency)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__Frequency(struct soap *soap, const enum ngwt__Frequency *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__Frequency);
	if (soap_out_ngwt__Frequency(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__Frequency[] =
{	{ (long)Daily, "Daily" },
	{ (long)Weekly, "Weekly" },
	{ (long)Monthly, "Monthly" },
	{ (long)Yearly, "Yearly" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__Frequency2s(struct soap *soap, enum ngwt__Frequency n)
{	const char *s = soap_str_code(soap_codes_ngwt__Frequency, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Frequency(struct soap *soap, const char *tag, int id, const enum ngwt__Frequency *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Frequency), type);
	soap_send(soap, soap_ngwt__Frequency2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__Frequency * SOAP_FMAC4 soap_get_ngwt__Frequency(struct soap *soap, enum ngwt__Frequency *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Frequency(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__Frequency(struct soap *soap, const char *s, enum ngwt__Frequency *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__Frequency, s);
	if (map)
		*a = (enum ngwt__Frequency)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__Frequency)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__Frequency * SOAP_FMAC4 soap_in_ngwt__Frequency(struct soap *soap, const char *tag, enum ngwt__Frequency *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__Frequency *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Frequency, sizeof(enum ngwt__Frequency), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__Frequency(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__Frequency *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Frequency, 0, sizeof(enum ngwt__Frequency), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__FolderType(struct soap *soap, enum ngwt__FolderType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__FolderType
	*a = SOAP_DEFAULT_ngwt__FolderType;
#else
	*a = (enum ngwt__FolderType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__FolderType(struct soap *soap, const enum ngwt__FolderType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__FolderType);
	if (soap_out_ngwt__FolderType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__FolderType[] =
{	{ (long)Mailbox, "Mailbox" },
	{ (long)SentItems, "SentItems" },
	{ (long)Draft, "Draft" },
	{ (long)Trash, "Trash" },
	{ (long)Calendar, "Calendar" },
	{ (long)Contacts, "Contacts" },
	{ (long)Documents, "Documents" },
	{ (long)Checklist, "Checklist" },
	{ (long)Cabinet, "Cabinet" },
	{ (long)Normal_, "Normal" },
	{ (long)NNTPServer, "NNTPServer" },
	{ (long)NNTPNewsGroup, "NNTPNewsGroup" },
	{ (long)IMAP, "IMAP" },
	{ (long)Query, "Query" },
	{ (long)Root, "Root" },
	{ (long)JunkMail, "JunkMail" },
	{ (long)Notes, "Notes" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__FolderType2s(struct soap *soap, enum ngwt__FolderType n)
{	const char *s = soap_str_code(soap_codes_ngwt__FolderType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FolderType(struct soap *soap, const char *tag, int id, const enum ngwt__FolderType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FolderType), type);
	soap_send(soap, soap_ngwt__FolderType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__FolderType * SOAP_FMAC4 soap_get_ngwt__FolderType(struct soap *soap, enum ngwt__FolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FolderType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__FolderType(struct soap *soap, const char *s, enum ngwt__FolderType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__FolderType, s);
	if (map)
		*a = (enum ngwt__FolderType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__FolderType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__FolderType * SOAP_FMAC4 soap_in_ngwt__FolderType(struct soap *soap, const char *tag, enum ngwt__FolderType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__FolderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FolderType, sizeof(enum ngwt__FolderType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__FolderType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__FolderType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FolderType, 0, sizeof(enum ngwt__FolderType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__FolderACLStatus(struct soap *soap, enum ngwt__FolderACLStatus *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__FolderACLStatus
	*a = SOAP_DEFAULT_ngwt__FolderACLStatus;
#else
	*a = (enum ngwt__FolderACLStatus)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__FolderACLStatus(struct soap *soap, const enum ngwt__FolderACLStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__FolderACLStatus);
	if (soap_out_ngwt__FolderACLStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__FolderACLStatus[] =
{	{ (long)pending, "pending" },
	{ (long)accepted, "accepted" },
	{ (long)deleted, "deleted" },
	{ (long)opened, "opened" },
	{ (long)owner, "owner" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__FolderACLStatus2s(struct soap *soap, enum ngwt__FolderACLStatus n)
{	const char *s = soap_str_code(soap_codes_ngwt__FolderACLStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FolderACLStatus(struct soap *soap, const char *tag, int id, const enum ngwt__FolderACLStatus *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FolderACLStatus), type);
	soap_send(soap, soap_ngwt__FolderACLStatus2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__FolderACLStatus * SOAP_FMAC4 soap_get_ngwt__FolderACLStatus(struct soap *soap, enum ngwt__FolderACLStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FolderACLStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__FolderACLStatus(struct soap *soap, const char *s, enum ngwt__FolderACLStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__FolderACLStatus, s);
	if (map)
		*a = (enum ngwt__FolderACLStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__FolderACLStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__FolderACLStatus * SOAP_FMAC4 soap_in_ngwt__FolderACLStatus(struct soap *soap, const char *tag, enum ngwt__FolderACLStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__FolderACLStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FolderACLStatus, sizeof(enum ngwt__FolderACLStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__FolderACLStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__FolderACLStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FolderACLStatus, 0, sizeof(enum ngwt__FolderACLStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__FilterOp(struct soap *soap, enum ngwt__FilterOp *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__FilterOp
	*a = SOAP_DEFAULT_ngwt__FilterOp;
#else
	*a = (enum ngwt__FilterOp)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__FilterOp(struct soap *soap, const enum ngwt__FilterOp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__FilterOp);
	if (soap_out_ngwt__FilterOp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__FilterOp[] =
{	{ (long)and_, "and" },
	{ (long)or_, "or" },
	{ (long)not_, "not" },
	{ (long)eq, "eq" },
	{ (long)ne, "ne" },
	{ (long)gt, "gt" },
	{ (long)lt, "lt" },
	{ (long)gte, "gte" },
	{ (long)lte, "lte" },
	{ (long)contains, "contains" },
	{ (long)containsWord, "containsWord" },
	{ (long)begins, "begins" },
	{ (long)exists, "exists" },
	{ (long)notExist, "notExist" },
	{ (long)isOf, "isOf" },
	{ (long)isNotOf, "isNotOf" },
	{ (long)fieldEqual, "fieldEqual" },
	{ (long)fieldGTE, "fieldGTE" },
	{ (long)fieldGT, "fieldGT" },
	{ (long)fieldLTE, "fieldLTE" },
	{ (long)fieldLT, "fieldLT" },
	{ (long)fieldNE, "fieldNE" },
	{ (long)fieldDateEqual, "fieldDateEqual" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__FilterOp2s(struct soap *soap, enum ngwt__FilterOp n)
{	const char *s = soap_str_code(soap_codes_ngwt__FilterOp, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FilterOp(struct soap *soap, const char *tag, int id, const enum ngwt__FilterOp *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FilterOp), type);
	soap_send(soap, soap_ngwt__FilterOp2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__FilterOp * SOAP_FMAC4 soap_get_ngwt__FilterOp(struct soap *soap, enum ngwt__FilterOp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FilterOp(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__FilterOp(struct soap *soap, const char *s, enum ngwt__FilterOp *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__FilterOp, s);
	if (map)
		*a = (enum ngwt__FilterOp)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__FilterOp)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__FilterOp * SOAP_FMAC4 soap_in_ngwt__FilterOp(struct soap *soap, const char *tag, enum ngwt__FilterOp *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__FilterOp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FilterOp, sizeof(enum ngwt__FilterOp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__FilterOp(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__FilterOp *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FilterOp, 0, sizeof(enum ngwt__FilterOp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__FilterDate(struct soap *soap, enum ngwt__FilterDate *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__FilterDate
	*a = SOAP_DEFAULT_ngwt__FilterDate;
#else
	*a = (enum ngwt__FilterDate)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__FilterDate(struct soap *soap, const enum ngwt__FilterDate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__FilterDate);
	if (soap_out_ngwt__FilterDate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__FilterDate[] =
{	{ (long)Today, "Today" },
	{ (long)Tomorrow, "Tomorrow" },
	{ (long)ThisMonth, "ThisMonth" },
	{ (long)ThisWeek, "ThisWeek" },
	{ (long)ThisYear, "ThisYear" },
	{ (long)Yesterday, "Yesterday" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__FilterDate2s(struct soap *soap, enum ngwt__FilterDate n)
{	const char *s = soap_str_code(soap_codes_ngwt__FilterDate, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FilterDate(struct soap *soap, const char *tag, int id, const enum ngwt__FilterDate *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FilterDate), type);
	soap_send(soap, soap_ngwt__FilterDate2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__FilterDate * SOAP_FMAC4 soap_get_ngwt__FilterDate(struct soap *soap, enum ngwt__FilterDate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FilterDate(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__FilterDate(struct soap *soap, const char *s, enum ngwt__FilterDate *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__FilterDate, s);
	if (map)
		*a = (enum ngwt__FilterDate)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__FilterDate)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__FilterDate * SOAP_FMAC4 soap_in_ngwt__FilterDate(struct soap *soap, const char *tag, enum ngwt__FilterDate *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__FilterDate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FilterDate, sizeof(enum ngwt__FilterDate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__FilterDate(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__FilterDate *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FilterDate, 0, sizeof(enum ngwt__FilterDate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__Execution(struct soap *soap, enum ngwt__Execution *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__Execution
	*a = SOAP_DEFAULT_ngwt__Execution;
#else
	*a = (enum ngwt__Execution)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__Execution(struct soap *soap, const enum ngwt__Execution *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__Execution);
	if (soap_out_ngwt__Execution(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__Execution[] =
{	{ (long)Startup, "Startup" },
	{ (long)Exit, "Exit" },
	{ (long)New, "New" },
	{ (long)FolderOpen, "FolderOpen" },
	{ (long)FolderClose, "FolderClose" },
	{ (long)FolderNew, "FolderNew" },
	{ (long)User, "User" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__Execution2s(struct soap *soap, enum ngwt__Execution n)
{	const char *s = soap_str_code(soap_codes_ngwt__Execution, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Execution(struct soap *soap, const char *tag, int id, const enum ngwt__Execution *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Execution), type);
	soap_send(soap, soap_ngwt__Execution2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__Execution * SOAP_FMAC4 soap_get_ngwt__Execution(struct soap *soap, enum ngwt__Execution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Execution(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__Execution(struct soap *soap, const char *s, enum ngwt__Execution *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__Execution, s);
	if (map)
		*a = (enum ngwt__Execution)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__Execution)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__Execution * SOAP_FMAC4 soap_in_ngwt__Execution(struct soap *soap, const char *tag, enum ngwt__Execution *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__Execution *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Execution, sizeof(enum ngwt__Execution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__Execution(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__Execution *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Execution, 0, sizeof(enum ngwt__Execution), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__DistributionType(struct soap *soap, enum ngwt__DistributionType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__DistributionType
	*a = SOAP_DEFAULT_ngwt__DistributionType;
#else
	*a = (enum ngwt__DistributionType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__DistributionType(struct soap *soap, const enum ngwt__DistributionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__DistributionType);
	if (soap_out_ngwt__DistributionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__DistributionType[] =
{	{ (long)TO, "TO" },
	{ (long)CC, "CC" },
	{ (long)BC, "BC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__DistributionType2s(struct soap *soap, enum ngwt__DistributionType n)
{	const char *s = soap_str_code(soap_codes_ngwt__DistributionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DistributionType(struct soap *soap, const char *tag, int id, const enum ngwt__DistributionType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__DistributionType), type);
	soap_send(soap, soap_ngwt__DistributionType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__DistributionType * SOAP_FMAC4 soap_get_ngwt__DistributionType(struct soap *soap, enum ngwt__DistributionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DistributionType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__DistributionType(struct soap *soap, const char *s, enum ngwt__DistributionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__DistributionType, s);
	if (map)
		*a = (enum ngwt__DistributionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__DistributionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__DistributionType * SOAP_FMAC4 soap_in_ngwt__DistributionType(struct soap *soap, const char *tag, enum ngwt__DistributionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__DistributionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DistributionType, sizeof(enum ngwt__DistributionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__DistributionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__DistributionType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DistributionType, 0, sizeof(enum ngwt__DistributionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__DeltaSyncType(struct soap *soap, enum ngwt__DeltaSyncType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__DeltaSyncType
	*a = SOAP_DEFAULT_ngwt__DeltaSyncType;
#else
	*a = (enum ngwt__DeltaSyncType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__DeltaSyncType(struct soap *soap, const enum ngwt__DeltaSyncType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__DeltaSyncType);
	if (soap_out_ngwt__DeltaSyncType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__DeltaSyncType[] =
{	{ (long)add, "add" },
	{ (long)delete_, "delete" },
	{ (long)update, "update" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__DeltaSyncType2s(struct soap *soap, enum ngwt__DeltaSyncType n)
{	const char *s = soap_str_code(soap_codes_ngwt__DeltaSyncType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DeltaSyncType(struct soap *soap, const char *tag, int id, const enum ngwt__DeltaSyncType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__DeltaSyncType), type);
	soap_send(soap, soap_ngwt__DeltaSyncType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__DeltaSyncType * SOAP_FMAC4 soap_get_ngwt__DeltaSyncType(struct soap *soap, enum ngwt__DeltaSyncType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DeltaSyncType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__DeltaSyncType(struct soap *soap, const char *s, enum ngwt__DeltaSyncType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__DeltaSyncType, s);
	if (map)
		*a = (enum ngwt__DeltaSyncType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__DeltaSyncType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__DeltaSyncType * SOAP_FMAC4 soap_in_ngwt__DeltaSyncType(struct soap *soap, const char *tag, enum ngwt__DeltaSyncType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__DeltaSyncType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DeltaSyncType, sizeof(enum ngwt__DeltaSyncType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__DeltaSyncType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__DeltaSyncType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DeltaSyncType, 0, sizeof(enum ngwt__DeltaSyncType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__CustomType(struct soap *soap, enum ngwt__CustomType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__CustomType
	*a = SOAP_DEFAULT_ngwt__CustomType;
#else
	*a = (enum ngwt__CustomType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__CustomType(struct soap *soap, const enum ngwt__CustomType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__CustomType);
	if (soap_out_ngwt__CustomType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__CustomType[] =
{	{ (long)String, "String" },
	{ (long)Numeric, "Numeric" },
	{ (long)Date, "Date" },
	{ (long)Binary, "Binary" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__CustomType2s(struct soap *soap, enum ngwt__CustomType n)
{	const char *s = soap_str_code(soap_codes_ngwt__CustomType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__CustomType(struct soap *soap, const char *tag, int id, const enum ngwt__CustomType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__CustomType), type);
	soap_send(soap, soap_ngwt__CustomType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__CustomType * SOAP_FMAC4 soap_get_ngwt__CustomType(struct soap *soap, enum ngwt__CustomType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__CustomType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__CustomType(struct soap *soap, const char *s, enum ngwt__CustomType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__CustomType, s);
	if (map)
		*a = (enum ngwt__CustomType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__CustomType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__CustomType * SOAP_FMAC4 soap_in_ngwt__CustomType(struct soap *soap, const char *tag, enum ngwt__CustomType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__CustomType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__CustomType, sizeof(enum ngwt__CustomType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__CustomType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__CustomType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CustomType, 0, sizeof(enum ngwt__CustomType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__CursorSeek(struct soap *soap, enum ngwt__CursorSeek *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__CursorSeek
	*a = SOAP_DEFAULT_ngwt__CursorSeek;
#else
	*a = (enum ngwt__CursorSeek)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__CursorSeek(struct soap *soap, const enum ngwt__CursorSeek *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__CursorSeek);
	if (soap_out_ngwt__CursorSeek(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__CursorSeek[] =
{	{ (long)current, "current" },
	{ (long)start, "start" },
	{ (long)end, "end" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__CursorSeek2s(struct soap *soap, enum ngwt__CursorSeek n)
{	const char *s = soap_str_code(soap_codes_ngwt__CursorSeek, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__CursorSeek(struct soap *soap, const char *tag, int id, const enum ngwt__CursorSeek *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__CursorSeek), type);
	soap_send(soap, soap_ngwt__CursorSeek2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__CursorSeek * SOAP_FMAC4 soap_get_ngwt__CursorSeek(struct soap *soap, enum ngwt__CursorSeek *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__CursorSeek(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__CursorSeek(struct soap *soap, const char *s, enum ngwt__CursorSeek *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__CursorSeek, s);
	if (map)
		*a = (enum ngwt__CursorSeek)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__CursorSeek)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__CursorSeek * SOAP_FMAC4 soap_in_ngwt__CursorSeek(struct soap *soap, const char *tag, enum ngwt__CursorSeek *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__CursorSeek *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__CursorSeek, sizeof(enum ngwt__CursorSeek), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__CursorSeek(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__CursorSeek *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CursorSeek, 0, sizeof(enum ngwt__CursorSeek), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__ContactType(struct soap *soap, enum ngwt__ContactType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__ContactType
	*a = SOAP_DEFAULT_ngwt__ContactType;
#else
	*a = (enum ngwt__ContactType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__ContactType(struct soap *soap, const enum ngwt__ContactType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__ContactType);
	if (soap_out_ngwt__ContactType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__ContactType[] =
{	{ (long)Contact__, "Contact" },
	{ (long)Group_, "Group" },
	{ (long)Resource_, "Resource" },
	{ (long)Organization__, "Organization" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__ContactType2s(struct soap *soap, enum ngwt__ContactType n)
{	const char *s = soap_str_code(soap_codes_ngwt__ContactType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ContactType(struct soap *soap, const char *tag, int id, const enum ngwt__ContactType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ContactType), type);
	soap_send(soap, soap_ngwt__ContactType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__ContactType * SOAP_FMAC4 soap_get_ngwt__ContactType(struct soap *soap, enum ngwt__ContactType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ContactType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__ContactType(struct soap *soap, const char *s, enum ngwt__ContactType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_ngwt__ContactType, t);
	if (map)
		*a = (enum ngwt__ContactType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__ContactType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__ContactType * SOAP_FMAC4 soap_in_ngwt__ContactType(struct soap *soap, const char *tag, enum ngwt__ContactType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__ContactType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ContactType, sizeof(enum ngwt__ContactType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__ContactType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__ContactType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ContactType, 0, sizeof(enum ngwt__ContactType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__CategoryType(struct soap *soap, enum ngwt__CategoryType *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__CategoryType
	*a = SOAP_DEFAULT_ngwt__CategoryType;
#else
	*a = (enum ngwt__CategoryType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__CategoryType(struct soap *soap, const enum ngwt__CategoryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__CategoryType);
	if (soap_out_ngwt__CategoryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__CategoryType[] =
{	{ (long)Normal, "Normal" },
	{ (long)Personal, "Personal" },
	{ (long)FollowUp, "FollowUp" },
	{ (long)Urgent, "Urgent" },
	{ (long)LowPriority, "LowPriority" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__CategoryType2s(struct soap *soap, enum ngwt__CategoryType n)
{	const char *s = soap_str_code(soap_codes_ngwt__CategoryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__CategoryType(struct soap *soap, const char *tag, int id, const enum ngwt__CategoryType *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__CategoryType), type);
	soap_send(soap, soap_ngwt__CategoryType2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__CategoryType * SOAP_FMAC4 soap_get_ngwt__CategoryType(struct soap *soap, enum ngwt__CategoryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__CategoryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__CategoryType(struct soap *soap, const char *s, enum ngwt__CategoryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__CategoryType, s);
	if (map)
		*a = (enum ngwt__CategoryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__CategoryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__CategoryType * SOAP_FMAC4 soap_in_ngwt__CategoryType(struct soap *soap, const char *tag, enum ngwt__CategoryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__CategoryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__CategoryType, sizeof(enum ngwt__CategoryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__CategoryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__CategoryType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CategoryType, 0, sizeof(enum ngwt__CategoryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__CalendarFolderFlags(struct soap *soap, enum ngwt__CalendarFolderFlags *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__CalendarFolderFlags
	*a = SOAP_DEFAULT_ngwt__CalendarFolderFlags;
#else
	*a = (enum ngwt__CalendarFolderFlags)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__CalendarFolderFlags(struct soap *soap, const enum ngwt__CalendarFolderFlags *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__CalendarFolderFlags);
	if (soap_out_ngwt__CalendarFolderFlags(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__CalendarFolderFlags[] =
{	{ (long)ShowInList, "ShowInList" },
	{ (long)DontIncludeContent, "DontIncludeContent" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__CalendarFolderFlags2s(struct soap *soap, enum ngwt__CalendarFolderFlags n)
{	const char *s = soap_str_code(soap_codes_ngwt__CalendarFolderFlags, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__CalendarFolderFlags(struct soap *soap, const char *tag, int id, const enum ngwt__CalendarFolderFlags *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__CalendarFolderFlags), type);
	soap_send(soap, soap_ngwt__CalendarFolderFlags2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__CalendarFolderFlags * SOAP_FMAC4 soap_get_ngwt__CalendarFolderFlags(struct soap *soap, enum ngwt__CalendarFolderFlags *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__CalendarFolderFlags(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__CalendarFolderFlags(struct soap *soap, const char *s, enum ngwt__CalendarFolderFlags *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__CalendarFolderFlags, s);
	if (map)
		*a = (enum ngwt__CalendarFolderFlags)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__CalendarFolderFlags)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__CalendarFolderFlags * SOAP_FMAC4 soap_in_ngwt__CalendarFolderFlags(struct soap *soap, const char *tag, enum ngwt__CalendarFolderFlags *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__CalendarFolderFlags *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__CalendarFolderFlags, sizeof(enum ngwt__CalendarFolderFlags), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__CalendarFolderFlags(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__CalendarFolderFlags *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CalendarFolderFlags, 0, sizeof(enum ngwt__CalendarFolderFlags), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__AppointmentConflict(struct soap *soap, enum ngwt__AppointmentConflict *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__AppointmentConflict
	*a = SOAP_DEFAULT_ngwt__AppointmentConflict;
#else
	*a = (enum ngwt__AppointmentConflict)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__AppointmentConflict(struct soap *soap, const enum ngwt__AppointmentConflict *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__AppointmentConflict);
	if (soap_out_ngwt__AppointmentConflict(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__AppointmentConflict[] =
{	{ (long)Yes, "Yes" },
	{ (long)No, "No" },
	{ (long)Ignore, "Ignore" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__AppointmentConflict2s(struct soap *soap, enum ngwt__AppointmentConflict n)
{	const char *s = soap_str_code(soap_codes_ngwt__AppointmentConflict, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AppointmentConflict(struct soap *soap, const char *tag, int id, const enum ngwt__AppointmentConflict *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AppointmentConflict), type);
	soap_send(soap, soap_ngwt__AppointmentConflict2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__AppointmentConflict * SOAP_FMAC4 soap_get_ngwt__AppointmentConflict(struct soap *soap, enum ngwt__AppointmentConflict *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AppointmentConflict(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__AppointmentConflict(struct soap *soap, const char *s, enum ngwt__AppointmentConflict *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__AppointmentConflict, s);
	if (map)
		*a = (enum ngwt__AppointmentConflict)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__AppointmentConflict)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__AppointmentConflict * SOAP_FMAC4 soap_in_ngwt__AppointmentConflict(struct soap *soap, const char *tag, enum ngwt__AppointmentConflict *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__AppointmentConflict *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AppointmentConflict, sizeof(enum ngwt__AppointmentConflict), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__AppointmentConflict(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__AppointmentConflict *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AppointmentConflict, 0, sizeof(enum ngwt__AppointmentConflict), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__AgeAction(struct soap *soap, enum ngwt__AgeAction *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__AgeAction
	*a = SOAP_DEFAULT_ngwt__AgeAction;
#else
	*a = (enum ngwt__AgeAction)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__AgeAction(struct soap *soap, const enum ngwt__AgeAction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__AgeAction);
	if (soap_out_ngwt__AgeAction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__AgeAction[] =
{	{ (long)archive, "archive" },
	{ (long)delete__, "delete" },
	{ (long)retain, "retain" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__AgeAction2s(struct soap *soap, enum ngwt__AgeAction n)
{	const char *s = soap_str_code(soap_codes_ngwt__AgeAction, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AgeAction(struct soap *soap, const char *tag, int id, const enum ngwt__AgeAction *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AgeAction), type);
	soap_send(soap, soap_ngwt__AgeAction2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__AgeAction * SOAP_FMAC4 soap_get_ngwt__AgeAction(struct soap *soap, enum ngwt__AgeAction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AgeAction(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__AgeAction(struct soap *soap, const char *s, enum ngwt__AgeAction *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__AgeAction, s);
	if (map)
		*a = (enum ngwt__AgeAction)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__AgeAction)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__AgeAction * SOAP_FMAC4 soap_in_ngwt__AgeAction(struct soap *soap, const char *tag, enum ngwt__AgeAction *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__AgeAction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AgeAction, sizeof(enum ngwt__AgeAction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__AgeAction(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__AgeAction *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AgeAction, 0, sizeof(enum ngwt__AgeAction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__AcceptLevel(struct soap *soap, enum ngwt__AcceptLevel *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__AcceptLevel
	*a = SOAP_DEFAULT_ngwt__AcceptLevel;
#else
	*a = (enum ngwt__AcceptLevel)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__AcceptLevel(struct soap *soap, const enum ngwt__AcceptLevel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__AcceptLevel);
	if (soap_out_ngwt__AcceptLevel(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__AcceptLevel[] =
{	{ (long)Free, "Free" },
	{ (long)Tentative, "Tentative" },
	{ (long)Busy, "Busy" },
	{ (long)OutOfOffice, "OutOfOffice" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ngwt__AcceptLevel2s(struct soap *soap, enum ngwt__AcceptLevel n)
{	const char *s = soap_str_code(soap_codes_ngwt__AcceptLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AcceptLevel(struct soap *soap, const char *tag, int id, const enum ngwt__AcceptLevel *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AcceptLevel), type);
	soap_send(soap, soap_ngwt__AcceptLevel2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__AcceptLevel * SOAP_FMAC4 soap_get_ngwt__AcceptLevel(struct soap *soap, enum ngwt__AcceptLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AcceptLevel(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ngwt__AcceptLevel(struct soap *soap, const char *s, enum ngwt__AcceptLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ngwt__AcceptLevel, s);
	if (map)
		*a = (enum ngwt__AcceptLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n))
			return soap->error;
		*a = (enum ngwt__AcceptLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ngwt__AcceptLevel * SOAP_FMAC4 soap_in_ngwt__AcceptLevel(struct soap *soap, const char *tag, enum ngwt__AcceptLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__AcceptLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AcceptLevel, sizeof(enum ngwt__AcceptLevel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ngwt__AcceptLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__AcceptLevel *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AcceptLevel, 0, sizeof(enum ngwt__AcceptLevel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwe__ItemTypeList(struct soap *soap, enum ngwe__ItemTypeList *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwe__ItemTypeList
	*a = SOAP_DEFAULT_ngwe__ItemTypeList;
#else
	*a = (enum ngwe__ItemTypeList)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwe__ItemTypeList(struct soap *soap, const enum ngwe__ItemTypeList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwe__ItemTypeList);
	if (soap_out_ngwe__ItemTypeList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwe__ItemTypeList[] =
{	{ (long)AddressBookItem, "AddressBookItem" },
	{ (long)Appointment_, "Appointment" },
	{ (long)CalendarItem_, "CalendarItem" },
	{ (long)Contact_, "Contact" },
	{ (long)Group, "Group" },
	{ (long)Mail_, "Mail" },
	{ (long)Note_, "Note" },
	{ (long)Organization_, "Organization" },
	{ (long)PhoneMessage_, "PhoneMessage" },
	{ (long)Resource, "Resource" },
	{ (long)Task_, "Task" },
	{ (long)DocumentRef, "DocumentRef" },
	{ 0, NULL }
};

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__ItemTypeList(struct soap *soap, const char *tag, int id, const enum ngwe__ItemTypeList *a, const char *type)
{	long i;
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__ItemTypeList), type);
	for (i = 1; i; i <<= 1)
		switch ((long)*a & i)
		{
			case 1: soap_send(soap, "AddressBookItem "); break;
			case 2: soap_send(soap, "Appointment "); break;
			case 4: soap_send(soap, "CalendarItem "); break;
			case 8: soap_send(soap, "Contact "); break;
			case 16: soap_send(soap, "Group "); break;
			case 32: soap_send(soap, "Mail "); break;
			case 64: soap_send(soap, "Note "); break;
			case 128: soap_send(soap, "Organization "); break;
			case 256: soap_send(soap, "PhoneMessage "); break;
			case 512: soap_send(soap, "Resource "); break;
			case 1024: soap_send(soap, "Task "); break;
			case 2048: soap_send(soap, "DocumentRef "); break;
		}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwe__ItemTypeList * SOAP_FMAC4 soap_get_ngwe__ItemTypeList(struct soap *soap, enum ngwe__ItemTypeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__ItemTypeList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwe__ItemTypeList * SOAP_FMAC4 soap_in_ngwe__ItemTypeList(struct soap *soap, const char *tag, enum ngwe__ItemTypeList *a, const char *type)
{
	const char *s;
	LONG64 i;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwe__ItemTypeList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__ItemTypeList, sizeof(enum ngwe__ItemTypeList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	i = 0;
		while (*(s = soap_token(soap)))
			if (!strcmp(s, "AddressBookItem"))
				i |= (LONG64)AddressBookItem;
			else if (!strcmp(s, "Appointment"))
				i |= (LONG64)Appointment_;
			else if (!strcmp(s, "CalendarItem"))
				i |= (LONG64)CalendarItem_;
			else if (!strcmp(s, "Contact"))
				i |= (LONG64)Contact_;
			else if (!strcmp(s, "Group"))
				i |= (LONG64)Group;
			else if (!strcmp(s, "Mail"))
				i |= (LONG64)Mail_;
			else if (!strcmp(s, "Note"))
				i |= (LONG64)Note_;
			else if (!strcmp(s, "Organization"))
				i |= (LONG64)Organization_;
			else if (!strcmp(s, "PhoneMessage"))
				i |= (LONG64)PhoneMessage_;
			else if (!strcmp(s, "Resource"))
				i |= (LONG64)Resource;
			else if (!strcmp(s, "Task"))
				i |= (LONG64)Task_;
			else if (!strcmp(s, "DocumentRef"))
				i |= (LONG64)DocumentRef;
			else 
			{	soap->error = SOAP_TYPE;
				return NULL;
			}
		*a = (enum ngwe__ItemTypeList)i;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwe__ItemTypeList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__ItemTypeList, 0, sizeof(enum ngwe__ItemTypeList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwe__FieldList(struct soap *soap, enum ngwe__FieldList *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwe__FieldList
	*a = SOAP_DEFAULT_ngwe__FieldList;
#else
	*a = (enum ngwe__FieldList)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwe__FieldList(struct soap *soap, const enum ngwe__FieldList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwe__FieldList);
	if (soap_out_ngwe__FieldList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwe__FieldList[] =
{	{ (long)AcceptLevel, "AcceptLevel" },
	{ (long)Alarm, "Alarm" },
	{ (long)AllDayEvent, "AllDayEvent" },
	{ (long)Attachment, "Attachment" },
	{ (long)Category, "Category" },
	{ (long)Classification, "Classification" },
	{ (long)Contact, "Contact" },
	{ (long)DueDate, "DueDate" },
	{ (long)Duration, "Duration" },
	{ (long)EmailAddress, "EmailAddress" },
	{ (long)ExpirationDate, "ExpirationDate" },
	{ (long)Hidden, "Hidden" },
	{ (long)IMAddress, "IMAddress" },
	{ (long)MessageBody, "MessageBody" },
	{ (long)Name, "Name" },
	{ (long)Organization, "Organization" },
	{ (long)Owner, "Owner" },
	{ (long)PersonalSubject, "PersonalSubject" },
	{ (long)PhoneNumber, "PhoneNumber" },
	{ (long)Place, "Place" },
	{ (long)PostalAddress, "PostalAddress" },
	{ (long)RecipientStatus, "RecipientStatus" },
	{ (long)Rights, "Rights" },
	{ (long)Security, "Security" },
	{ (long)SendPriority, "SendPriority" },
	{ (long)StartDate, "StartDate" },
	{ (long)Subject, "Subject" },
	{ (long)TaskCategory, "TaskCategory" },
	{ (long)TaskPriority, "TaskPriority" },
	{ 0, NULL }
};

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__FieldList(struct soap *soap, const char *tag, int id, const enum ngwe__FieldList *a, const char *type)
{	long i;
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__FieldList), type);
	for (i = 1; i; i <<= 1)
		switch ((long)*a & i)
		{
			case 1: soap_send(soap, "AcceptLevel "); break;
			case 2: soap_send(soap, "Alarm "); break;
			case 4: soap_send(soap, "AllDayEvent "); break;
			case 8: soap_send(soap, "Attachment "); break;
			case 16: soap_send(soap, "Category "); break;
			case 32: soap_send(soap, "Classification "); break;
			case 64: soap_send(soap, "Contact "); break;
			case 128: soap_send(soap, "DueDate "); break;
			case 256: soap_send(soap, "Duration "); break;
			case 512: soap_send(soap, "EmailAddress "); break;
			case 1024: soap_send(soap, "ExpirationDate "); break;
			case 2048: soap_send(soap, "Hidden "); break;
			case 4096: soap_send(soap, "IMAddress "); break;
			case 8192: soap_send(soap, "MessageBody "); break;
			case 16384: soap_send(soap, "Name "); break;
			case 32768: soap_send(soap, "Organization "); break;
			case 65536: soap_send(soap, "Owner "); break;
			case 131072: soap_send(soap, "PersonalSubject "); break;
			case 262144: soap_send(soap, "PhoneNumber "); break;
			case 524288: soap_send(soap, "Place "); break;
			case 1048576: soap_send(soap, "PostalAddress "); break;
			case 2097152: soap_send(soap, "RecipientStatus "); break;
			case 4194304: soap_send(soap, "Rights "); break;
			case 8388608: soap_send(soap, "Security "); break;
			case 16777216: soap_send(soap, "SendPriority "); break;
			case 33554432: soap_send(soap, "StartDate "); break;
			case 67108864: soap_send(soap, "Subject "); break;
			case 134217728: soap_send(soap, "TaskCategory "); break;
			case 268435456: soap_send(soap, "TaskPriority "); break;
		}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwe__FieldList * SOAP_FMAC4 soap_get_ngwe__FieldList(struct soap *soap, enum ngwe__FieldList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__FieldList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwe__FieldList * SOAP_FMAC4 soap_in_ngwe__FieldList(struct soap *soap, const char *tag, enum ngwe__FieldList *a, const char *type)
{
	const char *s;
	LONG64 i;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwe__FieldList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__FieldList, sizeof(enum ngwe__FieldList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	i = 0;
		while (*(s = soap_token(soap)))
			if (!strcmp(s, "AcceptLevel"))
				i |= (LONG64)AcceptLevel;
			else if (!strcmp(s, "Alarm"))
				i |= (LONG64)Alarm;
			else if (!strcmp(s, "AllDayEvent"))
				i |= (LONG64)AllDayEvent;
			else if (!strcmp(s, "Attachment"))
				i |= (LONG64)Attachment;
			else if (!strcmp(s, "Category"))
				i |= (LONG64)Category;
			else if (!strcmp(s, "Classification"))
				i |= (LONG64)Classification;
			else if (!strcmp(s, "Contact"))
				i |= (LONG64)Contact;
			else if (!strcmp(s, "DueDate"))
				i |= (LONG64)DueDate;
			else if (!strcmp(s, "Duration"))
				i |= (LONG64)Duration;
			else if (!strcmp(s, "EmailAddress"))
				i |= (LONG64)EmailAddress;
			else if (!strcmp(s, "ExpirationDate"))
				i |= (LONG64)ExpirationDate;
			else if (!strcmp(s, "Hidden"))
				i |= (LONG64)Hidden;
			else if (!strcmp(s, "IMAddress"))
				i |= (LONG64)IMAddress;
			else if (!strcmp(s, "MessageBody"))
				i |= (LONG64)MessageBody;
			else if (!strcmp(s, "Name"))
				i |= (LONG64)Name;
			else if (!strcmp(s, "Organization"))
				i |= (LONG64)Organization;
			else if (!strcmp(s, "Owner"))
				i |= (LONG64)Owner;
			else if (!strcmp(s, "PersonalSubject"))
				i |= (LONG64)PersonalSubject;
			else if (!strcmp(s, "PhoneNumber"))
				i |= (LONG64)PhoneNumber;
			else if (!strcmp(s, "Place"))
				i |= (LONG64)Place;
			else if (!strcmp(s, "PostalAddress"))
				i |= (LONG64)PostalAddress;
			else if (!strcmp(s, "RecipientStatus"))
				i |= (LONG64)RecipientStatus;
			else if (!strcmp(s, "Rights"))
				i |= (LONG64)Rights;
			else if (!strcmp(s, "Security"))
				i |= (LONG64)Security;
			else if (!strcmp(s, "SendPriority"))
				i |= (LONG64)SendPriority;
			else if (!strcmp(s, "StartDate"))
				i |= (LONG64)StartDate;
			else if (!strcmp(s, "Subject"))
				i |= (LONG64)Subject;
			else if (!strcmp(s, "TaskCategory"))
				i |= (LONG64)TaskCategory;
			else if (!strcmp(s, "TaskPriority"))
				i |= (LONG64)TaskPriority;
			else 
			{	soap->error = SOAP_TYPE;
				return NULL;
			}
		*a = (enum ngwe__FieldList)i;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwe__FieldList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__FieldList, 0, sizeof(enum ngwe__FieldList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__MessageTypeList(struct soap *soap, enum ngwt__MessageTypeList *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__MessageTypeList
	*a = SOAP_DEFAULT_ngwt__MessageTypeList;
#else
	*a = (enum ngwt__MessageTypeList)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__MessageTypeList(struct soap *soap, const enum ngwt__MessageTypeList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__MessageTypeList);
	if (soap_out_ngwt__MessageTypeList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__MessageTypeList[] =
{	{ (long)Appointment, "Appointment" },
	{ (long)CalendarItem, "CalendarItem" },
	{ (long)DocumentReference, "DocumentReference" },
	{ (long)Mail, "Mail" },
	{ (long)Note, "Note" },
	{ (long)PhoneMessage, "PhoneMessage" },
	{ (long)Task, "Task" },
	{ 0, NULL }
};

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__MessageTypeList(struct soap *soap, const char *tag, int id, const enum ngwt__MessageTypeList *a, const char *type)
{	long i;
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__MessageTypeList), type);
	for (i = 1; i; i <<= 1)
		switch ((long)*a & i)
		{
			case 1: soap_send(soap, "Appointment "); break;
			case 2: soap_send(soap, "CalendarItem "); break;
			case 4: soap_send(soap, "DocumentReference "); break;
			case 8: soap_send(soap, "Mail "); break;
			case 16: soap_send(soap, "Note "); break;
			case 32: soap_send(soap, "PhoneMessage "); break;
			case 64: soap_send(soap, "Task "); break;
		}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__MessageTypeList * SOAP_FMAC4 soap_get_ngwt__MessageTypeList(struct soap *soap, enum ngwt__MessageTypeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__MessageTypeList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__MessageTypeList * SOAP_FMAC4 soap_in_ngwt__MessageTypeList(struct soap *soap, const char *tag, enum ngwt__MessageTypeList *a, const char *type)
{
	const char *s;
	LONG64 i;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__MessageTypeList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__MessageTypeList, sizeof(enum ngwt__MessageTypeList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	i = 0;
		while (*(s = soap_token(soap)))
			if (!strcmp(s, "Appointment"))
				i |= (LONG64)Appointment;
			else if (!strcmp(s, "CalendarItem"))
				i |= (LONG64)CalendarItem;
			else if (!strcmp(s, "DocumentReference"))
				i |= (LONG64)DocumentReference;
			else if (!strcmp(s, "Mail"))
				i |= (LONG64)Mail;
			else if (!strcmp(s, "Note"))
				i |= (LONG64)Note;
			else if (!strcmp(s, "PhoneMessage"))
				i |= (LONG64)PhoneMessage;
			else if (!strcmp(s, "Task"))
				i |= (LONG64)Task;
			else 
			{	soap->error = SOAP_TYPE;
				return NULL;
			}
		*a = (enum ngwt__MessageTypeList)i;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__MessageTypeList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__MessageTypeList, 0, sizeof(enum ngwt__MessageTypeList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__ItemSourceList(struct soap *soap, enum ngwt__ItemSourceList *a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ngwt__ItemSourceList
	*a = SOAP_DEFAULT_ngwt__ItemSourceList;
#else
	*a = (enum ngwt__ItemSourceList)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__ItemSourceList(struct soap *soap, const enum ngwt__ItemSourceList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__ItemSourceList);
	if (soap_out_ngwt__ItemSourceList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ngwt__ItemSourceList[] =
{	{ (long)received, "received" },
	{ (long)sent, "sent" },
	{ (long)draft, "draft" },
	{ (long)personal, "personal" },
	{ 0, NULL }
};

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ItemSourceList(struct soap *soap, const char *tag, int id, const enum ngwt__ItemSourceList *a, const char *type)
{	long i;
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ItemSourceList), type);
	for (i = 1; i; i <<= 1)
		switch ((long)*a & i)
		{
			case 1: soap_send(soap, "received "); break;
			case 2: soap_send(soap, "sent "); break;
			case 4: soap_send(soap, "draft "); break;
			case 8: soap_send(soap, "personal "); break;
		}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ngwt__ItemSourceList * SOAP_FMAC4 soap_get_ngwt__ItemSourceList(struct soap *soap, enum ngwt__ItemSourceList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ItemSourceList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__ItemSourceList * SOAP_FMAC4 soap_in_ngwt__ItemSourceList(struct soap *soap, const char *tag, enum ngwt__ItemSourceList *a, const char *type)
{
	const char *s;
	LONG64 i;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ngwt__ItemSourceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ItemSourceList, sizeof(enum ngwt__ItemSourceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	i = 0;
		while (*(s = soap_token(soap)))
			if (!strcmp(s, "received"))
				i |= (LONG64)received;
			else if (!strcmp(s, "sent"))
				i |= (LONG64)sent;
			else if (!strcmp(s, "draft"))
				i |= (LONG64)draft;
			else if (!strcmp(s, "personal"))
				i |= (LONG64)personal;
			else 
			{	soap->error = SOAP_TYPE;
				return NULL;
			}
		*a = (enum ngwt__ItemSourceList)i;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ngwt__ItemSourceList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemSourceList, 0, sizeof(enum ngwt__ItemSourceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ngwt__UUID(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__UUID(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__UUID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__UUID);
	if (soap_out_ngwt__UUID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__UUID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ngwt__UUID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ngwt__UUID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__UUID(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_ngwt__UUID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ngwt__UUID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ngwt__UUID, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_ngwt__UUID, 0, sizeof(std::string), 0, soap_copy_ngwt__UUID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_ngwt__UUID(struct soap *soap, int n)
{	return soap_instantiate_ngwt__UUID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__UUID(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_ngwt__UUID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__UUID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__UUID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__UUID(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ngwt__uid(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__uid(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__uid(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__uid);
	if (soap_out_ngwt__uid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__uid(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ngwt__uid), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ngwt__uid(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__uid(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_ngwt__uid(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ngwt__uid, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ngwt__uid, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_ngwt__uid, 0, sizeof(std::string), 0, soap_copy_ngwt__uid);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_ngwt__uid(struct soap *soap, int n)
{	return soap_instantiate_ngwt__uid(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__uid(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_ngwt__uid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__uid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__uid, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__uid(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ngwt__View(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ngwt__View(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ngwt__View(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ngwt__View);
	if (soap_out_ngwt__View(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__View(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ngwt__View), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ngwt__View(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__View(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_ngwt__View(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ngwt__View, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ngwt__View, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_ngwt__View, 0, sizeof(std::string), 0, soap_copy_ngwt__View);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_ngwt__View(struct soap *soap, int n)
{	return soap_instantiate_ngwt__View(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__View(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_ngwt__View(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__View(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__View, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__View(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _ngwe__removeEventsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__removeEventsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwe__removeEventsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwe__removeEventsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwe__removeEventsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwe__removeEventsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__removeEventsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__removeEventsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__removeEventsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__removeEventsResponse(struct soap *soap, const char *tag, int id, const _ngwe__removeEventsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__removeEventsResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwe:status", -1, &(((_ngwe__removeEventsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__removeEventsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__removeEventsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__removeEventsResponse * SOAP_FMAC4 soap_get__ngwe__removeEventsResponse(struct soap *soap, _ngwe__removeEventsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__removeEventsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__removeEventsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__removeEventsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__removeEventsResponse * SOAP_FMAC4 soap_in__ngwe__removeEventsResponse(struct soap *soap, const char *tag, _ngwe__removeEventsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__removeEventsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__removeEventsResponse, sizeof(_ngwe__removeEventsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__removeEventsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__removeEventsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwe:status", &(((_ngwe__removeEventsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__removeEventsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__removeEventsResponse, 0, sizeof(_ngwe__removeEventsResponse), 0, soap_copy__ngwe__removeEventsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__removeEventsResponse * SOAP_FMAC6 soap_new__ngwe__removeEventsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwe__removeEventsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__removeEventsResponse(struct soap *soap, _ngwe__removeEventsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__removeEventsResponse * SOAP_FMAC6 soap_instantiate__ngwe__removeEventsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__removeEventsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__removeEventsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__removeEventsResponse;
		if (size)
			*size = sizeof(_ngwe__removeEventsResponse);
		((_ngwe__removeEventsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__removeEventsResponse[n];
		if (size)
			*size = n * sizeof(_ngwe__removeEventsResponse);
		for (int i = 0; i < n; i++)
			((_ngwe__removeEventsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__removeEventsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__removeEventsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__removeEventsResponse %p -> %p\n", q, p));
	*(_ngwe__removeEventsResponse*)p = *(_ngwe__removeEventsResponse*)q;
}

void _ngwe__removeEventsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__removeEventsRequest*)this)->key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((_ngwe__removeEventsRequest*)this)->key);
	soap_embedded(soap, &((_ngwe__removeEventsRequest*)this)->from, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwe__removeEventsRequest*)this)->from);
	soap_embedded(soap, &((_ngwe__removeEventsRequest*)this)->until, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwe__removeEventsRequest*)this)->until);
	/* transient soap skipped */
}

void _ngwe__removeEventsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((_ngwe__removeEventsRequest*)this)->key);
	soap_default_string(soap, &((_ngwe__removeEventsRequest*)this)->from);
	soap_default_string(soap, &((_ngwe__removeEventsRequest*)this)->until);
	/* transient soap skipped */
}

int _ngwe__removeEventsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__removeEventsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__removeEventsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__removeEventsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__removeEventsRequest(struct soap *soap, const char *tag, int id, const _ngwe__removeEventsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__removeEventsRequest), type);
	soap_out_std__string(soap, "ngwe:key", -1, &(((_ngwe__removeEventsRequest*)a)->key), "");
	soap_out_string(soap, "ngwe:from", -1, &(((_ngwe__removeEventsRequest*)a)->from), "");
	soap_out_string(soap, "ngwe:until", -1, &(((_ngwe__removeEventsRequest*)a)->until), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__removeEventsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__removeEventsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__removeEventsRequest * SOAP_FMAC4 soap_get__ngwe__removeEventsRequest(struct soap *soap, _ngwe__removeEventsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__removeEventsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__removeEventsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__removeEventsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__removeEventsRequest * SOAP_FMAC4 soap_in__ngwe__removeEventsRequest(struct soap *soap, const char *tag, _ngwe__removeEventsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__removeEventsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__removeEventsRequest, sizeof(_ngwe__removeEventsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__removeEventsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__removeEventsRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_key1 = 1, soap_flag_from1 = 1, soap_flag_until1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwe:key", &(((_ngwe__removeEventsRequest*)a)->key), ""))
				{	soap_flag_key1 = 0;
					continue;
				}
			if (soap_flag_from1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwe:from", &(((_ngwe__removeEventsRequest*)a)->from), ""))
				{	soap_flag_from1 = 0;
					continue;
				}
			if (soap_flag_until1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwe:until", &(((_ngwe__removeEventsRequest*)a)->until), ""))
				{	soap_flag_until1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__removeEventsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__removeEventsRequest, 0, sizeof(_ngwe__removeEventsRequest), 0, soap_copy__ngwe__removeEventsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__removeEventsRequest * SOAP_FMAC6 soap_new__ngwe__removeEventsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwe__removeEventsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__removeEventsRequest(struct soap *soap, _ngwe__removeEventsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__removeEventsRequest * SOAP_FMAC6 soap_instantiate__ngwe__removeEventsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__removeEventsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__removeEventsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__removeEventsRequest;
		if (size)
			*size = sizeof(_ngwe__removeEventsRequest);
		((_ngwe__removeEventsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__removeEventsRequest[n];
		if (size)
			*size = n * sizeof(_ngwe__removeEventsRequest);
		for (int i = 0; i < n; i++)
			((_ngwe__removeEventsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__removeEventsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__removeEventsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__removeEventsRequest %p -> %p\n", q, p));
	*(_ngwe__removeEventsRequest*)p = *(_ngwe__removeEventsRequest*)q;
}

void _ngwe__removeEventConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__removeEventConfigurationResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwe__removeEventConfigurationResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwe__removeEventConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwe__removeEventConfigurationResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwe__removeEventConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__removeEventConfigurationResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__removeEventConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__removeEventConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__removeEventConfigurationResponse(struct soap *soap, const char *tag, int id, const _ngwe__removeEventConfigurationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__removeEventConfigurationResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwe:status", -1, &(((_ngwe__removeEventConfigurationResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__removeEventConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__removeEventConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__removeEventConfigurationResponse * SOAP_FMAC4 soap_get__ngwe__removeEventConfigurationResponse(struct soap *soap, _ngwe__removeEventConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__removeEventConfigurationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__removeEventConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__removeEventConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__removeEventConfigurationResponse * SOAP_FMAC4 soap_in__ngwe__removeEventConfigurationResponse(struct soap *soap, const char *tag, _ngwe__removeEventConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__removeEventConfigurationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__removeEventConfigurationResponse, sizeof(_ngwe__removeEventConfigurationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__removeEventConfigurationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__removeEventConfigurationResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwe:status", &(((_ngwe__removeEventConfigurationResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__removeEventConfigurationResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__removeEventConfigurationResponse, 0, sizeof(_ngwe__removeEventConfigurationResponse), 0, soap_copy__ngwe__removeEventConfigurationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__removeEventConfigurationResponse * SOAP_FMAC6 soap_new__ngwe__removeEventConfigurationResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwe__removeEventConfigurationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__removeEventConfigurationResponse(struct soap *soap, _ngwe__removeEventConfigurationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__removeEventConfigurationResponse * SOAP_FMAC6 soap_instantiate__ngwe__removeEventConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__removeEventConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__removeEventConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__removeEventConfigurationResponse;
		if (size)
			*size = sizeof(_ngwe__removeEventConfigurationResponse);
		((_ngwe__removeEventConfigurationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__removeEventConfigurationResponse[n];
		if (size)
			*size = n * sizeof(_ngwe__removeEventConfigurationResponse);
		for (int i = 0; i < n; i++)
			((_ngwe__removeEventConfigurationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__removeEventConfigurationResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__removeEventConfigurationResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__removeEventConfigurationResponse %p -> %p\n", q, p));
	*(_ngwe__removeEventConfigurationResponse*)p = *(_ngwe__removeEventConfigurationResponse*)q;
}

void _ngwe__removeEventConfigurationRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__removeEventConfigurationRequest*)this)->key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((_ngwe__removeEventConfigurationRequest*)this)->key);
	/* transient soap skipped */
}

void _ngwe__removeEventConfigurationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((_ngwe__removeEventConfigurationRequest*)this)->key);
	/* transient soap skipped */
}

int _ngwe__removeEventConfigurationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__removeEventConfigurationRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__removeEventConfigurationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__removeEventConfigurationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__removeEventConfigurationRequest(struct soap *soap, const char *tag, int id, const _ngwe__removeEventConfigurationRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__removeEventConfigurationRequest), type);
	soap_out_std__string(soap, "ngwe:key", -1, &(((_ngwe__removeEventConfigurationRequest*)a)->key), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__removeEventConfigurationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__removeEventConfigurationRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__removeEventConfigurationRequest * SOAP_FMAC4 soap_get__ngwe__removeEventConfigurationRequest(struct soap *soap, _ngwe__removeEventConfigurationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__removeEventConfigurationRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__removeEventConfigurationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__removeEventConfigurationRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__removeEventConfigurationRequest * SOAP_FMAC4 soap_in__ngwe__removeEventConfigurationRequest(struct soap *soap, const char *tag, _ngwe__removeEventConfigurationRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__removeEventConfigurationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__removeEventConfigurationRequest, sizeof(_ngwe__removeEventConfigurationRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__removeEventConfigurationRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__removeEventConfigurationRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_key1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwe:key", &(((_ngwe__removeEventConfigurationRequest*)a)->key), ""))
				{	soap_flag_key1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__removeEventConfigurationRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__removeEventConfigurationRequest, 0, sizeof(_ngwe__removeEventConfigurationRequest), 0, soap_copy__ngwe__removeEventConfigurationRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__removeEventConfigurationRequest * SOAP_FMAC6 soap_new__ngwe__removeEventConfigurationRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwe__removeEventConfigurationRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__removeEventConfigurationRequest(struct soap *soap, _ngwe__removeEventConfigurationRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__removeEventConfigurationRequest * SOAP_FMAC6 soap_instantiate__ngwe__removeEventConfigurationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__removeEventConfigurationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__removeEventConfigurationRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__removeEventConfigurationRequest;
		if (size)
			*size = sizeof(_ngwe__removeEventConfigurationRequest);
		((_ngwe__removeEventConfigurationRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__removeEventConfigurationRequest[n];
		if (size)
			*size = n * sizeof(_ngwe__removeEventConfigurationRequest);
		for (int i = 0; i < n; i++)
			((_ngwe__removeEventConfigurationRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__removeEventConfigurationRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__removeEventConfigurationRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__removeEventConfigurationRequest %p -> %p\n", q, p));
	*(_ngwe__removeEventConfigurationRequest*)p = *(_ngwe__removeEventConfigurationRequest*)q;
}

void _ngwe__getEventsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__getEventsResponse*)this)->events, SOAP_TYPE_PointerTongwe__EventList);
	soap_serialize_PointerTongwe__EventList(soap, &((_ngwe__getEventsResponse*)this)->events);
	soap_embedded(soap, &((_ngwe__getEventsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwe__getEventsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwe__getEventsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwe__getEventsResponse*)this)->events = NULL;
	((_ngwe__getEventsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwe__getEventsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__getEventsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__getEventsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__getEventsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__getEventsResponse(struct soap *soap, const char *tag, int id, const _ngwe__getEventsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__getEventsResponse), type);
	soap_out_PointerTongwe__EventList(soap, "ngwe:events", -1, &(((_ngwe__getEventsResponse*)a)->events), "");
	soap_out_PointerTongwt__Status(soap, "ngwe:status", -1, &(((_ngwe__getEventsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__getEventsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__getEventsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__getEventsResponse * SOAP_FMAC4 soap_get__ngwe__getEventsResponse(struct soap *soap, _ngwe__getEventsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__getEventsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__getEventsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__getEventsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__getEventsResponse * SOAP_FMAC4 soap_in__ngwe__getEventsResponse(struct soap *soap, const char *tag, _ngwe__getEventsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__getEventsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__getEventsResponse, sizeof(_ngwe__getEventsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__getEventsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__getEventsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_events1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_events1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwe__EventList(soap, "ngwe:events", &(((_ngwe__getEventsResponse*)a)->events), "ngwe:EventList"))
				{	soap_flag_events1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwe:status", &(((_ngwe__getEventsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__getEventsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__getEventsResponse, 0, sizeof(_ngwe__getEventsResponse), 0, soap_copy__ngwe__getEventsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__getEventsResponse * SOAP_FMAC6 soap_new__ngwe__getEventsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwe__getEventsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__getEventsResponse(struct soap *soap, _ngwe__getEventsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__getEventsResponse * SOAP_FMAC6 soap_instantiate__ngwe__getEventsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__getEventsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__getEventsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__getEventsResponse;
		if (size)
			*size = sizeof(_ngwe__getEventsResponse);
		((_ngwe__getEventsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__getEventsResponse[n];
		if (size)
			*size = n * sizeof(_ngwe__getEventsResponse);
		for (int i = 0; i < n; i++)
			((_ngwe__getEventsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__getEventsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__getEventsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__getEventsResponse %p -> %p\n", q, p));
	*(_ngwe__getEventsResponse*)p = *(_ngwe__getEventsResponse*)q;
}

void _ngwe__getEventsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__getEventsRequest*)this)->key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((_ngwe__getEventsRequest*)this)->key);
	soap_embedded(soap, &((_ngwe__getEventsRequest*)this)->from, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwe__getEventsRequest*)this)->from);
	soap_embedded(soap, &((_ngwe__getEventsRequest*)this)->until, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwe__getEventsRequest*)this)->until);
	soap_embedded(soap, &((_ngwe__getEventsRequest*)this)->uid, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((_ngwe__getEventsRequest*)this)->uid);
	soap_embedded(soap, &((_ngwe__getEventsRequest*)this)->count, SOAP_TYPE_int);
	soap_embedded(soap, &((_ngwe__getEventsRequest*)this)->remove, SOAP_TYPE_bool);
	soap_embedded(soap, &((_ngwe__getEventsRequest*)this)->notify, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void _ngwe__getEventsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((_ngwe__getEventsRequest*)this)->key);
	soap_default_string(soap, &((_ngwe__getEventsRequest*)this)->from);
	soap_default_string(soap, &((_ngwe__getEventsRequest*)this)->until);
	((_ngwe__getEventsRequest*)this)->uid = NULL;
	((_ngwe__getEventsRequest*)this)->count = -1;
	((_ngwe__getEventsRequest*)this)->remove = (bool)0;
	((_ngwe__getEventsRequest*)this)->notify = (bool)0;
	/* transient soap skipped */
}

int _ngwe__getEventsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__getEventsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__getEventsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__getEventsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__getEventsRequest(struct soap *soap, const char *tag, int id, const _ngwe__getEventsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__getEventsRequest), type);
	soap_out_std__string(soap, "ngwe:key", -1, &(((_ngwe__getEventsRequest*)a)->key), "");
	soap_out_string(soap, "ngwe:from", -1, &(((_ngwe__getEventsRequest*)a)->from), "");
	soap_out_string(soap, "ngwe:until", -1, &(((_ngwe__getEventsRequest*)a)->until), "");
	soap_out_PointerTounsignedLong(soap, "ngwe:uid", -1, &(((_ngwe__getEventsRequest*)a)->uid), "");
	soap_out_int(soap, "ngwe:count", -1, &(((_ngwe__getEventsRequest*)a)->count), "");
	soap_out_bool(soap, "ngwe:remove", -1, &(((_ngwe__getEventsRequest*)a)->remove), "");
	soap_out_bool(soap, "ngwe:notify", -1, &(((_ngwe__getEventsRequest*)a)->notify), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__getEventsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__getEventsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__getEventsRequest * SOAP_FMAC4 soap_get__ngwe__getEventsRequest(struct soap *soap, _ngwe__getEventsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__getEventsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__getEventsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__getEventsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__getEventsRequest * SOAP_FMAC4 soap_in__ngwe__getEventsRequest(struct soap *soap, const char *tag, _ngwe__getEventsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__getEventsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__getEventsRequest, sizeof(_ngwe__getEventsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__getEventsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__getEventsRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_key1 = 1, soap_flag_from1 = 1, soap_flag_until1 = 1, soap_flag_uid1 = 1, soap_flag_count1 = 1, soap_flag_remove1 = 1, soap_flag_notify1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwe:key", &(((_ngwe__getEventsRequest*)a)->key), ""))
				{	soap_flag_key1 = 0;
					continue;
				}
			if (soap_flag_from1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwe:from", &(((_ngwe__getEventsRequest*)a)->from), ""))
				{	soap_flag_from1 = 0;
					continue;
				}
			if (soap_flag_until1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwe:until", &(((_ngwe__getEventsRequest*)a)->until), ""))
				{	soap_flag_until1 = 0;
					continue;
				}
			if (soap_flag_uid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwe:uid", &(((_ngwe__getEventsRequest*)a)->uid), ""))
				{	soap_flag_uid1 = 0;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwe:count", &(((_ngwe__getEventsRequest*)a)->count), ""))
				{	soap_flag_count1 = 0;
					continue;
				}
			if (soap_flag_remove1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwe:remove", &(((_ngwe__getEventsRequest*)a)->remove), ""))
				{	soap_flag_remove1 = 0;
					continue;
				}
			if (soap_flag_notify1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwe:notify", &(((_ngwe__getEventsRequest*)a)->notify), ""))
				{	soap_flag_notify1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__getEventsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__getEventsRequest, 0, sizeof(_ngwe__getEventsRequest), 0, soap_copy__ngwe__getEventsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__getEventsRequest * SOAP_FMAC6 soap_new__ngwe__getEventsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwe__getEventsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__getEventsRequest(struct soap *soap, _ngwe__getEventsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__getEventsRequest * SOAP_FMAC6 soap_instantiate__ngwe__getEventsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__getEventsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__getEventsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__getEventsRequest;
		if (size)
			*size = sizeof(_ngwe__getEventsRequest);
		((_ngwe__getEventsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__getEventsRequest[n];
		if (size)
			*size = n * sizeof(_ngwe__getEventsRequest);
		for (int i = 0; i < n; i++)
			((_ngwe__getEventsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__getEventsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__getEventsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__getEventsRequest %p -> %p\n", q, p));
	*(_ngwe__getEventsRequest*)p = *(_ngwe__getEventsRequest*)q;
}

void _ngwe__getEventConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__getEventConfigurationResponse*)this)->events, SOAP_TYPE_PointerTongwe__EventsList);
	soap_serialize_PointerTongwe__EventsList(soap, &((_ngwe__getEventConfigurationResponse*)this)->events);
	soap_embedded(soap, &((_ngwe__getEventConfigurationResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwe__getEventConfigurationResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwe__getEventConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwe__getEventConfigurationResponse*)this)->events = NULL;
	((_ngwe__getEventConfigurationResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwe__getEventConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__getEventConfigurationResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__getEventConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__getEventConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__getEventConfigurationResponse(struct soap *soap, const char *tag, int id, const _ngwe__getEventConfigurationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__getEventConfigurationResponse), type);
	soap_out_PointerTongwe__EventsList(soap, "ngwe:events", -1, &(((_ngwe__getEventConfigurationResponse*)a)->events), "");
	soap_out_PointerTongwt__Status(soap, "ngwe:status", -1, &(((_ngwe__getEventConfigurationResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__getEventConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__getEventConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__getEventConfigurationResponse * SOAP_FMAC4 soap_get__ngwe__getEventConfigurationResponse(struct soap *soap, _ngwe__getEventConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__getEventConfigurationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__getEventConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__getEventConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__getEventConfigurationResponse * SOAP_FMAC4 soap_in__ngwe__getEventConfigurationResponse(struct soap *soap, const char *tag, _ngwe__getEventConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__getEventConfigurationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__getEventConfigurationResponse, sizeof(_ngwe__getEventConfigurationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__getEventConfigurationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__getEventConfigurationResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_events1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_events1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwe__EventsList(soap, "ngwe:events", &(((_ngwe__getEventConfigurationResponse*)a)->events), "ngwe:EventsList"))
				{	soap_flag_events1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwe:status", &(((_ngwe__getEventConfigurationResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__getEventConfigurationResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__getEventConfigurationResponse, 0, sizeof(_ngwe__getEventConfigurationResponse), 0, soap_copy__ngwe__getEventConfigurationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__getEventConfigurationResponse * SOAP_FMAC6 soap_new__ngwe__getEventConfigurationResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwe__getEventConfigurationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__getEventConfigurationResponse(struct soap *soap, _ngwe__getEventConfigurationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__getEventConfigurationResponse * SOAP_FMAC6 soap_instantiate__ngwe__getEventConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__getEventConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__getEventConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__getEventConfigurationResponse;
		if (size)
			*size = sizeof(_ngwe__getEventConfigurationResponse);
		((_ngwe__getEventConfigurationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__getEventConfigurationResponse[n];
		if (size)
			*size = n * sizeof(_ngwe__getEventConfigurationResponse);
		for (int i = 0; i < n; i++)
			((_ngwe__getEventConfigurationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__getEventConfigurationResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__getEventConfigurationResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__getEventConfigurationResponse %p -> %p\n", q, p));
	*(_ngwe__getEventConfigurationResponse*)p = *(_ngwe__getEventConfigurationResponse*)q;
}

void _ngwe__getEventConfigurationRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__getEventConfigurationRequest*)this)->key, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwe__getEventConfigurationRequest*)this)->key);
	/* transient soap skipped */
}

void _ngwe__getEventConfigurationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwe__getEventConfigurationRequest*)this)->key = NULL;
	/* transient soap skipped */
}

int _ngwe__getEventConfigurationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__getEventConfigurationRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__getEventConfigurationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__getEventConfigurationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__getEventConfigurationRequest(struct soap *soap, const char *tag, int id, const _ngwe__getEventConfigurationRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__getEventConfigurationRequest), type);
	soap_out_PointerTostd__string(soap, "ngwe:key", -1, &(((_ngwe__getEventConfigurationRequest*)a)->key), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__getEventConfigurationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__getEventConfigurationRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__getEventConfigurationRequest * SOAP_FMAC4 soap_get__ngwe__getEventConfigurationRequest(struct soap *soap, _ngwe__getEventConfigurationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__getEventConfigurationRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__getEventConfigurationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__getEventConfigurationRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__getEventConfigurationRequest * SOAP_FMAC4 soap_in__ngwe__getEventConfigurationRequest(struct soap *soap, const char *tag, _ngwe__getEventConfigurationRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__getEventConfigurationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__getEventConfigurationRequest, sizeof(_ngwe__getEventConfigurationRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__getEventConfigurationRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__getEventConfigurationRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_key1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwe:key", &(((_ngwe__getEventConfigurationRequest*)a)->key), ""))
				{	soap_flag_key1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__getEventConfigurationRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__getEventConfigurationRequest, 0, sizeof(_ngwe__getEventConfigurationRequest), 0, soap_copy__ngwe__getEventConfigurationRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__getEventConfigurationRequest * SOAP_FMAC6 soap_new__ngwe__getEventConfigurationRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwe__getEventConfigurationRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__getEventConfigurationRequest(struct soap *soap, _ngwe__getEventConfigurationRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__getEventConfigurationRequest * SOAP_FMAC6 soap_instantiate__ngwe__getEventConfigurationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__getEventConfigurationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__getEventConfigurationRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__getEventConfigurationRequest;
		if (size)
			*size = sizeof(_ngwe__getEventConfigurationRequest);
		((_ngwe__getEventConfigurationRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__getEventConfigurationRequest[n];
		if (size)
			*size = n * sizeof(_ngwe__getEventConfigurationRequest);
		for (int i = 0; i < n; i++)
			((_ngwe__getEventConfigurationRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__getEventConfigurationRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__getEventConfigurationRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__getEventConfigurationRequest %p -> %p\n", q, p));
	*(_ngwe__getEventConfigurationRequest*)p = *(_ngwe__getEventConfigurationRequest*)q;
}

void _ngwe__configureEventsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__configureEventsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwe__configureEventsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwe__configureEventsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwe__configureEventsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwe__configureEventsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__configureEventsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__configureEventsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__configureEventsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__configureEventsResponse(struct soap *soap, const char *tag, int id, const _ngwe__configureEventsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__configureEventsResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwe:status", -1, &(((_ngwe__configureEventsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__configureEventsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__configureEventsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__configureEventsResponse * SOAP_FMAC4 soap_get__ngwe__configureEventsResponse(struct soap *soap, _ngwe__configureEventsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__configureEventsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__configureEventsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__configureEventsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__configureEventsResponse * SOAP_FMAC4 soap_in__ngwe__configureEventsResponse(struct soap *soap, const char *tag, _ngwe__configureEventsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__configureEventsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__configureEventsResponse, sizeof(_ngwe__configureEventsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__configureEventsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__configureEventsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwe:status", &(((_ngwe__configureEventsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__configureEventsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__configureEventsResponse, 0, sizeof(_ngwe__configureEventsResponse), 0, soap_copy__ngwe__configureEventsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__configureEventsResponse * SOAP_FMAC6 soap_new__ngwe__configureEventsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwe__configureEventsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__configureEventsResponse(struct soap *soap, _ngwe__configureEventsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__configureEventsResponse * SOAP_FMAC6 soap_instantiate__ngwe__configureEventsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__configureEventsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__configureEventsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__configureEventsResponse;
		if (size)
			*size = sizeof(_ngwe__configureEventsResponse);
		((_ngwe__configureEventsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__configureEventsResponse[n];
		if (size)
			*size = n * sizeof(_ngwe__configureEventsResponse);
		for (int i = 0; i < n; i++)
			((_ngwe__configureEventsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__configureEventsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__configureEventsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__configureEventsResponse %p -> %p\n", q, p));
	*(_ngwe__configureEventsResponse*)p = *(_ngwe__configureEventsResponse*)q;
}

void _ngwe__configureEventsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__configureEventsRequest*)this)->events, SOAP_TYPE_PointerTongwe__Events);
	soap_serialize_PointerTongwe__Events(soap, &((_ngwe__configureEventsRequest*)this)->events);
	/* transient soap skipped */
}

void _ngwe__configureEventsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwe__configureEventsRequest*)this)->events = NULL;
	/* transient soap skipped */
}

int _ngwe__configureEventsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__configureEventsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__configureEventsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__configureEventsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__configureEventsRequest(struct soap *soap, const char *tag, int id, const _ngwe__configureEventsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__configureEventsRequest), type);
	soap_out_PointerTongwe__Events(soap, "ngwe:events", -1, &(((_ngwe__configureEventsRequest*)a)->events), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__configureEventsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__configureEventsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__configureEventsRequest * SOAP_FMAC4 soap_get__ngwe__configureEventsRequest(struct soap *soap, _ngwe__configureEventsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__configureEventsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__configureEventsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__configureEventsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__configureEventsRequest * SOAP_FMAC4 soap_in__ngwe__configureEventsRequest(struct soap *soap, const char *tag, _ngwe__configureEventsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__configureEventsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__configureEventsRequest, sizeof(_ngwe__configureEventsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__configureEventsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__configureEventsRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_events1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_events1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwe__Events(soap, "ngwe:events", &(((_ngwe__configureEventsRequest*)a)->events), "ngwe:Events"))
				{	soap_flag_events1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__configureEventsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__configureEventsRequest, 0, sizeof(_ngwe__configureEventsRequest), 0, soap_copy__ngwe__configureEventsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__configureEventsRequest * SOAP_FMAC6 soap_new__ngwe__configureEventsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwe__configureEventsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__configureEventsRequest(struct soap *soap, _ngwe__configureEventsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__configureEventsRequest * SOAP_FMAC6 soap_instantiate__ngwe__configureEventsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__configureEventsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__configureEventsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__configureEventsRequest;
		if (size)
			*size = sizeof(_ngwe__configureEventsRequest);
		((_ngwe__configureEventsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__configureEventsRequest[n];
		if (size)
			*size = n * sizeof(_ngwe__configureEventsRequest);
		for (int i = 0; i < n; i++)
			((_ngwe__configureEventsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__configureEventsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__configureEventsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__configureEventsRequest %p -> %p\n", q, p));
	*(_ngwe__configureEventsRequest*)p = *(_ngwe__configureEventsRequest*)q;
}

void _ngwe__cleanEventConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__cleanEventConfigurationResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwe__cleanEventConfigurationResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwe__cleanEventConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwe__cleanEventConfigurationResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwe__cleanEventConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__cleanEventConfigurationResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__cleanEventConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__cleanEventConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__cleanEventConfigurationResponse(struct soap *soap, const char *tag, int id, const _ngwe__cleanEventConfigurationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__cleanEventConfigurationResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwe:status", -1, &(((_ngwe__cleanEventConfigurationResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__cleanEventConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__cleanEventConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__cleanEventConfigurationResponse * SOAP_FMAC4 soap_get__ngwe__cleanEventConfigurationResponse(struct soap *soap, _ngwe__cleanEventConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__cleanEventConfigurationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__cleanEventConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__cleanEventConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__cleanEventConfigurationResponse * SOAP_FMAC4 soap_in__ngwe__cleanEventConfigurationResponse(struct soap *soap, const char *tag, _ngwe__cleanEventConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__cleanEventConfigurationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__cleanEventConfigurationResponse, sizeof(_ngwe__cleanEventConfigurationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__cleanEventConfigurationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__cleanEventConfigurationResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwe:status", &(((_ngwe__cleanEventConfigurationResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__cleanEventConfigurationResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__cleanEventConfigurationResponse, 0, sizeof(_ngwe__cleanEventConfigurationResponse), 0, soap_copy__ngwe__cleanEventConfigurationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__cleanEventConfigurationResponse * SOAP_FMAC6 soap_new__ngwe__cleanEventConfigurationResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwe__cleanEventConfigurationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__cleanEventConfigurationResponse(struct soap *soap, _ngwe__cleanEventConfigurationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__cleanEventConfigurationResponse * SOAP_FMAC6 soap_instantiate__ngwe__cleanEventConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__cleanEventConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__cleanEventConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__cleanEventConfigurationResponse;
		if (size)
			*size = sizeof(_ngwe__cleanEventConfigurationResponse);
		((_ngwe__cleanEventConfigurationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__cleanEventConfigurationResponse[n];
		if (size)
			*size = n * sizeof(_ngwe__cleanEventConfigurationResponse);
		for (int i = 0; i < n; i++)
			((_ngwe__cleanEventConfigurationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__cleanEventConfigurationResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__cleanEventConfigurationResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__cleanEventConfigurationResponse %p -> %p\n", q, p));
	*(_ngwe__cleanEventConfigurationResponse*)p = *(_ngwe__cleanEventConfigurationResponse*)q;
}

void _ngwe__cleanEventConfigurationRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwe__cleanEventConfigurationRequest*)this)->all, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void _ngwe__cleanEventConfigurationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwe__cleanEventConfigurationRequest*)this)->all = (bool)0;
	/* transient soap skipped */
}

int _ngwe__cleanEventConfigurationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwe__cleanEventConfigurationRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwe__cleanEventConfigurationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwe__cleanEventConfigurationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwe__cleanEventConfigurationRequest(struct soap *soap, const char *tag, int id, const _ngwe__cleanEventConfigurationRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwe__cleanEventConfigurationRequest), type);
	soap_out_bool(soap, "ngwe:all", -1, &(((_ngwe__cleanEventConfigurationRequest*)a)->all), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwe__cleanEventConfigurationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwe__cleanEventConfigurationRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwe__cleanEventConfigurationRequest * SOAP_FMAC4 soap_get__ngwe__cleanEventConfigurationRequest(struct soap *soap, _ngwe__cleanEventConfigurationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwe__cleanEventConfigurationRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwe__cleanEventConfigurationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwe__cleanEventConfigurationRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwe__cleanEventConfigurationRequest * SOAP_FMAC4 soap_in__ngwe__cleanEventConfigurationRequest(struct soap *soap, const char *tag, _ngwe__cleanEventConfigurationRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwe__cleanEventConfigurationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwe__cleanEventConfigurationRequest, sizeof(_ngwe__cleanEventConfigurationRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwe__cleanEventConfigurationRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwe__cleanEventConfigurationRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_all1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_all1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwe:all", &(((_ngwe__cleanEventConfigurationRequest*)a)->all), ""))
				{	soap_flag_all1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwe__cleanEventConfigurationRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__cleanEventConfigurationRequest, 0, sizeof(_ngwe__cleanEventConfigurationRequest), 0, soap_copy__ngwe__cleanEventConfigurationRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwe__cleanEventConfigurationRequest * SOAP_FMAC6 soap_new__ngwe__cleanEventConfigurationRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwe__cleanEventConfigurationRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwe__cleanEventConfigurationRequest(struct soap *soap, _ngwe__cleanEventConfigurationRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwe__cleanEventConfigurationRequest * SOAP_FMAC6 soap_instantiate__ngwe__cleanEventConfigurationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwe__cleanEventConfigurationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwe__cleanEventConfigurationRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwe__cleanEventConfigurationRequest;
		if (size)
			*size = sizeof(_ngwe__cleanEventConfigurationRequest);
		((_ngwe__cleanEventConfigurationRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwe__cleanEventConfigurationRequest[n];
		if (size)
			*size = n * sizeof(_ngwe__cleanEventConfigurationRequest);
		for (int i = 0; i < n; i++)
			((_ngwe__cleanEventConfigurationRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwe__cleanEventConfigurationRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwe__cleanEventConfigurationRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwe__cleanEventConfigurationRequest %p -> %p\n", q, p));
	*(_ngwe__cleanEventConfigurationRequest*)p = *(_ngwe__cleanEventConfigurationRequest*)q;
}

void ngwe__Notify::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwe__Notify*)this)->userid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwe__Notify*)this)->userid);
	soap_embedded(soap, &((ngwe__Notify*)this)->key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwe__Notify*)this)->key);
	/* transient soap skipped */
}

void ngwe__Notify::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwe__Notify*)this)->userid);
	soap_default_std__string(soap, &((ngwe__Notify*)this)->key);
	/* transient soap skipped */
}

int ngwe__Notify::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwe__Notify);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwe__Notify::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwe__Notify(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__Notify(struct soap *soap, const char *tag, int id, const ngwe__Notify *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__Notify), type);
	soap_out_std__string(soap, "ngwe:userid", -1, &(((ngwe__Notify*)a)->userid), "");
	soap_out_std__string(soap, "ngwe:key", -1, &(((ngwe__Notify*)a)->key), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwe__Notify::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwe__Notify(soap, this, tag, type);
}

SOAP_FMAC3 ngwe__Notify * SOAP_FMAC4 soap_get_ngwe__Notify(struct soap *soap, ngwe__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__Notify(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwe__Notify::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwe__Notify(soap, tag, this, type);
}

SOAP_FMAC3 ngwe__Notify * SOAP_FMAC4 soap_in_ngwe__Notify(struct soap *soap, const char *tag, ngwe__Notify *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwe__Notify *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__Notify, sizeof(ngwe__Notify), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwe__Notify)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwe__Notify *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_userid1 = 1, soap_flag_key1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwe:userid", &(((ngwe__Notify*)a)->userid), ""))
				{	soap_flag_userid1 = 0;
					continue;
				}
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwe:key", &(((ngwe__Notify*)a)->key), ""))
				{	soap_flag_key1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userid1 || soap_flag_key1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwe__Notify *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__Notify, 0, sizeof(ngwe__Notify), 0, soap_copy_ngwe__Notify);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwe__Notify * SOAP_FMAC6 soap_new_ngwe__Notify(struct soap *soap, int n)
{	return soap_instantiate_ngwe__Notify(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwe__Notify(struct soap *soap, ngwe__Notify *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwe__Notify * SOAP_FMAC6 soap_instantiate_ngwe__Notify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwe__Notify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwe__Notify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwe__Notify;
		if (size)
			*size = sizeof(ngwe__Notify);
		((ngwe__Notify*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwe__Notify[n];
		if (size)
			*size = n * sizeof(ngwe__Notify);
		for (int i = 0; i < n; i++)
			((ngwe__Notify*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwe__Notify*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwe__Notify(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwe__Notify %p -> %p\n", q, p));
	*(ngwe__Notify*)p = *(ngwe__Notify*)q;
}

void ngwe__EventTypeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfngwe__EventType(soap, &((ngwe__EventTypeList*)this)->event);
	/* transient soap skipped */
}

void ngwe__EventTypeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfngwe__EventType(soap, &((ngwe__EventTypeList*)this)->event);
	/* transient soap skipped */
}

int ngwe__EventTypeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwe__EventTypeList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwe__EventTypeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwe__EventTypeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__EventTypeList(struct soap *soap, const char *tag, int id, const ngwe__EventTypeList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__EventTypeList), type);
	soap_out_std__vectorTemplateOfngwe__EventType(soap, "ngwe:event", -1, &(((ngwe__EventTypeList*)a)->event), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwe__EventTypeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwe__EventTypeList(soap, this, tag, type);
}

SOAP_FMAC3 ngwe__EventTypeList * SOAP_FMAC4 soap_get_ngwe__EventTypeList(struct soap *soap, ngwe__EventTypeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__EventTypeList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwe__EventTypeList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwe__EventTypeList(soap, tag, this, type);
}

SOAP_FMAC3 ngwe__EventTypeList * SOAP_FMAC4 soap_in_ngwe__EventTypeList(struct soap *soap, const char *tag, ngwe__EventTypeList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwe__EventTypeList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__EventTypeList, sizeof(ngwe__EventTypeList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwe__EventTypeList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwe__EventTypeList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwe__EventType(soap, "ngwe:event", &(((ngwe__EventTypeList*)a)->event), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (((ngwe__EventTypeList*)a)->event.size() > 36))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwe__EventTypeList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__EventTypeList, 0, sizeof(ngwe__EventTypeList), 0, soap_copy_ngwe__EventTypeList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwe__EventTypeList * SOAP_FMAC6 soap_new_ngwe__EventTypeList(struct soap *soap, int n)
{	return soap_instantiate_ngwe__EventTypeList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwe__EventTypeList(struct soap *soap, ngwe__EventTypeList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwe__EventTypeList * SOAP_FMAC6 soap_instantiate_ngwe__EventTypeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwe__EventTypeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwe__EventTypeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwe__EventTypeList;
		if (size)
			*size = sizeof(ngwe__EventTypeList);
		((ngwe__EventTypeList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwe__EventTypeList[n];
		if (size)
			*size = n * sizeof(ngwe__EventTypeList);
		for (int i = 0; i < n; i++)
			((ngwe__EventTypeList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwe__EventTypeList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwe__EventTypeList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwe__EventTypeList %p -> %p\n", q, p));
	*(ngwe__EventTypeList*)p = *(ngwe__EventTypeList*)q;
}

void ngwe__EventsList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwe__Events(soap, &((ngwe__EventsList*)this)->event);
	/* transient soap skipped */
}

void ngwe__EventsList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwe__Events(soap, &((ngwe__EventsList*)this)->event);
	/* transient soap skipped */
}

int ngwe__EventsList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwe__EventsList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwe__EventsList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwe__EventsList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__EventsList(struct soap *soap, const char *tag, int id, const ngwe__EventsList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__EventsList), type);
	soap_out_std__vectorTemplateOfPointerTongwe__Events(soap, "ngwe:event", -1, &(((ngwe__EventsList*)a)->event), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwe__EventsList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwe__EventsList(soap, this, tag, type);
}

SOAP_FMAC3 ngwe__EventsList * SOAP_FMAC4 soap_get_ngwe__EventsList(struct soap *soap, ngwe__EventsList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__EventsList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwe__EventsList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwe__EventsList(soap, tag, this, type);
}

SOAP_FMAC3 ngwe__EventsList * SOAP_FMAC4 soap_in_ngwe__EventsList(struct soap *soap, const char *tag, ngwe__EventsList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwe__EventsList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__EventsList, sizeof(ngwe__EventsList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwe__EventsList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwe__EventsList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwe__Events(soap, "ngwe:event", &(((ngwe__EventsList*)a)->event), "ngwe:Events"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwe__EventsList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__EventsList, 0, sizeof(ngwe__EventsList), 0, soap_copy_ngwe__EventsList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwe__EventsList * SOAP_FMAC6 soap_new_ngwe__EventsList(struct soap *soap, int n)
{	return soap_instantiate_ngwe__EventsList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwe__EventsList(struct soap *soap, ngwe__EventsList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwe__EventsList * SOAP_FMAC6 soap_instantiate_ngwe__EventsList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwe__EventsList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwe__EventsList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwe__EventsList;
		if (size)
			*size = sizeof(ngwe__EventsList);
		((ngwe__EventsList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwe__EventsList[n];
		if (size)
			*size = n * sizeof(ngwe__EventsList);
		for (int i = 0; i < n; i++)
			((ngwe__EventsList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwe__EventsList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwe__EventsList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwe__EventsList %p -> %p\n", q, p));
	*(ngwe__EventsList*)p = *(ngwe__EventsList*)q;
}

void ngwe__Events::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwe__Events*)this)->key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwe__Events*)this)->key);
	soap_embedded(soap, &((ngwe__Events*)this)->persistence, SOAP_TYPE_PointerToxsd__duration);
	soap_serialize_PointerToxsd__duration(soap, &((ngwe__Events*)this)->persistence);
	soap_embedded(soap, &((ngwe__Events*)this)->ipAddress, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwe__Events*)this)->ipAddress);
	soap_embedded(soap, &((ngwe__Events*)this)->port, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwe__Events*)this)->port);
	soap_embedded(soap, &((ngwe__Events*)this)->http, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwe__Events*)this)->definition, SOAP_TYPE_PointerTongwe__EventDefinition);
	soap_serialize_PointerTongwe__EventDefinition(soap, &((ngwe__Events*)this)->definition);
	/* transient soap skipped */
}

void ngwe__Events::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwe__Events*)this)->key);
	((ngwe__Events*)this)->persistence = NULL;
	((ngwe__Events*)this)->ipAddress = NULL;
	((ngwe__Events*)this)->port = NULL;
	((ngwe__Events*)this)->http = (bool)0;
	((ngwe__Events*)this)->definition = NULL;
	((ngwe__Events*)this)->enabled = NULL;
	/* transient soap skipped */
}

int ngwe__Events::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwe__Events);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwe__Events::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwe__Events(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__Events(struct soap *soap, const char *tag, int id, const ngwe__Events *a, const char *type)
{
	if (((ngwe__Events *)a)->enabled)
		soap_set_attr(soap, "enabled", soap_bool2s(soap, *((ngwe__Events *)a)->enabled));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__Events), type);
	soap_out_std__string(soap, "ngwe:key", -1, &(((ngwe__Events*)a)->key), "");
	soap_out_PointerToxsd__duration(soap, "ngwe:persistence", -1, &(((ngwe__Events*)a)->persistence), "");
	soap_out_PointerTostd__string(soap, "ngwe:ipAddress", -1, &(((ngwe__Events*)a)->ipAddress), "");
	soap_out_PointerToint(soap, "ngwe:port", -1, &(((ngwe__Events*)a)->port), "");
	soap_out_bool(soap, "ngwe:http", -1, &(((ngwe__Events*)a)->http), "");
	soap_out_PointerTongwe__EventDefinition(soap, "ngwe:definition", -1, &(((ngwe__Events*)a)->definition), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwe__Events::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwe__Events(soap, this, tag, type);
}

SOAP_FMAC3 ngwe__Events * SOAP_FMAC4 soap_get_ngwe__Events(struct soap *soap, ngwe__Events *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__Events(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwe__Events::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwe__Events(soap, tag, this, type);
}

SOAP_FMAC3 ngwe__Events * SOAP_FMAC4 soap_in_ngwe__Events(struct soap *soap, const char *tag, ngwe__Events *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwe__Events *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__Events, sizeof(ngwe__Events), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwe__Events)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwe__Events *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "enabled", 0);
		if (t)
		{	if (!(((ngwe__Events *)a)->enabled = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ngwe__Events *)a)->enabled))
		return NULL;
		}
	}
	short soap_flag_key1 = 1, soap_flag_persistence1 = 1, soap_flag_ipAddress1 = 1, soap_flag_port1 = 1, soap_flag_http1 = 1, soap_flag_definition1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwe:key", &(((ngwe__Events*)a)->key), ""))
				{	soap_flag_key1 = 0;
					continue;
				}
			if (soap_flag_persistence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__duration(soap, "ngwe:persistence", &(((ngwe__Events*)a)->persistence), "xsd:duration"))
				{	soap_flag_persistence1 = 0;
					continue;
				}
			if (soap_flag_ipAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwe:ipAddress", &(((ngwe__Events*)a)->ipAddress), ""))
				{	soap_flag_ipAddress1 = 0;
					continue;
				}
			if (soap_flag_port1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwe:port", &(((ngwe__Events*)a)->port), ""))
				{	soap_flag_port1 = 0;
					continue;
				}
			if (soap_flag_http1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwe:http", &(((ngwe__Events*)a)->http), ""))
				{	soap_flag_http1 = 0;
					continue;
				}
			if (soap_flag_definition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwe__EventDefinition(soap, "ngwe:definition", &(((ngwe__Events*)a)->definition), "ngwe:EventDefinition"))
				{	soap_flag_definition1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwe__Events *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__Events, 0, sizeof(ngwe__Events), 0, soap_copy_ngwe__Events);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwe__Events * SOAP_FMAC6 soap_new_ngwe__Events(struct soap *soap, int n)
{	return soap_instantiate_ngwe__Events(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwe__Events(struct soap *soap, ngwe__Events *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwe__Events * SOAP_FMAC6 soap_instantiate_ngwe__Events(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwe__Events(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwe__Events, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwe__Events;
		if (size)
			*size = sizeof(ngwe__Events);
		((ngwe__Events*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwe__Events[n];
		if (size)
			*size = n * sizeof(ngwe__Events);
		for (int i = 0; i < n; i++)
			((ngwe__Events*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwe__Events*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwe__Events(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwe__Events %p -> %p\n", q, p));
	*(ngwe__Events*)p = *(ngwe__Events*)q;
}

void ngwe__EventList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwe__Event(soap, &((ngwe__EventList*)this)->event);
	/* transient soap skipped */
}

void ngwe__EventList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwe__Event(soap, &((ngwe__EventList*)this)->event);
	/* transient soap skipped */
}

int ngwe__EventList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwe__EventList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwe__EventList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwe__EventList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__EventList(struct soap *soap, const char *tag, int id, const ngwe__EventList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__EventList), type);
	soap_out_std__vectorTemplateOfPointerTongwe__Event(soap, "ngwe:event", -1, &(((ngwe__EventList*)a)->event), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwe__EventList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwe__EventList(soap, this, tag, type);
}

SOAP_FMAC3 ngwe__EventList * SOAP_FMAC4 soap_get_ngwe__EventList(struct soap *soap, ngwe__EventList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__EventList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwe__EventList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwe__EventList(soap, tag, this, type);
}

SOAP_FMAC3 ngwe__EventList * SOAP_FMAC4 soap_in_ngwe__EventList(struct soap *soap, const char *tag, ngwe__EventList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwe__EventList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__EventList, sizeof(ngwe__EventList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwe__EventList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwe__EventList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwe__Event(soap, "ngwe:event", &(((ngwe__EventList*)a)->event), "ngwe:Event"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwe__EventList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__EventList, 0, sizeof(ngwe__EventList), 0, soap_copy_ngwe__EventList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwe__EventList * SOAP_FMAC6 soap_new_ngwe__EventList(struct soap *soap, int n)
{	return soap_instantiate_ngwe__EventList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwe__EventList(struct soap *soap, ngwe__EventList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwe__EventList * SOAP_FMAC6 soap_instantiate_ngwe__EventList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwe__EventList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwe__EventList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwe__EventList;
		if (size)
			*size = sizeof(ngwe__EventList);
		((ngwe__EventList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwe__EventList[n];
		if (size)
			*size = n * sizeof(ngwe__EventList);
		for (int i = 0; i < n; i++)
			((ngwe__EventList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwe__EventList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwe__EventList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwe__EventList %p -> %p\n", q, p));
	*(ngwe__EventList*)p = *(ngwe__EventList*)q;
}

void ngwe__EventDefinition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwe__EventDefinition*)this)->events, SOAP_TYPE_PointerTongwe__EventTypeList);
	soap_serialize_PointerTongwe__EventTypeList(soap, &((ngwe__EventDefinition*)this)->events);
	soap_embedded(soap, &((ngwe__EventDefinition*)this)->type, SOAP_TYPE_PointerTongwe__ItemTypeList);
	soap_serialize_PointerTongwe__ItemTypeList(soap, &((ngwe__EventDefinition*)this)->type);
	soap_embedded(soap, &((ngwe__EventDefinition*)this)->field, SOAP_TYPE_PointerTongwe__FieldList);
	soap_serialize_PointerTongwe__FieldList(soap, &((ngwe__EventDefinition*)this)->field);
	soap_embedded(soap, &((ngwe__EventDefinition*)this)->containers, SOAP_TYPE_PointerTongwe__ContainerList);
	soap_serialize_PointerTongwe__ContainerList(soap, &((ngwe__EventDefinition*)this)->containers);
	soap_embedded(soap, &((ngwe__EventDefinition*)this)->subType, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwe__EventDefinition*)this)->subType);
	/* transient soap skipped */
}

void ngwe__EventDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwe__EventDefinition*)this)->events = NULL;
	((ngwe__EventDefinition*)this)->type = NULL;
	((ngwe__EventDefinition*)this)->field = NULL;
	((ngwe__EventDefinition*)this)->containers = NULL;
	((ngwe__EventDefinition*)this)->subType = NULL;
	/* transient soap skipped */
}

int ngwe__EventDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwe__EventDefinition);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwe__EventDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwe__EventDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__EventDefinition(struct soap *soap, const char *tag, int id, const ngwe__EventDefinition *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__EventDefinition), type);
	soap_out_PointerTongwe__EventTypeList(soap, "ngwe:events", -1, &(((ngwe__EventDefinition*)a)->events), "");
	soap_out_PointerTongwe__ItemTypeList(soap, "ngwe:type", -1, &(((ngwe__EventDefinition*)a)->type), "");
	soap_out_PointerTongwe__FieldList(soap, "ngwe:field", -1, &(((ngwe__EventDefinition*)a)->field), "");
	soap_out_PointerTongwe__ContainerList(soap, "ngwe:containers", -1, &(((ngwe__EventDefinition*)a)->containers), "");
	soap_out_PointerTostd__string(soap, "ngwe:subType", -1, &(((ngwe__EventDefinition*)a)->subType), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwe__EventDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwe__EventDefinition(soap, this, tag, type);
}

SOAP_FMAC3 ngwe__EventDefinition * SOAP_FMAC4 soap_get_ngwe__EventDefinition(struct soap *soap, ngwe__EventDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__EventDefinition(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwe__EventDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwe__EventDefinition(soap, tag, this, type);
}

SOAP_FMAC3 ngwe__EventDefinition * SOAP_FMAC4 soap_in_ngwe__EventDefinition(struct soap *soap, const char *tag, ngwe__EventDefinition *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwe__EventDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__EventDefinition, sizeof(ngwe__EventDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwe__EventDefinition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwe__EventDefinition *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_events1 = 1, soap_flag_type1 = 1, soap_flag_field1 = 1, soap_flag_containers1 = 1, soap_flag_subType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_events1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwe__EventTypeList(soap, "ngwe:events", &(((ngwe__EventDefinition*)a)->events), "ngwe:EventTypeList"))
				{	soap_flag_events1 = 0;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwe__ItemTypeList(soap, "ngwe:type", &(((ngwe__EventDefinition*)a)->type), ""))
				{	soap_flag_type1 = 0;
					continue;
				}
			if (soap_flag_field1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwe__FieldList(soap, "ngwe:field", &(((ngwe__EventDefinition*)a)->field), ""))
				{	soap_flag_field1 = 0;
					continue;
				}
			if (soap_flag_containers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwe__ContainerList(soap, "ngwe:containers", &(((ngwe__EventDefinition*)a)->containers), "ngwe:ContainerList"))
				{	soap_flag_containers1 = 0;
					continue;
				}
			if (soap_flag_subType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwe:subType", &(((ngwe__EventDefinition*)a)->subType), ""))
				{	soap_flag_subType1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_events1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwe__EventDefinition *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__EventDefinition, 0, sizeof(ngwe__EventDefinition), 0, soap_copy_ngwe__EventDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwe__EventDefinition * SOAP_FMAC6 soap_new_ngwe__EventDefinition(struct soap *soap, int n)
{	return soap_instantiate_ngwe__EventDefinition(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwe__EventDefinition(struct soap *soap, ngwe__EventDefinition *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwe__EventDefinition * SOAP_FMAC6 soap_instantiate_ngwe__EventDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwe__EventDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwe__EventDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwe__EventDefinition;
		if (size)
			*size = sizeof(ngwe__EventDefinition);
		((ngwe__EventDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwe__EventDefinition[n];
		if (size)
			*size = n * sizeof(ngwe__EventDefinition);
		for (int i = 0; i < n; i++)
			((ngwe__EventDefinition*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwe__EventDefinition*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwe__EventDefinition(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwe__EventDefinition %p -> %p\n", q, p));
	*(ngwe__EventDefinition*)p = *(ngwe__EventDefinition*)q;
}

void ngwe__Event::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwe__Event*)this)->event, SOAP_TYPE_ngwe__EventType);
	soap_embedded(soap, &((ngwe__Event*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwe__Event*)this)->id);
	soap_embedded(soap, &((ngwe__Event*)this)->timeStamp, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwe__Event*)this)->timeStamp);
	soap_embedded(soap, &((ngwe__Event*)this)->field, SOAP_TYPE_PointerTongwe__FieldList);
	soap_serialize_PointerTongwe__FieldList(soap, &((ngwe__Event*)this)->field);
	soap_embedded(soap, &((ngwe__Event*)this)->container, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwe__Event*)this)->container);
	soap_embedded(soap, &((ngwe__Event*)this)->from, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwe__Event*)this)->from);
	soap_embedded(soap, &((ngwe__Event*)this)->key, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwe__Event*)this)->key);
	soap_embedded(soap, &((ngwe__Event*)this)->uid, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwe__Event*)this)->uid);
	soap_embedded(soap, &((ngwe__Event*)this)->type, SOAP_TYPE_PointerTongwe__ItemType);
	soap_serialize_PointerTongwe__ItemType(soap, &((ngwe__Event*)this)->type);
	/* transient soap skipped */
}

void ngwe__Event::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwe__EventType(soap, &((ngwe__Event*)this)->event);
	((ngwe__Event*)this)->id = NULL;
	soap_default_string(soap, &((ngwe__Event*)this)->timeStamp);
	((ngwe__Event*)this)->field = NULL;
	((ngwe__Event*)this)->container = NULL;
	((ngwe__Event*)this)->from = NULL;
	((ngwe__Event*)this)->key = NULL;
	((ngwe__Event*)this)->uid = NULL;
	((ngwe__Event*)this)->type = NULL;
	/* transient soap skipped */
}

int ngwe__Event::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwe__Event);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwe__Event::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwe__Event(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__Event(struct soap *soap, const char *tag, int id, const ngwe__Event *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__Event), type);
	soap_out_ngwe__EventType(soap, "ngwe:event", -1, &(((ngwe__Event*)a)->event), "");
	soap_out_PointerTongwt__uid(soap, "ngwe:id", -1, &(((ngwe__Event*)a)->id), "");
	soap_out_string(soap, "ngwe:timeStamp", -1, &(((ngwe__Event*)a)->timeStamp), "");
	soap_out_PointerTongwe__FieldList(soap, "ngwe:field", -1, &(((ngwe__Event*)a)->field), "");
	soap_out_PointerTongwt__uid(soap, "ngwe:container", -1, &(((ngwe__Event*)a)->container), "");
	soap_out_PointerTongwt__uid(soap, "ngwe:from", -1, &(((ngwe__Event*)a)->from), "");
	soap_out_PointerTostd__string(soap, "ngwe:key", -1, &(((ngwe__Event*)a)->key), "");
	soap_out_PointerTounsignedLong(soap, "ngwe:uid", -1, &(((ngwe__Event*)a)->uid), "");
	soap_out_PointerTongwe__ItemType(soap, "ngwe:type", -1, &(((ngwe__Event*)a)->type), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwe__Event::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwe__Event(soap, this, tag, type);
}

SOAP_FMAC3 ngwe__Event * SOAP_FMAC4 soap_get_ngwe__Event(struct soap *soap, ngwe__Event *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__Event(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwe__Event::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwe__Event(soap, tag, this, type);
}

SOAP_FMAC3 ngwe__Event * SOAP_FMAC4 soap_in_ngwe__Event(struct soap *soap, const char *tag, ngwe__Event *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwe__Event *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__Event, sizeof(ngwe__Event), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwe__Event)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwe__Event *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_event1 = 1, soap_flag_id1 = 1, soap_flag_timeStamp1 = 1, soap_flag_field1 = 1, soap_flag_container1 = 1, soap_flag_from1 = 1, soap_flag_key1 = 1, soap_flag_uid1 = 1, soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_event1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwe__EventType(soap, "ngwe:event", &(((ngwe__Event*)a)->event), ""))
				{	soap_flag_event1 = 0;
					continue;
				}
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwe:id", &(((ngwe__Event*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_timeStamp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwe:timeStamp", &(((ngwe__Event*)a)->timeStamp), ""))
				{	soap_flag_timeStamp1 = 0;
					continue;
				}
			if (soap_flag_field1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwe__FieldList(soap, "ngwe:field", &(((ngwe__Event*)a)->field), ""))
				{	soap_flag_field1 = 0;
					continue;
				}
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwe:container", &(((ngwe__Event*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_from1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwe:from", &(((ngwe__Event*)a)->from), "ngwt:uid"))
				{	soap_flag_from1 = 0;
					continue;
				}
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwe:key", &(((ngwe__Event*)a)->key), ""))
				{	soap_flag_key1 = 0;
					continue;
				}
			if (soap_flag_uid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwe:uid", &(((ngwe__Event*)a)->uid), ""))
				{	soap_flag_uid1 = 0;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwe__ItemType(soap, "ngwe:type", &(((ngwe__Event*)a)->type), ""))
				{	soap_flag_type1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_event1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwe__Event *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__Event, 0, sizeof(ngwe__Event), 0, soap_copy_ngwe__Event);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwe__Event * SOAP_FMAC6 soap_new_ngwe__Event(struct soap *soap, int n)
{	return soap_instantiate_ngwe__Event(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwe__Event(struct soap *soap, ngwe__Event *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwe__Event * SOAP_FMAC6 soap_instantiate_ngwe__Event(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwe__Event(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwe__Event, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwe__Event;
		if (size)
			*size = sizeof(ngwe__Event);
		((ngwe__Event*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwe__Event[n];
		if (size)
			*size = n * sizeof(ngwe__Event);
		for (int i = 0; i < n; i++)
			((ngwe__Event*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwe__Event*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwe__Event(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwe__Event %p -> %p\n", q, p));
	*(ngwe__Event*)p = *(ngwe__Event*)q;
}

void ngwe__ContainerList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfngwt__uid(soap, &((ngwe__ContainerList*)this)->container);
	/* transient soap skipped */
}

void ngwe__ContainerList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfngwt__uid(soap, &((ngwe__ContainerList*)this)->container);
	((ngwe__ContainerList*)this)->not_ = NULL;
	/* transient soap skipped */
}

int ngwe__ContainerList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwe__ContainerList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwe__ContainerList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwe__ContainerList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwe__ContainerList(struct soap *soap, const char *tag, int id, const ngwe__ContainerList *a, const char *type)
{
	if (((ngwe__ContainerList *)a)->not_)
		soap_set_attr(soap, "not", soap_bool2s(soap, *((ngwe__ContainerList *)a)->not_));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwe__ContainerList), type);
	soap_out_std__vectorTemplateOfngwt__uid(soap, "ngwe:container", -1, &(((ngwe__ContainerList*)a)->container), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwe__ContainerList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwe__ContainerList(soap, this, tag, type);
}

SOAP_FMAC3 ngwe__ContainerList * SOAP_FMAC4 soap_get_ngwe__ContainerList(struct soap *soap, ngwe__ContainerList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwe__ContainerList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwe__ContainerList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwe__ContainerList(soap, tag, this, type);
}

SOAP_FMAC3 ngwe__ContainerList * SOAP_FMAC4 soap_in_ngwe__ContainerList(struct soap *soap, const char *tag, ngwe__ContainerList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwe__ContainerList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwe__ContainerList, sizeof(ngwe__ContainerList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwe__ContainerList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwe__ContainerList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "not", 0);
		if (t)
		{	if (!(((ngwe__ContainerList *)a)->not_ = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ngwe__ContainerList *)a)->not_))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__uid(soap, "ngwe:container", &(((ngwe__ContainerList*)a)->container), "ngwt:uid"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwe__ContainerList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__ContainerList, 0, sizeof(ngwe__ContainerList), 0, soap_copy_ngwe__ContainerList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwe__ContainerList * SOAP_FMAC6 soap_new_ngwe__ContainerList(struct soap *soap, int n)
{	return soap_instantiate_ngwe__ContainerList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwe__ContainerList(struct soap *soap, ngwe__ContainerList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwe__ContainerList * SOAP_FMAC6 soap_instantiate_ngwe__ContainerList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwe__ContainerList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwe__ContainerList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwe__ContainerList;
		if (size)
			*size = sizeof(ngwe__ContainerList);
		((ngwe__ContainerList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwe__ContainerList[n];
		if (size)
			*size = n * sizeof(ngwe__ContainerList);
		for (int i = 0; i < n; i++)
			((ngwe__ContainerList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwe__ContainerList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwe__ContainerList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwe__ContainerList %p -> %p\n", q, p));
	*(ngwe__ContainerList*)p = *(ngwe__ContainerList*)q;
}

void _ngwm__updateVersionStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__updateVersionStatusResponse*)this)->part, SOAP_TYPE_PointerTongwt__SignatureData);
	soap_serialize_PointerTongwt__SignatureData(soap, &((_ngwm__updateVersionStatusResponse*)this)->part);
	soap_embedded(soap, &((_ngwm__updateVersionStatusResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__updateVersionStatusResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__updateVersionStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__updateVersionStatusResponse*)this)->part = NULL;
	((_ngwm__updateVersionStatusResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__updateVersionStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__updateVersionStatusResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__updateVersionStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__updateVersionStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__updateVersionStatusResponse(struct soap *soap, const char *tag, int id, const _ngwm__updateVersionStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__updateVersionStatusResponse), type);
	soap_out_PointerTongwt__SignatureData(soap, "ngwm:part", -1, &(((_ngwm__updateVersionStatusResponse*)a)->part), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__updateVersionStatusResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__updateVersionStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__updateVersionStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__updateVersionStatusResponse * SOAP_FMAC4 soap_get__ngwm__updateVersionStatusResponse(struct soap *soap, _ngwm__updateVersionStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__updateVersionStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__updateVersionStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__updateVersionStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__updateVersionStatusResponse * SOAP_FMAC4 soap_in__ngwm__updateVersionStatusResponse(struct soap *soap, const char *tag, _ngwm__updateVersionStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__updateVersionStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__updateVersionStatusResponse, sizeof(_ngwm__updateVersionStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__updateVersionStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__updateVersionStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_part1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_part1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SignatureData(soap, "ngwm:part", &(((_ngwm__updateVersionStatusResponse*)a)->part), "ngwt:SignatureData"))
				{	soap_flag_part1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__updateVersionStatusResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__updateVersionStatusResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__updateVersionStatusResponse, 0, sizeof(_ngwm__updateVersionStatusResponse), 0, soap_copy__ngwm__updateVersionStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__updateVersionStatusResponse * SOAP_FMAC6 soap_new__ngwm__updateVersionStatusResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__updateVersionStatusResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__updateVersionStatusResponse(struct soap *soap, _ngwm__updateVersionStatusResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__updateVersionStatusResponse * SOAP_FMAC6 soap_instantiate__ngwm__updateVersionStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__updateVersionStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__updateVersionStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__updateVersionStatusResponse;
		if (size)
			*size = sizeof(_ngwm__updateVersionStatusResponse);
		((_ngwm__updateVersionStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__updateVersionStatusResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__updateVersionStatusResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__updateVersionStatusResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__updateVersionStatusResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__updateVersionStatusResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__updateVersionStatusResponse %p -> %p\n", q, p));
	*(_ngwm__updateVersionStatusResponse*)p = *(_ngwm__updateVersionStatusResponse*)q;
}

void _ngwm__updateVersionStatusRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__updateVersionStatusRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__updateVersionStatusRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__updateVersionStatusRequest*)this)->event, SOAP_TYPE_ngwt__VersionEventType);
	soap_embedded(soap, &((_ngwm__updateVersionStatusRequest*)this)->part, SOAP_TYPE_PointerTongwt__SignatureData);
	soap_serialize_PointerTongwt__SignatureData(soap, &((_ngwm__updateVersionStatusRequest*)this)->part);
	/* transient soap skipped */
}

void _ngwm__updateVersionStatusRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__updateVersionStatusRequest*)this)->id);
	soap_default_ngwt__VersionEventType(soap, &((_ngwm__updateVersionStatusRequest*)this)->event);
	((_ngwm__updateVersionStatusRequest*)this)->part = NULL;
	/* transient soap skipped */
}

int _ngwm__updateVersionStatusRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__updateVersionStatusRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__updateVersionStatusRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__updateVersionStatusRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__updateVersionStatusRequest(struct soap *soap, const char *tag, int id, const _ngwm__updateVersionStatusRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__updateVersionStatusRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__updateVersionStatusRequest*)a)->id), "");
	soap_out_ngwt__VersionEventType(soap, "ngwm:event", -1, &(((_ngwm__updateVersionStatusRequest*)a)->event), "");
	soap_out_PointerTongwt__SignatureData(soap, "ngwm:part", -1, &(((_ngwm__updateVersionStatusRequest*)a)->part), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__updateVersionStatusRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__updateVersionStatusRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__updateVersionStatusRequest * SOAP_FMAC4 soap_get__ngwm__updateVersionStatusRequest(struct soap *soap, _ngwm__updateVersionStatusRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__updateVersionStatusRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__updateVersionStatusRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__updateVersionStatusRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__updateVersionStatusRequest * SOAP_FMAC4 soap_in__ngwm__updateVersionStatusRequest(struct soap *soap, const char *tag, _ngwm__updateVersionStatusRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__updateVersionStatusRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__updateVersionStatusRequest, sizeof(_ngwm__updateVersionStatusRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__updateVersionStatusRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__updateVersionStatusRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_event1 = 1, soap_flag_part1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__updateVersionStatusRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_event1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__VersionEventType(soap, "ngwm:event", &(((_ngwm__updateVersionStatusRequest*)a)->event), ""))
				{	soap_flag_event1 = 0;
					continue;
				}
			if (soap_flag_part1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SignatureData(soap, "ngwm:part", &(((_ngwm__updateVersionStatusRequest*)a)->part), "ngwt:SignatureData"))
				{	soap_flag_part1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_event1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__updateVersionStatusRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__updateVersionStatusRequest, 0, sizeof(_ngwm__updateVersionStatusRequest), 0, soap_copy__ngwm__updateVersionStatusRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__updateVersionStatusRequest * SOAP_FMAC6 soap_new__ngwm__updateVersionStatusRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__updateVersionStatusRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__updateVersionStatusRequest(struct soap *soap, _ngwm__updateVersionStatusRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__updateVersionStatusRequest * SOAP_FMAC6 soap_instantiate__ngwm__updateVersionStatusRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__updateVersionStatusRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__updateVersionStatusRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__updateVersionStatusRequest;
		if (size)
			*size = sizeof(_ngwm__updateVersionStatusRequest);
		((_ngwm__updateVersionStatusRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__updateVersionStatusRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__updateVersionStatusRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__updateVersionStatusRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__updateVersionStatusRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__updateVersionStatusRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__updateVersionStatusRequest %p -> %p\n", q, p));
	*(_ngwm__updateVersionStatusRequest*)p = *(_ngwm__updateVersionStatusRequest*)q;
}

void _ngwm__uncompleteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__uncompleteResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__uncompleteResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__uncompleteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__uncompleteResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__uncompleteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__uncompleteResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__uncompleteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__uncompleteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__uncompleteResponse(struct soap *soap, const char *tag, int id, const _ngwm__uncompleteResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__uncompleteResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__uncompleteResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__uncompleteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__uncompleteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__uncompleteResponse * SOAP_FMAC4 soap_get__ngwm__uncompleteResponse(struct soap *soap, _ngwm__uncompleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__uncompleteResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__uncompleteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__uncompleteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__uncompleteResponse * SOAP_FMAC4 soap_in__ngwm__uncompleteResponse(struct soap *soap, const char *tag, _ngwm__uncompleteResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__uncompleteResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__uncompleteResponse, sizeof(_ngwm__uncompleteResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__uncompleteResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__uncompleteResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__uncompleteResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__uncompleteResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__uncompleteResponse, 0, sizeof(_ngwm__uncompleteResponse), 0, soap_copy__ngwm__uncompleteResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__uncompleteResponse * SOAP_FMAC6 soap_new__ngwm__uncompleteResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__uncompleteResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__uncompleteResponse(struct soap *soap, _ngwm__uncompleteResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__uncompleteResponse * SOAP_FMAC6 soap_instantiate__ngwm__uncompleteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__uncompleteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__uncompleteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__uncompleteResponse;
		if (size)
			*size = sizeof(_ngwm__uncompleteResponse);
		((_ngwm__uncompleteResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__uncompleteResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__uncompleteResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__uncompleteResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__uncompleteResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__uncompleteResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__uncompleteResponse %p -> %p\n", q, p));
	*(_ngwm__uncompleteResponse*)p = *(_ngwm__uncompleteResponse*)q;
}

void _ngwm__uncompleteRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__uncompleteRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__uncompleteRequest*)this)->items);
	/* transient soap skipped */
}

void _ngwm__uncompleteRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__uncompleteRequest*)this)->items = NULL;
	/* transient soap skipped */
}

int _ngwm__uncompleteRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__uncompleteRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__uncompleteRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__uncompleteRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__uncompleteRequest(struct soap *soap, const char *tag, int id, const _ngwm__uncompleteRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__uncompleteRequest), type);
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__uncompleteRequest*)a)->items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__uncompleteRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__uncompleteRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__uncompleteRequest * SOAP_FMAC4 soap_get__ngwm__uncompleteRequest(struct soap *soap, _ngwm__uncompleteRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__uncompleteRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__uncompleteRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__uncompleteRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__uncompleteRequest * SOAP_FMAC4 soap_in__ngwm__uncompleteRequest(struct soap *soap, const char *tag, _ngwm__uncompleteRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__uncompleteRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__uncompleteRequest, sizeof(_ngwm__uncompleteRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__uncompleteRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__uncompleteRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__uncompleteRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__uncompleteRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__uncompleteRequest, 0, sizeof(_ngwm__uncompleteRequest), 0, soap_copy__ngwm__uncompleteRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__uncompleteRequest * SOAP_FMAC6 soap_new__ngwm__uncompleteRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__uncompleteRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__uncompleteRequest(struct soap *soap, _ngwm__uncompleteRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__uncompleteRequest * SOAP_FMAC6 soap_instantiate__ngwm__uncompleteRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__uncompleteRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__uncompleteRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__uncompleteRequest;
		if (size)
			*size = sizeof(_ngwm__uncompleteRequest);
		((_ngwm__uncompleteRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__uncompleteRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__uncompleteRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__uncompleteRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__uncompleteRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__uncompleteRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__uncompleteRequest %p -> %p\n", q, p));
	*(_ngwm__uncompleteRequest*)p = *(_ngwm__uncompleteRequest*)q;
}

void _ngwm__unacceptResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__unacceptResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__unacceptResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__unacceptResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__unacceptResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__unacceptResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__unacceptResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__unacceptResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__unacceptResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__unacceptResponse(struct soap *soap, const char *tag, int id, const _ngwm__unacceptResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__unacceptResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__unacceptResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__unacceptResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__unacceptResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__unacceptResponse * SOAP_FMAC4 soap_get__ngwm__unacceptResponse(struct soap *soap, _ngwm__unacceptResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__unacceptResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__unacceptResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__unacceptResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__unacceptResponse * SOAP_FMAC4 soap_in__ngwm__unacceptResponse(struct soap *soap, const char *tag, _ngwm__unacceptResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__unacceptResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__unacceptResponse, sizeof(_ngwm__unacceptResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__unacceptResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__unacceptResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__unacceptResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__unacceptResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__unacceptResponse, 0, sizeof(_ngwm__unacceptResponse), 0, soap_copy__ngwm__unacceptResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__unacceptResponse * SOAP_FMAC6 soap_new__ngwm__unacceptResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__unacceptResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__unacceptResponse(struct soap *soap, _ngwm__unacceptResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__unacceptResponse * SOAP_FMAC6 soap_instantiate__ngwm__unacceptResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__unacceptResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__unacceptResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__unacceptResponse;
		if (size)
			*size = sizeof(_ngwm__unacceptResponse);
		((_ngwm__unacceptResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__unacceptResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__unacceptResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__unacceptResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__unacceptResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__unacceptResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__unacceptResponse %p -> %p\n", q, p));
	*(_ngwm__unacceptResponse*)p = *(_ngwm__unacceptResponse*)q;
}

void _ngwm__unacceptRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__unacceptRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__unacceptRequest*)this)->items);
	/* transient soap skipped */
}

void _ngwm__unacceptRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__unacceptRequest*)this)->items = NULL;
	/* transient soap skipped */
}

int _ngwm__unacceptRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__unacceptRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__unacceptRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__unacceptRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__unacceptRequest(struct soap *soap, const char *tag, int id, const _ngwm__unacceptRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__unacceptRequest), type);
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__unacceptRequest*)a)->items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__unacceptRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__unacceptRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__unacceptRequest * SOAP_FMAC4 soap_get__ngwm__unacceptRequest(struct soap *soap, _ngwm__unacceptRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__unacceptRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__unacceptRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__unacceptRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__unacceptRequest * SOAP_FMAC4 soap_in__ngwm__unacceptRequest(struct soap *soap, const char *tag, _ngwm__unacceptRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__unacceptRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__unacceptRequest, sizeof(_ngwm__unacceptRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__unacceptRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__unacceptRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__unacceptRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__unacceptRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__unacceptRequest, 0, sizeof(_ngwm__unacceptRequest), 0, soap_copy__ngwm__unacceptRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__unacceptRequest * SOAP_FMAC6 soap_new__ngwm__unacceptRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__unacceptRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__unacceptRequest(struct soap *soap, _ngwm__unacceptRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__unacceptRequest * SOAP_FMAC6 soap_instantiate__ngwm__unacceptRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__unacceptRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__unacceptRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__unacceptRequest;
		if (size)
			*size = sizeof(_ngwm__unacceptRequest);
		((_ngwm__unacceptRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__unacceptRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__unacceptRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__unacceptRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__unacceptRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__unacceptRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__unacceptRequest %p -> %p\n", q, p));
	*(_ngwm__unacceptRequest*)p = *(_ngwm__unacceptRequest*)q;
}

void _ngwm__startFreeBusySessionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__startFreeBusySessionResponse*)this)->freeBusySessionId, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((_ngwm__startFreeBusySessionResponse*)this)->freeBusySessionId);
	soap_embedded(soap, &((_ngwm__startFreeBusySessionResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__startFreeBusySessionResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__startFreeBusySessionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__startFreeBusySessionResponse*)this)->freeBusySessionId = NULL;
	((_ngwm__startFreeBusySessionResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__startFreeBusySessionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__startFreeBusySessionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__startFreeBusySessionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__startFreeBusySessionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__startFreeBusySessionResponse(struct soap *soap, const char *tag, int id, const _ngwm__startFreeBusySessionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__startFreeBusySessionResponse), type);
	soap_out_PointerToint(soap, "ngwm:freeBusySessionId", -1, &(((_ngwm__startFreeBusySessionResponse*)a)->freeBusySessionId), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__startFreeBusySessionResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__startFreeBusySessionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__startFreeBusySessionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__startFreeBusySessionResponse * SOAP_FMAC4 soap_get__ngwm__startFreeBusySessionResponse(struct soap *soap, _ngwm__startFreeBusySessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__startFreeBusySessionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__startFreeBusySessionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__startFreeBusySessionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__startFreeBusySessionResponse * SOAP_FMAC4 soap_in__ngwm__startFreeBusySessionResponse(struct soap *soap, const char *tag, _ngwm__startFreeBusySessionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__startFreeBusySessionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__startFreeBusySessionResponse, sizeof(_ngwm__startFreeBusySessionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__startFreeBusySessionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__startFreeBusySessionResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_freeBusySessionId1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_freeBusySessionId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwm:freeBusySessionId", &(((_ngwm__startFreeBusySessionResponse*)a)->freeBusySessionId), ""))
				{	soap_flag_freeBusySessionId1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__startFreeBusySessionResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__startFreeBusySessionResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__startFreeBusySessionResponse, 0, sizeof(_ngwm__startFreeBusySessionResponse), 0, soap_copy__ngwm__startFreeBusySessionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__startFreeBusySessionResponse * SOAP_FMAC6 soap_new__ngwm__startFreeBusySessionResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__startFreeBusySessionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__startFreeBusySessionResponse(struct soap *soap, _ngwm__startFreeBusySessionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__startFreeBusySessionResponse * SOAP_FMAC6 soap_instantiate__ngwm__startFreeBusySessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__startFreeBusySessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__startFreeBusySessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__startFreeBusySessionResponse;
		if (size)
			*size = sizeof(_ngwm__startFreeBusySessionResponse);
		((_ngwm__startFreeBusySessionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__startFreeBusySessionResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__startFreeBusySessionResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__startFreeBusySessionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__startFreeBusySessionResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__startFreeBusySessionResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__startFreeBusySessionResponse %p -> %p\n", q, p));
	*(_ngwm__startFreeBusySessionResponse*)p = *(_ngwm__startFreeBusySessionResponse*)q;
}

void _ngwm__startFreeBusySessionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__startFreeBusySessionRequest*)this)->users, SOAP_TYPE_PointerTongwt__FreeBusyUserList);
	soap_serialize_PointerTongwt__FreeBusyUserList(soap, &((_ngwm__startFreeBusySessionRequest*)this)->users);
	soap_embedded(soap, &((_ngwm__startFreeBusySessionRequest*)this)->startDate, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwm__startFreeBusySessionRequest*)this)->startDate);
	soap_embedded(soap, &((_ngwm__startFreeBusySessionRequest*)this)->endDate, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwm__startFreeBusySessionRequest*)this)->endDate);
	/* transient soap skipped */
}

void _ngwm__startFreeBusySessionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__startFreeBusySessionRequest*)this)->users = NULL;
	soap_default_string(soap, &((_ngwm__startFreeBusySessionRequest*)this)->startDate);
	soap_default_string(soap, &((_ngwm__startFreeBusySessionRequest*)this)->endDate);
	/* transient soap skipped */
}

int _ngwm__startFreeBusySessionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__startFreeBusySessionRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__startFreeBusySessionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__startFreeBusySessionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__startFreeBusySessionRequest(struct soap *soap, const char *tag, int id, const _ngwm__startFreeBusySessionRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__startFreeBusySessionRequest), type);
	soap_out_PointerTongwt__FreeBusyUserList(soap, "ngwm:users", -1, &(((_ngwm__startFreeBusySessionRequest*)a)->users), "");
	soap_out_string(soap, "ngwm:startDate", -1, &(((_ngwm__startFreeBusySessionRequest*)a)->startDate), "");
	soap_out_string(soap, "ngwm:endDate", -1, &(((_ngwm__startFreeBusySessionRequest*)a)->endDate), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__startFreeBusySessionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__startFreeBusySessionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__startFreeBusySessionRequest * SOAP_FMAC4 soap_get__ngwm__startFreeBusySessionRequest(struct soap *soap, _ngwm__startFreeBusySessionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__startFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__startFreeBusySessionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__startFreeBusySessionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__startFreeBusySessionRequest * SOAP_FMAC4 soap_in__ngwm__startFreeBusySessionRequest(struct soap *soap, const char *tag, _ngwm__startFreeBusySessionRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__startFreeBusySessionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__startFreeBusySessionRequest, sizeof(_ngwm__startFreeBusySessionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__startFreeBusySessionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__startFreeBusySessionRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_users1 = 1, soap_flag_startDate1 = 1, soap_flag_endDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_users1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FreeBusyUserList(soap, "ngwm:users", &(((_ngwm__startFreeBusySessionRequest*)a)->users), "ngwt:FreeBusyUserList"))
				{	soap_flag_users1 = 0;
					continue;
				}
			if (soap_flag_startDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwm:startDate", &(((_ngwm__startFreeBusySessionRequest*)a)->startDate), ""))
				{	soap_flag_startDate1 = 0;
					continue;
				}
			if (soap_flag_endDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwm:endDate", &(((_ngwm__startFreeBusySessionRequest*)a)->endDate), ""))
				{	soap_flag_endDate1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_users1 || soap_flag_startDate1 || soap_flag_endDate1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__startFreeBusySessionRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__startFreeBusySessionRequest, 0, sizeof(_ngwm__startFreeBusySessionRequest), 0, soap_copy__ngwm__startFreeBusySessionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__startFreeBusySessionRequest * SOAP_FMAC6 soap_new__ngwm__startFreeBusySessionRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__startFreeBusySessionRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__startFreeBusySessionRequest(struct soap *soap, _ngwm__startFreeBusySessionRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__startFreeBusySessionRequest * SOAP_FMAC6 soap_instantiate__ngwm__startFreeBusySessionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__startFreeBusySessionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__startFreeBusySessionRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__startFreeBusySessionRequest;
		if (size)
			*size = sizeof(_ngwm__startFreeBusySessionRequest);
		((_ngwm__startFreeBusySessionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__startFreeBusySessionRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__startFreeBusySessionRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__startFreeBusySessionRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__startFreeBusySessionRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__startFreeBusySessionRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__startFreeBusySessionRequest %p -> %p\n", q, p));
	*(_ngwm__startFreeBusySessionRequest*)p = *(_ngwm__startFreeBusySessionRequest*)q;
}

void _ngwm__setTimestampResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__setTimestampResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__setTimestampResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__setTimestampResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__setTimestampResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__setTimestampResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__setTimestampResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__setTimestampResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__setTimestampResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__setTimestampResponse(struct soap *soap, const char *tag, int id, const _ngwm__setTimestampResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__setTimestampResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__setTimestampResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__setTimestampResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__setTimestampResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__setTimestampResponse * SOAP_FMAC4 soap_get__ngwm__setTimestampResponse(struct soap *soap, _ngwm__setTimestampResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__setTimestampResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__setTimestampResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__setTimestampResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__setTimestampResponse * SOAP_FMAC4 soap_in__ngwm__setTimestampResponse(struct soap *soap, const char *tag, _ngwm__setTimestampResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__setTimestampResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__setTimestampResponse, sizeof(_ngwm__setTimestampResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__setTimestampResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__setTimestampResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__setTimestampResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__setTimestampResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__setTimestampResponse, 0, sizeof(_ngwm__setTimestampResponse), 0, soap_copy__ngwm__setTimestampResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__setTimestampResponse * SOAP_FMAC6 soap_new__ngwm__setTimestampResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__setTimestampResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__setTimestampResponse(struct soap *soap, _ngwm__setTimestampResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__setTimestampResponse * SOAP_FMAC6 soap_instantiate__ngwm__setTimestampResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__setTimestampResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__setTimestampResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__setTimestampResponse;
		if (size)
			*size = sizeof(_ngwm__setTimestampResponse);
		((_ngwm__setTimestampResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__setTimestampResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__setTimestampResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__setTimestampResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__setTimestampResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__setTimestampResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__setTimestampResponse %p -> %p\n", q, p));
	*(_ngwm__setTimestampResponse*)p = *(_ngwm__setTimestampResponse*)q;
}

void _ngwm__setTimestampRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__setTimestampRequest*)this)->backup, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwm__setTimestampRequest*)this)->backup);
	soap_embedded(soap, &((_ngwm__setTimestampRequest*)this)->retention, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwm__setTimestampRequest*)this)->retention);
	/* transient soap skipped */
}

void _ngwm__setTimestampRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((_ngwm__setTimestampRequest*)this)->backup);
	soap_default_string(soap, &((_ngwm__setTimestampRequest*)this)->retention);
	/* transient soap skipped */
}

int _ngwm__setTimestampRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__setTimestampRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__setTimestampRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__setTimestampRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__setTimestampRequest(struct soap *soap, const char *tag, int id, const _ngwm__setTimestampRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__setTimestampRequest), type);
	soap_out_string(soap, "ngwm:backup", -1, &(((_ngwm__setTimestampRequest*)a)->backup), "");
	soap_out_string(soap, "ngwm:retention", -1, &(((_ngwm__setTimestampRequest*)a)->retention), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__setTimestampRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__setTimestampRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__setTimestampRequest * SOAP_FMAC4 soap_get__ngwm__setTimestampRequest(struct soap *soap, _ngwm__setTimestampRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__setTimestampRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__setTimestampRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__setTimestampRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__setTimestampRequest * SOAP_FMAC4 soap_in__ngwm__setTimestampRequest(struct soap *soap, const char *tag, _ngwm__setTimestampRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__setTimestampRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__setTimestampRequest, sizeof(_ngwm__setTimestampRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__setTimestampRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__setTimestampRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_backup1 = 1, soap_flag_retention1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_backup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwm:backup", &(((_ngwm__setTimestampRequest*)a)->backup), ""))
				{	soap_flag_backup1 = 0;
					continue;
				}
			if (soap_flag_retention1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwm:retention", &(((_ngwm__setTimestampRequest*)a)->retention), ""))
				{	soap_flag_retention1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__setTimestampRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__setTimestampRequest, 0, sizeof(_ngwm__setTimestampRequest), 0, soap_copy__ngwm__setTimestampRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__setTimestampRequest * SOAP_FMAC6 soap_new__ngwm__setTimestampRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__setTimestampRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__setTimestampRequest(struct soap *soap, _ngwm__setTimestampRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__setTimestampRequest * SOAP_FMAC6 soap_instantiate__ngwm__setTimestampRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__setTimestampRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__setTimestampRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__setTimestampRequest;
		if (size)
			*size = sizeof(_ngwm__setTimestampRequest);
		((_ngwm__setTimestampRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__setTimestampRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__setTimestampRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__setTimestampRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__setTimestampRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__setTimestampRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__setTimestampRequest %p -> %p\n", q, p));
	*(_ngwm__setTimestampRequest*)p = *(_ngwm__setTimestampRequest*)q;
}

void _ngwm__sendItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfngwt__uid(soap, &((_ngwm__sendItemResponse*)this)->id);
	soap_embedded(soap, &((_ngwm__sendItemResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__sendItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__sendItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfngwt__uid(soap, &((_ngwm__sendItemResponse*)this)->id);
	((_ngwm__sendItemResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__sendItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__sendItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__sendItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__sendItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__sendItemResponse(struct soap *soap, const char *tag, int id, const _ngwm__sendItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__sendItemResponse), type);
	soap_out_std__vectorTemplateOfngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__sendItemResponse*)a)->id), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__sendItemResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__sendItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__sendItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__sendItemResponse * SOAP_FMAC4 soap_get__ngwm__sendItemResponse(struct soap *soap, _ngwm__sendItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__sendItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__sendItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__sendItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__sendItemResponse * SOAP_FMAC4 soap_in__ngwm__sendItemResponse(struct soap *soap, const char *tag, _ngwm__sendItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__sendItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__sendItemResponse, sizeof(_ngwm__sendItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__sendItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__sendItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__uid(soap, "ngwm:id", &(((_ngwm__sendItemResponse*)a)->id), "ngwt:uid"))
					continue;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__sendItemResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__sendItemResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__sendItemResponse, 0, sizeof(_ngwm__sendItemResponse), 0, soap_copy__ngwm__sendItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__sendItemResponse * SOAP_FMAC6 soap_new__ngwm__sendItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__sendItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__sendItemResponse(struct soap *soap, _ngwm__sendItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__sendItemResponse * SOAP_FMAC6 soap_instantiate__ngwm__sendItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__sendItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__sendItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__sendItemResponse;
		if (size)
			*size = sizeof(_ngwm__sendItemResponse);
		((_ngwm__sendItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__sendItemResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__sendItemResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__sendItemResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__sendItemResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__sendItemResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__sendItemResponse %p -> %p\n", q, p));
	*(_ngwm__sendItemResponse*)p = *(_ngwm__sendItemResponse*)q;
}

void _ngwm__sendItemRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__sendItemRequest*)this)->item, SOAP_TYPE_PointerTongwt__Item);
	soap_serialize_PointerTongwt__Item(soap, &((_ngwm__sendItemRequest*)this)->item);
	/* transient soap skipped */
}

void _ngwm__sendItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__sendItemRequest*)this)->item = NULL;
	/* transient soap skipped */
}

int _ngwm__sendItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__sendItemRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__sendItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__sendItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__sendItemRequest(struct soap *soap, const char *tag, int id, const _ngwm__sendItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__sendItemRequest), type);
	soap_out_PointerTongwt__Item(soap, "ngwm:item", -1, &(((_ngwm__sendItemRequest*)a)->item), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__sendItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__sendItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__sendItemRequest * SOAP_FMAC4 soap_get__ngwm__sendItemRequest(struct soap *soap, _ngwm__sendItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__sendItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__sendItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__sendItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__sendItemRequest * SOAP_FMAC4 soap_in__ngwm__sendItemRequest(struct soap *soap, const char *tag, _ngwm__sendItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__sendItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__sendItemRequest, sizeof(_ngwm__sendItemRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__sendItemRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__sendItemRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_item1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Item(soap, "ngwm:item", &(((_ngwm__sendItemRequest*)a)->item), "ngwt:Item"))
				{	soap_flag_item1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_item1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__sendItemRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__sendItemRequest, 0, sizeof(_ngwm__sendItemRequest), 0, soap_copy__ngwm__sendItemRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__sendItemRequest * SOAP_FMAC6 soap_new__ngwm__sendItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__sendItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__sendItemRequest(struct soap *soap, _ngwm__sendItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__sendItemRequest * SOAP_FMAC6 soap_instantiate__ngwm__sendItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__sendItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__sendItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__sendItemRequest;
		if (size)
			*size = sizeof(_ngwm__sendItemRequest);
		((_ngwm__sendItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__sendItemRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__sendItemRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__sendItemRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__sendItemRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__sendItemRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__sendItemRequest %p -> %p\n", q, p));
	*(_ngwm__sendItemRequest*)p = *(_ngwm__sendItemRequest*)q;
}

void _ngwm__retractResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__retractResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__retractResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__retractResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__retractResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__retractResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__retractResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__retractResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__retractResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__retractResponse(struct soap *soap, const char *tag, int id, const _ngwm__retractResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__retractResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__retractResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__retractResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__retractResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__retractResponse * SOAP_FMAC4 soap_get__ngwm__retractResponse(struct soap *soap, _ngwm__retractResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__retractResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__retractResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__retractResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__retractResponse * SOAP_FMAC4 soap_in__ngwm__retractResponse(struct soap *soap, const char *tag, _ngwm__retractResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__retractResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__retractResponse, sizeof(_ngwm__retractResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__retractResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__retractResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__retractResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__retractResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__retractResponse, 0, sizeof(_ngwm__retractResponse), 0, soap_copy__ngwm__retractResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__retractResponse * SOAP_FMAC6 soap_new__ngwm__retractResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__retractResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__retractResponse(struct soap *soap, _ngwm__retractResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__retractResponse * SOAP_FMAC6 soap_instantiate__ngwm__retractResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__retractResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__retractResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__retractResponse;
		if (size)
			*size = sizeof(_ngwm__retractResponse);
		((_ngwm__retractResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__retractResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__retractResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__retractResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__retractResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__retractResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__retractResponse %p -> %p\n", q, p));
	*(_ngwm__retractResponse*)p = *(_ngwm__retractResponse*)q;
}

void _ngwm__retractRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__retractRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__retractRequest*)this)->items);
	soap_embedded(soap, &((_ngwm__retractRequest*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__retractRequest*)this)->comment);
	soap_embedded(soap, &((_ngwm__retractRequest*)this)->retractingAllInstances, SOAP_TYPE_bool);
	soap_embedded(soap, &((_ngwm__retractRequest*)this)->retractCausedByResend, SOAP_TYPE_bool);
	soap_embedded(soap, &((_ngwm__retractRequest*)this)->retractType, SOAP_TYPE_PointerTongwt__RetractType);
	soap_serialize_PointerTongwt__RetractType(soap, &((_ngwm__retractRequest*)this)->retractType);
	/* transient soap skipped */
}

void _ngwm__retractRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__retractRequest*)this)->items = NULL;
	((_ngwm__retractRequest*)this)->comment = NULL;
	((_ngwm__retractRequest*)this)->retractingAllInstances = (bool)0;
	((_ngwm__retractRequest*)this)->retractCausedByResend = (bool)0;
	((_ngwm__retractRequest*)this)->retractType = NULL;
	/* transient soap skipped */
}

int _ngwm__retractRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__retractRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__retractRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__retractRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__retractRequest(struct soap *soap, const char *tag, int id, const _ngwm__retractRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__retractRequest), type);
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__retractRequest*)a)->items), "");
	soap_out_PointerTostd__string(soap, "ngwm:comment", -1, &(((_ngwm__retractRequest*)a)->comment), "");
	soap_out_bool(soap, "ngwm:retractingAllInstances", -1, &(((_ngwm__retractRequest*)a)->retractingAllInstances), "");
	soap_out_bool(soap, "ngwm:retractCausedByResend", -1, &(((_ngwm__retractRequest*)a)->retractCausedByResend), "");
	soap_out_PointerTongwt__RetractType(soap, "ngwm:retractType", -1, &(((_ngwm__retractRequest*)a)->retractType), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__retractRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__retractRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__retractRequest * SOAP_FMAC4 soap_get__ngwm__retractRequest(struct soap *soap, _ngwm__retractRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__retractRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__retractRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__retractRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__retractRequest * SOAP_FMAC4 soap_in__ngwm__retractRequest(struct soap *soap, const char *tag, _ngwm__retractRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__retractRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__retractRequest, sizeof(_ngwm__retractRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__retractRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__retractRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1, soap_flag_comment1 = 1, soap_flag_retractingAllInstances1 = 1, soap_flag_retractCausedByResend1 = 1, soap_flag_retractType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__retractRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:comment", &(((_ngwm__retractRequest*)a)->comment), ""))
				{	soap_flag_comment1 = 0;
					continue;
				}
			if (soap_flag_retractingAllInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwm:retractingAllInstances", &(((_ngwm__retractRequest*)a)->retractingAllInstances), ""))
				{	soap_flag_retractingAllInstances1 = 0;
					continue;
				}
			if (soap_flag_retractCausedByResend1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwm:retractCausedByResend", &(((_ngwm__retractRequest*)a)->retractCausedByResend), ""))
				{	soap_flag_retractCausedByResend1 = 0;
					continue;
				}
			if (soap_flag_retractType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RetractType(soap, "ngwm:retractType", &(((_ngwm__retractRequest*)a)->retractType), ""))
				{	soap_flag_retractType1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__retractRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__retractRequest, 0, sizeof(_ngwm__retractRequest), 0, soap_copy__ngwm__retractRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__retractRequest * SOAP_FMAC6 soap_new__ngwm__retractRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__retractRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__retractRequest(struct soap *soap, _ngwm__retractRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__retractRequest * SOAP_FMAC6 soap_instantiate__ngwm__retractRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__retractRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__retractRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__retractRequest;
		if (size)
			*size = sizeof(_ngwm__retractRequest);
		((_ngwm__retractRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__retractRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__retractRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__retractRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__retractRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__retractRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__retractRequest %p -> %p\n", q, p));
	*(_ngwm__retractRequest*)p = *(_ngwm__retractRequest*)q;
}

void _ngwm__replyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__replyResponse*)this)->item, SOAP_TYPE_PointerTongwt__Item);
	soap_serialize_PointerTongwt__Item(soap, &((_ngwm__replyResponse*)this)->item);
	soap_embedded(soap, &((_ngwm__replyResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__replyResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__replyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__replyResponse*)this)->item = NULL;
	((_ngwm__replyResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__replyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__replyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__replyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__replyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__replyResponse(struct soap *soap, const char *tag, int id, const _ngwm__replyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__replyResponse), type);
	soap_out_PointerTongwt__Item(soap, "ngwm:item", -1, &(((_ngwm__replyResponse*)a)->item), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__replyResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__replyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__replyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__replyResponse * SOAP_FMAC4 soap_get__ngwm__replyResponse(struct soap *soap, _ngwm__replyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__replyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__replyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__replyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__replyResponse * SOAP_FMAC4 soap_in__ngwm__replyResponse(struct soap *soap, const char *tag, _ngwm__replyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__replyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__replyResponse, sizeof(_ngwm__replyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__replyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__replyResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_item1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Item(soap, "ngwm:item", &(((_ngwm__replyResponse*)a)->item), "ngwt:Item"))
				{	soap_flag_item1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__replyResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__replyResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__replyResponse, 0, sizeof(_ngwm__replyResponse), 0, soap_copy__ngwm__replyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__replyResponse * SOAP_FMAC6 soap_new__ngwm__replyResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__replyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__replyResponse(struct soap *soap, _ngwm__replyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__replyResponse * SOAP_FMAC6 soap_instantiate__ngwm__replyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__replyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__replyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__replyResponse;
		if (size)
			*size = sizeof(_ngwm__replyResponse);
		((_ngwm__replyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__replyResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__replyResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__replyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__replyResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__replyResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__replyResponse %p -> %p\n", q, p));
	*(_ngwm__replyResponse*)p = *(_ngwm__replyResponse*)q;
}

void _ngwm__replyRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__replyRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__replyRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__replyRequest*)this)->view, SOAP_TYPE_PointerTongwt__View);
	soap_serialize_PointerTongwt__View(soap, &((_ngwm__replyRequest*)this)->view);
	/* transient soap skipped */
}

void _ngwm__replyRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__replyRequest*)this)->id);
	((_ngwm__replyRequest*)this)->view = NULL;
	/* transient soap skipped */
}

int _ngwm__replyRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__replyRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__replyRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__replyRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__replyRequest(struct soap *soap, const char *tag, int id, const _ngwm__replyRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__replyRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__replyRequest*)a)->id), "");
	soap_out_PointerTongwt__View(soap, "ngwm:view", -1, &(((_ngwm__replyRequest*)a)->view), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__replyRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__replyRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__replyRequest * SOAP_FMAC4 soap_get__ngwm__replyRequest(struct soap *soap, _ngwm__replyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__replyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__replyRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__replyRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__replyRequest * SOAP_FMAC4 soap_in__ngwm__replyRequest(struct soap *soap, const char *tag, _ngwm__replyRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__replyRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__replyRequest, sizeof(_ngwm__replyRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__replyRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__replyRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_view1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__replyRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__View(soap, "ngwm:view", &(((_ngwm__replyRequest*)a)->view), "ngwt:View"))
				{	soap_flag_view1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__replyRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__replyRequest, 0, sizeof(_ngwm__replyRequest), 0, soap_copy__ngwm__replyRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__replyRequest * SOAP_FMAC6 soap_new__ngwm__replyRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__replyRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__replyRequest(struct soap *soap, _ngwm__replyRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__replyRequest * SOAP_FMAC6 soap_instantiate__ngwm__replyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__replyRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__replyRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__replyRequest;
		if (size)
			*size = sizeof(_ngwm__replyRequest);
		((_ngwm__replyRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__replyRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__replyRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__replyRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__replyRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__replyRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__replyRequest %p -> %p\n", q, p));
	*(_ngwm__replyRequest*)p = *(_ngwm__replyRequest*)q;
}

void _ngwm__removeSignatureResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeSignatureResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__removeSignatureResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__removeSignatureResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__removeSignatureResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__removeSignatureResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeSignatureResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeSignatureResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeSignatureResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeSignatureResponse(struct soap *soap, const char *tag, int id, const _ngwm__removeSignatureResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeSignatureResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__removeSignatureResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeSignatureResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeSignatureResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeSignatureResponse * SOAP_FMAC4 soap_get__ngwm__removeSignatureResponse(struct soap *soap, _ngwm__removeSignatureResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeSignatureResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeSignatureResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeSignatureResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeSignatureResponse * SOAP_FMAC4 soap_in__ngwm__removeSignatureResponse(struct soap *soap, const char *tag, _ngwm__removeSignatureResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeSignatureResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeSignatureResponse, sizeof(_ngwm__removeSignatureResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeSignatureResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeSignatureResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__removeSignatureResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeSignatureResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeSignatureResponse, 0, sizeof(_ngwm__removeSignatureResponse), 0, soap_copy__ngwm__removeSignatureResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeSignatureResponse * SOAP_FMAC6 soap_new__ngwm__removeSignatureResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeSignatureResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeSignatureResponse(struct soap *soap, _ngwm__removeSignatureResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeSignatureResponse * SOAP_FMAC6 soap_instantiate__ngwm__removeSignatureResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeSignatureResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeSignatureResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeSignatureResponse;
		if (size)
			*size = sizeof(_ngwm__removeSignatureResponse);
		((_ngwm__removeSignatureResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeSignatureResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__removeSignatureResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__removeSignatureResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeSignatureResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeSignatureResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeSignatureResponse %p -> %p\n", q, p));
	*(_ngwm__removeSignatureResponse*)p = *(_ngwm__removeSignatureResponse*)q;
}

void _ngwm__removeSignatureRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeSignatureRequest*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((_ngwm__removeSignatureRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__removeSignatureRequest*)this)->all, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((_ngwm__removeSignatureRequest*)this)->all);
	soap_embedded(soap, &((_ngwm__removeSignatureRequest*)this)->global, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void _ngwm__removeSignatureRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__removeSignatureRequest*)this)->id = NULL;
	((_ngwm__removeSignatureRequest*)this)->all = NULL;
	((_ngwm__removeSignatureRequest*)this)->global = (bool)0;
	/* transient soap skipped */
}

int _ngwm__removeSignatureRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeSignatureRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeSignatureRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeSignatureRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeSignatureRequest(struct soap *soap, const char *tag, int id, const _ngwm__removeSignatureRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeSignatureRequest), type);
	soap_out_PointerTongwt__uid(soap, "ngwm:id", -1, &(((_ngwm__removeSignatureRequest*)a)->id), "");
	soap_out_PointerTobool(soap, "ngwm:all", -1, &(((_ngwm__removeSignatureRequest*)a)->all), "");
	soap_out_bool(soap, "ngwm:global", -1, &(((_ngwm__removeSignatureRequest*)a)->global), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeSignatureRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeSignatureRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeSignatureRequest * SOAP_FMAC4 soap_get__ngwm__removeSignatureRequest(struct soap *soap, _ngwm__removeSignatureRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeSignatureRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeSignatureRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeSignatureRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeSignatureRequest * SOAP_FMAC4 soap_in__ngwm__removeSignatureRequest(struct soap *soap, const char *tag, _ngwm__removeSignatureRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeSignatureRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeSignatureRequest, sizeof(_ngwm__removeSignatureRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeSignatureRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeSignatureRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_all1 = 1, soap_flag_global1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwm:id", &(((_ngwm__removeSignatureRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_all1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwm:all", &(((_ngwm__removeSignatureRequest*)a)->all), ""))
				{	soap_flag_all1 = 0;
					continue;
				}
			if (soap_flag_global1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwm:global", &(((_ngwm__removeSignatureRequest*)a)->global), ""))
				{	soap_flag_global1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeSignatureRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeSignatureRequest, 0, sizeof(_ngwm__removeSignatureRequest), 0, soap_copy__ngwm__removeSignatureRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeSignatureRequest * SOAP_FMAC6 soap_new__ngwm__removeSignatureRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeSignatureRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeSignatureRequest(struct soap *soap, _ngwm__removeSignatureRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeSignatureRequest * SOAP_FMAC6 soap_instantiate__ngwm__removeSignatureRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeSignatureRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeSignatureRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeSignatureRequest;
		if (size)
			*size = sizeof(_ngwm__removeSignatureRequest);
		((_ngwm__removeSignatureRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeSignatureRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__removeSignatureRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__removeSignatureRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeSignatureRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeSignatureRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeSignatureRequest %p -> %p\n", q, p));
	*(_ngwm__removeSignatureRequest*)p = *(_ngwm__removeSignatureRequest*)q;
}

void _ngwm__removeProxyUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeProxyUserResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__removeProxyUserResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__removeProxyUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__removeProxyUserResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__removeProxyUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeProxyUserResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeProxyUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeProxyUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeProxyUserResponse(struct soap *soap, const char *tag, int id, const _ngwm__removeProxyUserResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeProxyUserResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__removeProxyUserResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeProxyUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeProxyUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeProxyUserResponse * SOAP_FMAC4 soap_get__ngwm__removeProxyUserResponse(struct soap *soap, _ngwm__removeProxyUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeProxyUserResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeProxyUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeProxyUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeProxyUserResponse * SOAP_FMAC4 soap_in__ngwm__removeProxyUserResponse(struct soap *soap, const char *tag, _ngwm__removeProxyUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeProxyUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeProxyUserResponse, sizeof(_ngwm__removeProxyUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeProxyUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeProxyUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__removeProxyUserResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeProxyUserResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeProxyUserResponse, 0, sizeof(_ngwm__removeProxyUserResponse), 0, soap_copy__ngwm__removeProxyUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeProxyUserResponse * SOAP_FMAC6 soap_new__ngwm__removeProxyUserResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeProxyUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeProxyUserResponse(struct soap *soap, _ngwm__removeProxyUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeProxyUserResponse * SOAP_FMAC6 soap_instantiate__ngwm__removeProxyUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeProxyUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeProxyUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeProxyUserResponse;
		if (size)
			*size = sizeof(_ngwm__removeProxyUserResponse);
		((_ngwm__removeProxyUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeProxyUserResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__removeProxyUserResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__removeProxyUserResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeProxyUserResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeProxyUserResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeProxyUserResponse %p -> %p\n", q, p));
	*(_ngwm__removeProxyUserResponse*)p = *(_ngwm__removeProxyUserResponse*)q;
}

void _ngwm__removeProxyUserRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeProxyUserRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__removeProxyUserRequest*)this)->id);
	/* transient soap skipped */
}

void _ngwm__removeProxyUserRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__removeProxyUserRequest*)this)->id);
	/* transient soap skipped */
}

int _ngwm__removeProxyUserRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeProxyUserRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeProxyUserRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeProxyUserRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeProxyUserRequest(struct soap *soap, const char *tag, int id, const _ngwm__removeProxyUserRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeProxyUserRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__removeProxyUserRequest*)a)->id), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeProxyUserRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeProxyUserRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeProxyUserRequest * SOAP_FMAC4 soap_get__ngwm__removeProxyUserRequest(struct soap *soap, _ngwm__removeProxyUserRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeProxyUserRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeProxyUserRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeProxyUserRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeProxyUserRequest * SOAP_FMAC4 soap_in__ngwm__removeProxyUserRequest(struct soap *soap, const char *tag, _ngwm__removeProxyUserRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeProxyUserRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeProxyUserRequest, sizeof(_ngwm__removeProxyUserRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeProxyUserRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeProxyUserRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__removeProxyUserRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeProxyUserRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeProxyUserRequest, 0, sizeof(_ngwm__removeProxyUserRequest), 0, soap_copy__ngwm__removeProxyUserRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeProxyUserRequest * SOAP_FMAC6 soap_new__ngwm__removeProxyUserRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeProxyUserRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeProxyUserRequest(struct soap *soap, _ngwm__removeProxyUserRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeProxyUserRequest * SOAP_FMAC6 soap_instantiate__ngwm__removeProxyUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeProxyUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeProxyUserRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeProxyUserRequest;
		if (size)
			*size = sizeof(_ngwm__removeProxyUserRequest);
		((_ngwm__removeProxyUserRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeProxyUserRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__removeProxyUserRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__removeProxyUserRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeProxyUserRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeProxyUserRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeProxyUserRequest %p -> %p\n", q, p));
	*(_ngwm__removeProxyUserRequest*)p = *(_ngwm__removeProxyUserRequest*)q;
}

void _ngwm__removeProxyAccessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeProxyAccessResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__removeProxyAccessResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__removeProxyAccessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__removeProxyAccessResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__removeProxyAccessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeProxyAccessResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeProxyAccessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeProxyAccessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeProxyAccessResponse(struct soap *soap, const char *tag, int id, const _ngwm__removeProxyAccessResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeProxyAccessResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__removeProxyAccessResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeProxyAccessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeProxyAccessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeProxyAccessResponse * SOAP_FMAC4 soap_get__ngwm__removeProxyAccessResponse(struct soap *soap, _ngwm__removeProxyAccessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeProxyAccessResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeProxyAccessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeProxyAccessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeProxyAccessResponse * SOAP_FMAC4 soap_in__ngwm__removeProxyAccessResponse(struct soap *soap, const char *tag, _ngwm__removeProxyAccessResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeProxyAccessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeProxyAccessResponse, sizeof(_ngwm__removeProxyAccessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeProxyAccessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeProxyAccessResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__removeProxyAccessResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeProxyAccessResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeProxyAccessResponse, 0, sizeof(_ngwm__removeProxyAccessResponse), 0, soap_copy__ngwm__removeProxyAccessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeProxyAccessResponse * SOAP_FMAC6 soap_new__ngwm__removeProxyAccessResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeProxyAccessResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeProxyAccessResponse(struct soap *soap, _ngwm__removeProxyAccessResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeProxyAccessResponse * SOAP_FMAC6 soap_instantiate__ngwm__removeProxyAccessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeProxyAccessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeProxyAccessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeProxyAccessResponse;
		if (size)
			*size = sizeof(_ngwm__removeProxyAccessResponse);
		((_ngwm__removeProxyAccessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeProxyAccessResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__removeProxyAccessResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__removeProxyAccessResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeProxyAccessResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeProxyAccessResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeProxyAccessResponse %p -> %p\n", q, p));
	*(_ngwm__removeProxyAccessResponse*)p = *(_ngwm__removeProxyAccessResponse*)q;
}

void _ngwm__removeProxyAccessRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeProxyAccessRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__removeProxyAccessRequest*)this)->id);
	/* transient soap skipped */
}

void _ngwm__removeProxyAccessRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__removeProxyAccessRequest*)this)->id);
	/* transient soap skipped */
}

int _ngwm__removeProxyAccessRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeProxyAccessRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeProxyAccessRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeProxyAccessRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeProxyAccessRequest(struct soap *soap, const char *tag, int id, const _ngwm__removeProxyAccessRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeProxyAccessRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__removeProxyAccessRequest*)a)->id), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeProxyAccessRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeProxyAccessRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeProxyAccessRequest * SOAP_FMAC4 soap_get__ngwm__removeProxyAccessRequest(struct soap *soap, _ngwm__removeProxyAccessRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeProxyAccessRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeProxyAccessRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeProxyAccessRequest * SOAP_FMAC4 soap_in__ngwm__removeProxyAccessRequest(struct soap *soap, const char *tag, _ngwm__removeProxyAccessRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeProxyAccessRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeProxyAccessRequest, sizeof(_ngwm__removeProxyAccessRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeProxyAccessRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeProxyAccessRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__removeProxyAccessRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeProxyAccessRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeProxyAccessRequest, 0, sizeof(_ngwm__removeProxyAccessRequest), 0, soap_copy__ngwm__removeProxyAccessRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeProxyAccessRequest * SOAP_FMAC6 soap_new__ngwm__removeProxyAccessRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeProxyAccessRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeProxyAccessRequest(struct soap *soap, _ngwm__removeProxyAccessRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeProxyAccessRequest * SOAP_FMAC6 soap_instantiate__ngwm__removeProxyAccessRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeProxyAccessRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeProxyAccessRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeProxyAccessRequest;
		if (size)
			*size = sizeof(_ngwm__removeProxyAccessRequest);
		((_ngwm__removeProxyAccessRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeProxyAccessRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__removeProxyAccessRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__removeProxyAccessRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeProxyAccessRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeProxyAccessRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeProxyAccessRequest %p -> %p\n", q, p));
	*(_ngwm__removeProxyAccessRequest*)p = *(_ngwm__removeProxyAccessRequest*)q;
}

void _ngwm__removeMembersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeMembersResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__removeMembersResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__removeMembersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__removeMembersResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__removeMembersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeMembersResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeMembersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeMembersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeMembersResponse(struct soap *soap, const char *tag, int id, const _ngwm__removeMembersResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeMembersResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__removeMembersResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeMembersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeMembersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeMembersResponse * SOAP_FMAC4 soap_get__ngwm__removeMembersResponse(struct soap *soap, _ngwm__removeMembersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeMembersResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeMembersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeMembersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeMembersResponse * SOAP_FMAC4 soap_in__ngwm__removeMembersResponse(struct soap *soap, const char *tag, _ngwm__removeMembersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeMembersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeMembersResponse, sizeof(_ngwm__removeMembersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeMembersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeMembersResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__removeMembersResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeMembersResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeMembersResponse, 0, sizeof(_ngwm__removeMembersResponse), 0, soap_copy__ngwm__removeMembersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeMembersResponse * SOAP_FMAC6 soap_new__ngwm__removeMembersResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeMembersResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeMembersResponse(struct soap *soap, _ngwm__removeMembersResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeMembersResponse * SOAP_FMAC6 soap_instantiate__ngwm__removeMembersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeMembersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeMembersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeMembersResponse;
		if (size)
			*size = sizeof(_ngwm__removeMembersResponse);
		((_ngwm__removeMembersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeMembersResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__removeMembersResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__removeMembersResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeMembersResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeMembersResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeMembersResponse %p -> %p\n", q, p));
	*(_ngwm__removeMembersResponse*)p = *(_ngwm__removeMembersResponse*)q;
}

void _ngwm__removeMembersRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeMembersRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__removeMembersRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__removeMembersRequest*)this)->members, SOAP_TYPE_PointerTongwt__GroupMemberList);
	soap_serialize_PointerTongwt__GroupMemberList(soap, &((_ngwm__removeMembersRequest*)this)->members);
	/* transient soap skipped */
}

void _ngwm__removeMembersRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__removeMembersRequest*)this)->container);
	((_ngwm__removeMembersRequest*)this)->members = NULL;
	/* transient soap skipped */
}

int _ngwm__removeMembersRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeMembersRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeMembersRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeMembersRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeMembersRequest(struct soap *soap, const char *tag, int id, const _ngwm__removeMembersRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeMembersRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__removeMembersRequest*)a)->container), "");
	soap_out_PointerTongwt__GroupMemberList(soap, "ngwm:members", -1, &(((_ngwm__removeMembersRequest*)a)->members), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeMembersRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeMembersRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeMembersRequest * SOAP_FMAC4 soap_get__ngwm__removeMembersRequest(struct soap *soap, _ngwm__removeMembersRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeMembersRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeMembersRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeMembersRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeMembersRequest * SOAP_FMAC4 soap_in__ngwm__removeMembersRequest(struct soap *soap, const char *tag, _ngwm__removeMembersRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeMembersRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeMembersRequest, sizeof(_ngwm__removeMembersRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeMembersRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeMembersRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_members1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__removeMembersRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_members1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__GroupMemberList(soap, "ngwm:members", &(((_ngwm__removeMembersRequest*)a)->members), "ngwt:GroupMemberList"))
				{	soap_flag_members1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_members1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeMembersRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeMembersRequest, 0, sizeof(_ngwm__removeMembersRequest), 0, soap_copy__ngwm__removeMembersRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeMembersRequest * SOAP_FMAC6 soap_new__ngwm__removeMembersRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeMembersRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeMembersRequest(struct soap *soap, _ngwm__removeMembersRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeMembersRequest * SOAP_FMAC6 soap_instantiate__ngwm__removeMembersRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeMembersRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeMembersRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeMembersRequest;
		if (size)
			*size = sizeof(_ngwm__removeMembersRequest);
		((_ngwm__removeMembersRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeMembersRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__removeMembersRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__removeMembersRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeMembersRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeMembersRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeMembersRequest %p -> %p\n", q, p));
	*(_ngwm__removeMembersRequest*)p = *(_ngwm__removeMembersRequest*)q;
}

void _ngwm__removeJunkEntryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeJunkEntryResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__removeJunkEntryResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__removeJunkEntryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__removeJunkEntryResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__removeJunkEntryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeJunkEntryResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeJunkEntryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeJunkEntryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeJunkEntryResponse(struct soap *soap, const char *tag, int id, const _ngwm__removeJunkEntryResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeJunkEntryResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__removeJunkEntryResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeJunkEntryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeJunkEntryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeJunkEntryResponse * SOAP_FMAC4 soap_get__ngwm__removeJunkEntryResponse(struct soap *soap, _ngwm__removeJunkEntryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeJunkEntryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeJunkEntryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeJunkEntryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeJunkEntryResponse * SOAP_FMAC4 soap_in__ngwm__removeJunkEntryResponse(struct soap *soap, const char *tag, _ngwm__removeJunkEntryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeJunkEntryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeJunkEntryResponse, sizeof(_ngwm__removeJunkEntryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeJunkEntryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeJunkEntryResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__removeJunkEntryResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeJunkEntryResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeJunkEntryResponse, 0, sizeof(_ngwm__removeJunkEntryResponse), 0, soap_copy__ngwm__removeJunkEntryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeJunkEntryResponse * SOAP_FMAC6 soap_new__ngwm__removeJunkEntryResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeJunkEntryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeJunkEntryResponse(struct soap *soap, _ngwm__removeJunkEntryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeJunkEntryResponse * SOAP_FMAC6 soap_instantiate__ngwm__removeJunkEntryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeJunkEntryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeJunkEntryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeJunkEntryResponse;
		if (size)
			*size = sizeof(_ngwm__removeJunkEntryResponse);
		((_ngwm__removeJunkEntryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeJunkEntryResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__removeJunkEntryResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__removeJunkEntryResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeJunkEntryResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeJunkEntryResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeJunkEntryResponse %p -> %p\n", q, p));
	*(_ngwm__removeJunkEntryResponse*)p = *(_ngwm__removeJunkEntryResponse*)q;
}

void _ngwm__removeJunkEntryRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeJunkEntryRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__removeJunkEntryRequest*)this)->id);
	/* transient soap skipped */
}

void _ngwm__removeJunkEntryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__removeJunkEntryRequest*)this)->id);
	/* transient soap skipped */
}

int _ngwm__removeJunkEntryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeJunkEntryRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeJunkEntryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeJunkEntryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeJunkEntryRequest(struct soap *soap, const char *tag, int id, const _ngwm__removeJunkEntryRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeJunkEntryRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__removeJunkEntryRequest*)a)->id), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeJunkEntryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeJunkEntryRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeJunkEntryRequest * SOAP_FMAC4 soap_get__ngwm__removeJunkEntryRequest(struct soap *soap, _ngwm__removeJunkEntryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeJunkEntryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeJunkEntryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeJunkEntryRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeJunkEntryRequest * SOAP_FMAC4 soap_in__ngwm__removeJunkEntryRequest(struct soap *soap, const char *tag, _ngwm__removeJunkEntryRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeJunkEntryRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeJunkEntryRequest, sizeof(_ngwm__removeJunkEntryRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeJunkEntryRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeJunkEntryRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__removeJunkEntryRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeJunkEntryRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeJunkEntryRequest, 0, sizeof(_ngwm__removeJunkEntryRequest), 0, soap_copy__ngwm__removeJunkEntryRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeJunkEntryRequest * SOAP_FMAC6 soap_new__ngwm__removeJunkEntryRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeJunkEntryRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeJunkEntryRequest(struct soap *soap, _ngwm__removeJunkEntryRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeJunkEntryRequest * SOAP_FMAC6 soap_instantiate__ngwm__removeJunkEntryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeJunkEntryRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeJunkEntryRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeJunkEntryRequest;
		if (size)
			*size = sizeof(_ngwm__removeJunkEntryRequest);
		((_ngwm__removeJunkEntryRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeJunkEntryRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__removeJunkEntryRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__removeJunkEntryRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeJunkEntryRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeJunkEntryRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeJunkEntryRequest %p -> %p\n", q, p));
	*(_ngwm__removeJunkEntryRequest*)p = *(_ngwm__removeJunkEntryRequest*)q;
}

void _ngwm__removeItemsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeItemsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__removeItemsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__removeItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__removeItemsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__removeItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeItemsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeItemsResponse(struct soap *soap, const char *tag, int id, const _ngwm__removeItemsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeItemsResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__removeItemsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeItemsResponse * SOAP_FMAC4 soap_get__ngwm__removeItemsResponse(struct soap *soap, _ngwm__removeItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeItemsResponse * SOAP_FMAC4 soap_in__ngwm__removeItemsResponse(struct soap *soap, const char *tag, _ngwm__removeItemsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeItemsResponse, sizeof(_ngwm__removeItemsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeItemsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeItemsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__removeItemsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeItemsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeItemsResponse, 0, sizeof(_ngwm__removeItemsResponse), 0, soap_copy__ngwm__removeItemsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeItemsResponse * SOAP_FMAC6 soap_new__ngwm__removeItemsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeItemsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeItemsResponse(struct soap *soap, _ngwm__removeItemsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeItemsResponse * SOAP_FMAC6 soap_instantiate__ngwm__removeItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeItemsResponse;
		if (size)
			*size = sizeof(_ngwm__removeItemsResponse);
		((_ngwm__removeItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeItemsResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__removeItemsResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__removeItemsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeItemsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeItemsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeItemsResponse %p -> %p\n", q, p));
	*(_ngwm__removeItemsResponse*)p = *(_ngwm__removeItemsResponse*)q;
}

void _ngwm__removeItemsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeItemsRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__removeItemsRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__removeItemsRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__removeItemsRequest*)this)->items);
	/* transient soap skipped */
}

void _ngwm__removeItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__removeItemsRequest*)this)->container);
	((_ngwm__removeItemsRequest*)this)->items = NULL;
	/* transient soap skipped */
}

int _ngwm__removeItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeItemsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeItemsRequest(struct soap *soap, const char *tag, int id, const _ngwm__removeItemsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeItemsRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__removeItemsRequest*)a)->container), "");
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__removeItemsRequest*)a)->items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeItemsRequest * SOAP_FMAC4 soap_get__ngwm__removeItemsRequest(struct soap *soap, _ngwm__removeItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeItemsRequest * SOAP_FMAC4 soap_in__ngwm__removeItemsRequest(struct soap *soap, const char *tag, _ngwm__removeItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeItemsRequest, sizeof(_ngwm__removeItemsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeItemsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeItemsRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_items1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__removeItemsRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__removeItemsRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeItemsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeItemsRequest, 0, sizeof(_ngwm__removeItemsRequest), 0, soap_copy__ngwm__removeItemsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeItemsRequest * SOAP_FMAC6 soap_new__ngwm__removeItemsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeItemsRequest(struct soap *soap, _ngwm__removeItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeItemsRequest * SOAP_FMAC6 soap_instantiate__ngwm__removeItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeItemsRequest;
		if (size)
			*size = sizeof(_ngwm__removeItemsRequest);
		((_ngwm__removeItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeItemsRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__removeItemsRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__removeItemsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeItemsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeItemsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeItemsRequest %p -> %p\n", q, p));
	*(_ngwm__removeItemsRequest*)p = *(_ngwm__removeItemsRequest*)q;
}

void _ngwm__removeItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeItemResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__removeItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__removeItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__removeItemResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__removeItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeItemResponse(struct soap *soap, const char *tag, int id, const _ngwm__removeItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeItemResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__removeItemResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeItemResponse * SOAP_FMAC4 soap_get__ngwm__removeItemResponse(struct soap *soap, _ngwm__removeItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeItemResponse * SOAP_FMAC4 soap_in__ngwm__removeItemResponse(struct soap *soap, const char *tag, _ngwm__removeItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeItemResponse, sizeof(_ngwm__removeItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__removeItemResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeItemResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeItemResponse, 0, sizeof(_ngwm__removeItemResponse), 0, soap_copy__ngwm__removeItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeItemResponse * SOAP_FMAC6 soap_new__ngwm__removeItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeItemResponse(struct soap *soap, _ngwm__removeItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeItemResponse * SOAP_FMAC6 soap_instantiate__ngwm__removeItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeItemResponse;
		if (size)
			*size = sizeof(_ngwm__removeItemResponse);
		((_ngwm__removeItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeItemResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__removeItemResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__removeItemResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeItemResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeItemResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeItemResponse %p -> %p\n", q, p));
	*(_ngwm__removeItemResponse*)p = *(_ngwm__removeItemResponse*)q;
}

void _ngwm__removeItemRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeItemRequest*)this)->container, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((_ngwm__removeItemRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__removeItemRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__removeItemRequest*)this)->id);
	/* transient soap skipped */
}

void _ngwm__removeItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__removeItemRequest*)this)->container = NULL;
	soap_default_ngwt__uid(soap, &((_ngwm__removeItemRequest*)this)->id);
	/* transient soap skipped */
}

int _ngwm__removeItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeItemRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeItemRequest(struct soap *soap, const char *tag, int id, const _ngwm__removeItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeItemRequest), type);
	soap_out_PointerTongwt__uid(soap, "ngwm:container", -1, &(((_ngwm__removeItemRequest*)a)->container), "");
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__removeItemRequest*)a)->id), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeItemRequest * SOAP_FMAC4 soap_get__ngwm__removeItemRequest(struct soap *soap, _ngwm__removeItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeItemRequest * SOAP_FMAC4 soap_in__ngwm__removeItemRequest(struct soap *soap, const char *tag, _ngwm__removeItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeItemRequest, sizeof(_ngwm__removeItemRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeItemRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeItemRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwm:container", &(((_ngwm__removeItemRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__removeItemRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeItemRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeItemRequest, 0, sizeof(_ngwm__removeItemRequest), 0, soap_copy__ngwm__removeItemRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeItemRequest * SOAP_FMAC6 soap_new__ngwm__removeItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeItemRequest(struct soap *soap, _ngwm__removeItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeItemRequest * SOAP_FMAC6 soap_instantiate__ngwm__removeItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeItemRequest;
		if (size)
			*size = sizeof(_ngwm__removeItemRequest);
		((_ngwm__removeItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeItemRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__removeItemRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__removeItemRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeItemRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeItemRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeItemRequest %p -> %p\n", q, p));
	*(_ngwm__removeItemRequest*)p = *(_ngwm__removeItemRequest*)q;
}

void _ngwm__removeCustomDefinitionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeCustomDefinitionResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__removeCustomDefinitionResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__removeCustomDefinitionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__removeCustomDefinitionResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__removeCustomDefinitionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeCustomDefinitionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeCustomDefinitionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeCustomDefinitionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeCustomDefinitionResponse(struct soap *soap, const char *tag, int id, const _ngwm__removeCustomDefinitionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeCustomDefinitionResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__removeCustomDefinitionResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeCustomDefinitionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeCustomDefinitionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeCustomDefinitionResponse * SOAP_FMAC4 soap_get__ngwm__removeCustomDefinitionResponse(struct soap *soap, _ngwm__removeCustomDefinitionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeCustomDefinitionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeCustomDefinitionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeCustomDefinitionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeCustomDefinitionResponse * SOAP_FMAC4 soap_in__ngwm__removeCustomDefinitionResponse(struct soap *soap, const char *tag, _ngwm__removeCustomDefinitionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeCustomDefinitionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeCustomDefinitionResponse, sizeof(_ngwm__removeCustomDefinitionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeCustomDefinitionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeCustomDefinitionResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__removeCustomDefinitionResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeCustomDefinitionResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeCustomDefinitionResponse, 0, sizeof(_ngwm__removeCustomDefinitionResponse), 0, soap_copy__ngwm__removeCustomDefinitionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeCustomDefinitionResponse * SOAP_FMAC6 soap_new__ngwm__removeCustomDefinitionResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeCustomDefinitionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeCustomDefinitionResponse(struct soap *soap, _ngwm__removeCustomDefinitionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeCustomDefinitionResponse * SOAP_FMAC6 soap_instantiate__ngwm__removeCustomDefinitionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeCustomDefinitionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeCustomDefinitionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeCustomDefinitionResponse;
		if (size)
			*size = sizeof(_ngwm__removeCustomDefinitionResponse);
		((_ngwm__removeCustomDefinitionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeCustomDefinitionResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__removeCustomDefinitionResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__removeCustomDefinitionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeCustomDefinitionResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeCustomDefinitionResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeCustomDefinitionResponse %p -> %p\n", q, p));
	*(_ngwm__removeCustomDefinitionResponse*)p = *(_ngwm__removeCustomDefinitionResponse*)q;
}

void _ngwm__removeCustomDefinitionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__removeCustomDefinitionRequest*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((_ngwm__removeCustomDefinitionRequest*)this)->customs);
	soap_embedded(soap, &((_ngwm__removeCustomDefinitionRequest*)this)->books, SOAP_TYPE_bool);
	soap_embedded(soap, &((_ngwm__removeCustomDefinitionRequest*)this)->doAsynchronous, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void _ngwm__removeCustomDefinitionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__removeCustomDefinitionRequest*)this)->customs = NULL;
	((_ngwm__removeCustomDefinitionRequest*)this)->books = (bool)0;
	((_ngwm__removeCustomDefinitionRequest*)this)->doAsynchronous = (bool)0;
	/* transient soap skipped */
}

int _ngwm__removeCustomDefinitionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__removeCustomDefinitionRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__removeCustomDefinitionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__removeCustomDefinitionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__removeCustomDefinitionRequest(struct soap *soap, const char *tag, int id, const _ngwm__removeCustomDefinitionRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__removeCustomDefinitionRequest), type);
	soap_out_PointerTongwt__CustomList(soap, "ngwm:customs", -1, &(((_ngwm__removeCustomDefinitionRequest*)a)->customs), "");
	soap_out_bool(soap, "ngwm:books", -1, &(((_ngwm__removeCustomDefinitionRequest*)a)->books), "");
	soap_out_bool(soap, "ngwm:doAsynchronous", -1, &(((_ngwm__removeCustomDefinitionRequest*)a)->doAsynchronous), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__removeCustomDefinitionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__removeCustomDefinitionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__removeCustomDefinitionRequest * SOAP_FMAC4 soap_get__ngwm__removeCustomDefinitionRequest(struct soap *soap, _ngwm__removeCustomDefinitionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__removeCustomDefinitionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__removeCustomDefinitionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__removeCustomDefinitionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__removeCustomDefinitionRequest * SOAP_FMAC4 soap_in__ngwm__removeCustomDefinitionRequest(struct soap *soap, const char *tag, _ngwm__removeCustomDefinitionRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__removeCustomDefinitionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__removeCustomDefinitionRequest, sizeof(_ngwm__removeCustomDefinitionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__removeCustomDefinitionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__removeCustomDefinitionRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_customs1 = 1, soap_flag_books1 = 1, soap_flag_doAsynchronous1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_customs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwm:customs", &(((_ngwm__removeCustomDefinitionRequest*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs1 = 0;
					continue;
				}
			if (soap_flag_books1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwm:books", &(((_ngwm__removeCustomDefinitionRequest*)a)->books), ""))
				{	soap_flag_books1 = 0;
					continue;
				}
			if (soap_flag_doAsynchronous1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwm:doAsynchronous", &(((_ngwm__removeCustomDefinitionRequest*)a)->doAsynchronous), ""))
				{	soap_flag_doAsynchronous1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__removeCustomDefinitionRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeCustomDefinitionRequest, 0, sizeof(_ngwm__removeCustomDefinitionRequest), 0, soap_copy__ngwm__removeCustomDefinitionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__removeCustomDefinitionRequest * SOAP_FMAC6 soap_new__ngwm__removeCustomDefinitionRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__removeCustomDefinitionRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__removeCustomDefinitionRequest(struct soap *soap, _ngwm__removeCustomDefinitionRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__removeCustomDefinitionRequest * SOAP_FMAC6 soap_instantiate__ngwm__removeCustomDefinitionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__removeCustomDefinitionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__removeCustomDefinitionRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__removeCustomDefinitionRequest;
		if (size)
			*size = sizeof(_ngwm__removeCustomDefinitionRequest);
		((_ngwm__removeCustomDefinitionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__removeCustomDefinitionRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__removeCustomDefinitionRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__removeCustomDefinitionRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__removeCustomDefinitionRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__removeCustomDefinitionRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__removeCustomDefinitionRequest %p -> %p\n", q, p));
	*(_ngwm__removeCustomDefinitionRequest*)p = *(_ngwm__removeCustomDefinitionRequest*)q;
}

void _ngwm__readCursorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__readCursorResponse*)this)->items, SOAP_TYPE_PointerTongwt__ItemList);
	soap_serialize_PointerTongwt__ItemList(soap, &((_ngwm__readCursorResponse*)this)->items);
	soap_embedded(soap, &((_ngwm__readCursorResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__readCursorResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__readCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__readCursorResponse*)this)->items = NULL;
	((_ngwm__readCursorResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__readCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__readCursorResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__readCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__readCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__readCursorResponse(struct soap *soap, const char *tag, int id, const _ngwm__readCursorResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__readCursorResponse), type);
	soap_out_PointerTongwt__ItemList(soap, "ngwm:items", -1, &(((_ngwm__readCursorResponse*)a)->items), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__readCursorResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__readCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__readCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__readCursorResponse * SOAP_FMAC4 soap_get__ngwm__readCursorResponse(struct soap *soap, _ngwm__readCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__readCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__readCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__readCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__readCursorResponse * SOAP_FMAC4 soap_in__ngwm__readCursorResponse(struct soap *soap, const char *tag, _ngwm__readCursorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__readCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__readCursorResponse, sizeof(_ngwm__readCursorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__readCursorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__readCursorResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemList(soap, "ngwm:items", &(((_ngwm__readCursorResponse*)a)->items), "ngwt:ItemList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__readCursorResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__readCursorResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__readCursorResponse, 0, sizeof(_ngwm__readCursorResponse), 0, soap_copy__ngwm__readCursorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__readCursorResponse * SOAP_FMAC6 soap_new__ngwm__readCursorResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__readCursorResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__readCursorResponse(struct soap *soap, _ngwm__readCursorResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__readCursorResponse * SOAP_FMAC6 soap_instantiate__ngwm__readCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__readCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__readCursorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__readCursorResponse;
		if (size)
			*size = sizeof(_ngwm__readCursorResponse);
		((_ngwm__readCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__readCursorResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__readCursorResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__readCursorResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__readCursorResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__readCursorResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__readCursorResponse %p -> %p\n", q, p));
	*(_ngwm__readCursorResponse*)p = *(_ngwm__readCursorResponse*)q;
}

void _ngwm__readCursorRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__readCursorRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__readCursorRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__readCursorRequest*)this)->cursor, SOAP_TYPE_int);
	soap_embedded(soap, &((_ngwm__readCursorRequest*)this)->forward, SOAP_TYPE_bool);
	soap_embedded(soap, &((_ngwm__readCursorRequest*)this)->position, SOAP_TYPE_PointerTongwt__CursorSeek);
	soap_serialize_PointerTongwt__CursorSeek(soap, &((_ngwm__readCursorRequest*)this)->position);
	soap_embedded(soap, &((_ngwm__readCursorRequest*)this)->count, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((_ngwm__readCursorRequest*)this)->count);
	/* transient soap skipped */
}

void _ngwm__readCursorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__readCursorRequest*)this)->container);
	soap_default_int(soap, &((_ngwm__readCursorRequest*)this)->cursor);
	((_ngwm__readCursorRequest*)this)->forward = (bool)1;
	((_ngwm__readCursorRequest*)this)->position = NULL;
	((_ngwm__readCursorRequest*)this)->count = NULL;
	/* transient soap skipped */
}

int _ngwm__readCursorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__readCursorRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__readCursorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__readCursorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__readCursorRequest(struct soap *soap, const char *tag, int id, const _ngwm__readCursorRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__readCursorRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__readCursorRequest*)a)->container), "");
	soap_out_int(soap, "ngwm:cursor", -1, &(((_ngwm__readCursorRequest*)a)->cursor), "");
	soap_out_bool(soap, "ngwm:forward", -1, &(((_ngwm__readCursorRequest*)a)->forward), "");
	soap_out_PointerTongwt__CursorSeek(soap, "ngwm:position", -1, &(((_ngwm__readCursorRequest*)a)->position), "");
	soap_out_PointerToint(soap, "ngwm:count", -1, &(((_ngwm__readCursorRequest*)a)->count), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__readCursorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__readCursorRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__readCursorRequest * SOAP_FMAC4 soap_get__ngwm__readCursorRequest(struct soap *soap, _ngwm__readCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__readCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__readCursorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__readCursorRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__readCursorRequest * SOAP_FMAC4 soap_in__ngwm__readCursorRequest(struct soap *soap, const char *tag, _ngwm__readCursorRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__readCursorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__readCursorRequest, sizeof(_ngwm__readCursorRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__readCursorRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__readCursorRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_cursor1 = 1, soap_flag_forward1 = 1, soap_flag_position1 = 1, soap_flag_count1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__readCursorRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_cursor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwm:cursor", &(((_ngwm__readCursorRequest*)a)->cursor), ""))
				{	soap_flag_cursor1 = 0;
					continue;
				}
			if (soap_flag_forward1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwm:forward", &(((_ngwm__readCursorRequest*)a)->forward), ""))
				{	soap_flag_forward1 = 0;
					continue;
				}
			if (soap_flag_position1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CursorSeek(soap, "ngwm:position", &(((_ngwm__readCursorRequest*)a)->position), ""))
				{	soap_flag_position1 = 0;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwm:count", &(((_ngwm__readCursorRequest*)a)->count), ""))
				{	soap_flag_count1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_cursor1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__readCursorRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__readCursorRequest, 0, sizeof(_ngwm__readCursorRequest), 0, soap_copy__ngwm__readCursorRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__readCursorRequest * SOAP_FMAC6 soap_new__ngwm__readCursorRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__readCursorRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__readCursorRequest(struct soap *soap, _ngwm__readCursorRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__readCursorRequest * SOAP_FMAC6 soap_instantiate__ngwm__readCursorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__readCursorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__readCursorRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__readCursorRequest;
		if (size)
			*size = sizeof(_ngwm__readCursorRequest);
		((_ngwm__readCursorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__readCursorRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__readCursorRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__readCursorRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__readCursorRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__readCursorRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__readCursorRequest %p -> %p\n", q, p));
	*(_ngwm__readCursorRequest*)p = *(_ngwm__readCursorRequest*)q;
}

void _ngwm__purgeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__purgeResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__purgeResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__purgeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__purgeResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__purgeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__purgeResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__purgeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__purgeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__purgeResponse(struct soap *soap, const char *tag, int id, const _ngwm__purgeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__purgeResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__purgeResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__purgeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__purgeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__purgeResponse * SOAP_FMAC4 soap_get__ngwm__purgeResponse(struct soap *soap, _ngwm__purgeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__purgeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__purgeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__purgeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__purgeResponse * SOAP_FMAC4 soap_in__ngwm__purgeResponse(struct soap *soap, const char *tag, _ngwm__purgeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__purgeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__purgeResponse, sizeof(_ngwm__purgeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__purgeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__purgeResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__purgeResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__purgeResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__purgeResponse, 0, sizeof(_ngwm__purgeResponse), 0, soap_copy__ngwm__purgeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__purgeResponse * SOAP_FMAC6 soap_new__ngwm__purgeResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__purgeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__purgeResponse(struct soap *soap, _ngwm__purgeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__purgeResponse * SOAP_FMAC6 soap_instantiate__ngwm__purgeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__purgeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__purgeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__purgeResponse;
		if (size)
			*size = sizeof(_ngwm__purgeResponse);
		((_ngwm__purgeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__purgeResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__purgeResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__purgeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__purgeResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__purgeResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__purgeResponse %p -> %p\n", q, p));
	*(_ngwm__purgeResponse*)p = *(_ngwm__purgeResponse*)q;
}

void _ngwm__purgeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__purgeRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__purgeRequest*)this)->items);
	/* transient soap skipped */
}

void _ngwm__purgeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__purgeRequest*)this)->items = NULL;
	/* transient soap skipped */
}

int _ngwm__purgeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__purgeRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__purgeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__purgeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__purgeRequest(struct soap *soap, const char *tag, int id, const _ngwm__purgeRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__purgeRequest), type);
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__purgeRequest*)a)->items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__purgeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__purgeRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__purgeRequest * SOAP_FMAC4 soap_get__ngwm__purgeRequest(struct soap *soap, _ngwm__purgeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__purgeRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__purgeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__purgeRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__purgeRequest * SOAP_FMAC4 soap_in__ngwm__purgeRequest(struct soap *soap, const char *tag, _ngwm__purgeRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__purgeRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__purgeRequest, sizeof(_ngwm__purgeRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__purgeRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__purgeRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__purgeRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__purgeRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__purgeRequest, 0, sizeof(_ngwm__purgeRequest), 0, soap_copy__ngwm__purgeRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__purgeRequest * SOAP_FMAC6 soap_new__ngwm__purgeRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__purgeRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__purgeRequest(struct soap *soap, _ngwm__purgeRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__purgeRequest * SOAP_FMAC6 soap_instantiate__ngwm__purgeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__purgeRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__purgeRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__purgeRequest;
		if (size)
			*size = sizeof(_ngwm__purgeRequest);
		((_ngwm__purgeRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__purgeRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__purgeRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__purgeRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__purgeRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__purgeRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__purgeRequest %p -> %p\n", q, p));
	*(_ngwm__purgeRequest*)p = *(_ngwm__purgeRequest*)q;
}

void _ngwm__purgeDeletedItemsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__purgeDeletedItemsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__purgeDeletedItemsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__purgeDeletedItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__purgeDeletedItemsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__purgeDeletedItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__purgeDeletedItemsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__purgeDeletedItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__purgeDeletedItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__purgeDeletedItemsResponse(struct soap *soap, const char *tag, int id, const _ngwm__purgeDeletedItemsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__purgeDeletedItemsResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__purgeDeletedItemsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__purgeDeletedItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__purgeDeletedItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__purgeDeletedItemsResponse * SOAP_FMAC4 soap_get__ngwm__purgeDeletedItemsResponse(struct soap *soap, _ngwm__purgeDeletedItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__purgeDeletedItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__purgeDeletedItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__purgeDeletedItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__purgeDeletedItemsResponse * SOAP_FMAC4 soap_in__ngwm__purgeDeletedItemsResponse(struct soap *soap, const char *tag, _ngwm__purgeDeletedItemsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__purgeDeletedItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__purgeDeletedItemsResponse, sizeof(_ngwm__purgeDeletedItemsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__purgeDeletedItemsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__purgeDeletedItemsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__purgeDeletedItemsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__purgeDeletedItemsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__purgeDeletedItemsResponse, 0, sizeof(_ngwm__purgeDeletedItemsResponse), 0, soap_copy__ngwm__purgeDeletedItemsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__purgeDeletedItemsResponse * SOAP_FMAC6 soap_new__ngwm__purgeDeletedItemsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__purgeDeletedItemsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__purgeDeletedItemsResponse(struct soap *soap, _ngwm__purgeDeletedItemsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__purgeDeletedItemsResponse * SOAP_FMAC6 soap_instantiate__ngwm__purgeDeletedItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__purgeDeletedItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__purgeDeletedItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__purgeDeletedItemsResponse;
		if (size)
			*size = sizeof(_ngwm__purgeDeletedItemsResponse);
		((_ngwm__purgeDeletedItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__purgeDeletedItemsResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__purgeDeletedItemsResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__purgeDeletedItemsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__purgeDeletedItemsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__purgeDeletedItemsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__purgeDeletedItemsResponse %p -> %p\n", q, p));
	*(_ngwm__purgeDeletedItemsResponse*)p = *(_ngwm__purgeDeletedItemsResponse*)q;
}

void _ngwm__purgeDeletedItemsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ngwm__purgeDeletedItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ngwm__purgeDeletedItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__purgeDeletedItemsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__purgeDeletedItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__purgeDeletedItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__purgeDeletedItemsRequest(struct soap *soap, const char *tag, int id, const _ngwm__purgeDeletedItemsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__purgeDeletedItemsRequest), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__purgeDeletedItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__purgeDeletedItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__purgeDeletedItemsRequest * SOAP_FMAC4 soap_get__ngwm__purgeDeletedItemsRequest(struct soap *soap, _ngwm__purgeDeletedItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__purgeDeletedItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__purgeDeletedItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__purgeDeletedItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__purgeDeletedItemsRequest * SOAP_FMAC4 soap_in__ngwm__purgeDeletedItemsRequest(struct soap *soap, const char *tag, _ngwm__purgeDeletedItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__purgeDeletedItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__purgeDeletedItemsRequest, sizeof(_ngwm__purgeDeletedItemsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__purgeDeletedItemsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__purgeDeletedItemsRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__purgeDeletedItemsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__purgeDeletedItemsRequest, 0, sizeof(_ngwm__purgeDeletedItemsRequest), 0, soap_copy__ngwm__purgeDeletedItemsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__purgeDeletedItemsRequest * SOAP_FMAC6 soap_new__ngwm__purgeDeletedItemsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__purgeDeletedItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__purgeDeletedItemsRequest(struct soap *soap, _ngwm__purgeDeletedItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__purgeDeletedItemsRequest * SOAP_FMAC6 soap_instantiate__ngwm__purgeDeletedItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__purgeDeletedItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__purgeDeletedItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__purgeDeletedItemsRequest;
		if (size)
			*size = sizeof(_ngwm__purgeDeletedItemsRequest);
		((_ngwm__purgeDeletedItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__purgeDeletedItemsRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__purgeDeletedItemsRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__purgeDeletedItemsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__purgeDeletedItemsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__purgeDeletedItemsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__purgeDeletedItemsRequest %p -> %p\n", q, p));
	*(_ngwm__purgeDeletedItemsRequest*)p = *(_ngwm__purgeDeletedItemsRequest*)q;
}

void _ngwm__positionCursorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__positionCursorResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__positionCursorResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__positionCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__positionCursorResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__positionCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__positionCursorResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__positionCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__positionCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__positionCursorResponse(struct soap *soap, const char *tag, int id, const _ngwm__positionCursorResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__positionCursorResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__positionCursorResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__positionCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__positionCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__positionCursorResponse * SOAP_FMAC4 soap_get__ngwm__positionCursorResponse(struct soap *soap, _ngwm__positionCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__positionCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__positionCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__positionCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__positionCursorResponse * SOAP_FMAC4 soap_in__ngwm__positionCursorResponse(struct soap *soap, const char *tag, _ngwm__positionCursorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__positionCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__positionCursorResponse, sizeof(_ngwm__positionCursorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__positionCursorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__positionCursorResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__positionCursorResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__positionCursorResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__positionCursorResponse, 0, sizeof(_ngwm__positionCursorResponse), 0, soap_copy__ngwm__positionCursorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__positionCursorResponse * SOAP_FMAC6 soap_new__ngwm__positionCursorResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__positionCursorResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__positionCursorResponse(struct soap *soap, _ngwm__positionCursorResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__positionCursorResponse * SOAP_FMAC6 soap_instantiate__ngwm__positionCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__positionCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__positionCursorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__positionCursorResponse;
		if (size)
			*size = sizeof(_ngwm__positionCursorResponse);
		((_ngwm__positionCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__positionCursorResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__positionCursorResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__positionCursorResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__positionCursorResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__positionCursorResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__positionCursorResponse %p -> %p\n", q, p));
	*(_ngwm__positionCursorResponse*)p = *(_ngwm__positionCursorResponse*)q;
}

void _ngwm__positionCursorRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__positionCursorRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__positionCursorRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__positionCursorRequest*)this)->cursor, SOAP_TYPE_int);
	soap_embedded(soap, &((_ngwm__positionCursorRequest*)this)->seek, SOAP_TYPE_ngwt__CursorSeek);
	soap_embedded(soap, &((_ngwm__positionCursorRequest*)this)->offset, SOAP_TYPE_int);
	/* transient soap skipped */
}

void _ngwm__positionCursorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__positionCursorRequest*)this)->container);
	soap_default_int(soap, &((_ngwm__positionCursorRequest*)this)->cursor);
	soap_default_ngwt__CursorSeek(soap, &((_ngwm__positionCursorRequest*)this)->seek);
	soap_default_int(soap, &((_ngwm__positionCursorRequest*)this)->offset);
	/* transient soap skipped */
}

int _ngwm__positionCursorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__positionCursorRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__positionCursorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__positionCursorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__positionCursorRequest(struct soap *soap, const char *tag, int id, const _ngwm__positionCursorRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__positionCursorRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__positionCursorRequest*)a)->container), "");
	soap_out_int(soap, "ngwm:cursor", -1, &(((_ngwm__positionCursorRequest*)a)->cursor), "");
	soap_out_ngwt__CursorSeek(soap, "ngwm:seek", -1, &(((_ngwm__positionCursorRequest*)a)->seek), "");
	soap_out_int(soap, "ngwm:offset", -1, &(((_ngwm__positionCursorRequest*)a)->offset), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__positionCursorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__positionCursorRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__positionCursorRequest * SOAP_FMAC4 soap_get__ngwm__positionCursorRequest(struct soap *soap, _ngwm__positionCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__positionCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__positionCursorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__positionCursorRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__positionCursorRequest * SOAP_FMAC4 soap_in__ngwm__positionCursorRequest(struct soap *soap, const char *tag, _ngwm__positionCursorRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__positionCursorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__positionCursorRequest, sizeof(_ngwm__positionCursorRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__positionCursorRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__positionCursorRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_cursor1 = 1, soap_flag_seek1 = 1, soap_flag_offset1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__positionCursorRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_cursor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwm:cursor", &(((_ngwm__positionCursorRequest*)a)->cursor), ""))
				{	soap_flag_cursor1 = 0;
					continue;
				}
			if (soap_flag_seek1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__CursorSeek(soap, "ngwm:seek", &(((_ngwm__positionCursorRequest*)a)->seek), ""))
				{	soap_flag_seek1 = 0;
					continue;
				}
			if (soap_flag_offset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwm:offset", &(((_ngwm__positionCursorRequest*)a)->offset), ""))
				{	soap_flag_offset1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_cursor1 || soap_flag_seek1 || soap_flag_offset1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__positionCursorRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__positionCursorRequest, 0, sizeof(_ngwm__positionCursorRequest), 0, soap_copy__ngwm__positionCursorRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__positionCursorRequest * SOAP_FMAC6 soap_new__ngwm__positionCursorRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__positionCursorRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__positionCursorRequest(struct soap *soap, _ngwm__positionCursorRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__positionCursorRequest * SOAP_FMAC6 soap_instantiate__ngwm__positionCursorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__positionCursorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__positionCursorRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__positionCursorRequest;
		if (size)
			*size = sizeof(_ngwm__positionCursorRequest);
		((_ngwm__positionCursorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__positionCursorRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__positionCursorRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__positionCursorRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__positionCursorRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__positionCursorRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__positionCursorRequest %p -> %p\n", q, p));
	*(_ngwm__positionCursorRequest*)p = *(_ngwm__positionCursorRequest*)q;
}

void _ngwm__moveItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__moveItemResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__moveItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__moveItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__moveItemResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__moveItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__moveItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__moveItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__moveItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__moveItemResponse(struct soap *soap, const char *tag, int id, const _ngwm__moveItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__moveItemResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__moveItemResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__moveItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__moveItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__moveItemResponse * SOAP_FMAC4 soap_get__ngwm__moveItemResponse(struct soap *soap, _ngwm__moveItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__moveItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__moveItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__moveItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__moveItemResponse * SOAP_FMAC4 soap_in__ngwm__moveItemResponse(struct soap *soap, const char *tag, _ngwm__moveItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__moveItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__moveItemResponse, sizeof(_ngwm__moveItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__moveItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__moveItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__moveItemResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__moveItemResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__moveItemResponse, 0, sizeof(_ngwm__moveItemResponse), 0, soap_copy__ngwm__moveItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__moveItemResponse * SOAP_FMAC6 soap_new__ngwm__moveItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__moveItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__moveItemResponse(struct soap *soap, _ngwm__moveItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__moveItemResponse * SOAP_FMAC6 soap_instantiate__ngwm__moveItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__moveItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__moveItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__moveItemResponse;
		if (size)
			*size = sizeof(_ngwm__moveItemResponse);
		((_ngwm__moveItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__moveItemResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__moveItemResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__moveItemResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__moveItemResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__moveItemResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__moveItemResponse %p -> %p\n", q, p));
	*(_ngwm__moveItemResponse*)p = *(_ngwm__moveItemResponse*)q;
}

void _ngwm__moveItemRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__moveItemRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__moveItemRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__moveItemRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__moveItemRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__moveItemRequest*)this)->from, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((_ngwm__moveItemRequest*)this)->from);
	/* transient soap skipped */
}

void _ngwm__moveItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__moveItemRequest*)this)->id);
	soap_default_ngwt__uid(soap, &((_ngwm__moveItemRequest*)this)->container);
	((_ngwm__moveItemRequest*)this)->from = NULL;
	/* transient soap skipped */
}

int _ngwm__moveItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__moveItemRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__moveItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__moveItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__moveItemRequest(struct soap *soap, const char *tag, int id, const _ngwm__moveItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__moveItemRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__moveItemRequest*)a)->id), "");
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__moveItemRequest*)a)->container), "");
	soap_out_PointerTongwt__uid(soap, "ngwm:from", -1, &(((_ngwm__moveItemRequest*)a)->from), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__moveItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__moveItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__moveItemRequest * SOAP_FMAC4 soap_get__ngwm__moveItemRequest(struct soap *soap, _ngwm__moveItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__moveItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__moveItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__moveItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__moveItemRequest * SOAP_FMAC4 soap_in__ngwm__moveItemRequest(struct soap *soap, const char *tag, _ngwm__moveItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__moveItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__moveItemRequest, sizeof(_ngwm__moveItemRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__moveItemRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__moveItemRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_container1 = 1, soap_flag_from1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__moveItemRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__moveItemRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_from1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwm:from", &(((_ngwm__moveItemRequest*)a)->from), "ngwt:uid"))
				{	soap_flag_from1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_container1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__moveItemRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__moveItemRequest, 0, sizeof(_ngwm__moveItemRequest), 0, soap_copy__ngwm__moveItemRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__moveItemRequest * SOAP_FMAC6 soap_new__ngwm__moveItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__moveItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__moveItemRequest(struct soap *soap, _ngwm__moveItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__moveItemRequest * SOAP_FMAC6 soap_instantiate__ngwm__moveItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__moveItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__moveItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__moveItemRequest;
		if (size)
			*size = sizeof(_ngwm__moveItemRequest);
		((_ngwm__moveItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__moveItemRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__moveItemRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__moveItemRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__moveItemRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__moveItemRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__moveItemRequest %p -> %p\n", q, p));
	*(_ngwm__moveItemRequest*)p = *(_ngwm__moveItemRequest*)q;
}

void _ngwm__modifySignaturesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifySignaturesResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__modifySignaturesResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__modifySignaturesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__modifySignaturesResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__modifySignaturesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifySignaturesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifySignaturesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifySignaturesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifySignaturesResponse(struct soap *soap, const char *tag, int id, const _ngwm__modifySignaturesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifySignaturesResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__modifySignaturesResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifySignaturesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifySignaturesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifySignaturesResponse * SOAP_FMAC4 soap_get__ngwm__modifySignaturesResponse(struct soap *soap, _ngwm__modifySignaturesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifySignaturesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifySignaturesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifySignaturesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifySignaturesResponse * SOAP_FMAC4 soap_in__ngwm__modifySignaturesResponse(struct soap *soap, const char *tag, _ngwm__modifySignaturesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifySignaturesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifySignaturesResponse, sizeof(_ngwm__modifySignaturesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifySignaturesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifySignaturesResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__modifySignaturesResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifySignaturesResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifySignaturesResponse, 0, sizeof(_ngwm__modifySignaturesResponse), 0, soap_copy__ngwm__modifySignaturesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifySignaturesResponse * SOAP_FMAC6 soap_new__ngwm__modifySignaturesResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifySignaturesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifySignaturesResponse(struct soap *soap, _ngwm__modifySignaturesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifySignaturesResponse * SOAP_FMAC6 soap_instantiate__ngwm__modifySignaturesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifySignaturesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifySignaturesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifySignaturesResponse;
		if (size)
			*size = sizeof(_ngwm__modifySignaturesResponse);
		((_ngwm__modifySignaturesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifySignaturesResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__modifySignaturesResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__modifySignaturesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifySignaturesResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifySignaturesResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifySignaturesResponse %p -> %p\n", q, p));
	*(_ngwm__modifySignaturesResponse*)p = *(_ngwm__modifySignaturesResponse*)q;
}

void _ngwm__modifySignaturesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifySignaturesRequest*)this)->updates, SOAP_TYPE_PointerTongwt__Signatures);
	soap_serialize_PointerTongwt__Signatures(soap, &((_ngwm__modifySignaturesRequest*)this)->updates);
	/* transient soap skipped */
}

void _ngwm__modifySignaturesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__modifySignaturesRequest*)this)->updates = NULL;
	/* transient soap skipped */
}

int _ngwm__modifySignaturesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifySignaturesRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifySignaturesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifySignaturesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifySignaturesRequest(struct soap *soap, const char *tag, int id, const _ngwm__modifySignaturesRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifySignaturesRequest), type);
	soap_out_PointerTongwt__Signatures(soap, "ngwm:updates", -1, &(((_ngwm__modifySignaturesRequest*)a)->updates), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifySignaturesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifySignaturesRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifySignaturesRequest * SOAP_FMAC4 soap_get__ngwm__modifySignaturesRequest(struct soap *soap, _ngwm__modifySignaturesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifySignaturesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifySignaturesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifySignaturesRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifySignaturesRequest * SOAP_FMAC4 soap_in__ngwm__modifySignaturesRequest(struct soap *soap, const char *tag, _ngwm__modifySignaturesRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifySignaturesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifySignaturesRequest, sizeof(_ngwm__modifySignaturesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifySignaturesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifySignaturesRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_updates1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_updates1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Signatures(soap, "ngwm:updates", &(((_ngwm__modifySignaturesRequest*)a)->updates), "ngwt:Signatures"))
				{	soap_flag_updates1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_updates1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifySignaturesRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifySignaturesRequest, 0, sizeof(_ngwm__modifySignaturesRequest), 0, soap_copy__ngwm__modifySignaturesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifySignaturesRequest * SOAP_FMAC6 soap_new__ngwm__modifySignaturesRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifySignaturesRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifySignaturesRequest(struct soap *soap, _ngwm__modifySignaturesRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifySignaturesRequest * SOAP_FMAC6 soap_instantiate__ngwm__modifySignaturesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifySignaturesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifySignaturesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifySignaturesRequest;
		if (size)
			*size = sizeof(_ngwm__modifySignaturesRequest);
		((_ngwm__modifySignaturesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifySignaturesRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__modifySignaturesRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__modifySignaturesRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifySignaturesRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifySignaturesRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifySignaturesRequest %p -> %p\n", q, p));
	*(_ngwm__modifySignaturesRequest*)p = *(_ngwm__modifySignaturesRequest*)q;
}

void _ngwm__modifySettingsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifySettingsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__modifySettingsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__modifySettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__modifySettingsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__modifySettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifySettingsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifySettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifySettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifySettingsResponse(struct soap *soap, const char *tag, int id, const _ngwm__modifySettingsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifySettingsResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__modifySettingsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifySettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifySettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifySettingsResponse * SOAP_FMAC4 soap_get__ngwm__modifySettingsResponse(struct soap *soap, _ngwm__modifySettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifySettingsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifySettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifySettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifySettingsResponse * SOAP_FMAC4 soap_in__ngwm__modifySettingsResponse(struct soap *soap, const char *tag, _ngwm__modifySettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifySettingsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifySettingsResponse, sizeof(_ngwm__modifySettingsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifySettingsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifySettingsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__modifySettingsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifySettingsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifySettingsResponse, 0, sizeof(_ngwm__modifySettingsResponse), 0, soap_copy__ngwm__modifySettingsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifySettingsResponse * SOAP_FMAC6 soap_new__ngwm__modifySettingsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifySettingsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifySettingsResponse(struct soap *soap, _ngwm__modifySettingsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifySettingsResponse * SOAP_FMAC6 soap_instantiate__ngwm__modifySettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifySettingsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifySettingsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifySettingsResponse;
		if (size)
			*size = sizeof(_ngwm__modifySettingsResponse);
		((_ngwm__modifySettingsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifySettingsResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__modifySettingsResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__modifySettingsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifySettingsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifySettingsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifySettingsResponse %p -> %p\n", q, p));
	*(_ngwm__modifySettingsResponse*)p = *(_ngwm__modifySettingsResponse*)q;
}

void _ngwm__modifySettingsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifySettingsRequest*)this)->settings, SOAP_TYPE_PointerTongwt__SettingsList);
	soap_serialize_PointerTongwt__SettingsList(soap, &((_ngwm__modifySettingsRequest*)this)->settings);
	/* transient soap skipped */
}

void _ngwm__modifySettingsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__modifySettingsRequest*)this)->settings = NULL;
	/* transient soap skipped */
}

int _ngwm__modifySettingsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifySettingsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifySettingsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifySettingsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifySettingsRequest(struct soap *soap, const char *tag, int id, const _ngwm__modifySettingsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifySettingsRequest), type);
	soap_out_PointerTongwt__SettingsList(soap, "ngwm:settings", -1, &(((_ngwm__modifySettingsRequest*)a)->settings), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifySettingsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifySettingsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifySettingsRequest * SOAP_FMAC4 soap_get__ngwm__modifySettingsRequest(struct soap *soap, _ngwm__modifySettingsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifySettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifySettingsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifySettingsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifySettingsRequest * SOAP_FMAC4 soap_in__ngwm__modifySettingsRequest(struct soap *soap, const char *tag, _ngwm__modifySettingsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifySettingsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifySettingsRequest, sizeof(_ngwm__modifySettingsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifySettingsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifySettingsRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_settings1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_settings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SettingsList(soap, "ngwm:settings", &(((_ngwm__modifySettingsRequest*)a)->settings), "ngwt:SettingsList"))
				{	soap_flag_settings1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_settings1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifySettingsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifySettingsRequest, 0, sizeof(_ngwm__modifySettingsRequest), 0, soap_copy__ngwm__modifySettingsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifySettingsRequest * SOAP_FMAC6 soap_new__ngwm__modifySettingsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifySettingsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifySettingsRequest(struct soap *soap, _ngwm__modifySettingsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifySettingsRequest * SOAP_FMAC6 soap_instantiate__ngwm__modifySettingsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifySettingsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifySettingsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifySettingsRequest;
		if (size)
			*size = sizeof(_ngwm__modifySettingsRequest);
		((_ngwm__modifySettingsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifySettingsRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__modifySettingsRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__modifySettingsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifySettingsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifySettingsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifySettingsRequest %p -> %p\n", q, p));
	*(_ngwm__modifySettingsRequest*)p = *(_ngwm__modifySettingsRequest*)q;
}

void _ngwm__modifyProxyAccessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifyProxyAccessResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__modifyProxyAccessResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__modifyProxyAccessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__modifyProxyAccessResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__modifyProxyAccessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyProxyAccessResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyProxyAccessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyProxyAccessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyProxyAccessResponse(struct soap *soap, const char *tag, int id, const _ngwm__modifyProxyAccessResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyProxyAccessResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__modifyProxyAccessResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyProxyAccessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyProxyAccessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyProxyAccessResponse * SOAP_FMAC4 soap_get__ngwm__modifyProxyAccessResponse(struct soap *soap, _ngwm__modifyProxyAccessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyProxyAccessResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyProxyAccessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyProxyAccessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyProxyAccessResponse * SOAP_FMAC4 soap_in__ngwm__modifyProxyAccessResponse(struct soap *soap, const char *tag, _ngwm__modifyProxyAccessResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyProxyAccessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyProxyAccessResponse, sizeof(_ngwm__modifyProxyAccessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyProxyAccessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyProxyAccessResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__modifyProxyAccessResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyProxyAccessResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyProxyAccessResponse, 0, sizeof(_ngwm__modifyProxyAccessResponse), 0, soap_copy__ngwm__modifyProxyAccessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyProxyAccessResponse * SOAP_FMAC6 soap_new__ngwm__modifyProxyAccessResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyProxyAccessResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyProxyAccessResponse(struct soap *soap, _ngwm__modifyProxyAccessResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyProxyAccessResponse * SOAP_FMAC6 soap_instantiate__ngwm__modifyProxyAccessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyProxyAccessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyProxyAccessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyProxyAccessResponse;
		if (size)
			*size = sizeof(_ngwm__modifyProxyAccessResponse);
		((_ngwm__modifyProxyAccessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyProxyAccessResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyProxyAccessResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyProxyAccessResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyProxyAccessResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyProxyAccessResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyProxyAccessResponse %p -> %p\n", q, p));
	*(_ngwm__modifyProxyAccessResponse*)p = *(_ngwm__modifyProxyAccessResponse*)q;
}

void _ngwm__modifyProxyAccessRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifyProxyAccessRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__modifyProxyAccessRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__modifyProxyAccessRequest*)this)->updates, SOAP_TYPE_PointerTongwt__AccessRightChanges);
	soap_serialize_PointerTongwt__AccessRightChanges(soap, &((_ngwm__modifyProxyAccessRequest*)this)->updates);
	/* transient soap skipped */
}

void _ngwm__modifyProxyAccessRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__modifyProxyAccessRequest*)this)->id);
	((_ngwm__modifyProxyAccessRequest*)this)->updates = NULL;
	/* transient soap skipped */
}

int _ngwm__modifyProxyAccessRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyProxyAccessRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyProxyAccessRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyProxyAccessRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyProxyAccessRequest(struct soap *soap, const char *tag, int id, const _ngwm__modifyProxyAccessRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyProxyAccessRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__modifyProxyAccessRequest*)a)->id), "");
	soap_out_PointerTongwt__AccessRightChanges(soap, "ngwm:updates", -1, &(((_ngwm__modifyProxyAccessRequest*)a)->updates), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyProxyAccessRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyProxyAccessRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyProxyAccessRequest * SOAP_FMAC4 soap_get__ngwm__modifyProxyAccessRequest(struct soap *soap, _ngwm__modifyProxyAccessRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyProxyAccessRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyProxyAccessRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyProxyAccessRequest * SOAP_FMAC4 soap_in__ngwm__modifyProxyAccessRequest(struct soap *soap, const char *tag, _ngwm__modifyProxyAccessRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyProxyAccessRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyProxyAccessRequest, sizeof(_ngwm__modifyProxyAccessRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyProxyAccessRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyProxyAccessRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_updates1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__modifyProxyAccessRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_updates1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessRightChanges(soap, "ngwm:updates", &(((_ngwm__modifyProxyAccessRequest*)a)->updates), "ngwt:AccessRightChanges"))
				{	soap_flag_updates1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_updates1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyProxyAccessRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyProxyAccessRequest, 0, sizeof(_ngwm__modifyProxyAccessRequest), 0, soap_copy__ngwm__modifyProxyAccessRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyProxyAccessRequest * SOAP_FMAC6 soap_new__ngwm__modifyProxyAccessRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyProxyAccessRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyProxyAccessRequest(struct soap *soap, _ngwm__modifyProxyAccessRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyProxyAccessRequest * SOAP_FMAC6 soap_instantiate__ngwm__modifyProxyAccessRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyProxyAccessRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyProxyAccessRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyProxyAccessRequest;
		if (size)
			*size = sizeof(_ngwm__modifyProxyAccessRequest);
		((_ngwm__modifyProxyAccessRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyProxyAccessRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyProxyAccessRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyProxyAccessRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyProxyAccessRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyProxyAccessRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyProxyAccessRequest %p -> %p\n", q, p));
	*(_ngwm__modifyProxyAccessRequest*)p = *(_ngwm__modifyProxyAccessRequest*)q;
}

void _ngwm__modifyPasswordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifyPasswordResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__modifyPasswordResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__modifyPasswordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__modifyPasswordResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__modifyPasswordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyPasswordResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyPasswordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyPasswordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyPasswordResponse(struct soap *soap, const char *tag, int id, const _ngwm__modifyPasswordResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyPasswordResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__modifyPasswordResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyPasswordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyPasswordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyPasswordResponse * SOAP_FMAC4 soap_get__ngwm__modifyPasswordResponse(struct soap *soap, _ngwm__modifyPasswordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyPasswordResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyPasswordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyPasswordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyPasswordResponse * SOAP_FMAC4 soap_in__ngwm__modifyPasswordResponse(struct soap *soap, const char *tag, _ngwm__modifyPasswordResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyPasswordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyPasswordResponse, sizeof(_ngwm__modifyPasswordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyPasswordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyPasswordResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__modifyPasswordResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyPasswordResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyPasswordResponse, 0, sizeof(_ngwm__modifyPasswordResponse), 0, soap_copy__ngwm__modifyPasswordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyPasswordResponse * SOAP_FMAC6 soap_new__ngwm__modifyPasswordResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyPasswordResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyPasswordResponse(struct soap *soap, _ngwm__modifyPasswordResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyPasswordResponse * SOAP_FMAC6 soap_instantiate__ngwm__modifyPasswordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyPasswordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyPasswordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyPasswordResponse;
		if (size)
			*size = sizeof(_ngwm__modifyPasswordResponse);
		((_ngwm__modifyPasswordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyPasswordResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyPasswordResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyPasswordResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyPasswordResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyPasswordResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyPasswordResponse %p -> %p\n", q, p));
	*(_ngwm__modifyPasswordResponse*)p = *(_ngwm__modifyPasswordResponse*)q;
}

void _ngwm__modifyPasswordRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifyPasswordRequest*)this)->old, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__modifyPasswordRequest*)this)->old);
	soap_embedded(soap, &((_ngwm__modifyPasswordRequest*)this)->_new, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__modifyPasswordRequest*)this)->_new);
	/* transient soap skipped */
}

void _ngwm__modifyPasswordRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__modifyPasswordRequest*)this)->old = NULL;
	((_ngwm__modifyPasswordRequest*)this)->_new = NULL;
	/* transient soap skipped */
}

int _ngwm__modifyPasswordRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyPasswordRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyPasswordRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyPasswordRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyPasswordRequest(struct soap *soap, const char *tag, int id, const _ngwm__modifyPasswordRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyPasswordRequest), type);
	soap_out_PointerTostd__string(soap, "ngwm:old", -1, &(((_ngwm__modifyPasswordRequest*)a)->old), "");
	soap_out_PointerTostd__string(soap, "ngwm:new", -1, &(((_ngwm__modifyPasswordRequest*)a)->_new), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyPasswordRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyPasswordRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyPasswordRequest * SOAP_FMAC4 soap_get__ngwm__modifyPasswordRequest(struct soap *soap, _ngwm__modifyPasswordRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyPasswordRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyPasswordRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyPasswordRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyPasswordRequest * SOAP_FMAC4 soap_in__ngwm__modifyPasswordRequest(struct soap *soap, const char *tag, _ngwm__modifyPasswordRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyPasswordRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyPasswordRequest, sizeof(_ngwm__modifyPasswordRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyPasswordRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyPasswordRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_old1 = 1, soap_flag_new1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_old1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:old", &(((_ngwm__modifyPasswordRequest*)a)->old), ""))
				{	soap_flag_old1 = 0;
					continue;
				}
			if (soap_flag_new1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:new", &(((_ngwm__modifyPasswordRequest*)a)->_new), ""))
				{	soap_flag_new1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyPasswordRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyPasswordRequest, 0, sizeof(_ngwm__modifyPasswordRequest), 0, soap_copy__ngwm__modifyPasswordRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyPasswordRequest * SOAP_FMAC6 soap_new__ngwm__modifyPasswordRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyPasswordRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyPasswordRequest(struct soap *soap, _ngwm__modifyPasswordRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyPasswordRequest * SOAP_FMAC6 soap_instantiate__ngwm__modifyPasswordRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyPasswordRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyPasswordRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyPasswordRequest;
		if (size)
			*size = sizeof(_ngwm__modifyPasswordRequest);
		((_ngwm__modifyPasswordRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyPasswordRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyPasswordRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyPasswordRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyPasswordRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyPasswordRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyPasswordRequest %p -> %p\n", q, p));
	*(_ngwm__modifyPasswordRequest*)p = *(_ngwm__modifyPasswordRequest*)q;
}

void _ngwm__modifyJunkMailSettingsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifyJunkMailSettingsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__modifyJunkMailSettingsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__modifyJunkMailSettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__modifyJunkMailSettingsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__modifyJunkMailSettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyJunkMailSettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyJunkMailSettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyJunkMailSettingsResponse(struct soap *soap, const char *tag, int id, const _ngwm__modifyJunkMailSettingsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__modifyJunkMailSettingsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyJunkMailSettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyJunkMailSettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyJunkMailSettingsResponse * SOAP_FMAC4 soap_get__ngwm__modifyJunkMailSettingsResponse(struct soap *soap, _ngwm__modifyJunkMailSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyJunkMailSettingsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyJunkMailSettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyJunkMailSettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyJunkMailSettingsResponse * SOAP_FMAC4 soap_in__ngwm__modifyJunkMailSettingsResponse(struct soap *soap, const char *tag, _ngwm__modifyJunkMailSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyJunkMailSettingsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse, sizeof(_ngwm__modifyJunkMailSettingsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyJunkMailSettingsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__modifyJunkMailSettingsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyJunkMailSettingsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse, 0, sizeof(_ngwm__modifyJunkMailSettingsResponse), 0, soap_copy__ngwm__modifyJunkMailSettingsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyJunkMailSettingsResponse * SOAP_FMAC6 soap_new__ngwm__modifyJunkMailSettingsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyJunkMailSettingsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyJunkMailSettingsResponse(struct soap *soap, _ngwm__modifyJunkMailSettingsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyJunkMailSettingsResponse * SOAP_FMAC6 soap_instantiate__ngwm__modifyJunkMailSettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyJunkMailSettingsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyJunkMailSettingsResponse;
		if (size)
			*size = sizeof(_ngwm__modifyJunkMailSettingsResponse);
		((_ngwm__modifyJunkMailSettingsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyJunkMailSettingsResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyJunkMailSettingsResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyJunkMailSettingsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyJunkMailSettingsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyJunkMailSettingsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyJunkMailSettingsResponse %p -> %p\n", q, p));
	*(_ngwm__modifyJunkMailSettingsResponse*)p = *(_ngwm__modifyJunkMailSettingsResponse*)q;
}

void _ngwm__modifyJunkMailSettingsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifyJunkMailSettingsRequest*)this)->settings, SOAP_TYPE_PointerTongwt__SettingsList);
	soap_serialize_PointerTongwt__SettingsList(soap, &((_ngwm__modifyJunkMailSettingsRequest*)this)->settings);
	/* transient soap skipped */
}

void _ngwm__modifyJunkMailSettingsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__modifyJunkMailSettingsRequest*)this)->settings = NULL;
	/* transient soap skipped */
}

int _ngwm__modifyJunkMailSettingsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyJunkMailSettingsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyJunkMailSettingsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyJunkMailSettingsRequest(struct soap *soap, const char *tag, int id, const _ngwm__modifyJunkMailSettingsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest), type);
	soap_out_PointerTongwt__SettingsList(soap, "ngwm:settings", -1, &(((_ngwm__modifyJunkMailSettingsRequest*)a)->settings), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyJunkMailSettingsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyJunkMailSettingsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyJunkMailSettingsRequest * SOAP_FMAC4 soap_get__ngwm__modifyJunkMailSettingsRequest(struct soap *soap, _ngwm__modifyJunkMailSettingsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyJunkMailSettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyJunkMailSettingsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyJunkMailSettingsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyJunkMailSettingsRequest * SOAP_FMAC4 soap_in__ngwm__modifyJunkMailSettingsRequest(struct soap *soap, const char *tag, _ngwm__modifyJunkMailSettingsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyJunkMailSettingsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest, sizeof(_ngwm__modifyJunkMailSettingsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyJunkMailSettingsRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_settings1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_settings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SettingsList(soap, "ngwm:settings", &(((_ngwm__modifyJunkMailSettingsRequest*)a)->settings), "ngwt:SettingsList"))
				{	soap_flag_settings1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_settings1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyJunkMailSettingsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest, 0, sizeof(_ngwm__modifyJunkMailSettingsRequest), 0, soap_copy__ngwm__modifyJunkMailSettingsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyJunkMailSettingsRequest * SOAP_FMAC6 soap_new__ngwm__modifyJunkMailSettingsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyJunkMailSettingsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyJunkMailSettingsRequest(struct soap *soap, _ngwm__modifyJunkMailSettingsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyJunkMailSettingsRequest * SOAP_FMAC6 soap_instantiate__ngwm__modifyJunkMailSettingsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyJunkMailSettingsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyJunkMailSettingsRequest;
		if (size)
			*size = sizeof(_ngwm__modifyJunkMailSettingsRequest);
		((_ngwm__modifyJunkMailSettingsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyJunkMailSettingsRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyJunkMailSettingsRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyJunkMailSettingsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyJunkMailSettingsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyJunkMailSettingsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyJunkMailSettingsRequest %p -> %p\n", q, p));
	*(_ngwm__modifyJunkMailSettingsRequest*)p = *(_ngwm__modifyJunkMailSettingsRequest*)q;
}

void _ngwm__modifyJunkEntryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifyJunkEntryResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__modifyJunkEntryResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__modifyJunkEntryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__modifyJunkEntryResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__modifyJunkEntryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyJunkEntryResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyJunkEntryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyJunkEntryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyJunkEntryResponse(struct soap *soap, const char *tag, int id, const _ngwm__modifyJunkEntryResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyJunkEntryResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__modifyJunkEntryResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyJunkEntryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyJunkEntryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyJunkEntryResponse * SOAP_FMAC4 soap_get__ngwm__modifyJunkEntryResponse(struct soap *soap, _ngwm__modifyJunkEntryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyJunkEntryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyJunkEntryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyJunkEntryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyJunkEntryResponse * SOAP_FMAC4 soap_in__ngwm__modifyJunkEntryResponse(struct soap *soap, const char *tag, _ngwm__modifyJunkEntryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyJunkEntryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyJunkEntryResponse, sizeof(_ngwm__modifyJunkEntryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyJunkEntryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyJunkEntryResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__modifyJunkEntryResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyJunkEntryResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyJunkEntryResponse, 0, sizeof(_ngwm__modifyJunkEntryResponse), 0, soap_copy__ngwm__modifyJunkEntryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyJunkEntryResponse * SOAP_FMAC6 soap_new__ngwm__modifyJunkEntryResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyJunkEntryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyJunkEntryResponse(struct soap *soap, _ngwm__modifyJunkEntryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyJunkEntryResponse * SOAP_FMAC6 soap_instantiate__ngwm__modifyJunkEntryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyJunkEntryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyJunkEntryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyJunkEntryResponse;
		if (size)
			*size = sizeof(_ngwm__modifyJunkEntryResponse);
		((_ngwm__modifyJunkEntryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyJunkEntryResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyJunkEntryResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyJunkEntryResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyJunkEntryResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyJunkEntryResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyJunkEntryResponse %p -> %p\n", q, p));
	*(_ngwm__modifyJunkEntryResponse*)p = *(_ngwm__modifyJunkEntryResponse*)q;
}

void _ngwm__modifyJunkEntryRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifyJunkEntryRequest*)this)->entry, SOAP_TYPE_PointerTongwt__JunkEntry);
	soap_serialize_PointerTongwt__JunkEntry(soap, &((_ngwm__modifyJunkEntryRequest*)this)->entry);
	/* transient soap skipped */
}

void _ngwm__modifyJunkEntryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__modifyJunkEntryRequest*)this)->entry = NULL;
	/* transient soap skipped */
}

int _ngwm__modifyJunkEntryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyJunkEntryRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyJunkEntryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyJunkEntryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyJunkEntryRequest(struct soap *soap, const char *tag, int id, const _ngwm__modifyJunkEntryRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyJunkEntryRequest), type);
	soap_out_PointerTongwt__JunkEntry(soap, "ngwm:entry", -1, &(((_ngwm__modifyJunkEntryRequest*)a)->entry), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyJunkEntryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyJunkEntryRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyJunkEntryRequest * SOAP_FMAC4 soap_get__ngwm__modifyJunkEntryRequest(struct soap *soap, _ngwm__modifyJunkEntryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyJunkEntryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyJunkEntryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyJunkEntryRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyJunkEntryRequest * SOAP_FMAC4 soap_in__ngwm__modifyJunkEntryRequest(struct soap *soap, const char *tag, _ngwm__modifyJunkEntryRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyJunkEntryRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyJunkEntryRequest, sizeof(_ngwm__modifyJunkEntryRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyJunkEntryRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyJunkEntryRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_entry1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__JunkEntry(soap, "ngwm:entry", &(((_ngwm__modifyJunkEntryRequest*)a)->entry), "ngwt:JunkEntry"))
				{	soap_flag_entry1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyJunkEntryRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyJunkEntryRequest, 0, sizeof(_ngwm__modifyJunkEntryRequest), 0, soap_copy__ngwm__modifyJunkEntryRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyJunkEntryRequest * SOAP_FMAC6 soap_new__ngwm__modifyJunkEntryRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyJunkEntryRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyJunkEntryRequest(struct soap *soap, _ngwm__modifyJunkEntryRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyJunkEntryRequest * SOAP_FMAC6 soap_instantiate__ngwm__modifyJunkEntryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyJunkEntryRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyJunkEntryRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyJunkEntryRequest;
		if (size)
			*size = sizeof(_ngwm__modifyJunkEntryRequest);
		((_ngwm__modifyJunkEntryRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyJunkEntryRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyJunkEntryRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyJunkEntryRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyJunkEntryRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyJunkEntryRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyJunkEntryRequest %p -> %p\n", q, p));
	*(_ngwm__modifyJunkEntryRequest*)p = *(_ngwm__modifyJunkEntryRequest*)q;
}

void _ngwm__modifyItemsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstring(soap, &((_ngwm__modifyItemsResponse*)this)->ngwt__modified);
	soap_serialize_std__vectorTemplateOfngwt__uid(soap, &((_ngwm__modifyItemsResponse*)this)->id);
	soap_embedded(soap, &((_ngwm__modifyItemsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__modifyItemsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__modifyItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstring(soap, &((_ngwm__modifyItemsResponse*)this)->ngwt__modified);
	soap_default_std__vectorTemplateOfngwt__uid(soap, &((_ngwm__modifyItemsResponse*)this)->id);
	((_ngwm__modifyItemsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__modifyItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyItemsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyItemsResponse(struct soap *soap, const char *tag, int id, const _ngwm__modifyItemsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyItemsResponse), type);
	soap_out_std__vectorTemplateOfstring(soap, "ngwt:modified", -1, &(((_ngwm__modifyItemsResponse*)a)->ngwt__modified), "");
	soap_out_std__vectorTemplateOfngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__modifyItemsResponse*)a)->id), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__modifyItemsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyItemsResponse * SOAP_FMAC4 soap_get__ngwm__modifyItemsResponse(struct soap *soap, _ngwm__modifyItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyItemsResponse * SOAP_FMAC4 soap_in__ngwm__modifyItemsResponse(struct soap *soap, const char *tag, _ngwm__modifyItemsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyItemsResponse, sizeof(_ngwm__modifyItemsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyItemsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyItemsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstring(soap, "ngwt:modified", &(((_ngwm__modifyItemsResponse*)a)->ngwt__modified), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__uid(soap, "ngwm:id", &(((_ngwm__modifyItemsResponse*)a)->id), "ngwt:uid"))
					continue;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__modifyItemsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyItemsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyItemsResponse, 0, sizeof(_ngwm__modifyItemsResponse), 0, soap_copy__ngwm__modifyItemsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyItemsResponse * SOAP_FMAC6 soap_new__ngwm__modifyItemsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyItemsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyItemsResponse(struct soap *soap, _ngwm__modifyItemsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyItemsResponse * SOAP_FMAC6 soap_instantiate__ngwm__modifyItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyItemsResponse;
		if (size)
			*size = sizeof(_ngwm__modifyItemsResponse);
		((_ngwm__modifyItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyItemsResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyItemsResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyItemsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyItemsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyItemsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyItemsResponse %p -> %p\n", q, p));
	*(_ngwm__modifyItemsResponse*)p = *(_ngwm__modifyItemsResponse*)q;
}

void _ngwm__modifyItemsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__ModifyItem(soap, &((_ngwm__modifyItemsRequest*)this)->item);
	/* transient soap skipped */
}

void _ngwm__modifyItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__ModifyItem(soap, &((_ngwm__modifyItemsRequest*)this)->item);
	/* transient soap skipped */
}

int _ngwm__modifyItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyItemsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyItemsRequest(struct soap *soap, const char *tag, int id, const _ngwm__modifyItemsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyItemsRequest), type);
	soap_out_std__vectorTemplateOfPointerTongwt__ModifyItem(soap, "ngwm:item", -1, &(((_ngwm__modifyItemsRequest*)a)->item), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyItemsRequest * SOAP_FMAC4 soap_get__ngwm__modifyItemsRequest(struct soap *soap, _ngwm__modifyItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyItemsRequest * SOAP_FMAC4 soap_in__ngwm__modifyItemsRequest(struct soap *soap, const char *tag, _ngwm__modifyItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyItemsRequest, sizeof(_ngwm__modifyItemsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyItemsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyItemsRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ModifyItem(soap, "ngwm:item", &(((_ngwm__modifyItemsRequest*)a)->item), "ngwt:ModifyItem"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyItemsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyItemsRequest, 0, sizeof(_ngwm__modifyItemsRequest), 0, soap_copy__ngwm__modifyItemsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyItemsRequest * SOAP_FMAC6 soap_new__ngwm__modifyItemsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyItemsRequest(struct soap *soap, _ngwm__modifyItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyItemsRequest * SOAP_FMAC6 soap_instantiate__ngwm__modifyItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyItemsRequest;
		if (size)
			*size = sizeof(_ngwm__modifyItemsRequest);
		((_ngwm__modifyItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyItemsRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyItemsRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyItemsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyItemsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyItemsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyItemsRequest %p -> %p\n", q, p));
	*(_ngwm__modifyItemsRequest*)p = *(_ngwm__modifyItemsRequest*)q;
}

void _ngwm__modifyItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifyItemResponse*)this)->ngwt__modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwm__modifyItemResponse*)this)->ngwt__modified);
	soap_serialize_std__vectorTemplateOfngwt__uid(soap, &((_ngwm__modifyItemResponse*)this)->id);
	soap_embedded(soap, &((_ngwm__modifyItemResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__modifyItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__modifyItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((_ngwm__modifyItemResponse*)this)->ngwt__modified);
	soap_default_std__vectorTemplateOfngwt__uid(soap, &((_ngwm__modifyItemResponse*)this)->id);
	((_ngwm__modifyItemResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__modifyItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyItemResponse(struct soap *soap, const char *tag, int id, const _ngwm__modifyItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyItemResponse), type);
	soap_out_string(soap, "ngwt:modified", -1, &(((_ngwm__modifyItemResponse*)a)->ngwt__modified), "");
	soap_out_std__vectorTemplateOfngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__modifyItemResponse*)a)->id), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__modifyItemResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyItemResponse * SOAP_FMAC4 soap_get__ngwm__modifyItemResponse(struct soap *soap, _ngwm__modifyItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyItemResponse * SOAP_FMAC4 soap_in__ngwm__modifyItemResponse(struct soap *soap, const char *tag, _ngwm__modifyItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyItemResponse, sizeof(_ngwm__modifyItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ngwt__modified1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwt__modified1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((_ngwm__modifyItemResponse*)a)->ngwt__modified), ""))
				{	soap_flag_ngwt__modified1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__uid(soap, "ngwm:id", &(((_ngwm__modifyItemResponse*)a)->id), "ngwt:uid"))
					continue;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__modifyItemResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyItemResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyItemResponse, 0, sizeof(_ngwm__modifyItemResponse), 0, soap_copy__ngwm__modifyItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyItemResponse * SOAP_FMAC6 soap_new__ngwm__modifyItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyItemResponse(struct soap *soap, _ngwm__modifyItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyItemResponse * SOAP_FMAC6 soap_instantiate__ngwm__modifyItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyItemResponse;
		if (size)
			*size = sizeof(_ngwm__modifyItemResponse);
		((_ngwm__modifyItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyItemResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyItemResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyItemResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyItemResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyItemResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyItemResponse %p -> %p\n", q, p));
	*(_ngwm__modifyItemResponse*)p = *(_ngwm__modifyItemResponse*)q;
}

void _ngwm__modifyItemRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__modifyItemRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__modifyItemRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__modifyItemRequest*)this)->notification, SOAP_TYPE_PointerTongwt__SharedFolderNotification);
	soap_serialize_PointerTongwt__SharedFolderNotification(soap, &((_ngwm__modifyItemRequest*)this)->notification);
	soap_embedded(soap, &((_ngwm__modifyItemRequest*)this)->updates, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((_ngwm__modifyItemRequest*)this)->updates);
	soap_embedded(soap, &((_ngwm__modifyItemRequest*)this)->recurrenceAllInstances, SOAP_TYPE_unsignedLong);
	/* transient soap skipped */
}

void _ngwm__modifyItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__modifyItemRequest*)this)->id);
	((_ngwm__modifyItemRequest*)this)->notification = NULL;
	((_ngwm__modifyItemRequest*)this)->updates = NULL;
	((_ngwm__modifyItemRequest*)this)->recurrenceAllInstances = 0;
	/* transient soap skipped */
}

int _ngwm__modifyItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__modifyItemRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__modifyItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__modifyItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__modifyItemRequest(struct soap *soap, const char *tag, int id, const _ngwm__modifyItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__modifyItemRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__modifyItemRequest*)a)->id), "");
	soap_out_PointerTongwt__SharedFolderNotification(soap, "ngwm:notification", -1, &(((_ngwm__modifyItemRequest*)a)->notification), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwm:updates", -1, &(((_ngwm__modifyItemRequest*)a)->updates), "");
	soap_out_unsignedLong(soap, "ngwm:recurrenceAllInstances", -1, &(((_ngwm__modifyItemRequest*)a)->recurrenceAllInstances), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__modifyItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__modifyItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__modifyItemRequest * SOAP_FMAC4 soap_get__ngwm__modifyItemRequest(struct soap *soap, _ngwm__modifyItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__modifyItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__modifyItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__modifyItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__modifyItemRequest * SOAP_FMAC4 soap_in__ngwm__modifyItemRequest(struct soap *soap, const char *tag, _ngwm__modifyItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__modifyItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__modifyItemRequest, sizeof(_ngwm__modifyItemRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__modifyItemRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__modifyItemRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_notification1 = 1, soap_flag_updates1 = 1, soap_flag_recurrenceAllInstances1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__modifyItemRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_notification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SharedFolderNotification(soap, "ngwm:notification", &(((_ngwm__modifyItemRequest*)a)->notification), "ngwt:SharedFolderNotification"))
				{	soap_flag_notification1 = 0;
					continue;
				}
			if (soap_flag_updates1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwm:updates", &(((_ngwm__modifyItemRequest*)a)->updates), "ngwt:ItemChanges"))
				{	soap_flag_updates1 = 0;
					continue;
				}
			if (soap_flag_recurrenceAllInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "ngwm:recurrenceAllInstances", &(((_ngwm__modifyItemRequest*)a)->recurrenceAllInstances), ""))
				{	soap_flag_recurrenceAllInstances1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_updates1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyItemRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyItemRequest, 0, sizeof(_ngwm__modifyItemRequest), 0, soap_copy__ngwm__modifyItemRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__modifyItemRequest * SOAP_FMAC6 soap_new__ngwm__modifyItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__modifyItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__modifyItemRequest(struct soap *soap, _ngwm__modifyItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__modifyItemRequest * SOAP_FMAC6 soap_instantiate__ngwm__modifyItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__modifyItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__modifyItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__modifyItemRequest;
		if (size)
			*size = sizeof(_ngwm__modifyItemRequest);
		((_ngwm__modifyItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__modifyItemRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__modifyItemRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__modifyItemRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__modifyItemRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__modifyItemRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__modifyItemRequest %p -> %p\n", q, p));
	*(_ngwm__modifyItemRequest*)p = *(_ngwm__modifyItemRequest*)q;
}

void _ngwm__markUnReadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__markUnReadResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__markUnReadResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__markUnReadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__markUnReadResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__markUnReadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__markUnReadResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__markUnReadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__markUnReadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__markUnReadResponse(struct soap *soap, const char *tag, int id, const _ngwm__markUnReadResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__markUnReadResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__markUnReadResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__markUnReadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__markUnReadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__markUnReadResponse * SOAP_FMAC4 soap_get__ngwm__markUnReadResponse(struct soap *soap, _ngwm__markUnReadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__markUnReadResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__markUnReadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__markUnReadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__markUnReadResponse * SOAP_FMAC4 soap_in__ngwm__markUnReadResponse(struct soap *soap, const char *tag, _ngwm__markUnReadResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__markUnReadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__markUnReadResponse, sizeof(_ngwm__markUnReadResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__markUnReadResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__markUnReadResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__markUnReadResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__markUnReadResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markUnReadResponse, 0, sizeof(_ngwm__markUnReadResponse), 0, soap_copy__ngwm__markUnReadResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__markUnReadResponse * SOAP_FMAC6 soap_new__ngwm__markUnReadResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__markUnReadResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__markUnReadResponse(struct soap *soap, _ngwm__markUnReadResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__markUnReadResponse * SOAP_FMAC6 soap_instantiate__ngwm__markUnReadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__markUnReadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__markUnReadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__markUnReadResponse;
		if (size)
			*size = sizeof(_ngwm__markUnReadResponse);
		((_ngwm__markUnReadResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__markUnReadResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__markUnReadResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__markUnReadResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__markUnReadResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__markUnReadResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__markUnReadResponse %p -> %p\n", q, p));
	*(_ngwm__markUnReadResponse*)p = *(_ngwm__markUnReadResponse*)q;
}

void _ngwm__markUnReadRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__markUnReadRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__markUnReadRequest*)this)->items);
	/* transient soap skipped */
}

void _ngwm__markUnReadRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__markUnReadRequest*)this)->items = NULL;
	/* transient soap skipped */
}

int _ngwm__markUnReadRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__markUnReadRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__markUnReadRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__markUnReadRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__markUnReadRequest(struct soap *soap, const char *tag, int id, const _ngwm__markUnReadRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__markUnReadRequest), type);
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__markUnReadRequest*)a)->items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__markUnReadRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__markUnReadRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__markUnReadRequest * SOAP_FMAC4 soap_get__ngwm__markUnReadRequest(struct soap *soap, _ngwm__markUnReadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__markUnReadRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__markUnReadRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__markUnReadRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__markUnReadRequest * SOAP_FMAC4 soap_in__ngwm__markUnReadRequest(struct soap *soap, const char *tag, _ngwm__markUnReadRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__markUnReadRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__markUnReadRequest, sizeof(_ngwm__markUnReadRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__markUnReadRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__markUnReadRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__markUnReadRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__markUnReadRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markUnReadRequest, 0, sizeof(_ngwm__markUnReadRequest), 0, soap_copy__ngwm__markUnReadRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__markUnReadRequest * SOAP_FMAC6 soap_new__ngwm__markUnReadRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__markUnReadRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__markUnReadRequest(struct soap *soap, _ngwm__markUnReadRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__markUnReadRequest * SOAP_FMAC6 soap_instantiate__ngwm__markUnReadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__markUnReadRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__markUnReadRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__markUnReadRequest;
		if (size)
			*size = sizeof(_ngwm__markUnReadRequest);
		((_ngwm__markUnReadRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__markUnReadRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__markUnReadRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__markUnReadRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__markUnReadRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__markUnReadRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__markUnReadRequest %p -> %p\n", q, p));
	*(_ngwm__markUnReadRequest*)p = *(_ngwm__markUnReadRequest*)q;
}

void _ngwm__markUnPrivateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__markUnPrivateResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__markUnPrivateResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__markUnPrivateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__markUnPrivateResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__markUnPrivateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__markUnPrivateResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__markUnPrivateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__markUnPrivateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__markUnPrivateResponse(struct soap *soap, const char *tag, int id, const _ngwm__markUnPrivateResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__markUnPrivateResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__markUnPrivateResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__markUnPrivateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__markUnPrivateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__markUnPrivateResponse * SOAP_FMAC4 soap_get__ngwm__markUnPrivateResponse(struct soap *soap, _ngwm__markUnPrivateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__markUnPrivateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__markUnPrivateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__markUnPrivateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__markUnPrivateResponse * SOAP_FMAC4 soap_in__ngwm__markUnPrivateResponse(struct soap *soap, const char *tag, _ngwm__markUnPrivateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__markUnPrivateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__markUnPrivateResponse, sizeof(_ngwm__markUnPrivateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__markUnPrivateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__markUnPrivateResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__markUnPrivateResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__markUnPrivateResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markUnPrivateResponse, 0, sizeof(_ngwm__markUnPrivateResponse), 0, soap_copy__ngwm__markUnPrivateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__markUnPrivateResponse * SOAP_FMAC6 soap_new__ngwm__markUnPrivateResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__markUnPrivateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__markUnPrivateResponse(struct soap *soap, _ngwm__markUnPrivateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__markUnPrivateResponse * SOAP_FMAC6 soap_instantiate__ngwm__markUnPrivateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__markUnPrivateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__markUnPrivateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__markUnPrivateResponse;
		if (size)
			*size = sizeof(_ngwm__markUnPrivateResponse);
		((_ngwm__markUnPrivateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__markUnPrivateResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__markUnPrivateResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__markUnPrivateResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__markUnPrivateResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__markUnPrivateResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__markUnPrivateResponse %p -> %p\n", q, p));
	*(_ngwm__markUnPrivateResponse*)p = *(_ngwm__markUnPrivateResponse*)q;
}

void _ngwm__markUnPrivateRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__markUnPrivateRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__markUnPrivateRequest*)this)->items);
	/* transient soap skipped */
}

void _ngwm__markUnPrivateRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__markUnPrivateRequest*)this)->items = NULL;
	/* transient soap skipped */
}

int _ngwm__markUnPrivateRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__markUnPrivateRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__markUnPrivateRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__markUnPrivateRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__markUnPrivateRequest(struct soap *soap, const char *tag, int id, const _ngwm__markUnPrivateRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__markUnPrivateRequest), type);
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__markUnPrivateRequest*)a)->items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__markUnPrivateRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__markUnPrivateRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__markUnPrivateRequest * SOAP_FMAC4 soap_get__ngwm__markUnPrivateRequest(struct soap *soap, _ngwm__markUnPrivateRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__markUnPrivateRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__markUnPrivateRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__markUnPrivateRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__markUnPrivateRequest * SOAP_FMAC4 soap_in__ngwm__markUnPrivateRequest(struct soap *soap, const char *tag, _ngwm__markUnPrivateRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__markUnPrivateRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__markUnPrivateRequest, sizeof(_ngwm__markUnPrivateRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__markUnPrivateRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__markUnPrivateRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__markUnPrivateRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__markUnPrivateRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markUnPrivateRequest, 0, sizeof(_ngwm__markUnPrivateRequest), 0, soap_copy__ngwm__markUnPrivateRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__markUnPrivateRequest * SOAP_FMAC6 soap_new__ngwm__markUnPrivateRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__markUnPrivateRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__markUnPrivateRequest(struct soap *soap, _ngwm__markUnPrivateRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__markUnPrivateRequest * SOAP_FMAC6 soap_instantiate__ngwm__markUnPrivateRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__markUnPrivateRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__markUnPrivateRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__markUnPrivateRequest;
		if (size)
			*size = sizeof(_ngwm__markUnPrivateRequest);
		((_ngwm__markUnPrivateRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__markUnPrivateRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__markUnPrivateRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__markUnPrivateRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__markUnPrivateRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__markUnPrivateRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__markUnPrivateRequest %p -> %p\n", q, p));
	*(_ngwm__markUnPrivateRequest*)p = *(_ngwm__markUnPrivateRequest*)q;
}

void _ngwm__markReadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__markReadResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__markReadResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__markReadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__markReadResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__markReadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__markReadResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__markReadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__markReadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__markReadResponse(struct soap *soap, const char *tag, int id, const _ngwm__markReadResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__markReadResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__markReadResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__markReadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__markReadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__markReadResponse * SOAP_FMAC4 soap_get__ngwm__markReadResponse(struct soap *soap, _ngwm__markReadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__markReadResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__markReadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__markReadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__markReadResponse * SOAP_FMAC4 soap_in__ngwm__markReadResponse(struct soap *soap, const char *tag, _ngwm__markReadResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__markReadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__markReadResponse, sizeof(_ngwm__markReadResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__markReadResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__markReadResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__markReadResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__markReadResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markReadResponse, 0, sizeof(_ngwm__markReadResponse), 0, soap_copy__ngwm__markReadResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__markReadResponse * SOAP_FMAC6 soap_new__ngwm__markReadResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__markReadResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__markReadResponse(struct soap *soap, _ngwm__markReadResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__markReadResponse * SOAP_FMAC6 soap_instantiate__ngwm__markReadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__markReadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__markReadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__markReadResponse;
		if (size)
			*size = sizeof(_ngwm__markReadResponse);
		((_ngwm__markReadResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__markReadResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__markReadResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__markReadResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__markReadResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__markReadResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__markReadResponse %p -> %p\n", q, p));
	*(_ngwm__markReadResponse*)p = *(_ngwm__markReadResponse*)q;
}

void _ngwm__markReadRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__markReadRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__markReadRequest*)this)->items);
	/* transient soap skipped */
}

void _ngwm__markReadRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__markReadRequest*)this)->items = NULL;
	/* transient soap skipped */
}

int _ngwm__markReadRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__markReadRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__markReadRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__markReadRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__markReadRequest(struct soap *soap, const char *tag, int id, const _ngwm__markReadRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__markReadRequest), type);
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__markReadRequest*)a)->items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__markReadRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__markReadRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__markReadRequest * SOAP_FMAC4 soap_get__ngwm__markReadRequest(struct soap *soap, _ngwm__markReadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__markReadRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__markReadRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__markReadRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__markReadRequest * SOAP_FMAC4 soap_in__ngwm__markReadRequest(struct soap *soap, const char *tag, _ngwm__markReadRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__markReadRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__markReadRequest, sizeof(_ngwm__markReadRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__markReadRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__markReadRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__markReadRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__markReadRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markReadRequest, 0, sizeof(_ngwm__markReadRequest), 0, soap_copy__ngwm__markReadRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__markReadRequest * SOAP_FMAC6 soap_new__ngwm__markReadRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__markReadRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__markReadRequest(struct soap *soap, _ngwm__markReadRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__markReadRequest * SOAP_FMAC6 soap_instantiate__ngwm__markReadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__markReadRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__markReadRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__markReadRequest;
		if (size)
			*size = sizeof(_ngwm__markReadRequest);
		((_ngwm__markReadRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__markReadRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__markReadRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__markReadRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__markReadRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__markReadRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__markReadRequest %p -> %p\n", q, p));
	*(_ngwm__markReadRequest*)p = *(_ngwm__markReadRequest*)q;
}

void _ngwm__markPrivateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__markPrivateResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__markPrivateResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__markPrivateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__markPrivateResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__markPrivateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__markPrivateResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__markPrivateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__markPrivateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__markPrivateResponse(struct soap *soap, const char *tag, int id, const _ngwm__markPrivateResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__markPrivateResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__markPrivateResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__markPrivateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__markPrivateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__markPrivateResponse * SOAP_FMAC4 soap_get__ngwm__markPrivateResponse(struct soap *soap, _ngwm__markPrivateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__markPrivateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__markPrivateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__markPrivateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__markPrivateResponse * SOAP_FMAC4 soap_in__ngwm__markPrivateResponse(struct soap *soap, const char *tag, _ngwm__markPrivateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__markPrivateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__markPrivateResponse, sizeof(_ngwm__markPrivateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__markPrivateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__markPrivateResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__markPrivateResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__markPrivateResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markPrivateResponse, 0, sizeof(_ngwm__markPrivateResponse), 0, soap_copy__ngwm__markPrivateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__markPrivateResponse * SOAP_FMAC6 soap_new__ngwm__markPrivateResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__markPrivateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__markPrivateResponse(struct soap *soap, _ngwm__markPrivateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__markPrivateResponse * SOAP_FMAC6 soap_instantiate__ngwm__markPrivateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__markPrivateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__markPrivateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__markPrivateResponse;
		if (size)
			*size = sizeof(_ngwm__markPrivateResponse);
		((_ngwm__markPrivateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__markPrivateResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__markPrivateResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__markPrivateResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__markPrivateResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__markPrivateResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__markPrivateResponse %p -> %p\n", q, p));
	*(_ngwm__markPrivateResponse*)p = *(_ngwm__markPrivateResponse*)q;
}

void _ngwm__markPrivateRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__markPrivateRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__markPrivateRequest*)this)->items);
	/* transient soap skipped */
}

void _ngwm__markPrivateRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__markPrivateRequest*)this)->items = NULL;
	/* transient soap skipped */
}

int _ngwm__markPrivateRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__markPrivateRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__markPrivateRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__markPrivateRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__markPrivateRequest(struct soap *soap, const char *tag, int id, const _ngwm__markPrivateRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__markPrivateRequest), type);
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__markPrivateRequest*)a)->items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__markPrivateRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__markPrivateRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__markPrivateRequest * SOAP_FMAC4 soap_get__ngwm__markPrivateRequest(struct soap *soap, _ngwm__markPrivateRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__markPrivateRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__markPrivateRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__markPrivateRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__markPrivateRequest * SOAP_FMAC4 soap_in__ngwm__markPrivateRequest(struct soap *soap, const char *tag, _ngwm__markPrivateRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__markPrivateRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__markPrivateRequest, sizeof(_ngwm__markPrivateRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__markPrivateRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__markPrivateRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__markPrivateRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__markPrivateRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markPrivateRequest, 0, sizeof(_ngwm__markPrivateRequest), 0, soap_copy__ngwm__markPrivateRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__markPrivateRequest * SOAP_FMAC6 soap_new__ngwm__markPrivateRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__markPrivateRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__markPrivateRequest(struct soap *soap, _ngwm__markPrivateRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__markPrivateRequest * SOAP_FMAC6 soap_instantiate__ngwm__markPrivateRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__markPrivateRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__markPrivateRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__markPrivateRequest;
		if (size)
			*size = sizeof(_ngwm__markPrivateRequest);
		((_ngwm__markPrivateRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__markPrivateRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__markPrivateRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__markPrivateRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__markPrivateRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__markPrivateRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__markPrivateRequest %p -> %p\n", q, p));
	*(_ngwm__markPrivateRequest*)p = *(_ngwm__markPrivateRequest*)q;
}

void _ngwm__logoutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__logoutResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__logoutResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__logoutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__logoutResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__logoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__logoutResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__logoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__logoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__logoutResponse(struct soap *soap, const char *tag, int id, const _ngwm__logoutResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__logoutResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__logoutResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__logoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__logoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__logoutResponse * SOAP_FMAC4 soap_get__ngwm__logoutResponse(struct soap *soap, _ngwm__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__logoutResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__logoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__logoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__logoutResponse * SOAP_FMAC4 soap_in__ngwm__logoutResponse(struct soap *soap, const char *tag, _ngwm__logoutResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__logoutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__logoutResponse, sizeof(_ngwm__logoutResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__logoutResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__logoutResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__logoutResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__logoutResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__logoutResponse, 0, sizeof(_ngwm__logoutResponse), 0, soap_copy__ngwm__logoutResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__logoutResponse * SOAP_FMAC6 soap_new__ngwm__logoutResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__logoutResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__logoutResponse(struct soap *soap, _ngwm__logoutResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__logoutResponse * SOAP_FMAC6 soap_instantiate__ngwm__logoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__logoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__logoutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__logoutResponse;
		if (size)
			*size = sizeof(_ngwm__logoutResponse);
		((_ngwm__logoutResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__logoutResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__logoutResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__logoutResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__logoutResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__logoutResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__logoutResponse %p -> %p\n", q, p));
	*(_ngwm__logoutResponse*)p = *(_ngwm__logoutResponse*)q;
}

void _ngwm__logoutRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ngwm__logoutRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ngwm__logoutRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__logoutRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__logoutRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__logoutRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__logoutRequest(struct soap *soap, const char *tag, int id, const _ngwm__logoutRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__logoutRequest), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__logoutRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__logoutRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__logoutRequest * SOAP_FMAC4 soap_get__ngwm__logoutRequest(struct soap *soap, _ngwm__logoutRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__logoutRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__logoutRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__logoutRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__logoutRequest * SOAP_FMAC4 soap_in__ngwm__logoutRequest(struct soap *soap, const char *tag, _ngwm__logoutRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__logoutRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__logoutRequest, sizeof(_ngwm__logoutRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__logoutRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__logoutRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__logoutRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__logoutRequest, 0, sizeof(_ngwm__logoutRequest), 0, soap_copy__ngwm__logoutRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__logoutRequest * SOAP_FMAC6 soap_new__ngwm__logoutRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__logoutRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__logoutRequest(struct soap *soap, _ngwm__logoutRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__logoutRequest * SOAP_FMAC6 soap_instantiate__ngwm__logoutRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__logoutRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__logoutRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__logoutRequest;
		if (size)
			*size = sizeof(_ngwm__logoutRequest);
		((_ngwm__logoutRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__logoutRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__logoutRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__logoutRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__logoutRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__logoutRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__logoutRequest %p -> %p\n", q, p));
	*(_ngwm__logoutRequest*)p = *(_ngwm__logoutRequest*)q;
}

void _ngwm__loginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__loginResponse*)this)->session, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__loginResponse*)this)->session);
	soap_embedded(soap, &((_ngwm__loginResponse*)this)->userinfo, SOAP_TYPE_PointerTongwt__UserInfo);
	soap_serialize_PointerTongwt__UserInfo(soap, &((_ngwm__loginResponse*)this)->userinfo);
	soap_embedded(soap, &((_ngwm__loginResponse*)this)->entry, SOAP_TYPE_PointerTongwt__AccessRightEntry);
	soap_serialize_PointerTongwt__AccessRightEntry(soap, &((_ngwm__loginResponse*)this)->entry);
	soap_embedded(soap, &((_ngwm__loginResponse*)this)->gwVersion, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__loginResponse*)this)->gwVersion);
	soap_embedded(soap, &((_ngwm__loginResponse*)this)->build, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__loginResponse*)this)->build);
	soap_serialize_std__vectorTemplateOfPointerTongwt__Host(soap, &((_ngwm__loginResponse*)this)->redirectToHost);
	soap_embedded(soap, &((_ngwm__loginResponse*)this)->serverUTCTime, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwm__loginResponse*)this)->serverUTCTime);
	soap_embedded(soap, &((_ngwm__loginResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__loginResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__loginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__loginResponse*)this)->session = NULL;
	((_ngwm__loginResponse*)this)->userinfo = NULL;
	((_ngwm__loginResponse*)this)->entry = NULL;
	((_ngwm__loginResponse*)this)->gwVersion = NULL;
	((_ngwm__loginResponse*)this)->build = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__Host(soap, &((_ngwm__loginResponse*)this)->redirectToHost);
	soap_default_string(soap, &((_ngwm__loginResponse*)this)->serverUTCTime);
	((_ngwm__loginResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__loginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__loginResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__loginResponse(struct soap *soap, const char *tag, int id, const _ngwm__loginResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__loginResponse), type);
	soap_out_PointerTostd__string(soap, "ngwm:session", -1, &(((_ngwm__loginResponse*)a)->session), "");
	soap_out_PointerTongwt__UserInfo(soap, "ngwm:userinfo", -1, &(((_ngwm__loginResponse*)a)->userinfo), "");
	soap_out_PointerTongwt__AccessRightEntry(soap, "ngwm:entry", -1, &(((_ngwm__loginResponse*)a)->entry), "");
	soap_out_PointerTostd__string(soap, "ngwm:gwVersion", -1, &(((_ngwm__loginResponse*)a)->gwVersion), "");
	soap_out_PointerTostd__string(soap, "ngwm:build", -1, &(((_ngwm__loginResponse*)a)->build), "");
	soap_out_std__vectorTemplateOfPointerTongwt__Host(soap, "ngwm:redirectToHost", -1, &(((_ngwm__loginResponse*)a)->redirectToHost), "");
	soap_out_string(soap, "ngwm:serverUTCTime", -1, &(((_ngwm__loginResponse*)a)->serverUTCTime), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__loginResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__loginResponse * SOAP_FMAC4 soap_get__ngwm__loginResponse(struct soap *soap, _ngwm__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__loginResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__loginResponse * SOAP_FMAC4 soap_in__ngwm__loginResponse(struct soap *soap, const char *tag, _ngwm__loginResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__loginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__loginResponse, sizeof(_ngwm__loginResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__loginResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__loginResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_session1 = 1, soap_flag_userinfo1 = 1, soap_flag_entry1 = 1, soap_flag_gwVersion1 = 1, soap_flag_build1 = 1, soap_flag_serverUTCTime1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:session", &(((_ngwm__loginResponse*)a)->session), ""))
				{	soap_flag_session1 = 0;
					continue;
				}
			if (soap_flag_userinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__UserInfo(soap, "ngwm:userinfo", &(((_ngwm__loginResponse*)a)->userinfo), "ngwt:UserInfo"))
				{	soap_flag_userinfo1 = 0;
					continue;
				}
			if (soap_flag_entry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessRightEntry(soap, "ngwm:entry", &(((_ngwm__loginResponse*)a)->entry), "ngwt:AccessRightEntry"))
				{	soap_flag_entry1 = 0;
					continue;
				}
			if (soap_flag_gwVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:gwVersion", &(((_ngwm__loginResponse*)a)->gwVersion), ""))
				{	soap_flag_gwVersion1 = 0;
					continue;
				}
			if (soap_flag_build1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:build", &(((_ngwm__loginResponse*)a)->build), ""))
				{	soap_flag_build1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Host(soap, "ngwm:redirectToHost", &(((_ngwm__loginResponse*)a)->redirectToHost), "ngwt:Host"))
					continue;
			if (soap_flag_serverUTCTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwm:serverUTCTime", &(((_ngwm__loginResponse*)a)->serverUTCTime), ""))
				{	soap_flag_serverUTCTime1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__loginResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__loginResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__loginResponse, 0, sizeof(_ngwm__loginResponse), 0, soap_copy__ngwm__loginResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__loginResponse * SOAP_FMAC6 soap_new__ngwm__loginResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__loginResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__loginResponse(struct soap *soap, _ngwm__loginResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__loginResponse * SOAP_FMAC6 soap_instantiate__ngwm__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__loginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__loginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__loginResponse;
		if (size)
			*size = sizeof(_ngwm__loginResponse);
		((_ngwm__loginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__loginResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__loginResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__loginResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__loginResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__loginResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__loginResponse %p -> %p\n", q, p));
	*(_ngwm__loginResponse*)p = *(_ngwm__loginResponse*)q;
}

void _ngwm__loginRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__loginRequest*)this)->auth, SOAP_TYPE_PointerTongwt__Authentication);
	soap_serialize_PointerTongwt__Authentication(soap, &((_ngwm__loginRequest*)this)->auth);
	soap_embedded(soap, &((_ngwm__loginRequest*)this)->language, SOAP_TYPE_xsd__language);
	soap_serialize_xsd__language(soap, &((_ngwm__loginRequest*)this)->language);
	soap_embedded(soap, &((_ngwm__loginRequest*)this)->version, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &((_ngwm__loginRequest*)this)->version);
	soap_embedded(soap, &((_ngwm__loginRequest*)this)->application, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__loginRequest*)this)->application);
	/* transient soap skipped */
}

void _ngwm__loginRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__loginRequest*)this)->auth = NULL;
	soap_default_xsd__language(soap, &((_ngwm__loginRequest*)this)->language);
	soap_default_xsd__decimal(soap, &((_ngwm__loginRequest*)this)->version);
	((_ngwm__loginRequest*)this)->application = NULL;
	/* transient soap skipped */
}

int _ngwm__loginRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__loginRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__loginRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__loginRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__loginRequest(struct soap *soap, const char *tag, int id, const _ngwm__loginRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__loginRequest), type);
	soap_out_PointerTongwt__Authentication(soap, "ngwm:auth", -1, &(((_ngwm__loginRequest*)a)->auth), "");
	soap_out_xsd__language(soap, "ngwm:language", -1, &(((_ngwm__loginRequest*)a)->language), "");
	soap_out_xsd__decimal(soap, "ngwm:version", -1, &(((_ngwm__loginRequest*)a)->version), "");
	soap_out_PointerTostd__string(soap, "ngwm:application", -1, &(((_ngwm__loginRequest*)a)->application), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__loginRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__loginRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__loginRequest * SOAP_FMAC4 soap_get__ngwm__loginRequest(struct soap *soap, _ngwm__loginRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__loginRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__loginRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__loginRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__loginRequest * SOAP_FMAC4 soap_in__ngwm__loginRequest(struct soap *soap, const char *tag, _ngwm__loginRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__loginRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__loginRequest, sizeof(_ngwm__loginRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__loginRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__loginRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_auth1 = 1, soap_flag_language1 = 1, soap_flag_version1 = 1, soap_flag_application1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_auth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Authentication(soap, "ngwm:auth", &(((_ngwm__loginRequest*)a)->auth), "ngwt:Authentication"))
				{	soap_flag_auth1 = 0;
					continue;
				}
			if (soap_flag_language1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__language(soap, "ngwm:language", &(((_ngwm__loginRequest*)a)->language), "xsd:language"))
				{	soap_flag_language1 = 0;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ngwm:version", &(((_ngwm__loginRequest*)a)->version), "xsd:decimal"))
				{	soap_flag_version1 = 0;
					continue;
				}
			if (soap_flag_application1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:application", &(((_ngwm__loginRequest*)a)->application), ""))
				{	soap_flag_application1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_auth1 || soap_flag_language1 || soap_flag_version1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__loginRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__loginRequest, 0, sizeof(_ngwm__loginRequest), 0, soap_copy__ngwm__loginRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__loginRequest * SOAP_FMAC6 soap_new__ngwm__loginRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__loginRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__loginRequest(struct soap *soap, _ngwm__loginRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__loginRequest * SOAP_FMAC6 soap_instantiate__ngwm__loginRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__loginRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__loginRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__loginRequest;
		if (size)
			*size = sizeof(_ngwm__loginRequest);
		((_ngwm__loginRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__loginRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__loginRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__loginRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__loginRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__loginRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__loginRequest %p -> %p\n", q, p));
	*(_ngwm__loginRequest*)p = *(_ngwm__loginRequest*)q;
}

void _ngwm__getUserListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getUserListResponse*)this)->users, SOAP_TYPE_PointerTongwt__UserList);
	soap_serialize_PointerTongwt__UserList(soap, &((_ngwm__getUserListResponse*)this)->users);
	soap_embedded(soap, &((_ngwm__getUserListResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getUserListResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getUserListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getUserListResponse*)this)->users = NULL;
	((_ngwm__getUserListResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getUserListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getUserListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getUserListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getUserListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getUserListResponse(struct soap *soap, const char *tag, int id, const _ngwm__getUserListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getUserListResponse), type);
	soap_out_PointerTongwt__UserList(soap, "ngwm:users", -1, &(((_ngwm__getUserListResponse*)a)->users), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getUserListResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getUserListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getUserListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getUserListResponse * SOAP_FMAC4 soap_get__ngwm__getUserListResponse(struct soap *soap, _ngwm__getUserListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getUserListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getUserListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getUserListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getUserListResponse * SOAP_FMAC4 soap_in__ngwm__getUserListResponse(struct soap *soap, const char *tag, _ngwm__getUserListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getUserListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getUserListResponse, sizeof(_ngwm__getUserListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getUserListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getUserListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_users1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_users1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__UserList(soap, "ngwm:users", &(((_ngwm__getUserListResponse*)a)->users), "ngwt:UserList"))
				{	soap_flag_users1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getUserListResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getUserListResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getUserListResponse, 0, sizeof(_ngwm__getUserListResponse), 0, soap_copy__ngwm__getUserListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getUserListResponse * SOAP_FMAC6 soap_new__ngwm__getUserListResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getUserListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getUserListResponse(struct soap *soap, _ngwm__getUserListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getUserListResponse * SOAP_FMAC6 soap_instantiate__ngwm__getUserListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getUserListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getUserListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getUserListResponse;
		if (size)
			*size = sizeof(_ngwm__getUserListResponse);
		((_ngwm__getUserListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getUserListResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getUserListResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getUserListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getUserListResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getUserListResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getUserListResponse %p -> %p\n", q, p));
	*(_ngwm__getUserListResponse*)p = *(_ngwm__getUserListResponse*)q;
}

void _ngwm__getUserListRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getUserListRequest*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__getUserListRequest*)this)->name);
	soap_embedded(soap, &((_ngwm__getUserListRequest*)this)->key, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__getUserListRequest*)this)->key);
	/* transient soap skipped */
}

void _ngwm__getUserListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getUserListRequest*)this)->name = NULL;
	((_ngwm__getUserListRequest*)this)->key = NULL;
	/* transient soap skipped */
}

int _ngwm__getUserListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getUserListRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getUserListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getUserListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getUserListRequest(struct soap *soap, const char *tag, int id, const _ngwm__getUserListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getUserListRequest), type);
	soap_out_PointerTostd__string(soap, "ngwm:name", -1, &(((_ngwm__getUserListRequest*)a)->name), "");
	soap_out_PointerTostd__string(soap, "ngwm:key", -1, &(((_ngwm__getUserListRequest*)a)->key), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getUserListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getUserListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getUserListRequest * SOAP_FMAC4 soap_get__ngwm__getUserListRequest(struct soap *soap, _ngwm__getUserListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getUserListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getUserListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getUserListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getUserListRequest * SOAP_FMAC4 soap_in__ngwm__getUserListRequest(struct soap *soap, const char *tag, _ngwm__getUserListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getUserListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getUserListRequest, sizeof(_ngwm__getUserListRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getUserListRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getUserListRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1, soap_flag_key1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:name", &(((_ngwm__getUserListRequest*)a)->name), ""))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:key", &(((_ngwm__getUserListRequest*)a)->key), ""))
				{	soap_flag_key1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getUserListRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getUserListRequest, 0, sizeof(_ngwm__getUserListRequest), 0, soap_copy__ngwm__getUserListRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getUserListRequest * SOAP_FMAC6 soap_new__ngwm__getUserListRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getUserListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getUserListRequest(struct soap *soap, _ngwm__getUserListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getUserListRequest * SOAP_FMAC6 soap_instantiate__ngwm__getUserListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getUserListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getUserListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getUserListRequest;
		if (size)
			*size = sizeof(_ngwm__getUserListRequest);
		((_ngwm__getUserListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getUserListRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getUserListRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getUserListRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getUserListRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getUserListRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getUserListRequest %p -> %p\n", q, p));
	*(_ngwm__getUserListRequest*)p = *(_ngwm__getUserListRequest*)q;
}

void _ngwm__getTimezoneListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getTimezoneListResponse*)this)->timezones, SOAP_TYPE_PointerTongwt__TimezoneList);
	soap_serialize_PointerTongwt__TimezoneList(soap, &((_ngwm__getTimezoneListResponse*)this)->timezones);
	soap_embedded(soap, &((_ngwm__getTimezoneListResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getTimezoneListResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getTimezoneListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getTimezoneListResponse*)this)->timezones = NULL;
	((_ngwm__getTimezoneListResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getTimezoneListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getTimezoneListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getTimezoneListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getTimezoneListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getTimezoneListResponse(struct soap *soap, const char *tag, int id, const _ngwm__getTimezoneListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getTimezoneListResponse), type);
	soap_out_PointerTongwt__TimezoneList(soap, "ngwm:timezones", -1, &(((_ngwm__getTimezoneListResponse*)a)->timezones), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getTimezoneListResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getTimezoneListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getTimezoneListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getTimezoneListResponse * SOAP_FMAC4 soap_get__ngwm__getTimezoneListResponse(struct soap *soap, _ngwm__getTimezoneListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getTimezoneListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getTimezoneListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getTimezoneListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getTimezoneListResponse * SOAP_FMAC4 soap_in__ngwm__getTimezoneListResponse(struct soap *soap, const char *tag, _ngwm__getTimezoneListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getTimezoneListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getTimezoneListResponse, sizeof(_ngwm__getTimezoneListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getTimezoneListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getTimezoneListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_timezones1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timezones1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__TimezoneList(soap, "ngwm:timezones", &(((_ngwm__getTimezoneListResponse*)a)->timezones), "ngwt:TimezoneList"))
				{	soap_flag_timezones1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getTimezoneListResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getTimezoneListResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getTimezoneListResponse, 0, sizeof(_ngwm__getTimezoneListResponse), 0, soap_copy__ngwm__getTimezoneListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getTimezoneListResponse * SOAP_FMAC6 soap_new__ngwm__getTimezoneListResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getTimezoneListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getTimezoneListResponse(struct soap *soap, _ngwm__getTimezoneListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getTimezoneListResponse * SOAP_FMAC6 soap_instantiate__ngwm__getTimezoneListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getTimezoneListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getTimezoneListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getTimezoneListResponse;
		if (size)
			*size = sizeof(_ngwm__getTimezoneListResponse);
		((_ngwm__getTimezoneListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getTimezoneListResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getTimezoneListResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getTimezoneListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getTimezoneListResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getTimezoneListResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getTimezoneListResponse %p -> %p\n", q, p));
	*(_ngwm__getTimezoneListResponse*)p = *(_ngwm__getTimezoneListResponse*)q;
}

void _ngwm__getTimezoneListRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ngwm__getTimezoneListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ngwm__getTimezoneListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getTimezoneListRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getTimezoneListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getTimezoneListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getTimezoneListRequest(struct soap *soap, const char *tag, int id, const _ngwm__getTimezoneListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getTimezoneListRequest), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getTimezoneListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getTimezoneListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getTimezoneListRequest * SOAP_FMAC4 soap_get__ngwm__getTimezoneListRequest(struct soap *soap, _ngwm__getTimezoneListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getTimezoneListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getTimezoneListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getTimezoneListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getTimezoneListRequest * SOAP_FMAC4 soap_in__ngwm__getTimezoneListRequest(struct soap *soap, const char *tag, _ngwm__getTimezoneListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getTimezoneListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getTimezoneListRequest, sizeof(_ngwm__getTimezoneListRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getTimezoneListRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getTimezoneListRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getTimezoneListRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getTimezoneListRequest, 0, sizeof(_ngwm__getTimezoneListRequest), 0, soap_copy__ngwm__getTimezoneListRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getTimezoneListRequest * SOAP_FMAC6 soap_new__ngwm__getTimezoneListRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getTimezoneListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getTimezoneListRequest(struct soap *soap, _ngwm__getTimezoneListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getTimezoneListRequest * SOAP_FMAC6 soap_instantiate__ngwm__getTimezoneListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getTimezoneListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getTimezoneListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getTimezoneListRequest;
		if (size)
			*size = sizeof(_ngwm__getTimezoneListRequest);
		((_ngwm__getTimezoneListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getTimezoneListRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getTimezoneListRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getTimezoneListRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getTimezoneListRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getTimezoneListRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getTimezoneListRequest %p -> %p\n", q, p));
	*(_ngwm__getTimezoneListRequest*)p = *(_ngwm__getTimezoneListRequest*)q;
}

void _ngwm__getTimestampResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getTimestampResponse*)this)->backup, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwm__getTimestampResponse*)this)->backup);
	soap_embedded(soap, &((_ngwm__getTimestampResponse*)this)->retention, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwm__getTimestampResponse*)this)->retention);
	soap_embedded(soap, &((_ngwm__getTimestampResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getTimestampResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getTimestampResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((_ngwm__getTimestampResponse*)this)->backup);
	soap_default_string(soap, &((_ngwm__getTimestampResponse*)this)->retention);
	((_ngwm__getTimestampResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getTimestampResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getTimestampResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getTimestampResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getTimestampResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getTimestampResponse(struct soap *soap, const char *tag, int id, const _ngwm__getTimestampResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getTimestampResponse), type);
	soap_out_string(soap, "ngwm:backup", -1, &(((_ngwm__getTimestampResponse*)a)->backup), "");
	soap_out_string(soap, "ngwm:retention", -1, &(((_ngwm__getTimestampResponse*)a)->retention), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getTimestampResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getTimestampResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getTimestampResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getTimestampResponse * SOAP_FMAC4 soap_get__ngwm__getTimestampResponse(struct soap *soap, _ngwm__getTimestampResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getTimestampResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getTimestampResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getTimestampResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getTimestampResponse * SOAP_FMAC4 soap_in__ngwm__getTimestampResponse(struct soap *soap, const char *tag, _ngwm__getTimestampResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getTimestampResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getTimestampResponse, sizeof(_ngwm__getTimestampResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getTimestampResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getTimestampResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_backup1 = 1, soap_flag_retention1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_backup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwm:backup", &(((_ngwm__getTimestampResponse*)a)->backup), ""))
				{	soap_flag_backup1 = 0;
					continue;
				}
			if (soap_flag_retention1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwm:retention", &(((_ngwm__getTimestampResponse*)a)->retention), ""))
				{	soap_flag_retention1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getTimestampResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getTimestampResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getTimestampResponse, 0, sizeof(_ngwm__getTimestampResponse), 0, soap_copy__ngwm__getTimestampResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getTimestampResponse * SOAP_FMAC6 soap_new__ngwm__getTimestampResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getTimestampResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getTimestampResponse(struct soap *soap, _ngwm__getTimestampResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getTimestampResponse * SOAP_FMAC6 soap_instantiate__ngwm__getTimestampResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getTimestampResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getTimestampResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getTimestampResponse;
		if (size)
			*size = sizeof(_ngwm__getTimestampResponse);
		((_ngwm__getTimestampResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getTimestampResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getTimestampResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getTimestampResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getTimestampResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getTimestampResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getTimestampResponse %p -> %p\n", q, p));
	*(_ngwm__getTimestampResponse*)p = *(_ngwm__getTimestampResponse*)q;
}

void _ngwm__getTimestampRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getTimestampRequest*)this)->backup, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((_ngwm__getTimestampRequest*)this)->backup);
	soap_embedded(soap, &((_ngwm__getTimestampRequest*)this)->retention, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((_ngwm__getTimestampRequest*)this)->retention);
	soap_embedded(soap, &((_ngwm__getTimestampRequest*)this)->noop, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((_ngwm__getTimestampRequest*)this)->noop);
	/* transient soap skipped */
}

void _ngwm__getTimestampRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getTimestampRequest*)this)->backup = NULL;
	((_ngwm__getTimestampRequest*)this)->retention = NULL;
	((_ngwm__getTimestampRequest*)this)->noop = NULL;
	/* transient soap skipped */
}

int _ngwm__getTimestampRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getTimestampRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getTimestampRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getTimestampRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getTimestampRequest(struct soap *soap, const char *tag, int id, const _ngwm__getTimestampRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getTimestampRequest), type);
	soap_out_PointerTobool(soap, "ngwm:backup", -1, &(((_ngwm__getTimestampRequest*)a)->backup), "");
	soap_out_PointerTobool(soap, "ngwm:retention", -1, &(((_ngwm__getTimestampRequest*)a)->retention), "");
	soap_out_PointerTobool(soap, "ngwm:noop", -1, &(((_ngwm__getTimestampRequest*)a)->noop), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getTimestampRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getTimestampRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getTimestampRequest * SOAP_FMAC4 soap_get__ngwm__getTimestampRequest(struct soap *soap, _ngwm__getTimestampRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getTimestampRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getTimestampRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getTimestampRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getTimestampRequest * SOAP_FMAC4 soap_in__ngwm__getTimestampRequest(struct soap *soap, const char *tag, _ngwm__getTimestampRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getTimestampRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getTimestampRequest, sizeof(_ngwm__getTimestampRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getTimestampRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getTimestampRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_backup1 = 1, soap_flag_retention1 = 1, soap_flag_noop1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_backup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwm:backup", &(((_ngwm__getTimestampRequest*)a)->backup), ""))
				{	soap_flag_backup1 = 0;
					continue;
				}
			if (soap_flag_retention1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwm:retention", &(((_ngwm__getTimestampRequest*)a)->retention), ""))
				{	soap_flag_retention1 = 0;
					continue;
				}
			if (soap_flag_noop1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwm:noop", &(((_ngwm__getTimestampRequest*)a)->noop), ""))
				{	soap_flag_noop1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getTimestampRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getTimestampRequest, 0, sizeof(_ngwm__getTimestampRequest), 0, soap_copy__ngwm__getTimestampRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getTimestampRequest * SOAP_FMAC6 soap_new__ngwm__getTimestampRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getTimestampRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getTimestampRequest(struct soap *soap, _ngwm__getTimestampRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getTimestampRequest * SOAP_FMAC6 soap_instantiate__ngwm__getTimestampRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getTimestampRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getTimestampRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getTimestampRequest;
		if (size)
			*size = sizeof(_ngwm__getTimestampRequest);
		((_ngwm__getTimestampRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getTimestampRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getTimestampRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getTimestampRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getTimestampRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getTimestampRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getTimestampRequest %p -> %p\n", q, p));
	*(_ngwm__getTimestampRequest*)p = *(_ngwm__getTimestampRequest*)q;
}

void _ngwm__getSignaturesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getSignaturesResponse*)this)->signatures, SOAP_TYPE_PointerTongwt__Signatures);
	soap_serialize_PointerTongwt__Signatures(soap, &((_ngwm__getSignaturesResponse*)this)->signatures);
	soap_embedded(soap, &((_ngwm__getSignaturesResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getSignaturesResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getSignaturesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getSignaturesResponse*)this)->signatures = NULL;
	((_ngwm__getSignaturesResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getSignaturesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getSignaturesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getSignaturesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getSignaturesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getSignaturesResponse(struct soap *soap, const char *tag, int id, const _ngwm__getSignaturesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getSignaturesResponse), type);
	soap_out_PointerTongwt__Signatures(soap, "ngwm:signatures", -1, &(((_ngwm__getSignaturesResponse*)a)->signatures), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getSignaturesResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getSignaturesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getSignaturesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getSignaturesResponse * SOAP_FMAC4 soap_get__ngwm__getSignaturesResponse(struct soap *soap, _ngwm__getSignaturesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getSignaturesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getSignaturesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getSignaturesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getSignaturesResponse * SOAP_FMAC4 soap_in__ngwm__getSignaturesResponse(struct soap *soap, const char *tag, _ngwm__getSignaturesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getSignaturesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getSignaturesResponse, sizeof(_ngwm__getSignaturesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getSignaturesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getSignaturesResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_signatures1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_signatures1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Signatures(soap, "ngwm:signatures", &(((_ngwm__getSignaturesResponse*)a)->signatures), "ngwt:Signatures"))
				{	soap_flag_signatures1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getSignaturesResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getSignaturesResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getSignaturesResponse, 0, sizeof(_ngwm__getSignaturesResponse), 0, soap_copy__ngwm__getSignaturesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getSignaturesResponse * SOAP_FMAC6 soap_new__ngwm__getSignaturesResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getSignaturesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getSignaturesResponse(struct soap *soap, _ngwm__getSignaturesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getSignaturesResponse * SOAP_FMAC6 soap_instantiate__ngwm__getSignaturesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getSignaturesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getSignaturesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getSignaturesResponse;
		if (size)
			*size = sizeof(_ngwm__getSignaturesResponse);
		((_ngwm__getSignaturesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getSignaturesResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getSignaturesResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getSignaturesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getSignaturesResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getSignaturesResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getSignaturesResponse %p -> %p\n", q, p));
	*(_ngwm__getSignaturesResponse*)p = *(_ngwm__getSignaturesResponse*)q;
}

void _ngwm__getSignaturesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getSignaturesRequest*)this)->global, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void _ngwm__getSignaturesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getSignaturesRequest*)this)->global = (bool)0;
	/* transient soap skipped */
}

int _ngwm__getSignaturesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getSignaturesRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getSignaturesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getSignaturesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getSignaturesRequest(struct soap *soap, const char *tag, int id, const _ngwm__getSignaturesRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getSignaturesRequest), type);
	soap_out_bool(soap, "ngwm:global", -1, &(((_ngwm__getSignaturesRequest*)a)->global), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getSignaturesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getSignaturesRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getSignaturesRequest * SOAP_FMAC4 soap_get__ngwm__getSignaturesRequest(struct soap *soap, _ngwm__getSignaturesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getSignaturesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getSignaturesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getSignaturesRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getSignaturesRequest * SOAP_FMAC4 soap_in__ngwm__getSignaturesRequest(struct soap *soap, const char *tag, _ngwm__getSignaturesRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getSignaturesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getSignaturesRequest, sizeof(_ngwm__getSignaturesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getSignaturesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getSignaturesRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_global1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_global1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwm:global", &(((_ngwm__getSignaturesRequest*)a)->global), ""))
				{	soap_flag_global1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getSignaturesRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getSignaturesRequest, 0, sizeof(_ngwm__getSignaturesRequest), 0, soap_copy__ngwm__getSignaturesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getSignaturesRequest * SOAP_FMAC6 soap_new__ngwm__getSignaturesRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getSignaturesRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getSignaturesRequest(struct soap *soap, _ngwm__getSignaturesRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getSignaturesRequest * SOAP_FMAC6 soap_instantiate__ngwm__getSignaturesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getSignaturesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getSignaturesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getSignaturesRequest;
		if (size)
			*size = sizeof(_ngwm__getSignaturesRequest);
		((_ngwm__getSignaturesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getSignaturesRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getSignaturesRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getSignaturesRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getSignaturesRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getSignaturesRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getSignaturesRequest %p -> %p\n", q, p));
	*(_ngwm__getSignaturesRequest*)p = *(_ngwm__getSignaturesRequest*)q;
}

void _ngwm__getSettingsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getSettingsResponse*)this)->settings, SOAP_TYPE_PointerTongwt__Settings);
	soap_serialize_PointerTongwt__Settings(soap, &((_ngwm__getSettingsResponse*)this)->settings);
	soap_embedded(soap, &((_ngwm__getSettingsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getSettingsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getSettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getSettingsResponse*)this)->settings = NULL;
	((_ngwm__getSettingsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getSettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getSettingsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getSettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getSettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getSettingsResponse(struct soap *soap, const char *tag, int id, const _ngwm__getSettingsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getSettingsResponse), type);
	soap_out_PointerTongwt__Settings(soap, "ngwm:settings", -1, &(((_ngwm__getSettingsResponse*)a)->settings), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getSettingsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getSettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getSettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getSettingsResponse * SOAP_FMAC4 soap_get__ngwm__getSettingsResponse(struct soap *soap, _ngwm__getSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getSettingsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getSettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getSettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getSettingsResponse * SOAP_FMAC4 soap_in__ngwm__getSettingsResponse(struct soap *soap, const char *tag, _ngwm__getSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getSettingsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getSettingsResponse, sizeof(_ngwm__getSettingsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getSettingsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getSettingsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_settings1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_settings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Settings(soap, "ngwm:settings", &(((_ngwm__getSettingsResponse*)a)->settings), "ngwt:Settings"))
				{	soap_flag_settings1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getSettingsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getSettingsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getSettingsResponse, 0, sizeof(_ngwm__getSettingsResponse), 0, soap_copy__ngwm__getSettingsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getSettingsResponse * SOAP_FMAC6 soap_new__ngwm__getSettingsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getSettingsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getSettingsResponse(struct soap *soap, _ngwm__getSettingsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getSettingsResponse * SOAP_FMAC6 soap_instantiate__ngwm__getSettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getSettingsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getSettingsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getSettingsResponse;
		if (size)
			*size = sizeof(_ngwm__getSettingsResponse);
		((_ngwm__getSettingsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getSettingsResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getSettingsResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getSettingsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getSettingsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getSettingsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getSettingsResponse %p -> %p\n", q, p));
	*(_ngwm__getSettingsResponse*)p = *(_ngwm__getSettingsResponse*)q;
}

void _ngwm__getSettingsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getSettingsRequest*)this)->id, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__getSettingsRequest*)this)->id);
	/* transient soap skipped */
}

void _ngwm__getSettingsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getSettingsRequest*)this)->id = NULL;
	/* transient soap skipped */
}

int _ngwm__getSettingsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getSettingsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getSettingsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getSettingsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getSettingsRequest(struct soap *soap, const char *tag, int id, const _ngwm__getSettingsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getSettingsRequest), type);
	soap_out_PointerTostd__string(soap, "ngwm:id", -1, &(((_ngwm__getSettingsRequest*)a)->id), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getSettingsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getSettingsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getSettingsRequest * SOAP_FMAC4 soap_get__ngwm__getSettingsRequest(struct soap *soap, _ngwm__getSettingsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getSettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getSettingsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getSettingsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getSettingsRequest * SOAP_FMAC4 soap_in__ngwm__getSettingsRequest(struct soap *soap, const char *tag, _ngwm__getSettingsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getSettingsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getSettingsRequest, sizeof(_ngwm__getSettingsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getSettingsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getSettingsRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:id", &(((_ngwm__getSettingsRequest*)a)->id), ""))
				{	soap_flag_id1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getSettingsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getSettingsRequest, 0, sizeof(_ngwm__getSettingsRequest), 0, soap_copy__ngwm__getSettingsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getSettingsRequest * SOAP_FMAC6 soap_new__ngwm__getSettingsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getSettingsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getSettingsRequest(struct soap *soap, _ngwm__getSettingsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getSettingsRequest * SOAP_FMAC6 soap_instantiate__ngwm__getSettingsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getSettingsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getSettingsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getSettingsRequest;
		if (size)
			*size = sizeof(_ngwm__getSettingsRequest);
		((_ngwm__getSettingsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getSettingsRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getSettingsRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getSettingsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getSettingsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getSettingsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getSettingsRequest %p -> %p\n", q, p));
	*(_ngwm__getSettingsRequest*)p = *(_ngwm__getSettingsRequest*)q;
}

void _ngwm__getRuleListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getRuleListResponse*)this)->rules, SOAP_TYPE_PointerTongwt__RuleList);
	soap_serialize_PointerTongwt__RuleList(soap, &((_ngwm__getRuleListResponse*)this)->rules);
	soap_embedded(soap, &((_ngwm__getRuleListResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getRuleListResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getRuleListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getRuleListResponse*)this)->rules = NULL;
	((_ngwm__getRuleListResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getRuleListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getRuleListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getRuleListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getRuleListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getRuleListResponse(struct soap *soap, const char *tag, int id, const _ngwm__getRuleListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getRuleListResponse), type);
	soap_out_PointerTongwt__RuleList(soap, "ngwm:rules", -1, &(((_ngwm__getRuleListResponse*)a)->rules), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getRuleListResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getRuleListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getRuleListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getRuleListResponse * SOAP_FMAC4 soap_get__ngwm__getRuleListResponse(struct soap *soap, _ngwm__getRuleListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getRuleListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getRuleListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getRuleListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getRuleListResponse * SOAP_FMAC4 soap_in__ngwm__getRuleListResponse(struct soap *soap, const char *tag, _ngwm__getRuleListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getRuleListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getRuleListResponse, sizeof(_ngwm__getRuleListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getRuleListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getRuleListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_rules1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_rules1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RuleList(soap, "ngwm:rules", &(((_ngwm__getRuleListResponse*)a)->rules), "ngwt:RuleList"))
				{	soap_flag_rules1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getRuleListResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getRuleListResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getRuleListResponse, 0, sizeof(_ngwm__getRuleListResponse), 0, soap_copy__ngwm__getRuleListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getRuleListResponse * SOAP_FMAC6 soap_new__ngwm__getRuleListResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getRuleListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getRuleListResponse(struct soap *soap, _ngwm__getRuleListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getRuleListResponse * SOAP_FMAC6 soap_instantiate__ngwm__getRuleListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getRuleListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getRuleListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getRuleListResponse;
		if (size)
			*size = sizeof(_ngwm__getRuleListResponse);
		((_ngwm__getRuleListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getRuleListResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getRuleListResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getRuleListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getRuleListResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getRuleListResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getRuleListResponse %p -> %p\n", q, p));
	*(_ngwm__getRuleListResponse*)p = *(_ngwm__getRuleListResponse*)q;
}

void _ngwm__getRuleListRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ngwm__getRuleListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ngwm__getRuleListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getRuleListRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getRuleListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getRuleListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getRuleListRequest(struct soap *soap, const char *tag, int id, const _ngwm__getRuleListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getRuleListRequest), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getRuleListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getRuleListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getRuleListRequest * SOAP_FMAC4 soap_get__ngwm__getRuleListRequest(struct soap *soap, _ngwm__getRuleListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getRuleListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getRuleListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getRuleListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getRuleListRequest * SOAP_FMAC4 soap_in__ngwm__getRuleListRequest(struct soap *soap, const char *tag, _ngwm__getRuleListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getRuleListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getRuleListRequest, sizeof(_ngwm__getRuleListRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getRuleListRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getRuleListRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getRuleListRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getRuleListRequest, 0, sizeof(_ngwm__getRuleListRequest), 0, soap_copy__ngwm__getRuleListRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getRuleListRequest * SOAP_FMAC6 soap_new__ngwm__getRuleListRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getRuleListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getRuleListRequest(struct soap *soap, _ngwm__getRuleListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getRuleListRequest * SOAP_FMAC6 soap_instantiate__ngwm__getRuleListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getRuleListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getRuleListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getRuleListRequest;
		if (size)
			*size = sizeof(_ngwm__getRuleListRequest);
		((_ngwm__getRuleListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getRuleListRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getRuleListRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getRuleListRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getRuleListRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getRuleListRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getRuleListRequest %p -> %p\n", q, p));
	*(_ngwm__getRuleListRequest*)p = *(_ngwm__getRuleListRequest*)q;
}

void _ngwm__getProxyListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getProxyListResponse*)this)->proxies, SOAP_TYPE_PointerTongwt__ProxyList);
	soap_serialize_PointerTongwt__ProxyList(soap, &((_ngwm__getProxyListResponse*)this)->proxies);
	soap_embedded(soap, &((_ngwm__getProxyListResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getProxyListResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getProxyListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getProxyListResponse*)this)->proxies = NULL;
	((_ngwm__getProxyListResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getProxyListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getProxyListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getProxyListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getProxyListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getProxyListResponse(struct soap *soap, const char *tag, int id, const _ngwm__getProxyListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getProxyListResponse), type);
	soap_out_PointerTongwt__ProxyList(soap, "ngwm:proxies", -1, &(((_ngwm__getProxyListResponse*)a)->proxies), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getProxyListResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getProxyListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getProxyListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getProxyListResponse * SOAP_FMAC4 soap_get__ngwm__getProxyListResponse(struct soap *soap, _ngwm__getProxyListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getProxyListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getProxyListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getProxyListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getProxyListResponse * SOAP_FMAC4 soap_in__ngwm__getProxyListResponse(struct soap *soap, const char *tag, _ngwm__getProxyListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getProxyListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getProxyListResponse, sizeof(_ngwm__getProxyListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getProxyListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getProxyListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_proxies1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_proxies1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ProxyList(soap, "ngwm:proxies", &(((_ngwm__getProxyListResponse*)a)->proxies), "ngwt:ProxyList"))
				{	soap_flag_proxies1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getProxyListResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getProxyListResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getProxyListResponse, 0, sizeof(_ngwm__getProxyListResponse), 0, soap_copy__ngwm__getProxyListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getProxyListResponse * SOAP_FMAC6 soap_new__ngwm__getProxyListResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getProxyListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getProxyListResponse(struct soap *soap, _ngwm__getProxyListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getProxyListResponse * SOAP_FMAC6 soap_instantiate__ngwm__getProxyListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getProxyListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getProxyListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getProxyListResponse;
		if (size)
			*size = sizeof(_ngwm__getProxyListResponse);
		((_ngwm__getProxyListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getProxyListResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getProxyListResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getProxyListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getProxyListResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getProxyListResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getProxyListResponse %p -> %p\n", q, p));
	*(_ngwm__getProxyListResponse*)p = *(_ngwm__getProxyListResponse*)q;
}

void _ngwm__getProxyListRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ngwm__getProxyListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ngwm__getProxyListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getProxyListRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getProxyListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getProxyListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getProxyListRequest(struct soap *soap, const char *tag, int id, const _ngwm__getProxyListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getProxyListRequest), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getProxyListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getProxyListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getProxyListRequest * SOAP_FMAC4 soap_get__ngwm__getProxyListRequest(struct soap *soap, _ngwm__getProxyListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getProxyListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getProxyListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getProxyListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getProxyListRequest * SOAP_FMAC4 soap_in__ngwm__getProxyListRequest(struct soap *soap, const char *tag, _ngwm__getProxyListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getProxyListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getProxyListRequest, sizeof(_ngwm__getProxyListRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getProxyListRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getProxyListRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getProxyListRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getProxyListRequest, 0, sizeof(_ngwm__getProxyListRequest), 0, soap_copy__ngwm__getProxyListRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getProxyListRequest * SOAP_FMAC6 soap_new__ngwm__getProxyListRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getProxyListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getProxyListRequest(struct soap *soap, _ngwm__getProxyListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getProxyListRequest * SOAP_FMAC6 soap_instantiate__ngwm__getProxyListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getProxyListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getProxyListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getProxyListRequest;
		if (size)
			*size = sizeof(_ngwm__getProxyListRequest);
		((_ngwm__getProxyListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getProxyListRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getProxyListRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getProxyListRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getProxyListRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getProxyListRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getProxyListRequest %p -> %p\n", q, p));
	*(_ngwm__getProxyListRequest*)p = *(_ngwm__getProxyListRequest*)q;
}

void _ngwm__getProxyAccessListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getProxyAccessListResponse*)this)->accessRights, SOAP_TYPE_PointerTongwt__AccessRightList);
	soap_serialize_PointerTongwt__AccessRightList(soap, &((_ngwm__getProxyAccessListResponse*)this)->accessRights);
	soap_embedded(soap, &((_ngwm__getProxyAccessListResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getProxyAccessListResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getProxyAccessListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getProxyAccessListResponse*)this)->accessRights = NULL;
	((_ngwm__getProxyAccessListResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getProxyAccessListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getProxyAccessListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getProxyAccessListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getProxyAccessListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getProxyAccessListResponse(struct soap *soap, const char *tag, int id, const _ngwm__getProxyAccessListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getProxyAccessListResponse), type);
	soap_out_PointerTongwt__AccessRightList(soap, "ngwm:accessRights", -1, &(((_ngwm__getProxyAccessListResponse*)a)->accessRights), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getProxyAccessListResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getProxyAccessListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getProxyAccessListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getProxyAccessListResponse * SOAP_FMAC4 soap_get__ngwm__getProxyAccessListResponse(struct soap *soap, _ngwm__getProxyAccessListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getProxyAccessListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getProxyAccessListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getProxyAccessListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getProxyAccessListResponse * SOAP_FMAC4 soap_in__ngwm__getProxyAccessListResponse(struct soap *soap, const char *tag, _ngwm__getProxyAccessListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getProxyAccessListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getProxyAccessListResponse, sizeof(_ngwm__getProxyAccessListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getProxyAccessListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getProxyAccessListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_accessRights1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessRights1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessRightList(soap, "ngwm:accessRights", &(((_ngwm__getProxyAccessListResponse*)a)->accessRights), "ngwt:AccessRightList"))
				{	soap_flag_accessRights1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getProxyAccessListResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getProxyAccessListResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getProxyAccessListResponse, 0, sizeof(_ngwm__getProxyAccessListResponse), 0, soap_copy__ngwm__getProxyAccessListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getProxyAccessListResponse * SOAP_FMAC6 soap_new__ngwm__getProxyAccessListResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getProxyAccessListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getProxyAccessListResponse(struct soap *soap, _ngwm__getProxyAccessListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getProxyAccessListResponse * SOAP_FMAC6 soap_instantiate__ngwm__getProxyAccessListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getProxyAccessListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getProxyAccessListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getProxyAccessListResponse;
		if (size)
			*size = sizeof(_ngwm__getProxyAccessListResponse);
		((_ngwm__getProxyAccessListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getProxyAccessListResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getProxyAccessListResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getProxyAccessListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getProxyAccessListResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getProxyAccessListResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getProxyAccessListResponse %p -> %p\n", q, p));
	*(_ngwm__getProxyAccessListResponse*)p = *(_ngwm__getProxyAccessListResponse*)q;
}

void _ngwm__getProxyAccessListRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ngwm__getProxyAccessListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ngwm__getProxyAccessListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getProxyAccessListRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getProxyAccessListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getProxyAccessListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getProxyAccessListRequest(struct soap *soap, const char *tag, int id, const _ngwm__getProxyAccessListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getProxyAccessListRequest), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getProxyAccessListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getProxyAccessListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getProxyAccessListRequest * SOAP_FMAC4 soap_get__ngwm__getProxyAccessListRequest(struct soap *soap, _ngwm__getProxyAccessListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getProxyAccessListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getProxyAccessListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getProxyAccessListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getProxyAccessListRequest * SOAP_FMAC4 soap_in__ngwm__getProxyAccessListRequest(struct soap *soap, const char *tag, _ngwm__getProxyAccessListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getProxyAccessListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getProxyAccessListRequest, sizeof(_ngwm__getProxyAccessListRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getProxyAccessListRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getProxyAccessListRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getProxyAccessListRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getProxyAccessListRequest, 0, sizeof(_ngwm__getProxyAccessListRequest), 0, soap_copy__ngwm__getProxyAccessListRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getProxyAccessListRequest * SOAP_FMAC6 soap_new__ngwm__getProxyAccessListRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getProxyAccessListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getProxyAccessListRequest(struct soap *soap, _ngwm__getProxyAccessListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getProxyAccessListRequest * SOAP_FMAC6 soap_instantiate__ngwm__getProxyAccessListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getProxyAccessListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getProxyAccessListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getProxyAccessListRequest;
		if (size)
			*size = sizeof(_ngwm__getProxyAccessListRequest);
		((_ngwm__getProxyAccessListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getProxyAccessListRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getProxyAccessListRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getProxyAccessListRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getProxyAccessListRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getProxyAccessListRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getProxyAccessListRequest %p -> %p\n", q, p));
	*(_ngwm__getProxyAccessListRequest*)p = *(_ngwm__getProxyAccessListRequest*)q;
}

void _ngwm__getQuickMessagesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getQuickMessagesResponse*)this)->ngwt__startDate, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwm__getQuickMessagesResponse*)this)->ngwt__startDate);
	soap_embedded(soap, &((_ngwm__getQuickMessagesResponse*)this)->items, SOAP_TYPE_PointerTongwt__Items);
	soap_serialize_PointerTongwt__Items(soap, &((_ngwm__getQuickMessagesResponse*)this)->items);
	soap_embedded(soap, &((_ngwm__getQuickMessagesResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getQuickMessagesResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getQuickMessagesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((_ngwm__getQuickMessagesResponse*)this)->ngwt__startDate);
	((_ngwm__getQuickMessagesResponse*)this)->items = NULL;
	((_ngwm__getQuickMessagesResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getQuickMessagesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getQuickMessagesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getQuickMessagesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getQuickMessagesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getQuickMessagesResponse(struct soap *soap, const char *tag, int id, const _ngwm__getQuickMessagesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getQuickMessagesResponse), type);
	soap_out_string(soap, "ngwt:startDate", -1, &(((_ngwm__getQuickMessagesResponse*)a)->ngwt__startDate), "");
	soap_out_PointerTongwt__Items(soap, "ngwm:items", -1, &(((_ngwm__getQuickMessagesResponse*)a)->items), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getQuickMessagesResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getQuickMessagesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getQuickMessagesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getQuickMessagesResponse * SOAP_FMAC4 soap_get__ngwm__getQuickMessagesResponse(struct soap *soap, _ngwm__getQuickMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getQuickMessagesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getQuickMessagesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getQuickMessagesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getQuickMessagesResponse * SOAP_FMAC4 soap_in__ngwm__getQuickMessagesResponse(struct soap *soap, const char *tag, _ngwm__getQuickMessagesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getQuickMessagesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getQuickMessagesResponse, sizeof(_ngwm__getQuickMessagesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getQuickMessagesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getQuickMessagesResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ngwt__startDate1 = 1, soap_flag_items1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwt__startDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:startDate", &(((_ngwm__getQuickMessagesResponse*)a)->ngwt__startDate), ""))
				{	soap_flag_ngwt__startDate1 = 0;
					continue;
				}
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Items(soap, "ngwm:items", &(((_ngwm__getQuickMessagesResponse*)a)->items), "ngwt:Items"))
				{	soap_flag_items1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getQuickMessagesResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getQuickMessagesResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getQuickMessagesResponse, 0, sizeof(_ngwm__getQuickMessagesResponse), 0, soap_copy__ngwm__getQuickMessagesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getQuickMessagesResponse * SOAP_FMAC6 soap_new__ngwm__getQuickMessagesResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getQuickMessagesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getQuickMessagesResponse(struct soap *soap, _ngwm__getQuickMessagesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getQuickMessagesResponse * SOAP_FMAC6 soap_instantiate__ngwm__getQuickMessagesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getQuickMessagesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getQuickMessagesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getQuickMessagesResponse;
		if (size)
			*size = sizeof(_ngwm__getQuickMessagesResponse);
		((_ngwm__getQuickMessagesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getQuickMessagesResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getQuickMessagesResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getQuickMessagesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getQuickMessagesResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getQuickMessagesResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getQuickMessagesResponse %p -> %p\n", q, p));
	*(_ngwm__getQuickMessagesResponse*)p = *(_ngwm__getQuickMessagesResponse*)q;
}

void _ngwm__getQuickMessagesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getQuickMessagesRequest*)this)->list, SOAP_TYPE_ngwt__MessageList);
	soap_embedded(soap, &((_ngwm__getQuickMessagesRequest*)this)->ngwt__startDate, SOAP_TYPE_string);
	soap_serialize_string(soap, &((_ngwm__getQuickMessagesRequest*)this)->ngwt__startDate);
	soap_embedded(soap, &((_ngwm__getQuickMessagesRequest*)this)->container, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((_ngwm__getQuickMessagesRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__getQuickMessagesRequest*)this)->types, SOAP_TYPE_PointerTongwt__MessageTypeList);
	soap_serialize_PointerTongwt__MessageTypeList(soap, &((_ngwm__getQuickMessagesRequest*)this)->types);
	soap_embedded(soap, &((_ngwm__getQuickMessagesRequest*)this)->source, SOAP_TYPE_PointerTongwt__ItemSourceList);
	soap_serialize_PointerTongwt__ItemSourceList(soap, &((_ngwm__getQuickMessagesRequest*)this)->source);
	soap_embedded(soap, &((_ngwm__getQuickMessagesRequest*)this)->view, SOAP_TYPE_PointerTongwt__View);
	soap_serialize_PointerTongwt__View(soap, &((_ngwm__getQuickMessagesRequest*)this)->view);
	soap_embedded(soap, &((_ngwm__getQuickMessagesRequest*)this)->count, SOAP_TYPE_int);
	/* transient soap skipped */
}

void _ngwm__getQuickMessagesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__MessageList(soap, &((_ngwm__getQuickMessagesRequest*)this)->list);
	soap_default_string(soap, &((_ngwm__getQuickMessagesRequest*)this)->ngwt__startDate);
	((_ngwm__getQuickMessagesRequest*)this)->container = NULL;
	((_ngwm__getQuickMessagesRequest*)this)->types = NULL;
	((_ngwm__getQuickMessagesRequest*)this)->source = NULL;
	((_ngwm__getQuickMessagesRequest*)this)->view = NULL;
	((_ngwm__getQuickMessagesRequest*)this)->count = -1;
	/* transient soap skipped */
}

int _ngwm__getQuickMessagesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getQuickMessagesRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getQuickMessagesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getQuickMessagesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getQuickMessagesRequest(struct soap *soap, const char *tag, int id, const _ngwm__getQuickMessagesRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getQuickMessagesRequest), type);
	soap_out_ngwt__MessageList(soap, "ngwm:list", -1, &(((_ngwm__getQuickMessagesRequest*)a)->list), "");
	soap_out_string(soap, "ngwt:startDate", -1, &(((_ngwm__getQuickMessagesRequest*)a)->ngwt__startDate), "");
	soap_out_PointerTongwt__uid(soap, "ngwm:container", -1, &(((_ngwm__getQuickMessagesRequest*)a)->container), "");
	soap_out_PointerTongwt__MessageTypeList(soap, "ngwm:types", -1, &(((_ngwm__getQuickMessagesRequest*)a)->types), "");
	soap_out_PointerTongwt__ItemSourceList(soap, "ngwm:source", -1, &(((_ngwm__getQuickMessagesRequest*)a)->source), "");
	soap_out_PointerTongwt__View(soap, "ngwm:view", -1, &(((_ngwm__getQuickMessagesRequest*)a)->view), "");
	soap_out_int(soap, "ngwm:count", -1, &(((_ngwm__getQuickMessagesRequest*)a)->count), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getQuickMessagesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getQuickMessagesRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getQuickMessagesRequest * SOAP_FMAC4 soap_get__ngwm__getQuickMessagesRequest(struct soap *soap, _ngwm__getQuickMessagesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getQuickMessagesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getQuickMessagesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getQuickMessagesRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getQuickMessagesRequest * SOAP_FMAC4 soap_in__ngwm__getQuickMessagesRequest(struct soap *soap, const char *tag, _ngwm__getQuickMessagesRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getQuickMessagesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getQuickMessagesRequest, sizeof(_ngwm__getQuickMessagesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getQuickMessagesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getQuickMessagesRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_list1 = 1, soap_flag_ngwt__startDate1 = 1, soap_flag_container1 = 1, soap_flag_types1 = 1, soap_flag_source1 = 1, soap_flag_view1 = 1, soap_flag_count1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_list1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__MessageList(soap, "ngwm:list", &(((_ngwm__getQuickMessagesRequest*)a)->list), ""))
				{	soap_flag_list1 = 0;
					continue;
				}
			if (soap_flag_ngwt__startDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:startDate", &(((_ngwm__getQuickMessagesRequest*)a)->ngwt__startDate), ""))
				{	soap_flag_ngwt__startDate1 = 0;
					continue;
				}
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwm:container", &(((_ngwm__getQuickMessagesRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_types1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessageTypeList(soap, "ngwm:types", &(((_ngwm__getQuickMessagesRequest*)a)->types), ""))
				{	soap_flag_types1 = 0;
					continue;
				}
			if (soap_flag_source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSourceList(soap, "ngwm:source", &(((_ngwm__getQuickMessagesRequest*)a)->source), ""))
				{	soap_flag_source1 = 0;
					continue;
				}
			if (soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__View(soap, "ngwm:view", &(((_ngwm__getQuickMessagesRequest*)a)->view), "ngwt:View"))
				{	soap_flag_view1 = 0;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwm:count", &(((_ngwm__getQuickMessagesRequest*)a)->count), ""))
				{	soap_flag_count1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_list1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getQuickMessagesRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getQuickMessagesRequest, 0, sizeof(_ngwm__getQuickMessagesRequest), 0, soap_copy__ngwm__getQuickMessagesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getQuickMessagesRequest * SOAP_FMAC6 soap_new__ngwm__getQuickMessagesRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getQuickMessagesRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getQuickMessagesRequest(struct soap *soap, _ngwm__getQuickMessagesRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getQuickMessagesRequest * SOAP_FMAC6 soap_instantiate__ngwm__getQuickMessagesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getQuickMessagesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getQuickMessagesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getQuickMessagesRequest;
		if (size)
			*size = sizeof(_ngwm__getQuickMessagesRequest);
		((_ngwm__getQuickMessagesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getQuickMessagesRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getQuickMessagesRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getQuickMessagesRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getQuickMessagesRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getQuickMessagesRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getQuickMessagesRequest %p -> %p\n", q, p));
	*(_ngwm__getQuickMessagesRequest*)p = *(_ngwm__getQuickMessagesRequest*)q;
}

void _ngwm__getLibraryListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getLibraryListResponse*)this)->libraries, SOAP_TYPE_PointerTongwt__LibraryList);
	soap_serialize_PointerTongwt__LibraryList(soap, &((_ngwm__getLibraryListResponse*)this)->libraries);
	soap_embedded(soap, &((_ngwm__getLibraryListResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getLibraryListResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getLibraryListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getLibraryListResponse*)this)->libraries = NULL;
	((_ngwm__getLibraryListResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getLibraryListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getLibraryListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getLibraryListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getLibraryListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getLibraryListResponse(struct soap *soap, const char *tag, int id, const _ngwm__getLibraryListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getLibraryListResponse), type);
	soap_out_PointerTongwt__LibraryList(soap, "ngwm:libraries", -1, &(((_ngwm__getLibraryListResponse*)a)->libraries), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getLibraryListResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getLibraryListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getLibraryListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getLibraryListResponse * SOAP_FMAC4 soap_get__ngwm__getLibraryListResponse(struct soap *soap, _ngwm__getLibraryListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getLibraryListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getLibraryListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getLibraryListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getLibraryListResponse * SOAP_FMAC4 soap_in__ngwm__getLibraryListResponse(struct soap *soap, const char *tag, _ngwm__getLibraryListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getLibraryListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getLibraryListResponse, sizeof(_ngwm__getLibraryListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getLibraryListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getLibraryListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_libraries1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_libraries1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__LibraryList(soap, "ngwm:libraries", &(((_ngwm__getLibraryListResponse*)a)->libraries), "ngwt:LibraryList"))
				{	soap_flag_libraries1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getLibraryListResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getLibraryListResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getLibraryListResponse, 0, sizeof(_ngwm__getLibraryListResponse), 0, soap_copy__ngwm__getLibraryListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getLibraryListResponse * SOAP_FMAC6 soap_new__ngwm__getLibraryListResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getLibraryListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getLibraryListResponse(struct soap *soap, _ngwm__getLibraryListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getLibraryListResponse * SOAP_FMAC6 soap_instantiate__ngwm__getLibraryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getLibraryListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getLibraryListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getLibraryListResponse;
		if (size)
			*size = sizeof(_ngwm__getLibraryListResponse);
		((_ngwm__getLibraryListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getLibraryListResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getLibraryListResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getLibraryListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getLibraryListResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getLibraryListResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getLibraryListResponse %p -> %p\n", q, p));
	*(_ngwm__getLibraryListResponse*)p = *(_ngwm__getLibraryListResponse*)q;
}

void _ngwm__getLibraryListRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ngwm__getLibraryListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ngwm__getLibraryListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getLibraryListRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getLibraryListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getLibraryListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getLibraryListRequest(struct soap *soap, const char *tag, int id, const _ngwm__getLibraryListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getLibraryListRequest), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getLibraryListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getLibraryListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getLibraryListRequest * SOAP_FMAC4 soap_get__ngwm__getLibraryListRequest(struct soap *soap, _ngwm__getLibraryListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getLibraryListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getLibraryListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getLibraryListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getLibraryListRequest * SOAP_FMAC4 soap_in__ngwm__getLibraryListRequest(struct soap *soap, const char *tag, _ngwm__getLibraryListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getLibraryListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getLibraryListRequest, sizeof(_ngwm__getLibraryListRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getLibraryListRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getLibraryListRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getLibraryListRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getLibraryListRequest, 0, sizeof(_ngwm__getLibraryListRequest), 0, soap_copy__ngwm__getLibraryListRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getLibraryListRequest * SOAP_FMAC6 soap_new__ngwm__getLibraryListRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getLibraryListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getLibraryListRequest(struct soap *soap, _ngwm__getLibraryListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getLibraryListRequest * SOAP_FMAC6 soap_instantiate__ngwm__getLibraryListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getLibraryListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getLibraryListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getLibraryListRequest;
		if (size)
			*size = sizeof(_ngwm__getLibraryListRequest);
		((_ngwm__getLibraryListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getLibraryListRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getLibraryListRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getLibraryListRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getLibraryListRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getLibraryListRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getLibraryListRequest %p -> %p\n", q, p));
	*(_ngwm__getLibraryListRequest*)p = *(_ngwm__getLibraryListRequest*)q;
}

void _ngwm__getLibraryItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getLibraryItemResponse*)this)->item, SOAP_TYPE_PointerTongwt__Item);
	soap_serialize_PointerTongwt__Item(soap, &((_ngwm__getLibraryItemResponse*)this)->item);
	soap_embedded(soap, &((_ngwm__getLibraryItemResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getLibraryItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getLibraryItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getLibraryItemResponse*)this)->item = NULL;
	((_ngwm__getLibraryItemResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getLibraryItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getLibraryItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getLibraryItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getLibraryItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getLibraryItemResponse(struct soap *soap, const char *tag, int id, const _ngwm__getLibraryItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getLibraryItemResponse), type);
	soap_out_PointerTongwt__Item(soap, "ngwm:item", -1, &(((_ngwm__getLibraryItemResponse*)a)->item), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getLibraryItemResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getLibraryItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getLibraryItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getLibraryItemResponse * SOAP_FMAC4 soap_get__ngwm__getLibraryItemResponse(struct soap *soap, _ngwm__getLibraryItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getLibraryItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getLibraryItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getLibraryItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getLibraryItemResponse * SOAP_FMAC4 soap_in__ngwm__getLibraryItemResponse(struct soap *soap, const char *tag, _ngwm__getLibraryItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getLibraryItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getLibraryItemResponse, sizeof(_ngwm__getLibraryItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getLibraryItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getLibraryItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_item1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Item(soap, "ngwm:item", &(((_ngwm__getLibraryItemResponse*)a)->item), "ngwt:Item"))
				{	soap_flag_item1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getLibraryItemResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getLibraryItemResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getLibraryItemResponse, 0, sizeof(_ngwm__getLibraryItemResponse), 0, soap_copy__ngwm__getLibraryItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getLibraryItemResponse * SOAP_FMAC6 soap_new__ngwm__getLibraryItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getLibraryItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getLibraryItemResponse(struct soap *soap, _ngwm__getLibraryItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getLibraryItemResponse * SOAP_FMAC6 soap_instantiate__ngwm__getLibraryItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getLibraryItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getLibraryItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getLibraryItemResponse;
		if (size)
			*size = sizeof(_ngwm__getLibraryItemResponse);
		((_ngwm__getLibraryItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getLibraryItemResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getLibraryItemResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getLibraryItemResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getLibraryItemResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getLibraryItemResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getLibraryItemResponse %p -> %p\n", q, p));
	*(_ngwm__getLibraryItemResponse*)p = *(_ngwm__getLibraryItemResponse*)q;
}

void _ngwm__getLibraryItemRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getLibraryItemRequest*)this)->library, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__getLibraryItemRequest*)this)->library);
	soap_embedded(soap, &((_ngwm__getLibraryItemRequest*)this)->documentNumber, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((_ngwm__getLibraryItemRequest*)this)->documentNumber);
	soap_embedded(soap, &((_ngwm__getLibraryItemRequest*)this)->versionNumber, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__getLibraryItemRequest*)this)->versionNumber);
	/* transient soap skipped */
}

void _ngwm__getLibraryItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__getLibraryItemRequest*)this)->library);
	((_ngwm__getLibraryItemRequest*)this)->documentNumber = NULL;
	((_ngwm__getLibraryItemRequest*)this)->versionNumber = NULL;
	/* transient soap skipped */
}

int _ngwm__getLibraryItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getLibraryItemRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getLibraryItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getLibraryItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getLibraryItemRequest(struct soap *soap, const char *tag, int id, const _ngwm__getLibraryItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getLibraryItemRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:library", -1, &(((_ngwm__getLibraryItemRequest*)a)->library), "");
	soap_out_PointerTounsignedLong(soap, "ngwm:documentNumber", -1, &(((_ngwm__getLibraryItemRequest*)a)->documentNumber), "");
	soap_out_PointerTostd__string(soap, "ngwm:versionNumber", -1, &(((_ngwm__getLibraryItemRequest*)a)->versionNumber), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getLibraryItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getLibraryItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getLibraryItemRequest * SOAP_FMAC4 soap_get__ngwm__getLibraryItemRequest(struct soap *soap, _ngwm__getLibraryItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getLibraryItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getLibraryItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getLibraryItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getLibraryItemRequest * SOAP_FMAC4 soap_in__ngwm__getLibraryItemRequest(struct soap *soap, const char *tag, _ngwm__getLibraryItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getLibraryItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getLibraryItemRequest, sizeof(_ngwm__getLibraryItemRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getLibraryItemRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getLibraryItemRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_library1 = 1, soap_flag_documentNumber1 = 1, soap_flag_versionNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_library1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:library", &(((_ngwm__getLibraryItemRequest*)a)->library), "ngwt:uid"))
				{	soap_flag_library1 = 0;
					continue;
				}
			if (soap_flag_documentNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwm:documentNumber", &(((_ngwm__getLibraryItemRequest*)a)->documentNumber), ""))
				{	soap_flag_documentNumber1 = 0;
					continue;
				}
			if (soap_flag_versionNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:versionNumber", &(((_ngwm__getLibraryItemRequest*)a)->versionNumber), ""))
				{	soap_flag_versionNumber1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_library1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getLibraryItemRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getLibraryItemRequest, 0, sizeof(_ngwm__getLibraryItemRequest), 0, soap_copy__ngwm__getLibraryItemRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getLibraryItemRequest * SOAP_FMAC6 soap_new__ngwm__getLibraryItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getLibraryItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getLibraryItemRequest(struct soap *soap, _ngwm__getLibraryItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getLibraryItemRequest * SOAP_FMAC6 soap_instantiate__ngwm__getLibraryItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getLibraryItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getLibraryItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getLibraryItemRequest;
		if (size)
			*size = sizeof(_ngwm__getLibraryItemRequest);
		((_ngwm__getLibraryItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getLibraryItemRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getLibraryItemRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getLibraryItemRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getLibraryItemRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getLibraryItemRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getLibraryItemRequest %p -> %p\n", q, p));
	*(_ngwm__getLibraryItemRequest*)p = *(_ngwm__getLibraryItemRequest*)q;
}

void _ngwm__getJunkMailSettingsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getJunkMailSettingsResponse*)this)->settings, SOAP_TYPE_PointerTongwt__SettingsList);
	soap_serialize_PointerTongwt__SettingsList(soap, &((_ngwm__getJunkMailSettingsResponse*)this)->settings);
	soap_embedded(soap, &((_ngwm__getJunkMailSettingsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getJunkMailSettingsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getJunkMailSettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getJunkMailSettingsResponse*)this)->settings = NULL;
	((_ngwm__getJunkMailSettingsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getJunkMailSettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getJunkMailSettingsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getJunkMailSettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getJunkMailSettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getJunkMailSettingsResponse(struct soap *soap, const char *tag, int id, const _ngwm__getJunkMailSettingsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getJunkMailSettingsResponse), type);
	soap_out_PointerTongwt__SettingsList(soap, "ngwm:settings", -1, &(((_ngwm__getJunkMailSettingsResponse*)a)->settings), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getJunkMailSettingsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getJunkMailSettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getJunkMailSettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getJunkMailSettingsResponse * SOAP_FMAC4 soap_get__ngwm__getJunkMailSettingsResponse(struct soap *soap, _ngwm__getJunkMailSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getJunkMailSettingsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getJunkMailSettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getJunkMailSettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getJunkMailSettingsResponse * SOAP_FMAC4 soap_in__ngwm__getJunkMailSettingsResponse(struct soap *soap, const char *tag, _ngwm__getJunkMailSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getJunkMailSettingsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getJunkMailSettingsResponse, sizeof(_ngwm__getJunkMailSettingsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getJunkMailSettingsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getJunkMailSettingsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_settings1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_settings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SettingsList(soap, "ngwm:settings", &(((_ngwm__getJunkMailSettingsResponse*)a)->settings), "ngwt:SettingsList"))
				{	soap_flag_settings1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getJunkMailSettingsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getJunkMailSettingsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getJunkMailSettingsResponse, 0, sizeof(_ngwm__getJunkMailSettingsResponse), 0, soap_copy__ngwm__getJunkMailSettingsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getJunkMailSettingsResponse * SOAP_FMAC6 soap_new__ngwm__getJunkMailSettingsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getJunkMailSettingsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getJunkMailSettingsResponse(struct soap *soap, _ngwm__getJunkMailSettingsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getJunkMailSettingsResponse * SOAP_FMAC6 soap_instantiate__ngwm__getJunkMailSettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getJunkMailSettingsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getJunkMailSettingsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getJunkMailSettingsResponse;
		if (size)
			*size = sizeof(_ngwm__getJunkMailSettingsResponse);
		((_ngwm__getJunkMailSettingsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getJunkMailSettingsResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getJunkMailSettingsResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getJunkMailSettingsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getJunkMailSettingsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getJunkMailSettingsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getJunkMailSettingsResponse %p -> %p\n", q, p));
	*(_ngwm__getJunkMailSettingsResponse*)p = *(_ngwm__getJunkMailSettingsResponse*)q;
}

void _ngwm__getJunkMailSettingsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ngwm__getJunkMailSettingsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ngwm__getJunkMailSettingsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getJunkMailSettingsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getJunkMailSettingsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getJunkMailSettingsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getJunkMailSettingsRequest(struct soap *soap, const char *tag, int id, const _ngwm__getJunkMailSettingsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getJunkMailSettingsRequest), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getJunkMailSettingsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getJunkMailSettingsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getJunkMailSettingsRequest * SOAP_FMAC4 soap_get__ngwm__getJunkMailSettingsRequest(struct soap *soap, _ngwm__getJunkMailSettingsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getJunkMailSettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getJunkMailSettingsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getJunkMailSettingsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getJunkMailSettingsRequest * SOAP_FMAC4 soap_in__ngwm__getJunkMailSettingsRequest(struct soap *soap, const char *tag, _ngwm__getJunkMailSettingsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getJunkMailSettingsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getJunkMailSettingsRequest, sizeof(_ngwm__getJunkMailSettingsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getJunkMailSettingsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getJunkMailSettingsRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getJunkMailSettingsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getJunkMailSettingsRequest, 0, sizeof(_ngwm__getJunkMailSettingsRequest), 0, soap_copy__ngwm__getJunkMailSettingsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getJunkMailSettingsRequest * SOAP_FMAC6 soap_new__ngwm__getJunkMailSettingsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getJunkMailSettingsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getJunkMailSettingsRequest(struct soap *soap, _ngwm__getJunkMailSettingsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getJunkMailSettingsRequest * SOAP_FMAC6 soap_instantiate__ngwm__getJunkMailSettingsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getJunkMailSettingsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getJunkMailSettingsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getJunkMailSettingsRequest;
		if (size)
			*size = sizeof(_ngwm__getJunkMailSettingsRequest);
		((_ngwm__getJunkMailSettingsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getJunkMailSettingsRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getJunkMailSettingsRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getJunkMailSettingsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getJunkMailSettingsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getJunkMailSettingsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getJunkMailSettingsRequest %p -> %p\n", q, p));
	*(_ngwm__getJunkMailSettingsRequest*)p = *(_ngwm__getJunkMailSettingsRequest*)q;
}

void _ngwm__getJunkEntriesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getJunkEntriesResponse*)this)->junk, SOAP_TYPE_PointerTongwt__JunkHandlingList);
	soap_serialize_PointerTongwt__JunkHandlingList(soap, &((_ngwm__getJunkEntriesResponse*)this)->junk);
	soap_embedded(soap, &((_ngwm__getJunkEntriesResponse*)this)->block, SOAP_TYPE_PointerTongwt__JunkHandlingList);
	soap_serialize_PointerTongwt__JunkHandlingList(soap, &((_ngwm__getJunkEntriesResponse*)this)->block);
	soap_embedded(soap, &((_ngwm__getJunkEntriesResponse*)this)->trust, SOAP_TYPE_PointerTongwt__JunkHandlingList);
	soap_serialize_PointerTongwt__JunkHandlingList(soap, &((_ngwm__getJunkEntriesResponse*)this)->trust);
	soap_embedded(soap, &((_ngwm__getJunkEntriesResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getJunkEntriesResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getJunkEntriesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getJunkEntriesResponse*)this)->junk = NULL;
	((_ngwm__getJunkEntriesResponse*)this)->block = NULL;
	((_ngwm__getJunkEntriesResponse*)this)->trust = NULL;
	((_ngwm__getJunkEntriesResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getJunkEntriesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getJunkEntriesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getJunkEntriesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getJunkEntriesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getJunkEntriesResponse(struct soap *soap, const char *tag, int id, const _ngwm__getJunkEntriesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getJunkEntriesResponse), type);
	soap_out_PointerTongwt__JunkHandlingList(soap, "ngwm:junk", -1, &(((_ngwm__getJunkEntriesResponse*)a)->junk), "");
	soap_out_PointerTongwt__JunkHandlingList(soap, "ngwm:block", -1, &(((_ngwm__getJunkEntriesResponse*)a)->block), "");
	soap_out_PointerTongwt__JunkHandlingList(soap, "ngwm:trust", -1, &(((_ngwm__getJunkEntriesResponse*)a)->trust), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getJunkEntriesResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getJunkEntriesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getJunkEntriesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getJunkEntriesResponse * SOAP_FMAC4 soap_get__ngwm__getJunkEntriesResponse(struct soap *soap, _ngwm__getJunkEntriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getJunkEntriesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getJunkEntriesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getJunkEntriesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getJunkEntriesResponse * SOAP_FMAC4 soap_in__ngwm__getJunkEntriesResponse(struct soap *soap, const char *tag, _ngwm__getJunkEntriesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getJunkEntriesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getJunkEntriesResponse, sizeof(_ngwm__getJunkEntriesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getJunkEntriesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getJunkEntriesResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_junk1 = 1, soap_flag_block1 = 1, soap_flag_trust1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_junk1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__JunkHandlingList(soap, "ngwm:junk", &(((_ngwm__getJunkEntriesResponse*)a)->junk), "ngwt:JunkHandlingList"))
				{	soap_flag_junk1 = 0;
					continue;
				}
			if (soap_flag_block1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__JunkHandlingList(soap, "ngwm:block", &(((_ngwm__getJunkEntriesResponse*)a)->block), "ngwt:JunkHandlingList"))
				{	soap_flag_block1 = 0;
					continue;
				}
			if (soap_flag_trust1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__JunkHandlingList(soap, "ngwm:trust", &(((_ngwm__getJunkEntriesResponse*)a)->trust), "ngwt:JunkHandlingList"))
				{	soap_flag_trust1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getJunkEntriesResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getJunkEntriesResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getJunkEntriesResponse, 0, sizeof(_ngwm__getJunkEntriesResponse), 0, soap_copy__ngwm__getJunkEntriesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getJunkEntriesResponse * SOAP_FMAC6 soap_new__ngwm__getJunkEntriesResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getJunkEntriesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getJunkEntriesResponse(struct soap *soap, _ngwm__getJunkEntriesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getJunkEntriesResponse * SOAP_FMAC6 soap_instantiate__ngwm__getJunkEntriesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getJunkEntriesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getJunkEntriesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getJunkEntriesResponse;
		if (size)
			*size = sizeof(_ngwm__getJunkEntriesResponse);
		((_ngwm__getJunkEntriesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getJunkEntriesResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getJunkEntriesResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getJunkEntriesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getJunkEntriesResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getJunkEntriesResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getJunkEntriesResponse %p -> %p\n", q, p));
	*(_ngwm__getJunkEntriesResponse*)p = *(_ngwm__getJunkEntriesResponse*)q;
}

void _ngwm__getJunkEntriesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getJunkEntriesRequest*)this)->container, SOAP_TYPE_PointerTongwt__JunkHandlingListType);
	soap_serialize_PointerTongwt__JunkHandlingListType(soap, &((_ngwm__getJunkEntriesRequest*)this)->container);
	/* transient soap skipped */
}

void _ngwm__getJunkEntriesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getJunkEntriesRequest*)this)->container = NULL;
	/* transient soap skipped */
}

int _ngwm__getJunkEntriesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getJunkEntriesRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getJunkEntriesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getJunkEntriesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getJunkEntriesRequest(struct soap *soap, const char *tag, int id, const _ngwm__getJunkEntriesRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getJunkEntriesRequest), type);
	soap_out_PointerTongwt__JunkHandlingListType(soap, "ngwm:container", -1, &(((_ngwm__getJunkEntriesRequest*)a)->container), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getJunkEntriesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getJunkEntriesRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getJunkEntriesRequest * SOAP_FMAC4 soap_get__ngwm__getJunkEntriesRequest(struct soap *soap, _ngwm__getJunkEntriesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getJunkEntriesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getJunkEntriesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getJunkEntriesRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getJunkEntriesRequest * SOAP_FMAC4 soap_in__ngwm__getJunkEntriesRequest(struct soap *soap, const char *tag, _ngwm__getJunkEntriesRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getJunkEntriesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getJunkEntriesRequest, sizeof(_ngwm__getJunkEntriesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getJunkEntriesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getJunkEntriesRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__JunkHandlingListType(soap, "ngwm:container", &(((_ngwm__getJunkEntriesRequest*)a)->container), ""))
				{	soap_flag_container1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getJunkEntriesRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getJunkEntriesRequest, 0, sizeof(_ngwm__getJunkEntriesRequest), 0, soap_copy__ngwm__getJunkEntriesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getJunkEntriesRequest * SOAP_FMAC6 soap_new__ngwm__getJunkEntriesRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getJunkEntriesRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getJunkEntriesRequest(struct soap *soap, _ngwm__getJunkEntriesRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getJunkEntriesRequest * SOAP_FMAC6 soap_instantiate__ngwm__getJunkEntriesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getJunkEntriesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getJunkEntriesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getJunkEntriesRequest;
		if (size)
			*size = sizeof(_ngwm__getJunkEntriesRequest);
		((_ngwm__getJunkEntriesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getJunkEntriesRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getJunkEntriesRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getJunkEntriesRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getJunkEntriesRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getJunkEntriesRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getJunkEntriesRequest %p -> %p\n", q, p));
	*(_ngwm__getJunkEntriesRequest*)p = *(_ngwm__getJunkEntriesRequest*)q;
}

void _ngwm__getItemsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getItemsResponse*)this)->items, SOAP_TYPE_PointerTongwt__Items);
	soap_serialize_PointerTongwt__Items(soap, &((_ngwm__getItemsResponse*)this)->items);
	soap_embedded(soap, &((_ngwm__getItemsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getItemsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getItemsResponse*)this)->items = NULL;
	((_ngwm__getItemsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getItemsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getItemsResponse(struct soap *soap, const char *tag, int id, const _ngwm__getItemsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getItemsResponse), type);
	soap_out_PointerTongwt__Items(soap, "ngwm:items", -1, &(((_ngwm__getItemsResponse*)a)->items), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getItemsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getItemsResponse * SOAP_FMAC4 soap_get__ngwm__getItemsResponse(struct soap *soap, _ngwm__getItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getItemsResponse * SOAP_FMAC4 soap_in__ngwm__getItemsResponse(struct soap *soap, const char *tag, _ngwm__getItemsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getItemsResponse, sizeof(_ngwm__getItemsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getItemsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getItemsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Items(soap, "ngwm:items", &(((_ngwm__getItemsResponse*)a)->items), "ngwt:Items"))
				{	soap_flag_items1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getItemsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getItemsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getItemsResponse, 0, sizeof(_ngwm__getItemsResponse), 0, soap_copy__ngwm__getItemsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getItemsResponse * SOAP_FMAC6 soap_new__ngwm__getItemsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getItemsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getItemsResponse(struct soap *soap, _ngwm__getItemsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getItemsResponse * SOAP_FMAC6 soap_instantiate__ngwm__getItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getItemsResponse;
		if (size)
			*size = sizeof(_ngwm__getItemsResponse);
		((_ngwm__getItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getItemsResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getItemsResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getItemsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getItemsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getItemsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getItemsResponse %p -> %p\n", q, p));
	*(_ngwm__getItemsResponse*)p = *(_ngwm__getItemsResponse*)q;
}

void _ngwm__getItemsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getItemsRequest*)this)->container, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((_ngwm__getItemsRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__getItemsRequest*)this)->view, SOAP_TYPE_PointerTongwt__View);
	soap_serialize_PointerTongwt__View(soap, &((_ngwm__getItemsRequest*)this)->view);
	soap_embedded(soap, &((_ngwm__getItemsRequest*)this)->filter, SOAP_TYPE_PointerTongwt__Filter);
	soap_serialize_PointerTongwt__Filter(soap, &((_ngwm__getItemsRequest*)this)->filter);
	soap_embedded(soap, &((_ngwm__getItemsRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__getItemsRequest*)this)->items);
	soap_embedded(soap, &((_ngwm__getItemsRequest*)this)->count, SOAP_TYPE_int);
	/* transient soap skipped */
}

void _ngwm__getItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getItemsRequest*)this)->container = NULL;
	((_ngwm__getItemsRequest*)this)->view = NULL;
	((_ngwm__getItemsRequest*)this)->filter = NULL;
	((_ngwm__getItemsRequest*)this)->items = NULL;
	((_ngwm__getItemsRequest*)this)->count = -1;
	/* transient soap skipped */
}

int _ngwm__getItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getItemsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getItemsRequest(struct soap *soap, const char *tag, int id, const _ngwm__getItemsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getItemsRequest), type);
	soap_out_PointerTongwt__uid(soap, "ngwm:container", -1, &(((_ngwm__getItemsRequest*)a)->container), "");
	soap_out_PointerTongwt__View(soap, "ngwm:view", -1, &(((_ngwm__getItemsRequest*)a)->view), "");
	soap_out_PointerTongwt__Filter(soap, "ngwm:filter", -1, &(((_ngwm__getItemsRequest*)a)->filter), "");
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__getItemsRequest*)a)->items), "");
	soap_out_int(soap, "ngwm:count", -1, &(((_ngwm__getItemsRequest*)a)->count), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getItemsRequest * SOAP_FMAC4 soap_get__ngwm__getItemsRequest(struct soap *soap, _ngwm__getItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getItemsRequest * SOAP_FMAC4 soap_in__ngwm__getItemsRequest(struct soap *soap, const char *tag, _ngwm__getItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getItemsRequest, sizeof(_ngwm__getItemsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getItemsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getItemsRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_view1 = 1, soap_flag_filter1 = 1, soap_flag_items1 = 1, soap_flag_count1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwm:container", &(((_ngwm__getItemsRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__View(soap, "ngwm:view", &(((_ngwm__getItemsRequest*)a)->view), "ngwt:View"))
				{	soap_flag_view1 = 0;
					continue;
				}
			if (soap_flag_filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Filter(soap, "ngwm:filter", &(((_ngwm__getItemsRequest*)a)->filter), "ngwt:Filter"))
				{	soap_flag_filter1 = 0;
					continue;
				}
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__getItemsRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwm:count", &(((_ngwm__getItemsRequest*)a)->count), ""))
				{	soap_flag_count1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getItemsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getItemsRequest, 0, sizeof(_ngwm__getItemsRequest), 0, soap_copy__ngwm__getItemsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getItemsRequest * SOAP_FMAC6 soap_new__ngwm__getItemsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getItemsRequest(struct soap *soap, _ngwm__getItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getItemsRequest * SOAP_FMAC6 soap_instantiate__ngwm__getItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getItemsRequest;
		if (size)
			*size = sizeof(_ngwm__getItemsRequest);
		((_ngwm__getItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getItemsRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getItemsRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getItemsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getItemsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getItemsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getItemsRequest %p -> %p\n", q, p));
	*(_ngwm__getItemsRequest*)p = *(_ngwm__getItemsRequest*)q;
}

void _ngwm__getItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getItemResponse*)this)->item, SOAP_TYPE_PointerTongwt__Item);
	soap_serialize_PointerTongwt__Item(soap, &((_ngwm__getItemResponse*)this)->item);
	soap_embedded(soap, &((_ngwm__getItemResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getItemResponse*)this)->item = NULL;
	((_ngwm__getItemResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getItemResponse(struct soap *soap, const char *tag, int id, const _ngwm__getItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getItemResponse), type);
	soap_out_PointerTongwt__Item(soap, "ngwm:item", -1, &(((_ngwm__getItemResponse*)a)->item), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getItemResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getItemResponse * SOAP_FMAC4 soap_get__ngwm__getItemResponse(struct soap *soap, _ngwm__getItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getItemResponse * SOAP_FMAC4 soap_in__ngwm__getItemResponse(struct soap *soap, const char *tag, _ngwm__getItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getItemResponse, sizeof(_ngwm__getItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_item1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Item(soap, "ngwm:item", &(((_ngwm__getItemResponse*)a)->item), "ngwt:Item"))
				{	soap_flag_item1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getItemResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getItemResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getItemResponse, 0, sizeof(_ngwm__getItemResponse), 0, soap_copy__ngwm__getItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getItemResponse * SOAP_FMAC6 soap_new__ngwm__getItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getItemResponse(struct soap *soap, _ngwm__getItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getItemResponse * SOAP_FMAC6 soap_instantiate__ngwm__getItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getItemResponse;
		if (size)
			*size = sizeof(_ngwm__getItemResponse);
		((_ngwm__getItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getItemResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getItemResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getItemResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getItemResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getItemResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getItemResponse %p -> %p\n", q, p));
	*(_ngwm__getItemResponse*)p = *(_ngwm__getItemResponse*)q;
}

void _ngwm__getItemRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getItemRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__getItemRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__getItemRequest*)this)->view, SOAP_TYPE_PointerTongwt__View);
	soap_serialize_PointerTongwt__View(soap, &((_ngwm__getItemRequest*)this)->view);
	/* transient soap skipped */
}

void _ngwm__getItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__getItemRequest*)this)->id);
	((_ngwm__getItemRequest*)this)->view = NULL;
	/* transient soap skipped */
}

int _ngwm__getItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getItemRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getItemRequest(struct soap *soap, const char *tag, int id, const _ngwm__getItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getItemRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__getItemRequest*)a)->id), "");
	soap_out_PointerTongwt__View(soap, "ngwm:view", -1, &(((_ngwm__getItemRequest*)a)->view), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getItemRequest * SOAP_FMAC4 soap_get__ngwm__getItemRequest(struct soap *soap, _ngwm__getItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getItemRequest * SOAP_FMAC4 soap_in__ngwm__getItemRequest(struct soap *soap, const char *tag, _ngwm__getItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getItemRequest, sizeof(_ngwm__getItemRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getItemRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getItemRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_view1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__getItemRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__View(soap, "ngwm:view", &(((_ngwm__getItemRequest*)a)->view), "ngwt:View"))
				{	soap_flag_view1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getItemRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getItemRequest, 0, sizeof(_ngwm__getItemRequest), 0, soap_copy__ngwm__getItemRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getItemRequest * SOAP_FMAC6 soap_new__ngwm__getItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getItemRequest(struct soap *soap, _ngwm__getItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getItemRequest * SOAP_FMAC6 soap_instantiate__ngwm__getItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getItemRequest;
		if (size)
			*size = sizeof(_ngwm__getItemRequest);
		((_ngwm__getItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getItemRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getItemRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getItemRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getItemRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getItemRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getItemRequest %p -> %p\n", q, p));
	*(_ngwm__getItemRequest*)p = *(_ngwm__getItemRequest*)q;
}

void _ngwm__getFreeBusyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getFreeBusyResponse*)this)->freeBusyStats, SOAP_TYPE_PointerTongwt__FreeBusyStats);
	soap_serialize_PointerTongwt__FreeBusyStats(soap, &((_ngwm__getFreeBusyResponse*)this)->freeBusyStats);
	soap_embedded(soap, &((_ngwm__getFreeBusyResponse*)this)->freeBusyInfo, SOAP_TYPE_PointerTongwt__FreeBusyInfoList);
	soap_serialize_PointerTongwt__FreeBusyInfoList(soap, &((_ngwm__getFreeBusyResponse*)this)->freeBusyInfo);
	soap_embedded(soap, &((_ngwm__getFreeBusyResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getFreeBusyResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getFreeBusyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getFreeBusyResponse*)this)->freeBusyStats = NULL;
	((_ngwm__getFreeBusyResponse*)this)->freeBusyInfo = NULL;
	((_ngwm__getFreeBusyResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getFreeBusyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getFreeBusyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getFreeBusyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getFreeBusyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getFreeBusyResponse(struct soap *soap, const char *tag, int id, const _ngwm__getFreeBusyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getFreeBusyResponse), type);
	soap_out_PointerTongwt__FreeBusyStats(soap, "ngwm:freeBusyStats", -1, &(((_ngwm__getFreeBusyResponse*)a)->freeBusyStats), "");
	soap_out_PointerTongwt__FreeBusyInfoList(soap, "ngwm:freeBusyInfo", -1, &(((_ngwm__getFreeBusyResponse*)a)->freeBusyInfo), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getFreeBusyResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getFreeBusyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getFreeBusyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getFreeBusyResponse * SOAP_FMAC4 soap_get__ngwm__getFreeBusyResponse(struct soap *soap, _ngwm__getFreeBusyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getFreeBusyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getFreeBusyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getFreeBusyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getFreeBusyResponse * SOAP_FMAC4 soap_in__ngwm__getFreeBusyResponse(struct soap *soap, const char *tag, _ngwm__getFreeBusyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getFreeBusyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getFreeBusyResponse, sizeof(_ngwm__getFreeBusyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getFreeBusyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getFreeBusyResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_freeBusyStats1 = 1, soap_flag_freeBusyInfo1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_freeBusyStats1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FreeBusyStats(soap, "ngwm:freeBusyStats", &(((_ngwm__getFreeBusyResponse*)a)->freeBusyStats), "ngwt:FreeBusyStats"))
				{	soap_flag_freeBusyStats1 = 0;
					continue;
				}
			if (soap_flag_freeBusyInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FreeBusyInfoList(soap, "ngwm:freeBusyInfo", &(((_ngwm__getFreeBusyResponse*)a)->freeBusyInfo), "ngwt:FreeBusyInfoList"))
				{	soap_flag_freeBusyInfo1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getFreeBusyResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getFreeBusyResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFreeBusyResponse, 0, sizeof(_ngwm__getFreeBusyResponse), 0, soap_copy__ngwm__getFreeBusyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getFreeBusyResponse * SOAP_FMAC6 soap_new__ngwm__getFreeBusyResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getFreeBusyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getFreeBusyResponse(struct soap *soap, _ngwm__getFreeBusyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getFreeBusyResponse * SOAP_FMAC6 soap_instantiate__ngwm__getFreeBusyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getFreeBusyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getFreeBusyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getFreeBusyResponse;
		if (size)
			*size = sizeof(_ngwm__getFreeBusyResponse);
		((_ngwm__getFreeBusyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getFreeBusyResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getFreeBusyResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getFreeBusyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getFreeBusyResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getFreeBusyResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getFreeBusyResponse %p -> %p\n", q, p));
	*(_ngwm__getFreeBusyResponse*)p = *(_ngwm__getFreeBusyResponse*)q;
}

void _ngwm__getFreeBusyRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getFreeBusyRequest*)this)->freeBusySessionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((_ngwm__getFreeBusyRequest*)this)->freeBusySessionId);
	/* transient soap skipped */
}

void _ngwm__getFreeBusyRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((_ngwm__getFreeBusyRequest*)this)->freeBusySessionId);
	/* transient soap skipped */
}

int _ngwm__getFreeBusyRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getFreeBusyRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getFreeBusyRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getFreeBusyRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getFreeBusyRequest(struct soap *soap, const char *tag, int id, const _ngwm__getFreeBusyRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getFreeBusyRequest), type);
	soap_out_std__string(soap, "ngwm:freeBusySessionId", -1, &(((_ngwm__getFreeBusyRequest*)a)->freeBusySessionId), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getFreeBusyRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getFreeBusyRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getFreeBusyRequest * SOAP_FMAC4 soap_get__ngwm__getFreeBusyRequest(struct soap *soap, _ngwm__getFreeBusyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getFreeBusyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getFreeBusyRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getFreeBusyRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getFreeBusyRequest * SOAP_FMAC4 soap_in__ngwm__getFreeBusyRequest(struct soap *soap, const char *tag, _ngwm__getFreeBusyRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getFreeBusyRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getFreeBusyRequest, sizeof(_ngwm__getFreeBusyRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getFreeBusyRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getFreeBusyRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_freeBusySessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_freeBusySessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwm:freeBusySessionId", &(((_ngwm__getFreeBusyRequest*)a)->freeBusySessionId), ""))
				{	soap_flag_freeBusySessionId1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_freeBusySessionId1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getFreeBusyRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFreeBusyRequest, 0, sizeof(_ngwm__getFreeBusyRequest), 0, soap_copy__ngwm__getFreeBusyRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getFreeBusyRequest * SOAP_FMAC6 soap_new__ngwm__getFreeBusyRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getFreeBusyRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getFreeBusyRequest(struct soap *soap, _ngwm__getFreeBusyRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getFreeBusyRequest * SOAP_FMAC6 soap_instantiate__ngwm__getFreeBusyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getFreeBusyRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getFreeBusyRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getFreeBusyRequest;
		if (size)
			*size = sizeof(_ngwm__getFreeBusyRequest);
		((_ngwm__getFreeBusyRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getFreeBusyRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getFreeBusyRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getFreeBusyRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getFreeBusyRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getFreeBusyRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getFreeBusyRequest %p -> %p\n", q, p));
	*(_ngwm__getFreeBusyRequest*)p = *(_ngwm__getFreeBusyRequest*)q;
}

void _ngwm__getFolderListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getFolderListResponse*)this)->folders, SOAP_TYPE_PointerTongwt__FolderList);
	soap_serialize_PointerTongwt__FolderList(soap, &((_ngwm__getFolderListResponse*)this)->folders);
	soap_embedded(soap, &((_ngwm__getFolderListResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getFolderListResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getFolderListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getFolderListResponse*)this)->folders = NULL;
	((_ngwm__getFolderListResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getFolderListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getFolderListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getFolderListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getFolderListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getFolderListResponse(struct soap *soap, const char *tag, int id, const _ngwm__getFolderListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getFolderListResponse), type);
	soap_out_PointerTongwt__FolderList(soap, "ngwm:folders", -1, &(((_ngwm__getFolderListResponse*)a)->folders), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getFolderListResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getFolderListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getFolderListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getFolderListResponse * SOAP_FMAC4 soap_get__ngwm__getFolderListResponse(struct soap *soap, _ngwm__getFolderListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getFolderListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getFolderListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getFolderListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getFolderListResponse * SOAP_FMAC4 soap_in__ngwm__getFolderListResponse(struct soap *soap, const char *tag, _ngwm__getFolderListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getFolderListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getFolderListResponse, sizeof(_ngwm__getFolderListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getFolderListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getFolderListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_folders1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_folders1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FolderList(soap, "ngwm:folders", &(((_ngwm__getFolderListResponse*)a)->folders), "ngwt:FolderList"))
				{	soap_flag_folders1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getFolderListResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getFolderListResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFolderListResponse, 0, sizeof(_ngwm__getFolderListResponse), 0, soap_copy__ngwm__getFolderListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getFolderListResponse * SOAP_FMAC6 soap_new__ngwm__getFolderListResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getFolderListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getFolderListResponse(struct soap *soap, _ngwm__getFolderListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getFolderListResponse * SOAP_FMAC6 soap_instantiate__ngwm__getFolderListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getFolderListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getFolderListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getFolderListResponse;
		if (size)
			*size = sizeof(_ngwm__getFolderListResponse);
		((_ngwm__getFolderListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getFolderListResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getFolderListResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getFolderListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getFolderListResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getFolderListResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getFolderListResponse %p -> %p\n", q, p));
	*(_ngwm__getFolderListResponse*)p = *(_ngwm__getFolderListResponse*)q;
}

void _ngwm__getFolderListRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getFolderListRequest*)this)->parent, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__getFolderListRequest*)this)->parent);
	soap_embedded(soap, &((_ngwm__getFolderListRequest*)this)->view, SOAP_TYPE_PointerTongwt__View);
	soap_serialize_PointerTongwt__View(soap, &((_ngwm__getFolderListRequest*)this)->view);
	soap_embedded(soap, &((_ngwm__getFolderListRequest*)this)->recurse, SOAP_TYPE_bool);
	soap_embedded(soap, &((_ngwm__getFolderListRequest*)this)->imap, SOAP_TYPE_bool);
	soap_embedded(soap, &((_ngwm__getFolderListRequest*)this)->nntp, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void _ngwm__getFolderListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__getFolderListRequest*)this)->parent);
	((_ngwm__getFolderListRequest*)this)->view = NULL;
	soap_default_bool(soap, &((_ngwm__getFolderListRequest*)this)->recurse);
	((_ngwm__getFolderListRequest*)this)->imap = (bool)0;
	((_ngwm__getFolderListRequest*)this)->nntp = (bool)0;
	/* transient soap skipped */
}

int _ngwm__getFolderListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getFolderListRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getFolderListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getFolderListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getFolderListRequest(struct soap *soap, const char *tag, int id, const _ngwm__getFolderListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getFolderListRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:parent", -1, &(((_ngwm__getFolderListRequest*)a)->parent), "");
	soap_out_PointerTongwt__View(soap, "ngwm:view", -1, &(((_ngwm__getFolderListRequest*)a)->view), "");
	soap_out_bool(soap, "ngwm:recurse", -1, &(((_ngwm__getFolderListRequest*)a)->recurse), "");
	soap_out_bool(soap, "ngwm:imap", -1, &(((_ngwm__getFolderListRequest*)a)->imap), "");
	soap_out_bool(soap, "ngwm:nntp", -1, &(((_ngwm__getFolderListRequest*)a)->nntp), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getFolderListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getFolderListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getFolderListRequest * SOAP_FMAC4 soap_get__ngwm__getFolderListRequest(struct soap *soap, _ngwm__getFolderListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getFolderListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getFolderListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getFolderListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getFolderListRequest * SOAP_FMAC4 soap_in__ngwm__getFolderListRequest(struct soap *soap, const char *tag, _ngwm__getFolderListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getFolderListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getFolderListRequest, sizeof(_ngwm__getFolderListRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getFolderListRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getFolderListRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_parent1 = 1, soap_flag_view1 = 1, soap_flag_recurse1 = 1, soap_flag_imap1 = 1, soap_flag_nntp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_parent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:parent", &(((_ngwm__getFolderListRequest*)a)->parent), "ngwt:uid"))
				{	soap_flag_parent1 = 0;
					continue;
				}
			if (soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__View(soap, "ngwm:view", &(((_ngwm__getFolderListRequest*)a)->view), "ngwt:View"))
				{	soap_flag_view1 = 0;
					continue;
				}
			if (soap_flag_recurse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwm:recurse", &(((_ngwm__getFolderListRequest*)a)->recurse), ""))
				{	soap_flag_recurse1 = 0;
					continue;
				}
			if (soap_flag_imap1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwm:imap", &(((_ngwm__getFolderListRequest*)a)->imap), ""))
				{	soap_flag_imap1 = 0;
					continue;
				}
			if (soap_flag_nntp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwm:nntp", &(((_ngwm__getFolderListRequest*)a)->nntp), ""))
				{	soap_flag_nntp1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent1 || soap_flag_recurse1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getFolderListRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFolderListRequest, 0, sizeof(_ngwm__getFolderListRequest), 0, soap_copy__ngwm__getFolderListRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getFolderListRequest * SOAP_FMAC6 soap_new__ngwm__getFolderListRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getFolderListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getFolderListRequest(struct soap *soap, _ngwm__getFolderListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getFolderListRequest * SOAP_FMAC6 soap_instantiate__ngwm__getFolderListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getFolderListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getFolderListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getFolderListRequest;
		if (size)
			*size = sizeof(_ngwm__getFolderListRequest);
		((_ngwm__getFolderListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getFolderListRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getFolderListRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getFolderListRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getFolderListRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getFolderListRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getFolderListRequest %p -> %p\n", q, p));
	*(_ngwm__getFolderListRequest*)p = *(_ngwm__getFolderListRequest*)q;
}

void _ngwm__getFolderResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getFolderResponse*)this)->folder, SOAP_TYPE_PointerTongwt__Folder);
	soap_serialize_PointerTongwt__Folder(soap, &((_ngwm__getFolderResponse*)this)->folder);
	soap_embedded(soap, &((_ngwm__getFolderResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getFolderResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getFolderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getFolderResponse*)this)->folder = NULL;
	((_ngwm__getFolderResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getFolderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getFolderResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getFolderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getFolderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getFolderResponse(struct soap *soap, const char *tag, int id, const _ngwm__getFolderResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getFolderResponse), type);
	soap_out_PointerTongwt__Folder(soap, "ngwm:folder", -1, &(((_ngwm__getFolderResponse*)a)->folder), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getFolderResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getFolderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getFolderResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getFolderResponse * SOAP_FMAC4 soap_get__ngwm__getFolderResponse(struct soap *soap, _ngwm__getFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getFolderResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getFolderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getFolderResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getFolderResponse * SOAP_FMAC4 soap_in__ngwm__getFolderResponse(struct soap *soap, const char *tag, _ngwm__getFolderResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getFolderResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getFolderResponse, sizeof(_ngwm__getFolderResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getFolderResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getFolderResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_folder1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_folder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Folder(soap, "ngwm:folder", &(((_ngwm__getFolderResponse*)a)->folder), "ngwt:Folder"))
				{	soap_flag_folder1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getFolderResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getFolderResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFolderResponse, 0, sizeof(_ngwm__getFolderResponse), 0, soap_copy__ngwm__getFolderResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getFolderResponse * SOAP_FMAC6 soap_new__ngwm__getFolderResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getFolderResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getFolderResponse(struct soap *soap, _ngwm__getFolderResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getFolderResponse * SOAP_FMAC6 soap_instantiate__ngwm__getFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getFolderResponse;
		if (size)
			*size = sizeof(_ngwm__getFolderResponse);
		((_ngwm__getFolderResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getFolderResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getFolderResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getFolderResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getFolderResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getFolderResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getFolderResponse %p -> %p\n", q, p));
	*(_ngwm__getFolderResponse*)p = *(_ngwm__getFolderResponse*)q;
}

void _ngwm__getFolderRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getFolderRequest*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((_ngwm__getFolderRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__getFolderRequest*)this)->folderType, SOAP_TYPE_PointerTongwt__FolderType);
	soap_serialize_PointerTongwt__FolderType(soap, &((_ngwm__getFolderRequest*)this)->folderType);
	soap_embedded(soap, &((_ngwm__getFolderRequest*)this)->types, SOAP_TYPE_PointerTongwt__MessageTypeList);
	soap_serialize_PointerTongwt__MessageTypeList(soap, &((_ngwm__getFolderRequest*)this)->types);
	soap_embedded(soap, &((_ngwm__getFolderRequest*)this)->source, SOAP_TYPE_PointerTongwt__ItemSourceList);
	soap_serialize_PointerTongwt__ItemSourceList(soap, &((_ngwm__getFolderRequest*)this)->source);
	soap_embedded(soap, &((_ngwm__getFolderRequest*)this)->view, SOAP_TYPE_PointerTongwt__View);
	soap_serialize_PointerTongwt__View(soap, &((_ngwm__getFolderRequest*)this)->view);
	/* transient soap skipped */
}

void _ngwm__getFolderRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getFolderRequest*)this)->id = NULL;
	((_ngwm__getFolderRequest*)this)->folderType = NULL;
	((_ngwm__getFolderRequest*)this)->types = NULL;
	((_ngwm__getFolderRequest*)this)->source = NULL;
	((_ngwm__getFolderRequest*)this)->view = NULL;
	/* transient soap skipped */
}

int _ngwm__getFolderRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getFolderRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getFolderRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getFolderRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getFolderRequest(struct soap *soap, const char *tag, int id, const _ngwm__getFolderRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getFolderRequest), type);
	soap_out_PointerTongwt__uid(soap, "ngwm:id", -1, &(((_ngwm__getFolderRequest*)a)->id), "");
	soap_out_PointerTongwt__FolderType(soap, "ngwm:folderType", -1, &(((_ngwm__getFolderRequest*)a)->folderType), "");
	soap_out_PointerTongwt__MessageTypeList(soap, "ngwm:types", -1, &(((_ngwm__getFolderRequest*)a)->types), "");
	soap_out_PointerTongwt__ItemSourceList(soap, "ngwm:source", -1, &(((_ngwm__getFolderRequest*)a)->source), "");
	soap_out_PointerTongwt__View(soap, "ngwm:view", -1, &(((_ngwm__getFolderRequest*)a)->view), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getFolderRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getFolderRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getFolderRequest * SOAP_FMAC4 soap_get__ngwm__getFolderRequest(struct soap *soap, _ngwm__getFolderRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getFolderRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getFolderRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getFolderRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getFolderRequest * SOAP_FMAC4 soap_in__ngwm__getFolderRequest(struct soap *soap, const char *tag, _ngwm__getFolderRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getFolderRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getFolderRequest, sizeof(_ngwm__getFolderRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getFolderRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getFolderRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_folderType1 = 1, soap_flag_types1 = 1, soap_flag_source1 = 1, soap_flag_view1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwm:id", &(((_ngwm__getFolderRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_folderType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FolderType(soap, "ngwm:folderType", &(((_ngwm__getFolderRequest*)a)->folderType), ""))
				{	soap_flag_folderType1 = 0;
					continue;
				}
			if (soap_flag_types1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessageTypeList(soap, "ngwm:types", &(((_ngwm__getFolderRequest*)a)->types), ""))
				{	soap_flag_types1 = 0;
					continue;
				}
			if (soap_flag_source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSourceList(soap, "ngwm:source", &(((_ngwm__getFolderRequest*)a)->source), ""))
				{	soap_flag_source1 = 0;
					continue;
				}
			if (soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__View(soap, "ngwm:view", &(((_ngwm__getFolderRequest*)a)->view), "ngwt:View"))
				{	soap_flag_view1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getFolderRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFolderRequest, 0, sizeof(_ngwm__getFolderRequest), 0, soap_copy__ngwm__getFolderRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getFolderRequest * SOAP_FMAC6 soap_new__ngwm__getFolderRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getFolderRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getFolderRequest(struct soap *soap, _ngwm__getFolderRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getFolderRequest * SOAP_FMAC6 soap_instantiate__ngwm__getFolderRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getFolderRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getFolderRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getFolderRequest;
		if (size)
			*size = sizeof(_ngwm__getFolderRequest);
		((_ngwm__getFolderRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getFolderRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getFolderRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getFolderRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getFolderRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getFolderRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getFolderRequest %p -> %p\n", q, p));
	*(_ngwm__getFolderRequest*)p = *(_ngwm__getFolderRequest*)q;
}

void _ngwm__getDocumentTypeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getDocumentTypeListResponse*)this)->items, SOAP_TYPE_PointerTongwt__DocumentTypeList);
	soap_serialize_PointerTongwt__DocumentTypeList(soap, &((_ngwm__getDocumentTypeListResponse*)this)->items);
	soap_embedded(soap, &((_ngwm__getDocumentTypeListResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getDocumentTypeListResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getDocumentTypeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getDocumentTypeListResponse*)this)->items = NULL;
	((_ngwm__getDocumentTypeListResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getDocumentTypeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getDocumentTypeListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getDocumentTypeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getDocumentTypeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getDocumentTypeListResponse(struct soap *soap, const char *tag, int id, const _ngwm__getDocumentTypeListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getDocumentTypeListResponse), type);
	soap_out_PointerTongwt__DocumentTypeList(soap, "ngwm:items", -1, &(((_ngwm__getDocumentTypeListResponse*)a)->items), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getDocumentTypeListResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getDocumentTypeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getDocumentTypeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getDocumentTypeListResponse * SOAP_FMAC4 soap_get__ngwm__getDocumentTypeListResponse(struct soap *soap, _ngwm__getDocumentTypeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getDocumentTypeListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getDocumentTypeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getDocumentTypeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getDocumentTypeListResponse * SOAP_FMAC4 soap_in__ngwm__getDocumentTypeListResponse(struct soap *soap, const char *tag, _ngwm__getDocumentTypeListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getDocumentTypeListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getDocumentTypeListResponse, sizeof(_ngwm__getDocumentTypeListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getDocumentTypeListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getDocumentTypeListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DocumentTypeList(soap, "ngwm:items", &(((_ngwm__getDocumentTypeListResponse*)a)->items), "ngwt:DocumentTypeList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getDocumentTypeListResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getDocumentTypeListResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDocumentTypeListResponse, 0, sizeof(_ngwm__getDocumentTypeListResponse), 0, soap_copy__ngwm__getDocumentTypeListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getDocumentTypeListResponse * SOAP_FMAC6 soap_new__ngwm__getDocumentTypeListResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getDocumentTypeListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getDocumentTypeListResponse(struct soap *soap, _ngwm__getDocumentTypeListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getDocumentTypeListResponse * SOAP_FMAC6 soap_instantiate__ngwm__getDocumentTypeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getDocumentTypeListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getDocumentTypeListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getDocumentTypeListResponse;
		if (size)
			*size = sizeof(_ngwm__getDocumentTypeListResponse);
		((_ngwm__getDocumentTypeListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getDocumentTypeListResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getDocumentTypeListResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getDocumentTypeListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getDocumentTypeListResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getDocumentTypeListResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getDocumentTypeListResponse %p -> %p\n", q, p));
	*(_ngwm__getDocumentTypeListResponse*)p = *(_ngwm__getDocumentTypeListResponse*)q;
}

void _ngwm__getDocumentTypeListRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getDocumentTypeListRequest*)this)->library, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__getDocumentTypeListRequest*)this)->library);
	/* transient soap skipped */
}

void _ngwm__getDocumentTypeListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__getDocumentTypeListRequest*)this)->library);
	/* transient soap skipped */
}

int _ngwm__getDocumentTypeListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getDocumentTypeListRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getDocumentTypeListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getDocumentTypeListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getDocumentTypeListRequest(struct soap *soap, const char *tag, int id, const _ngwm__getDocumentTypeListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getDocumentTypeListRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:library", -1, &(((_ngwm__getDocumentTypeListRequest*)a)->library), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getDocumentTypeListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getDocumentTypeListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getDocumentTypeListRequest * SOAP_FMAC4 soap_get__ngwm__getDocumentTypeListRequest(struct soap *soap, _ngwm__getDocumentTypeListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getDocumentTypeListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getDocumentTypeListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getDocumentTypeListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getDocumentTypeListRequest * SOAP_FMAC4 soap_in__ngwm__getDocumentTypeListRequest(struct soap *soap, const char *tag, _ngwm__getDocumentTypeListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getDocumentTypeListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getDocumentTypeListRequest, sizeof(_ngwm__getDocumentTypeListRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getDocumentTypeListRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getDocumentTypeListRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_library1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_library1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:library", &(((_ngwm__getDocumentTypeListRequest*)a)->library), "ngwt:uid"))
				{	soap_flag_library1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_library1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getDocumentTypeListRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDocumentTypeListRequest, 0, sizeof(_ngwm__getDocumentTypeListRequest), 0, soap_copy__ngwm__getDocumentTypeListRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getDocumentTypeListRequest * SOAP_FMAC6 soap_new__ngwm__getDocumentTypeListRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getDocumentTypeListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getDocumentTypeListRequest(struct soap *soap, _ngwm__getDocumentTypeListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getDocumentTypeListRequest * SOAP_FMAC6 soap_instantiate__ngwm__getDocumentTypeListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getDocumentTypeListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getDocumentTypeListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getDocumentTypeListRequest;
		if (size)
			*size = sizeof(_ngwm__getDocumentTypeListRequest);
		((_ngwm__getDocumentTypeListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getDocumentTypeListRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getDocumentTypeListRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getDocumentTypeListRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getDocumentTypeListRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getDocumentTypeListRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getDocumentTypeListRequest %p -> %p\n", q, p));
	*(_ngwm__getDocumentTypeListRequest*)p = *(_ngwm__getDocumentTypeListRequest*)q;
}

void _ngwm__getDeltaInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getDeltaInfoResponse*)this)->deltaInfo, SOAP_TYPE_PointerTongwt__DeltaInfo);
	soap_serialize_PointerTongwt__DeltaInfo(soap, &((_ngwm__getDeltaInfoResponse*)this)->deltaInfo);
	soap_embedded(soap, &((_ngwm__getDeltaInfoResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getDeltaInfoResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getDeltaInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getDeltaInfoResponse*)this)->deltaInfo = NULL;
	((_ngwm__getDeltaInfoResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getDeltaInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getDeltaInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getDeltaInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getDeltaInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getDeltaInfoResponse(struct soap *soap, const char *tag, int id, const _ngwm__getDeltaInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getDeltaInfoResponse), type);
	soap_out_PointerTongwt__DeltaInfo(soap, "ngwm:deltaInfo", -1, &(((_ngwm__getDeltaInfoResponse*)a)->deltaInfo), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getDeltaInfoResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getDeltaInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getDeltaInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getDeltaInfoResponse * SOAP_FMAC4 soap_get__ngwm__getDeltaInfoResponse(struct soap *soap, _ngwm__getDeltaInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getDeltaInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getDeltaInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getDeltaInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getDeltaInfoResponse * SOAP_FMAC4 soap_in__ngwm__getDeltaInfoResponse(struct soap *soap, const char *tag, _ngwm__getDeltaInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getDeltaInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getDeltaInfoResponse, sizeof(_ngwm__getDeltaInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getDeltaInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getDeltaInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_deltaInfo1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deltaInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DeltaInfo(soap, "ngwm:deltaInfo", &(((_ngwm__getDeltaInfoResponse*)a)->deltaInfo), "ngwt:DeltaInfo"))
				{	soap_flag_deltaInfo1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getDeltaInfoResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deltaInfo1 || soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getDeltaInfoResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDeltaInfoResponse, 0, sizeof(_ngwm__getDeltaInfoResponse), 0, soap_copy__ngwm__getDeltaInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getDeltaInfoResponse * SOAP_FMAC6 soap_new__ngwm__getDeltaInfoResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getDeltaInfoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getDeltaInfoResponse(struct soap *soap, _ngwm__getDeltaInfoResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getDeltaInfoResponse * SOAP_FMAC6 soap_instantiate__ngwm__getDeltaInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getDeltaInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getDeltaInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getDeltaInfoResponse;
		if (size)
			*size = sizeof(_ngwm__getDeltaInfoResponse);
		((_ngwm__getDeltaInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getDeltaInfoResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getDeltaInfoResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getDeltaInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getDeltaInfoResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getDeltaInfoResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getDeltaInfoResponse %p -> %p\n", q, p));
	*(_ngwm__getDeltaInfoResponse*)p = *(_ngwm__getDeltaInfoResponse*)q;
}

void _ngwm__getDeltaInfoRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getDeltaInfoRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__getDeltaInfoRequest*)this)->container);
	/* transient soap skipped */
}

void _ngwm__getDeltaInfoRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__getDeltaInfoRequest*)this)->container);
	/* transient soap skipped */
}

int _ngwm__getDeltaInfoRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getDeltaInfoRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getDeltaInfoRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getDeltaInfoRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getDeltaInfoRequest(struct soap *soap, const char *tag, int id, const _ngwm__getDeltaInfoRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getDeltaInfoRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__getDeltaInfoRequest*)a)->container), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getDeltaInfoRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getDeltaInfoRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getDeltaInfoRequest * SOAP_FMAC4 soap_get__ngwm__getDeltaInfoRequest(struct soap *soap, _ngwm__getDeltaInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getDeltaInfoRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getDeltaInfoRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getDeltaInfoRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getDeltaInfoRequest * SOAP_FMAC4 soap_in__ngwm__getDeltaInfoRequest(struct soap *soap, const char *tag, _ngwm__getDeltaInfoRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getDeltaInfoRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getDeltaInfoRequest, sizeof(_ngwm__getDeltaInfoRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getDeltaInfoRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getDeltaInfoRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__getDeltaInfoRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getDeltaInfoRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDeltaInfoRequest, 0, sizeof(_ngwm__getDeltaInfoRequest), 0, soap_copy__ngwm__getDeltaInfoRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getDeltaInfoRequest * SOAP_FMAC6 soap_new__ngwm__getDeltaInfoRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getDeltaInfoRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getDeltaInfoRequest(struct soap *soap, _ngwm__getDeltaInfoRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getDeltaInfoRequest * SOAP_FMAC6 soap_instantiate__ngwm__getDeltaInfoRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getDeltaInfoRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getDeltaInfoRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getDeltaInfoRequest;
		if (size)
			*size = sizeof(_ngwm__getDeltaInfoRequest);
		((_ngwm__getDeltaInfoRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getDeltaInfoRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getDeltaInfoRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getDeltaInfoRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getDeltaInfoRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getDeltaInfoRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getDeltaInfoRequest %p -> %p\n", q, p));
	*(_ngwm__getDeltaInfoRequest*)p = *(_ngwm__getDeltaInfoRequest*)q;
}

void _ngwm__getDeltasResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getDeltasResponse*)this)->items, SOAP_TYPE_PointerTongwt__Items);
	soap_serialize_PointerTongwt__Items(soap, &((_ngwm__getDeltasResponse*)this)->items);
	soap_embedded(soap, &((_ngwm__getDeltasResponse*)this)->deltaInfo, SOAP_TYPE_PointerTongwt__DeltaInfo);
	soap_serialize_PointerTongwt__DeltaInfo(soap, &((_ngwm__getDeltasResponse*)this)->deltaInfo);
	soap_embedded(soap, &((_ngwm__getDeltasResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getDeltasResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getDeltasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getDeltasResponse*)this)->items = NULL;
	((_ngwm__getDeltasResponse*)this)->deltaInfo = NULL;
	((_ngwm__getDeltasResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getDeltasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getDeltasResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getDeltasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getDeltasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getDeltasResponse(struct soap *soap, const char *tag, int id, const _ngwm__getDeltasResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getDeltasResponse), type);
	soap_out_PointerTongwt__Items(soap, "ngwm:items", -1, &(((_ngwm__getDeltasResponse*)a)->items), "");
	soap_out_PointerTongwt__DeltaInfo(soap, "ngwm:deltaInfo", -1, &(((_ngwm__getDeltasResponse*)a)->deltaInfo), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getDeltasResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getDeltasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getDeltasResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getDeltasResponse * SOAP_FMAC4 soap_get__ngwm__getDeltasResponse(struct soap *soap, _ngwm__getDeltasResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getDeltasResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getDeltasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getDeltasResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getDeltasResponse * SOAP_FMAC4 soap_in__ngwm__getDeltasResponse(struct soap *soap, const char *tag, _ngwm__getDeltasResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getDeltasResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getDeltasResponse, sizeof(_ngwm__getDeltasResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getDeltasResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getDeltasResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1, soap_flag_deltaInfo1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Items(soap, "ngwm:items", &(((_ngwm__getDeltasResponse*)a)->items), "ngwt:Items"))
				{	soap_flag_items1 = 0;
					continue;
				}
			if (soap_flag_deltaInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DeltaInfo(soap, "ngwm:deltaInfo", &(((_ngwm__getDeltasResponse*)a)->deltaInfo), "ngwt:DeltaInfo"))
				{	soap_flag_deltaInfo1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getDeltasResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deltaInfo1 || soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getDeltasResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDeltasResponse, 0, sizeof(_ngwm__getDeltasResponse), 0, soap_copy__ngwm__getDeltasResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getDeltasResponse * SOAP_FMAC6 soap_new__ngwm__getDeltasResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getDeltasResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getDeltasResponse(struct soap *soap, _ngwm__getDeltasResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getDeltasResponse * SOAP_FMAC6 soap_instantiate__ngwm__getDeltasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getDeltasResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getDeltasResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getDeltasResponse;
		if (size)
			*size = sizeof(_ngwm__getDeltasResponse);
		((_ngwm__getDeltasResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getDeltasResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getDeltasResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getDeltasResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getDeltasResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getDeltasResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getDeltasResponse %p -> %p\n", q, p));
	*(_ngwm__getDeltasResponse*)p = *(_ngwm__getDeltasResponse*)q;
}

void _ngwm__getDeltasRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getDeltasRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__getDeltasRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__getDeltasRequest*)this)->view, SOAP_TYPE_PointerTongwt__View);
	soap_serialize_PointerTongwt__View(soap, &((_ngwm__getDeltasRequest*)this)->view);
	soap_embedded(soap, &((_ngwm__getDeltasRequest*)this)->deltaInfo, SOAP_TYPE_PointerTongwt__DeltaInfo);
	soap_serialize_PointerTongwt__DeltaInfo(soap, &((_ngwm__getDeltasRequest*)this)->deltaInfo);
	/* transient soap skipped */
}

void _ngwm__getDeltasRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__getDeltasRequest*)this)->container);
	((_ngwm__getDeltasRequest*)this)->view = NULL;
	((_ngwm__getDeltasRequest*)this)->deltaInfo = NULL;
	/* transient soap skipped */
}

int _ngwm__getDeltasRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getDeltasRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getDeltasRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getDeltasRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getDeltasRequest(struct soap *soap, const char *tag, int id, const _ngwm__getDeltasRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getDeltasRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__getDeltasRequest*)a)->container), "");
	soap_out_PointerTongwt__View(soap, "ngwm:view", -1, &(((_ngwm__getDeltasRequest*)a)->view), "");
	soap_out_PointerTongwt__DeltaInfo(soap, "ngwm:deltaInfo", -1, &(((_ngwm__getDeltasRequest*)a)->deltaInfo), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getDeltasRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getDeltasRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getDeltasRequest * SOAP_FMAC4 soap_get__ngwm__getDeltasRequest(struct soap *soap, _ngwm__getDeltasRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getDeltasRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getDeltasRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getDeltasRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getDeltasRequest * SOAP_FMAC4 soap_in__ngwm__getDeltasRequest(struct soap *soap, const char *tag, _ngwm__getDeltasRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getDeltasRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getDeltasRequest, sizeof(_ngwm__getDeltasRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getDeltasRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getDeltasRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_view1 = 1, soap_flag_deltaInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__getDeltasRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__View(soap, "ngwm:view", &(((_ngwm__getDeltasRequest*)a)->view), "ngwt:View"))
				{	soap_flag_view1 = 0;
					continue;
				}
			if (soap_flag_deltaInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DeltaInfo(soap, "ngwm:deltaInfo", &(((_ngwm__getDeltasRequest*)a)->deltaInfo), "ngwt:DeltaInfo"))
				{	soap_flag_deltaInfo1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_deltaInfo1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getDeltasRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDeltasRequest, 0, sizeof(_ngwm__getDeltasRequest), 0, soap_copy__ngwm__getDeltasRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getDeltasRequest * SOAP_FMAC6 soap_new__ngwm__getDeltasRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getDeltasRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getDeltasRequest(struct soap *soap, _ngwm__getDeltasRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getDeltasRequest * SOAP_FMAC6 soap_instantiate__ngwm__getDeltasRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getDeltasRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getDeltasRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getDeltasRequest;
		if (size)
			*size = sizeof(_ngwm__getDeltasRequest);
		((_ngwm__getDeltasRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getDeltasRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getDeltasRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getDeltasRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getDeltasRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getDeltasRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getDeltasRequest %p -> %p\n", q, p));
	*(_ngwm__getDeltasRequest*)p = *(_ngwm__getDeltasRequest*)q;
}

void _ngwm__getCustomListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getCustomListResponse*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((_ngwm__getCustomListResponse*)this)->customs);
	soap_embedded(soap, &((_ngwm__getCustomListResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getCustomListResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getCustomListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getCustomListResponse*)this)->customs = NULL;
	((_ngwm__getCustomListResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getCustomListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getCustomListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getCustomListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getCustomListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getCustomListResponse(struct soap *soap, const char *tag, int id, const _ngwm__getCustomListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getCustomListResponse), type);
	soap_out_PointerTongwt__CustomList(soap, "ngwm:customs", -1, &(((_ngwm__getCustomListResponse*)a)->customs), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getCustomListResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getCustomListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getCustomListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getCustomListResponse * SOAP_FMAC4 soap_get__ngwm__getCustomListResponse(struct soap *soap, _ngwm__getCustomListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getCustomListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getCustomListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getCustomListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getCustomListResponse * SOAP_FMAC4 soap_in__ngwm__getCustomListResponse(struct soap *soap, const char *tag, _ngwm__getCustomListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getCustomListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getCustomListResponse, sizeof(_ngwm__getCustomListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getCustomListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getCustomListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_customs1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_customs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwm:customs", &(((_ngwm__getCustomListResponse*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getCustomListResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getCustomListResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getCustomListResponse, 0, sizeof(_ngwm__getCustomListResponse), 0, soap_copy__ngwm__getCustomListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getCustomListResponse * SOAP_FMAC6 soap_new__ngwm__getCustomListResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getCustomListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getCustomListResponse(struct soap *soap, _ngwm__getCustomListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getCustomListResponse * SOAP_FMAC6 soap_instantiate__ngwm__getCustomListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getCustomListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getCustomListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getCustomListResponse;
		if (size)
			*size = sizeof(_ngwm__getCustomListResponse);
		((_ngwm__getCustomListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getCustomListResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getCustomListResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getCustomListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getCustomListResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getCustomListResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getCustomListResponse %p -> %p\n", q, p));
	*(_ngwm__getCustomListResponse*)p = *(_ngwm__getCustomListResponse*)q;
}

void _ngwm__getCustomListRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ngwm__getCustomListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ngwm__getCustomListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getCustomListRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getCustomListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getCustomListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getCustomListRequest(struct soap *soap, const char *tag, int id, const _ngwm__getCustomListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getCustomListRequest), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getCustomListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getCustomListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getCustomListRequest * SOAP_FMAC4 soap_get__ngwm__getCustomListRequest(struct soap *soap, _ngwm__getCustomListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getCustomListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getCustomListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getCustomListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getCustomListRequest * SOAP_FMAC4 soap_in__ngwm__getCustomListRequest(struct soap *soap, const char *tag, _ngwm__getCustomListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getCustomListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getCustomListRequest, sizeof(_ngwm__getCustomListRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getCustomListRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getCustomListRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getCustomListRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getCustomListRequest, 0, sizeof(_ngwm__getCustomListRequest), 0, soap_copy__ngwm__getCustomListRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getCustomListRequest * SOAP_FMAC6 soap_new__ngwm__getCustomListRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getCustomListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getCustomListRequest(struct soap *soap, _ngwm__getCustomListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getCustomListRequest * SOAP_FMAC6 soap_instantiate__ngwm__getCustomListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getCustomListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getCustomListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getCustomListRequest;
		if (size)
			*size = sizeof(_ngwm__getCustomListRequest);
		((_ngwm__getCustomListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getCustomListRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getCustomListRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getCustomListRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getCustomListRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getCustomListRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getCustomListRequest %p -> %p\n", q, p));
	*(_ngwm__getCustomListRequest*)p = *(_ngwm__getCustomListRequest*)q;
}

void _ngwm__getCategoryListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getCategoryListResponse*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryList);
	soap_serialize_PointerTongwt__CategoryList(soap, &((_ngwm__getCategoryListResponse*)this)->categories);
	soap_embedded(soap, &((_ngwm__getCategoryListResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getCategoryListResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getCategoryListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getCategoryListResponse*)this)->categories = NULL;
	((_ngwm__getCategoryListResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getCategoryListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getCategoryListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getCategoryListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getCategoryListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getCategoryListResponse(struct soap *soap, const char *tag, int id, const _ngwm__getCategoryListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getCategoryListResponse), type);
	soap_out_PointerTongwt__CategoryList(soap, "ngwm:categories", -1, &(((_ngwm__getCategoryListResponse*)a)->categories), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getCategoryListResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getCategoryListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getCategoryListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getCategoryListResponse * SOAP_FMAC4 soap_get__ngwm__getCategoryListResponse(struct soap *soap, _ngwm__getCategoryListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getCategoryListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getCategoryListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getCategoryListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getCategoryListResponse * SOAP_FMAC4 soap_in__ngwm__getCategoryListResponse(struct soap *soap, const char *tag, _ngwm__getCategoryListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getCategoryListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getCategoryListResponse, sizeof(_ngwm__getCategoryListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getCategoryListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getCategoryListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_categories1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_categories1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryList(soap, "ngwm:categories", &(((_ngwm__getCategoryListResponse*)a)->categories), "ngwt:CategoryList"))
				{	soap_flag_categories1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getCategoryListResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getCategoryListResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getCategoryListResponse, 0, sizeof(_ngwm__getCategoryListResponse), 0, soap_copy__ngwm__getCategoryListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getCategoryListResponse * SOAP_FMAC6 soap_new__ngwm__getCategoryListResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getCategoryListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getCategoryListResponse(struct soap *soap, _ngwm__getCategoryListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getCategoryListResponse * SOAP_FMAC6 soap_instantiate__ngwm__getCategoryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getCategoryListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getCategoryListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getCategoryListResponse;
		if (size)
			*size = sizeof(_ngwm__getCategoryListResponse);
		((_ngwm__getCategoryListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getCategoryListResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getCategoryListResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getCategoryListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getCategoryListResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getCategoryListResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getCategoryListResponse %p -> %p\n", q, p));
	*(_ngwm__getCategoryListResponse*)p = *(_ngwm__getCategoryListResponse*)q;
}

void _ngwm__getCategoryListRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ngwm__getCategoryListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ngwm__getCategoryListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getCategoryListRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getCategoryListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getCategoryListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getCategoryListRequest(struct soap *soap, const char *tag, int id, const _ngwm__getCategoryListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getCategoryListRequest), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getCategoryListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getCategoryListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getCategoryListRequest * SOAP_FMAC4 soap_get__ngwm__getCategoryListRequest(struct soap *soap, _ngwm__getCategoryListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getCategoryListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getCategoryListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getCategoryListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getCategoryListRequest * SOAP_FMAC4 soap_in__ngwm__getCategoryListRequest(struct soap *soap, const char *tag, _ngwm__getCategoryListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getCategoryListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getCategoryListRequest, sizeof(_ngwm__getCategoryListRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getCategoryListRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getCategoryListRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getCategoryListRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getCategoryListRequest, 0, sizeof(_ngwm__getCategoryListRequest), 0, soap_copy__ngwm__getCategoryListRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getCategoryListRequest * SOAP_FMAC6 soap_new__ngwm__getCategoryListRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getCategoryListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getCategoryListRequest(struct soap *soap, _ngwm__getCategoryListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getCategoryListRequest * SOAP_FMAC6 soap_instantiate__ngwm__getCategoryListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getCategoryListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getCategoryListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getCategoryListRequest;
		if (size)
			*size = sizeof(_ngwm__getCategoryListRequest);
		((_ngwm__getCategoryListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getCategoryListRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getCategoryListRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getCategoryListRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getCategoryListRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getCategoryListRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getCategoryListRequest %p -> %p\n", q, p));
	*(_ngwm__getCategoryListRequest*)p = *(_ngwm__getCategoryListRequest*)q;
}

void _ngwm__getAttachmentResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getAttachmentResponse*)this)->part, SOAP_TYPE_PointerTongwt__MessagePart);
	soap_serialize_PointerTongwt__MessagePart(soap, &((_ngwm__getAttachmentResponse*)this)->part);
	soap_embedded(soap, &((_ngwm__getAttachmentResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getAttachmentResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getAttachmentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getAttachmentResponse*)this)->part = NULL;
	((_ngwm__getAttachmentResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getAttachmentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getAttachmentResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getAttachmentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getAttachmentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getAttachmentResponse(struct soap *soap, const char *tag, int id, const _ngwm__getAttachmentResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getAttachmentResponse), type);
	soap_out_PointerTongwt__MessagePart(soap, "ngwm:part", -1, &(((_ngwm__getAttachmentResponse*)a)->part), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getAttachmentResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getAttachmentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getAttachmentResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getAttachmentResponse * SOAP_FMAC4 soap_get__ngwm__getAttachmentResponse(struct soap *soap, _ngwm__getAttachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getAttachmentResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getAttachmentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getAttachmentResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getAttachmentResponse * SOAP_FMAC4 soap_in__ngwm__getAttachmentResponse(struct soap *soap, const char *tag, _ngwm__getAttachmentResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getAttachmentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getAttachmentResponse, sizeof(_ngwm__getAttachmentResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getAttachmentResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getAttachmentResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_part1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_part1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessagePart(soap, "ngwm:part", &(((_ngwm__getAttachmentResponse*)a)->part), "ngwt:MessagePart"))
				{	soap_flag_part1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getAttachmentResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getAttachmentResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getAttachmentResponse, 0, sizeof(_ngwm__getAttachmentResponse), 0, soap_copy__ngwm__getAttachmentResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getAttachmentResponse * SOAP_FMAC6 soap_new__ngwm__getAttachmentResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getAttachmentResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getAttachmentResponse(struct soap *soap, _ngwm__getAttachmentResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getAttachmentResponse * SOAP_FMAC6 soap_instantiate__ngwm__getAttachmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getAttachmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getAttachmentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getAttachmentResponse;
		if (size)
			*size = sizeof(_ngwm__getAttachmentResponse);
		((_ngwm__getAttachmentResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getAttachmentResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getAttachmentResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getAttachmentResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getAttachmentResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getAttachmentResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getAttachmentResponse %p -> %p\n", q, p));
	*(_ngwm__getAttachmentResponse*)p = *(_ngwm__getAttachmentResponse*)q;
}

void _ngwm__getAttachmentRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getAttachmentRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__getAttachmentRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__getAttachmentRequest*)this)->offset, SOAP_TYPE_int);
	soap_embedded(soap, &((_ngwm__getAttachmentRequest*)this)->length, SOAP_TYPE_int);
	/* transient soap skipped */
}

void _ngwm__getAttachmentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__getAttachmentRequest*)this)->id);
	soap_default_int(soap, &((_ngwm__getAttachmentRequest*)this)->offset);
	soap_default_int(soap, &((_ngwm__getAttachmentRequest*)this)->length);
	/* transient soap skipped */
}

int _ngwm__getAttachmentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getAttachmentRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getAttachmentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getAttachmentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getAttachmentRequest(struct soap *soap, const char *tag, int id, const _ngwm__getAttachmentRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getAttachmentRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__getAttachmentRequest*)a)->id), "");
	soap_out_int(soap, "ngwm:offset", -1, &(((_ngwm__getAttachmentRequest*)a)->offset), "");
	soap_out_int(soap, "ngwm:length", -1, &(((_ngwm__getAttachmentRequest*)a)->length), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getAttachmentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getAttachmentRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getAttachmentRequest * SOAP_FMAC4 soap_get__ngwm__getAttachmentRequest(struct soap *soap, _ngwm__getAttachmentRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getAttachmentRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getAttachmentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getAttachmentRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getAttachmentRequest * SOAP_FMAC4 soap_in__ngwm__getAttachmentRequest(struct soap *soap, const char *tag, _ngwm__getAttachmentRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getAttachmentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getAttachmentRequest, sizeof(_ngwm__getAttachmentRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getAttachmentRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getAttachmentRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_offset1 = 1, soap_flag_length1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__getAttachmentRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_offset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwm:offset", &(((_ngwm__getAttachmentRequest*)a)->offset), ""))
				{	soap_flag_offset1 = 0;
					continue;
				}
			if (soap_flag_length1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwm:length", &(((_ngwm__getAttachmentRequest*)a)->length), ""))
				{	soap_flag_length1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_offset1 || soap_flag_length1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getAttachmentRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getAttachmentRequest, 0, sizeof(_ngwm__getAttachmentRequest), 0, soap_copy__ngwm__getAttachmentRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getAttachmentRequest * SOAP_FMAC6 soap_new__ngwm__getAttachmentRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getAttachmentRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getAttachmentRequest(struct soap *soap, _ngwm__getAttachmentRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getAttachmentRequest * SOAP_FMAC6 soap_instantiate__ngwm__getAttachmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getAttachmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getAttachmentRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getAttachmentRequest;
		if (size)
			*size = sizeof(_ngwm__getAttachmentRequest);
		((_ngwm__getAttachmentRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getAttachmentRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getAttachmentRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getAttachmentRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getAttachmentRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getAttachmentRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getAttachmentRequest %p -> %p\n", q, p));
	*(_ngwm__getAttachmentRequest*)p = *(_ngwm__getAttachmentRequest*)q;
}

void _ngwm__getAddressBookListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__getAddressBookListResponse*)this)->books, SOAP_TYPE_PointerTongwt__AddressBookList);
	soap_serialize_PointerTongwt__AddressBookList(soap, &((_ngwm__getAddressBookListResponse*)this)->books);
	soap_embedded(soap, &((_ngwm__getAddressBookListResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__getAddressBookListResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__getAddressBookListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__getAddressBookListResponse*)this)->books = NULL;
	((_ngwm__getAddressBookListResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__getAddressBookListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getAddressBookListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getAddressBookListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getAddressBookListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getAddressBookListResponse(struct soap *soap, const char *tag, int id, const _ngwm__getAddressBookListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getAddressBookListResponse), type);
	soap_out_PointerTongwt__AddressBookList(soap, "ngwm:books", -1, &(((_ngwm__getAddressBookListResponse*)a)->books), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__getAddressBookListResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getAddressBookListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getAddressBookListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getAddressBookListResponse * SOAP_FMAC4 soap_get__ngwm__getAddressBookListResponse(struct soap *soap, _ngwm__getAddressBookListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getAddressBookListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getAddressBookListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getAddressBookListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getAddressBookListResponse * SOAP_FMAC4 soap_in__ngwm__getAddressBookListResponse(struct soap *soap, const char *tag, _ngwm__getAddressBookListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getAddressBookListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getAddressBookListResponse, sizeof(_ngwm__getAddressBookListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getAddressBookListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getAddressBookListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_books1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_books1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AddressBookList(soap, "ngwm:books", &(((_ngwm__getAddressBookListResponse*)a)->books), "ngwt:AddressBookList"))
				{	soap_flag_books1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__getAddressBookListResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getAddressBookListResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getAddressBookListResponse, 0, sizeof(_ngwm__getAddressBookListResponse), 0, soap_copy__ngwm__getAddressBookListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getAddressBookListResponse * SOAP_FMAC6 soap_new__ngwm__getAddressBookListResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getAddressBookListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getAddressBookListResponse(struct soap *soap, _ngwm__getAddressBookListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getAddressBookListResponse * SOAP_FMAC6 soap_instantiate__ngwm__getAddressBookListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getAddressBookListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getAddressBookListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getAddressBookListResponse;
		if (size)
			*size = sizeof(_ngwm__getAddressBookListResponse);
		((_ngwm__getAddressBookListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getAddressBookListResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__getAddressBookListResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__getAddressBookListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getAddressBookListResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getAddressBookListResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getAddressBookListResponse %p -> %p\n", q, p));
	*(_ngwm__getAddressBookListResponse*)p = *(_ngwm__getAddressBookListResponse*)q;
}

void _ngwm__getAddressBookListRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void _ngwm__getAddressBookListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int _ngwm__getAddressBookListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__getAddressBookListRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__getAddressBookListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__getAddressBookListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__getAddressBookListRequest(struct soap *soap, const char *tag, int id, const _ngwm__getAddressBookListRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__getAddressBookListRequest), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__getAddressBookListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__getAddressBookListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__getAddressBookListRequest * SOAP_FMAC4 soap_get__ngwm__getAddressBookListRequest(struct soap *soap, _ngwm__getAddressBookListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__getAddressBookListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__getAddressBookListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__getAddressBookListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__getAddressBookListRequest * SOAP_FMAC4 soap_in__ngwm__getAddressBookListRequest(struct soap *soap, const char *tag, _ngwm__getAddressBookListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__getAddressBookListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__getAddressBookListRequest, sizeof(_ngwm__getAddressBookListRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__getAddressBookListRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__getAddressBookListRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__getAddressBookListRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getAddressBookListRequest, 0, sizeof(_ngwm__getAddressBookListRequest), 0, soap_copy__ngwm__getAddressBookListRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__getAddressBookListRequest * SOAP_FMAC6 soap_new__ngwm__getAddressBookListRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__getAddressBookListRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__getAddressBookListRequest(struct soap *soap, _ngwm__getAddressBookListRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__getAddressBookListRequest * SOAP_FMAC6 soap_instantiate__ngwm__getAddressBookListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__getAddressBookListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__getAddressBookListRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__getAddressBookListRequest;
		if (size)
			*size = sizeof(_ngwm__getAddressBookListRequest);
		((_ngwm__getAddressBookListRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__getAddressBookListRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__getAddressBookListRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__getAddressBookListRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__getAddressBookListRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__getAddressBookListRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__getAddressBookListRequest %p -> %p\n", q, p));
	*(_ngwm__getAddressBookListRequest*)p = *(_ngwm__getAddressBookListRequest*)q;
}

void _ngwm__forwardResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__forwardResponse*)this)->item, SOAP_TYPE_PointerTongwt__Item);
	soap_serialize_PointerTongwt__Item(soap, &((_ngwm__forwardResponse*)this)->item);
	soap_embedded(soap, &((_ngwm__forwardResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__forwardResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__forwardResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__forwardResponse*)this)->item = NULL;
	((_ngwm__forwardResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__forwardResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__forwardResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__forwardResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__forwardResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__forwardResponse(struct soap *soap, const char *tag, int id, const _ngwm__forwardResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__forwardResponse), type);
	soap_out_PointerTongwt__Item(soap, "ngwm:item", -1, &(((_ngwm__forwardResponse*)a)->item), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__forwardResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__forwardResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__forwardResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__forwardResponse * SOAP_FMAC4 soap_get__ngwm__forwardResponse(struct soap *soap, _ngwm__forwardResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__forwardResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__forwardResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__forwardResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__forwardResponse * SOAP_FMAC4 soap_in__ngwm__forwardResponse(struct soap *soap, const char *tag, _ngwm__forwardResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__forwardResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__forwardResponse, sizeof(_ngwm__forwardResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__forwardResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__forwardResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_item1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Item(soap, "ngwm:item", &(((_ngwm__forwardResponse*)a)->item), "ngwt:Item"))
				{	soap_flag_item1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__forwardResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__forwardResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__forwardResponse, 0, sizeof(_ngwm__forwardResponse), 0, soap_copy__ngwm__forwardResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__forwardResponse * SOAP_FMAC6 soap_new__ngwm__forwardResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__forwardResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__forwardResponse(struct soap *soap, _ngwm__forwardResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__forwardResponse * SOAP_FMAC6 soap_instantiate__ngwm__forwardResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__forwardResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__forwardResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__forwardResponse;
		if (size)
			*size = sizeof(_ngwm__forwardResponse);
		((_ngwm__forwardResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__forwardResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__forwardResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__forwardResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__forwardResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__forwardResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__forwardResponse %p -> %p\n", q, p));
	*(_ngwm__forwardResponse*)p = *(_ngwm__forwardResponse*)q;
}

void _ngwm__forwardRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__forwardRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__forwardRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__forwardRequest*)this)->view, SOAP_TYPE_PointerTongwt__View);
	soap_serialize_PointerTongwt__View(soap, &((_ngwm__forwardRequest*)this)->view);
	soap_embedded(soap, &((_ngwm__forwardRequest*)this)->embed, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void _ngwm__forwardRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__forwardRequest*)this)->id);
	((_ngwm__forwardRequest*)this)->view = NULL;
	((_ngwm__forwardRequest*)this)->embed = (bool)0;
	/* transient soap skipped */
}

int _ngwm__forwardRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__forwardRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__forwardRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__forwardRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__forwardRequest(struct soap *soap, const char *tag, int id, const _ngwm__forwardRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__forwardRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__forwardRequest*)a)->id), "");
	soap_out_PointerTongwt__View(soap, "ngwm:view", -1, &(((_ngwm__forwardRequest*)a)->view), "");
	soap_out_bool(soap, "ngwm:embed", -1, &(((_ngwm__forwardRequest*)a)->embed), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__forwardRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__forwardRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__forwardRequest * SOAP_FMAC4 soap_get__ngwm__forwardRequest(struct soap *soap, _ngwm__forwardRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__forwardRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__forwardRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__forwardRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__forwardRequest * SOAP_FMAC4 soap_in__ngwm__forwardRequest(struct soap *soap, const char *tag, _ngwm__forwardRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__forwardRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__forwardRequest, sizeof(_ngwm__forwardRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__forwardRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__forwardRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_view1 = 1, soap_flag_embed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__forwardRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__View(soap, "ngwm:view", &(((_ngwm__forwardRequest*)a)->view), "ngwt:View"))
				{	soap_flag_view1 = 0;
					continue;
				}
			if (soap_flag_embed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwm:embed", &(((_ngwm__forwardRequest*)a)->embed), ""))
				{	soap_flag_embed1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__forwardRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__forwardRequest, 0, sizeof(_ngwm__forwardRequest), 0, soap_copy__ngwm__forwardRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__forwardRequest * SOAP_FMAC6 soap_new__ngwm__forwardRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__forwardRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__forwardRequest(struct soap *soap, _ngwm__forwardRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__forwardRequest * SOAP_FMAC6 soap_instantiate__ngwm__forwardRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__forwardRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__forwardRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__forwardRequest;
		if (size)
			*size = sizeof(_ngwm__forwardRequest);
		((_ngwm__forwardRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__forwardRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__forwardRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__forwardRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__forwardRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__forwardRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__forwardRequest %p -> %p\n", q, p));
	*(_ngwm__forwardRequest*)p = *(_ngwm__forwardRequest*)q;
}

void _ngwm__executeRuleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__executeRuleResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__executeRuleResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__executeRuleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__executeRuleResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__executeRuleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__executeRuleResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__executeRuleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__executeRuleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__executeRuleResponse(struct soap *soap, const char *tag, int id, const _ngwm__executeRuleResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__executeRuleResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__executeRuleResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__executeRuleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__executeRuleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__executeRuleResponse * SOAP_FMAC4 soap_get__ngwm__executeRuleResponse(struct soap *soap, _ngwm__executeRuleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__executeRuleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__executeRuleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__executeRuleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__executeRuleResponse * SOAP_FMAC4 soap_in__ngwm__executeRuleResponse(struct soap *soap, const char *tag, _ngwm__executeRuleResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__executeRuleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__executeRuleResponse, sizeof(_ngwm__executeRuleResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__executeRuleResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__executeRuleResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__executeRuleResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__executeRuleResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__executeRuleResponse, 0, sizeof(_ngwm__executeRuleResponse), 0, soap_copy__ngwm__executeRuleResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__executeRuleResponse * SOAP_FMAC6 soap_new__ngwm__executeRuleResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__executeRuleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__executeRuleResponse(struct soap *soap, _ngwm__executeRuleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__executeRuleResponse * SOAP_FMAC6 soap_instantiate__ngwm__executeRuleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__executeRuleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__executeRuleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__executeRuleResponse;
		if (size)
			*size = sizeof(_ngwm__executeRuleResponse);
		((_ngwm__executeRuleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__executeRuleResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__executeRuleResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__executeRuleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__executeRuleResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__executeRuleResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__executeRuleResponse %p -> %p\n", q, p));
	*(_ngwm__executeRuleResponse*)p = *(_ngwm__executeRuleResponse*)q;
}

void _ngwm__executeRuleRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__executeRuleRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__executeRuleRequest*)this)->id);
	/* transient soap skipped */
}

void _ngwm__executeRuleRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__executeRuleRequest*)this)->id);
	/* transient soap skipped */
}

int _ngwm__executeRuleRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__executeRuleRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__executeRuleRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__executeRuleRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__executeRuleRequest(struct soap *soap, const char *tag, int id, const _ngwm__executeRuleRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__executeRuleRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__executeRuleRequest*)a)->id), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__executeRuleRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__executeRuleRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__executeRuleRequest * SOAP_FMAC4 soap_get__ngwm__executeRuleRequest(struct soap *soap, _ngwm__executeRuleRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__executeRuleRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__executeRuleRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__executeRuleRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__executeRuleRequest * SOAP_FMAC4 soap_in__ngwm__executeRuleRequest(struct soap *soap, const char *tag, _ngwm__executeRuleRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__executeRuleRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__executeRuleRequest, sizeof(_ngwm__executeRuleRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__executeRuleRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__executeRuleRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__executeRuleRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__executeRuleRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__executeRuleRequest, 0, sizeof(_ngwm__executeRuleRequest), 0, soap_copy__ngwm__executeRuleRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__executeRuleRequest * SOAP_FMAC6 soap_new__ngwm__executeRuleRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__executeRuleRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__executeRuleRequest(struct soap *soap, _ngwm__executeRuleRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__executeRuleRequest * SOAP_FMAC6 soap_instantiate__ngwm__executeRuleRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__executeRuleRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__executeRuleRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__executeRuleRequest;
		if (size)
			*size = sizeof(_ngwm__executeRuleRequest);
		((_ngwm__executeRuleRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__executeRuleRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__executeRuleRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__executeRuleRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__executeRuleRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__executeRuleRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__executeRuleRequest %p -> %p\n", q, p));
	*(_ngwm__executeRuleRequest*)p = *(_ngwm__executeRuleRequest*)q;
}

void _ngwm__destroyCursorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__destroyCursorResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__destroyCursorResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__destroyCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__destroyCursorResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__destroyCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__destroyCursorResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__destroyCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__destroyCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__destroyCursorResponse(struct soap *soap, const char *tag, int id, const _ngwm__destroyCursorResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__destroyCursorResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__destroyCursorResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__destroyCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__destroyCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__destroyCursorResponse * SOAP_FMAC4 soap_get__ngwm__destroyCursorResponse(struct soap *soap, _ngwm__destroyCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__destroyCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__destroyCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__destroyCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__destroyCursorResponse * SOAP_FMAC4 soap_in__ngwm__destroyCursorResponse(struct soap *soap, const char *tag, _ngwm__destroyCursorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__destroyCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__destroyCursorResponse, sizeof(_ngwm__destroyCursorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__destroyCursorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__destroyCursorResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__destroyCursorResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__destroyCursorResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__destroyCursorResponse, 0, sizeof(_ngwm__destroyCursorResponse), 0, soap_copy__ngwm__destroyCursorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__destroyCursorResponse * SOAP_FMAC6 soap_new__ngwm__destroyCursorResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__destroyCursorResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__destroyCursorResponse(struct soap *soap, _ngwm__destroyCursorResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__destroyCursorResponse * SOAP_FMAC6 soap_instantiate__ngwm__destroyCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__destroyCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__destroyCursorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__destroyCursorResponse;
		if (size)
			*size = sizeof(_ngwm__destroyCursorResponse);
		((_ngwm__destroyCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__destroyCursorResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__destroyCursorResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__destroyCursorResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__destroyCursorResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__destroyCursorResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__destroyCursorResponse %p -> %p\n", q, p));
	*(_ngwm__destroyCursorResponse*)p = *(_ngwm__destroyCursorResponse*)q;
}

void _ngwm__destroyCursorRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__destroyCursorRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__destroyCursorRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__destroyCursorRequest*)this)->cursor, SOAP_TYPE_int);
	/* transient soap skipped */
}

void _ngwm__destroyCursorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__destroyCursorRequest*)this)->container);
	soap_default_int(soap, &((_ngwm__destroyCursorRequest*)this)->cursor);
	/* transient soap skipped */
}

int _ngwm__destroyCursorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__destroyCursorRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__destroyCursorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__destroyCursorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__destroyCursorRequest(struct soap *soap, const char *tag, int id, const _ngwm__destroyCursorRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__destroyCursorRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__destroyCursorRequest*)a)->container), "");
	soap_out_int(soap, "ngwm:cursor", -1, &(((_ngwm__destroyCursorRequest*)a)->cursor), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__destroyCursorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__destroyCursorRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__destroyCursorRequest * SOAP_FMAC4 soap_get__ngwm__destroyCursorRequest(struct soap *soap, _ngwm__destroyCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__destroyCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__destroyCursorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__destroyCursorRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__destroyCursorRequest * SOAP_FMAC4 soap_in__ngwm__destroyCursorRequest(struct soap *soap, const char *tag, _ngwm__destroyCursorRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__destroyCursorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__destroyCursorRequest, sizeof(_ngwm__destroyCursorRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__destroyCursorRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__destroyCursorRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_cursor1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__destroyCursorRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_cursor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwm:cursor", &(((_ngwm__destroyCursorRequest*)a)->cursor), ""))
				{	soap_flag_cursor1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_cursor1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__destroyCursorRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__destroyCursorRequest, 0, sizeof(_ngwm__destroyCursorRequest), 0, soap_copy__ngwm__destroyCursorRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__destroyCursorRequest * SOAP_FMAC6 soap_new__ngwm__destroyCursorRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__destroyCursorRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__destroyCursorRequest(struct soap *soap, _ngwm__destroyCursorRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__destroyCursorRequest * SOAP_FMAC6 soap_instantiate__ngwm__destroyCursorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__destroyCursorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__destroyCursorRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__destroyCursorRequest;
		if (size)
			*size = sizeof(_ngwm__destroyCursorRequest);
		((_ngwm__destroyCursorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__destroyCursorRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__destroyCursorRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__destroyCursorRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__destroyCursorRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__destroyCursorRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__destroyCursorRequest %p -> %p\n", q, p));
	*(_ngwm__destroyCursorRequest*)p = *(_ngwm__destroyCursorRequest*)q;
}

void _ngwm__delegateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__delegateResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__delegateResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__delegateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__delegateResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__delegateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__delegateResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__delegateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__delegateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__delegateResponse(struct soap *soap, const char *tag, int id, const _ngwm__delegateResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__delegateResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__delegateResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__delegateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__delegateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__delegateResponse * SOAP_FMAC4 soap_get__ngwm__delegateResponse(struct soap *soap, _ngwm__delegateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__delegateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__delegateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__delegateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__delegateResponse * SOAP_FMAC4 soap_in__ngwm__delegateResponse(struct soap *soap, const char *tag, _ngwm__delegateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__delegateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__delegateResponse, sizeof(_ngwm__delegateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__delegateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__delegateResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__delegateResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__delegateResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__delegateResponse, 0, sizeof(_ngwm__delegateResponse), 0, soap_copy__ngwm__delegateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__delegateResponse * SOAP_FMAC6 soap_new__ngwm__delegateResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__delegateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__delegateResponse(struct soap *soap, _ngwm__delegateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__delegateResponse * SOAP_FMAC6 soap_instantiate__ngwm__delegateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__delegateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__delegateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__delegateResponse;
		if (size)
			*size = sizeof(_ngwm__delegateResponse);
		((_ngwm__delegateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__delegateResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__delegateResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__delegateResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__delegateResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__delegateResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__delegateResponse %p -> %p\n", q, p));
	*(_ngwm__delegateResponse*)p = *(_ngwm__delegateResponse*)q;
}

void _ngwm__delegateRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__delegateRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__delegateRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__delegateRequest*)this)->commentToOrganizer, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__delegateRequest*)this)->commentToOrganizer);
	soap_embedded(soap, &((_ngwm__delegateRequest*)this)->commentToDelegatee, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__delegateRequest*)this)->commentToDelegatee);
	soap_embedded(soap, &((_ngwm__delegateRequest*)this)->distribution, SOAP_TYPE_PointerTongwt__Distribution);
	soap_serialize_PointerTongwt__Distribution(soap, &((_ngwm__delegateRequest*)this)->distribution);
	soap_embedded(soap, &((_ngwm__delegateRequest*)this)->recurrenceAllInstances, SOAP_TYPE_unsignedLong);
	/* transient soap skipped */
}

void _ngwm__delegateRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__delegateRequest*)this)->id);
	((_ngwm__delegateRequest*)this)->commentToOrganizer = NULL;
	((_ngwm__delegateRequest*)this)->commentToDelegatee = NULL;
	((_ngwm__delegateRequest*)this)->distribution = NULL;
	((_ngwm__delegateRequest*)this)->recurrenceAllInstances = 0;
	/* transient soap skipped */
}

int _ngwm__delegateRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__delegateRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__delegateRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__delegateRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__delegateRequest(struct soap *soap, const char *tag, int id, const _ngwm__delegateRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__delegateRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__delegateRequest*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwm:commentToOrganizer", -1, &(((_ngwm__delegateRequest*)a)->commentToOrganizer), "");
	soap_out_PointerTostd__string(soap, "ngwm:commentToDelegatee", -1, &(((_ngwm__delegateRequest*)a)->commentToDelegatee), "");
	soap_out_PointerTongwt__Distribution(soap, "ngwm:distribution", -1, &(((_ngwm__delegateRequest*)a)->distribution), "");
	soap_out_unsignedLong(soap, "ngwm:recurrenceAllInstances", -1, &(((_ngwm__delegateRequest*)a)->recurrenceAllInstances), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__delegateRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__delegateRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__delegateRequest * SOAP_FMAC4 soap_get__ngwm__delegateRequest(struct soap *soap, _ngwm__delegateRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__delegateRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__delegateRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__delegateRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__delegateRequest * SOAP_FMAC4 soap_in__ngwm__delegateRequest(struct soap *soap, const char *tag, _ngwm__delegateRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__delegateRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__delegateRequest, sizeof(_ngwm__delegateRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__delegateRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__delegateRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_commentToOrganizer1 = 1, soap_flag_commentToDelegatee1 = 1, soap_flag_distribution1 = 1, soap_flag_recurrenceAllInstances1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__delegateRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_commentToOrganizer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:commentToOrganizer", &(((_ngwm__delegateRequest*)a)->commentToOrganizer), ""))
				{	soap_flag_commentToOrganizer1 = 0;
					continue;
				}
			if (soap_flag_commentToDelegatee1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:commentToDelegatee", &(((_ngwm__delegateRequest*)a)->commentToDelegatee), ""))
				{	soap_flag_commentToDelegatee1 = 0;
					continue;
				}
			if (soap_flag_distribution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Distribution(soap, "ngwm:distribution", &(((_ngwm__delegateRequest*)a)->distribution), "ngwt:Distribution"))
				{	soap_flag_distribution1 = 0;
					continue;
				}
			if (soap_flag_recurrenceAllInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "ngwm:recurrenceAllInstances", &(((_ngwm__delegateRequest*)a)->recurrenceAllInstances), ""))
				{	soap_flag_recurrenceAllInstances1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_distribution1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__delegateRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__delegateRequest, 0, sizeof(_ngwm__delegateRequest), 0, soap_copy__ngwm__delegateRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__delegateRequest * SOAP_FMAC6 soap_new__ngwm__delegateRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__delegateRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__delegateRequest(struct soap *soap, _ngwm__delegateRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__delegateRequest * SOAP_FMAC6 soap_instantiate__ngwm__delegateRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__delegateRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__delegateRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__delegateRequest;
		if (size)
			*size = sizeof(_ngwm__delegateRequest);
		((_ngwm__delegateRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__delegateRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__delegateRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__delegateRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__delegateRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__delegateRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__delegateRequest %p -> %p\n", q, p));
	*(_ngwm__delegateRequest*)p = *(_ngwm__delegateRequest*)q;
}

void _ngwm__declineResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__declineResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__declineResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__declineResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__declineResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__declineResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__declineResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__declineResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__declineResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__declineResponse(struct soap *soap, const char *tag, int id, const _ngwm__declineResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__declineResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__declineResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__declineResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__declineResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__declineResponse * SOAP_FMAC4 soap_get__ngwm__declineResponse(struct soap *soap, _ngwm__declineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__declineResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__declineResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__declineResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__declineResponse * SOAP_FMAC4 soap_in__ngwm__declineResponse(struct soap *soap, const char *tag, _ngwm__declineResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__declineResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__declineResponse, sizeof(_ngwm__declineResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__declineResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__declineResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__declineResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__declineResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__declineResponse, 0, sizeof(_ngwm__declineResponse), 0, soap_copy__ngwm__declineResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__declineResponse * SOAP_FMAC6 soap_new__ngwm__declineResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__declineResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__declineResponse(struct soap *soap, _ngwm__declineResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__declineResponse * SOAP_FMAC6 soap_instantiate__ngwm__declineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__declineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__declineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__declineResponse;
		if (size)
			*size = sizeof(_ngwm__declineResponse);
		((_ngwm__declineResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__declineResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__declineResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__declineResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__declineResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__declineResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__declineResponse %p -> %p\n", q, p));
	*(_ngwm__declineResponse*)p = *(_ngwm__declineResponse*)q;
}

void _ngwm__declineRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__declineRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__declineRequest*)this)->items);
	soap_embedded(soap, &((_ngwm__declineRequest*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__declineRequest*)this)->comment);
	soap_embedded(soap, &((_ngwm__declineRequest*)this)->recurrenceAllInstances, SOAP_TYPE_unsignedLong);
	/* transient soap skipped */
}

void _ngwm__declineRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__declineRequest*)this)->items = NULL;
	((_ngwm__declineRequest*)this)->comment = NULL;
	((_ngwm__declineRequest*)this)->recurrenceAllInstances = 0;
	/* transient soap skipped */
}

int _ngwm__declineRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__declineRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__declineRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__declineRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__declineRequest(struct soap *soap, const char *tag, int id, const _ngwm__declineRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__declineRequest), type);
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__declineRequest*)a)->items), "");
	soap_out_PointerTostd__string(soap, "ngwm:comment", -1, &(((_ngwm__declineRequest*)a)->comment), "");
	soap_out_unsignedLong(soap, "ngwm:recurrenceAllInstances", -1, &(((_ngwm__declineRequest*)a)->recurrenceAllInstances), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__declineRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__declineRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__declineRequest * SOAP_FMAC4 soap_get__ngwm__declineRequest(struct soap *soap, _ngwm__declineRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__declineRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__declineRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__declineRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__declineRequest * SOAP_FMAC4 soap_in__ngwm__declineRequest(struct soap *soap, const char *tag, _ngwm__declineRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__declineRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__declineRequest, sizeof(_ngwm__declineRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__declineRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__declineRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1, soap_flag_comment1 = 1, soap_flag_recurrenceAllInstances1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__declineRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:comment", &(((_ngwm__declineRequest*)a)->comment), ""))
				{	soap_flag_comment1 = 0;
					continue;
				}
			if (soap_flag_recurrenceAllInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "ngwm:recurrenceAllInstances", &(((_ngwm__declineRequest*)a)->recurrenceAllInstances), ""))
				{	soap_flag_recurrenceAllInstances1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__declineRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__declineRequest, 0, sizeof(_ngwm__declineRequest), 0, soap_copy__ngwm__declineRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__declineRequest * SOAP_FMAC6 soap_new__ngwm__declineRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__declineRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__declineRequest(struct soap *soap, _ngwm__declineRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__declineRequest * SOAP_FMAC6 soap_instantiate__ngwm__declineRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__declineRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__declineRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__declineRequest;
		if (size)
			*size = sizeof(_ngwm__declineRequest);
		((_ngwm__declineRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__declineRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__declineRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__declineRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__declineRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__declineRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__declineRequest %p -> %p\n", q, p));
	*(_ngwm__declineRequest*)p = *(_ngwm__declineRequest*)q;
}

void _ngwm__createSignatureResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__createSignatureResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__createSignatureResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__createSignatureResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__createSignatureResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__createSignatureResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createSignatureResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createSignatureResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createSignatureResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createSignatureResponse(struct soap *soap, const char *tag, int id, const _ngwm__createSignatureResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createSignatureResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__createSignatureResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createSignatureResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createSignatureResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createSignatureResponse * SOAP_FMAC4 soap_get__ngwm__createSignatureResponse(struct soap *soap, _ngwm__createSignatureResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createSignatureResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createSignatureResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createSignatureResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createSignatureResponse * SOAP_FMAC4 soap_in__ngwm__createSignatureResponse(struct soap *soap, const char *tag, _ngwm__createSignatureResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createSignatureResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createSignatureResponse, sizeof(_ngwm__createSignatureResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createSignatureResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createSignatureResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__createSignatureResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createSignatureResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createSignatureResponse, 0, sizeof(_ngwm__createSignatureResponse), 0, soap_copy__ngwm__createSignatureResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createSignatureResponse * SOAP_FMAC6 soap_new__ngwm__createSignatureResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createSignatureResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createSignatureResponse(struct soap *soap, _ngwm__createSignatureResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createSignatureResponse * SOAP_FMAC6 soap_instantiate__ngwm__createSignatureResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createSignatureResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createSignatureResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createSignatureResponse;
		if (size)
			*size = sizeof(_ngwm__createSignatureResponse);
		((_ngwm__createSignatureResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createSignatureResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__createSignatureResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__createSignatureResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createSignatureResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createSignatureResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createSignatureResponse %p -> %p\n", q, p));
	*(_ngwm__createSignatureResponse*)p = *(_ngwm__createSignatureResponse*)q;
}

void _ngwm__createSignatureRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__createSignatureRequest*)this)->signature, SOAP_TYPE_PointerTongwt__Signature);
	soap_serialize_PointerTongwt__Signature(soap, &((_ngwm__createSignatureRequest*)this)->signature);
	/* transient soap skipped */
}

void _ngwm__createSignatureRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__createSignatureRequest*)this)->signature = NULL;
	/* transient soap skipped */
}

int _ngwm__createSignatureRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createSignatureRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createSignatureRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createSignatureRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createSignatureRequest(struct soap *soap, const char *tag, int id, const _ngwm__createSignatureRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createSignatureRequest), type);
	soap_out_PointerTongwt__Signature(soap, "ngwm:signature", -1, &(((_ngwm__createSignatureRequest*)a)->signature), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createSignatureRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createSignatureRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createSignatureRequest * SOAP_FMAC4 soap_get__ngwm__createSignatureRequest(struct soap *soap, _ngwm__createSignatureRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createSignatureRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createSignatureRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createSignatureRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createSignatureRequest * SOAP_FMAC4 soap_in__ngwm__createSignatureRequest(struct soap *soap, const char *tag, _ngwm__createSignatureRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createSignatureRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createSignatureRequest, sizeof(_ngwm__createSignatureRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createSignatureRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createSignatureRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_signature1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_signature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Signature(soap, "ngwm:signature", &(((_ngwm__createSignatureRequest*)a)->signature), "ngwt:Signature"))
				{	soap_flag_signature1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_signature1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createSignatureRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createSignatureRequest, 0, sizeof(_ngwm__createSignatureRequest), 0, soap_copy__ngwm__createSignatureRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createSignatureRequest * SOAP_FMAC6 soap_new__ngwm__createSignatureRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createSignatureRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createSignatureRequest(struct soap *soap, _ngwm__createSignatureRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createSignatureRequest * SOAP_FMAC6 soap_instantiate__ngwm__createSignatureRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createSignatureRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createSignatureRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createSignatureRequest;
		if (size)
			*size = sizeof(_ngwm__createSignatureRequest);
		((_ngwm__createSignatureRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createSignatureRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__createSignatureRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__createSignatureRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createSignatureRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createSignatureRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createSignatureRequest %p -> %p\n", q, p));
	*(_ngwm__createSignatureRequest*)p = *(_ngwm__createSignatureRequest*)q;
}

void _ngwm__createProxyAccessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__createProxyAccessResponse*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((_ngwm__createProxyAccessResponse*)this)->id);
	soap_embedded(soap, &((_ngwm__createProxyAccessResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__createProxyAccessResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__createProxyAccessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__createProxyAccessResponse*)this)->id = NULL;
	((_ngwm__createProxyAccessResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__createProxyAccessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createProxyAccessResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createProxyAccessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createProxyAccessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createProxyAccessResponse(struct soap *soap, const char *tag, int id, const _ngwm__createProxyAccessResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createProxyAccessResponse), type);
	soap_out_PointerTongwt__uid(soap, "ngwm:id", -1, &(((_ngwm__createProxyAccessResponse*)a)->id), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__createProxyAccessResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createProxyAccessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createProxyAccessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createProxyAccessResponse * SOAP_FMAC4 soap_get__ngwm__createProxyAccessResponse(struct soap *soap, _ngwm__createProxyAccessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createProxyAccessResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createProxyAccessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createProxyAccessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createProxyAccessResponse * SOAP_FMAC4 soap_in__ngwm__createProxyAccessResponse(struct soap *soap, const char *tag, _ngwm__createProxyAccessResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createProxyAccessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createProxyAccessResponse, sizeof(_ngwm__createProxyAccessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createProxyAccessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createProxyAccessResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwm:id", &(((_ngwm__createProxyAccessResponse*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__createProxyAccessResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createProxyAccessResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createProxyAccessResponse, 0, sizeof(_ngwm__createProxyAccessResponse), 0, soap_copy__ngwm__createProxyAccessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createProxyAccessResponse * SOAP_FMAC6 soap_new__ngwm__createProxyAccessResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createProxyAccessResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createProxyAccessResponse(struct soap *soap, _ngwm__createProxyAccessResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createProxyAccessResponse * SOAP_FMAC6 soap_instantiate__ngwm__createProxyAccessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createProxyAccessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createProxyAccessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createProxyAccessResponse;
		if (size)
			*size = sizeof(_ngwm__createProxyAccessResponse);
		((_ngwm__createProxyAccessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createProxyAccessResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__createProxyAccessResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__createProxyAccessResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createProxyAccessResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createProxyAccessResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createProxyAccessResponse %p -> %p\n", q, p));
	*(_ngwm__createProxyAccessResponse*)p = *(_ngwm__createProxyAccessResponse*)q;
}

void _ngwm__createProxyAccessRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__createProxyAccessRequest*)this)->entry, SOAP_TYPE_PointerTongwt__AccessRightEntry);
	soap_serialize_PointerTongwt__AccessRightEntry(soap, &((_ngwm__createProxyAccessRequest*)this)->entry);
	/* transient soap skipped */
}

void _ngwm__createProxyAccessRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__createProxyAccessRequest*)this)->entry = NULL;
	/* transient soap skipped */
}

int _ngwm__createProxyAccessRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createProxyAccessRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createProxyAccessRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createProxyAccessRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createProxyAccessRequest(struct soap *soap, const char *tag, int id, const _ngwm__createProxyAccessRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createProxyAccessRequest), type);
	soap_out_PointerTongwt__AccessRightEntry(soap, "ngwm:entry", -1, &(((_ngwm__createProxyAccessRequest*)a)->entry), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createProxyAccessRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createProxyAccessRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createProxyAccessRequest * SOAP_FMAC4 soap_get__ngwm__createProxyAccessRequest(struct soap *soap, _ngwm__createProxyAccessRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createProxyAccessRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createProxyAccessRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createProxyAccessRequest * SOAP_FMAC4 soap_in__ngwm__createProxyAccessRequest(struct soap *soap, const char *tag, _ngwm__createProxyAccessRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createProxyAccessRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createProxyAccessRequest, sizeof(_ngwm__createProxyAccessRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createProxyAccessRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createProxyAccessRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_entry1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessRightEntry(soap, "ngwm:entry", &(((_ngwm__createProxyAccessRequest*)a)->entry), "ngwt:AccessRightEntry"))
				{	soap_flag_entry1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createProxyAccessRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createProxyAccessRequest, 0, sizeof(_ngwm__createProxyAccessRequest), 0, soap_copy__ngwm__createProxyAccessRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createProxyAccessRequest * SOAP_FMAC6 soap_new__ngwm__createProxyAccessRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createProxyAccessRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createProxyAccessRequest(struct soap *soap, _ngwm__createProxyAccessRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createProxyAccessRequest * SOAP_FMAC6 soap_instantiate__ngwm__createProxyAccessRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createProxyAccessRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createProxyAccessRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createProxyAccessRequest;
		if (size)
			*size = sizeof(_ngwm__createProxyAccessRequest);
		((_ngwm__createProxyAccessRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createProxyAccessRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__createProxyAccessRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__createProxyAccessRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createProxyAccessRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createProxyAccessRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createProxyAccessRequest %p -> %p\n", q, p));
	*(_ngwm__createProxyAccessRequest*)p = *(_ngwm__createProxyAccessRequest*)q;
}

void _ngwm__createJunkEntryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__createJunkEntryResponse*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((_ngwm__createJunkEntryResponse*)this)->id);
	soap_embedded(soap, &((_ngwm__createJunkEntryResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__createJunkEntryResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__createJunkEntryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__createJunkEntryResponse*)this)->id = NULL;
	((_ngwm__createJunkEntryResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__createJunkEntryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createJunkEntryResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createJunkEntryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createJunkEntryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createJunkEntryResponse(struct soap *soap, const char *tag, int id, const _ngwm__createJunkEntryResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createJunkEntryResponse), type);
	soap_out_PointerTongwt__uid(soap, "ngwm:id", -1, &(((_ngwm__createJunkEntryResponse*)a)->id), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__createJunkEntryResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createJunkEntryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createJunkEntryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createJunkEntryResponse * SOAP_FMAC4 soap_get__ngwm__createJunkEntryResponse(struct soap *soap, _ngwm__createJunkEntryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createJunkEntryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createJunkEntryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createJunkEntryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createJunkEntryResponse * SOAP_FMAC4 soap_in__ngwm__createJunkEntryResponse(struct soap *soap, const char *tag, _ngwm__createJunkEntryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createJunkEntryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createJunkEntryResponse, sizeof(_ngwm__createJunkEntryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createJunkEntryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createJunkEntryResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwm:id", &(((_ngwm__createJunkEntryResponse*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__createJunkEntryResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createJunkEntryResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createJunkEntryResponse, 0, sizeof(_ngwm__createJunkEntryResponse), 0, soap_copy__ngwm__createJunkEntryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createJunkEntryResponse * SOAP_FMAC6 soap_new__ngwm__createJunkEntryResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createJunkEntryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createJunkEntryResponse(struct soap *soap, _ngwm__createJunkEntryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createJunkEntryResponse * SOAP_FMAC6 soap_instantiate__ngwm__createJunkEntryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createJunkEntryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createJunkEntryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createJunkEntryResponse;
		if (size)
			*size = sizeof(_ngwm__createJunkEntryResponse);
		((_ngwm__createJunkEntryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createJunkEntryResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__createJunkEntryResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__createJunkEntryResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createJunkEntryResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createJunkEntryResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createJunkEntryResponse %p -> %p\n", q, p));
	*(_ngwm__createJunkEntryResponse*)p = *(_ngwm__createJunkEntryResponse*)q;
}

void _ngwm__createJunkEntryRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__createJunkEntryRequest*)this)->entry, SOAP_TYPE_PointerTongwt__JunkEntry);
	soap_serialize_PointerTongwt__JunkEntry(soap, &((_ngwm__createJunkEntryRequest*)this)->entry);
	/* transient soap skipped */
}

void _ngwm__createJunkEntryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__createJunkEntryRequest*)this)->entry = NULL;
	/* transient soap skipped */
}

int _ngwm__createJunkEntryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createJunkEntryRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createJunkEntryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createJunkEntryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createJunkEntryRequest(struct soap *soap, const char *tag, int id, const _ngwm__createJunkEntryRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createJunkEntryRequest), type);
	soap_out_PointerTongwt__JunkEntry(soap, "ngwm:entry", -1, &(((_ngwm__createJunkEntryRequest*)a)->entry), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createJunkEntryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createJunkEntryRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createJunkEntryRequest * SOAP_FMAC4 soap_get__ngwm__createJunkEntryRequest(struct soap *soap, _ngwm__createJunkEntryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createJunkEntryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createJunkEntryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createJunkEntryRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createJunkEntryRequest * SOAP_FMAC4 soap_in__ngwm__createJunkEntryRequest(struct soap *soap, const char *tag, _ngwm__createJunkEntryRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createJunkEntryRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createJunkEntryRequest, sizeof(_ngwm__createJunkEntryRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createJunkEntryRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createJunkEntryRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_entry1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__JunkEntry(soap, "ngwm:entry", &(((_ngwm__createJunkEntryRequest*)a)->entry), "ngwt:JunkEntry"))
				{	soap_flag_entry1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createJunkEntryRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createJunkEntryRequest, 0, sizeof(_ngwm__createJunkEntryRequest), 0, soap_copy__ngwm__createJunkEntryRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createJunkEntryRequest * SOAP_FMAC6 soap_new__ngwm__createJunkEntryRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createJunkEntryRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createJunkEntryRequest(struct soap *soap, _ngwm__createJunkEntryRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createJunkEntryRequest * SOAP_FMAC6 soap_instantiate__ngwm__createJunkEntryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createJunkEntryRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createJunkEntryRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createJunkEntryRequest;
		if (size)
			*size = sizeof(_ngwm__createJunkEntryRequest);
		((_ngwm__createJunkEntryRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createJunkEntryRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__createJunkEntryRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__createJunkEntryRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createJunkEntryRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createJunkEntryRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createJunkEntryRequest %p -> %p\n", q, p));
	*(_ngwm__createJunkEntryRequest*)p = *(_ngwm__createJunkEntryRequest*)q;
}

void _ngwm__createItemsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfngwt__uid(soap, &((_ngwm__createItemsResponse*)this)->id);
	soap_embedded(soap, &((_ngwm__createItemsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__createItemsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__createItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfngwt__uid(soap, &((_ngwm__createItemsResponse*)this)->id);
	((_ngwm__createItemsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__createItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createItemsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createItemsResponse(struct soap *soap, const char *tag, int id, const _ngwm__createItemsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createItemsResponse), type);
	soap_out_std__vectorTemplateOfngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__createItemsResponse*)a)->id), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__createItemsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createItemsResponse * SOAP_FMAC4 soap_get__ngwm__createItemsResponse(struct soap *soap, _ngwm__createItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createItemsResponse * SOAP_FMAC4 soap_in__ngwm__createItemsResponse(struct soap *soap, const char *tag, _ngwm__createItemsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createItemsResponse, sizeof(_ngwm__createItemsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createItemsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createItemsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__uid(soap, "ngwm:id", &(((_ngwm__createItemsResponse*)a)->id), "ngwt:uid"))
					continue;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__createItemsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createItemsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createItemsResponse, 0, sizeof(_ngwm__createItemsResponse), 0, soap_copy__ngwm__createItemsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createItemsResponse * SOAP_FMAC6 soap_new__ngwm__createItemsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createItemsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createItemsResponse(struct soap *soap, _ngwm__createItemsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createItemsResponse * SOAP_FMAC6 soap_instantiate__ngwm__createItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createItemsResponse;
		if (size)
			*size = sizeof(_ngwm__createItemsResponse);
		((_ngwm__createItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createItemsResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__createItemsResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__createItemsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createItemsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createItemsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createItemsResponse %p -> %p\n", q, p));
	*(_ngwm__createItemsResponse*)p = *(_ngwm__createItemsResponse*)q;
}

void _ngwm__createItemsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Item(soap, &((_ngwm__createItemsRequest*)this)->item);
	/* transient soap skipped */
}

void _ngwm__createItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Item(soap, &((_ngwm__createItemsRequest*)this)->item);
	/* transient soap skipped */
}

int _ngwm__createItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createItemsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createItemsRequest(struct soap *soap, const char *tag, int id, const _ngwm__createItemsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createItemsRequest), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Item(soap, "ngwm:item", -1, &(((_ngwm__createItemsRequest*)a)->item), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createItemsRequest * SOAP_FMAC4 soap_get__ngwm__createItemsRequest(struct soap *soap, _ngwm__createItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createItemsRequest * SOAP_FMAC4 soap_in__ngwm__createItemsRequest(struct soap *soap, const char *tag, _ngwm__createItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createItemsRequest, sizeof(_ngwm__createItemsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createItemsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createItemsRequest *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Item(soap, "ngwm:item", &(((_ngwm__createItemsRequest*)a)->item), "ngwt:Item"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createItemsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createItemsRequest, 0, sizeof(_ngwm__createItemsRequest), 0, soap_copy__ngwm__createItemsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createItemsRequest * SOAP_FMAC6 soap_new__ngwm__createItemsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createItemsRequest(struct soap *soap, _ngwm__createItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createItemsRequest * SOAP_FMAC6 soap_instantiate__ngwm__createItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createItemsRequest;
		if (size)
			*size = sizeof(_ngwm__createItemsRequest);
		((_ngwm__createItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createItemsRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__createItemsRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__createItemsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createItemsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createItemsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createItemsRequest %p -> %p\n", q, p));
	*(_ngwm__createItemsRequest*)p = *(_ngwm__createItemsRequest*)q;
}

void _ngwm__createItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfngwt__uid(soap, &((_ngwm__createItemResponse*)this)->id);
	soap_embedded(soap, &((_ngwm__createItemResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__createItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__createItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfngwt__uid(soap, &((_ngwm__createItemResponse*)this)->id);
	((_ngwm__createItemResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__createItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createItemResponse(struct soap *soap, const char *tag, int id, const _ngwm__createItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createItemResponse), type);
	soap_out_std__vectorTemplateOfngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__createItemResponse*)a)->id), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__createItemResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createItemResponse * SOAP_FMAC4 soap_get__ngwm__createItemResponse(struct soap *soap, _ngwm__createItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createItemResponse * SOAP_FMAC4 soap_in__ngwm__createItemResponse(struct soap *soap, const char *tag, _ngwm__createItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createItemResponse, sizeof(_ngwm__createItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__uid(soap, "ngwm:id", &(((_ngwm__createItemResponse*)a)->id), "ngwt:uid"))
					continue;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__createItemResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createItemResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createItemResponse, 0, sizeof(_ngwm__createItemResponse), 0, soap_copy__ngwm__createItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createItemResponse * SOAP_FMAC6 soap_new__ngwm__createItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createItemResponse(struct soap *soap, _ngwm__createItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createItemResponse * SOAP_FMAC6 soap_instantiate__ngwm__createItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createItemResponse;
		if (size)
			*size = sizeof(_ngwm__createItemResponse);
		((_ngwm__createItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createItemResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__createItemResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__createItemResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createItemResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createItemResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createItemResponse %p -> %p\n", q, p));
	*(_ngwm__createItemResponse*)p = *(_ngwm__createItemResponse*)q;
}

void _ngwm__createItemRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__createItemRequest*)this)->item, SOAP_TYPE_PointerTongwt__Item);
	soap_serialize_PointerTongwt__Item(soap, &((_ngwm__createItemRequest*)this)->item);
	soap_embedded(soap, &((_ngwm__createItemRequest*)this)->notification, SOAP_TYPE_PointerTongwt__SharedFolderNotification);
	soap_serialize_PointerTongwt__SharedFolderNotification(soap, &((_ngwm__createItemRequest*)this)->notification);
	/* transient soap skipped */
}

void _ngwm__createItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__createItemRequest*)this)->item = NULL;
	((_ngwm__createItemRequest*)this)->notification = NULL;
	/* transient soap skipped */
}

int _ngwm__createItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createItemRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createItemRequest(struct soap *soap, const char *tag, int id, const _ngwm__createItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createItemRequest), type);
	soap_out_PointerTongwt__Item(soap, "ngwm:item", -1, &(((_ngwm__createItemRequest*)a)->item), "");
	soap_out_PointerTongwt__SharedFolderNotification(soap, "ngwm:notification", -1, &(((_ngwm__createItemRequest*)a)->notification), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createItemRequest * SOAP_FMAC4 soap_get__ngwm__createItemRequest(struct soap *soap, _ngwm__createItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createItemRequest * SOAP_FMAC4 soap_in__ngwm__createItemRequest(struct soap *soap, const char *tag, _ngwm__createItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createItemRequest, sizeof(_ngwm__createItemRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createItemRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createItemRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_item1 = 1, soap_flag_notification1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Item(soap, "ngwm:item", &(((_ngwm__createItemRequest*)a)->item), "ngwt:Item"))
				{	soap_flag_item1 = 0;
					continue;
				}
			if (soap_flag_notification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SharedFolderNotification(soap, "ngwm:notification", &(((_ngwm__createItemRequest*)a)->notification), "ngwt:SharedFolderNotification"))
				{	soap_flag_notification1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_item1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createItemRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createItemRequest, 0, sizeof(_ngwm__createItemRequest), 0, soap_copy__ngwm__createItemRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createItemRequest * SOAP_FMAC6 soap_new__ngwm__createItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createItemRequest(struct soap *soap, _ngwm__createItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createItemRequest * SOAP_FMAC6 soap_instantiate__ngwm__createItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createItemRequest;
		if (size)
			*size = sizeof(_ngwm__createItemRequest);
		((_ngwm__createItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createItemRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__createItemRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__createItemRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createItemRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createItemRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createItemRequest %p -> %p\n", q, p));
	*(_ngwm__createItemRequest*)p = *(_ngwm__createItemRequest*)q;
}

void _ngwm__createCursorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__createCursorResponse*)this)->cursor, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((_ngwm__createCursorResponse*)this)->cursor);
	soap_embedded(soap, &((_ngwm__createCursorResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__createCursorResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__createCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__createCursorResponse*)this)->cursor = NULL;
	((_ngwm__createCursorResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__createCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createCursorResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createCursorResponse(struct soap *soap, const char *tag, int id, const _ngwm__createCursorResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createCursorResponse), type);
	soap_out_PointerToint(soap, "ngwm:cursor", -1, &(((_ngwm__createCursorResponse*)a)->cursor), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__createCursorResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createCursorResponse * SOAP_FMAC4 soap_get__ngwm__createCursorResponse(struct soap *soap, _ngwm__createCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createCursorResponse * SOAP_FMAC4 soap_in__ngwm__createCursorResponse(struct soap *soap, const char *tag, _ngwm__createCursorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createCursorResponse, sizeof(_ngwm__createCursorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createCursorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createCursorResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cursor1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cursor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwm:cursor", &(((_ngwm__createCursorResponse*)a)->cursor), ""))
				{	soap_flag_cursor1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__createCursorResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createCursorResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createCursorResponse, 0, sizeof(_ngwm__createCursorResponse), 0, soap_copy__ngwm__createCursorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createCursorResponse * SOAP_FMAC6 soap_new__ngwm__createCursorResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createCursorResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createCursorResponse(struct soap *soap, _ngwm__createCursorResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createCursorResponse * SOAP_FMAC6 soap_instantiate__ngwm__createCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createCursorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createCursorResponse;
		if (size)
			*size = sizeof(_ngwm__createCursorResponse);
		((_ngwm__createCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createCursorResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__createCursorResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__createCursorResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createCursorResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createCursorResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createCursorResponse %p -> %p\n", q, p));
	*(_ngwm__createCursorResponse*)p = *(_ngwm__createCursorResponse*)q;
}

void _ngwm__createCursorRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__createCursorRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__createCursorRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__createCursorRequest*)this)->view, SOAP_TYPE_PointerTongwt__View);
	soap_serialize_PointerTongwt__View(soap, &((_ngwm__createCursorRequest*)this)->view);
	soap_embedded(soap, &((_ngwm__createCursorRequest*)this)->filter, SOAP_TYPE_PointerTongwt__Filter);
	soap_serialize_PointerTongwt__Filter(soap, &((_ngwm__createCursorRequest*)this)->filter);
	/* transient soap skipped */
}

void _ngwm__createCursorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__createCursorRequest*)this)->container);
	((_ngwm__createCursorRequest*)this)->view = NULL;
	((_ngwm__createCursorRequest*)this)->filter = NULL;
	/* transient soap skipped */
}

int _ngwm__createCursorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__createCursorRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__createCursorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__createCursorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__createCursorRequest(struct soap *soap, const char *tag, int id, const _ngwm__createCursorRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__createCursorRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__createCursorRequest*)a)->container), "");
	soap_out_PointerTongwt__View(soap, "ngwm:view", -1, &(((_ngwm__createCursorRequest*)a)->view), "");
	soap_out_PointerTongwt__Filter(soap, "ngwm:filter", -1, &(((_ngwm__createCursorRequest*)a)->filter), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__createCursorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__createCursorRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__createCursorRequest * SOAP_FMAC4 soap_get__ngwm__createCursorRequest(struct soap *soap, _ngwm__createCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__createCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__createCursorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__createCursorRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__createCursorRequest * SOAP_FMAC4 soap_in__ngwm__createCursorRequest(struct soap *soap, const char *tag, _ngwm__createCursorRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__createCursorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__createCursorRequest, sizeof(_ngwm__createCursorRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__createCursorRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__createCursorRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_view1 = 1, soap_flag_filter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__createCursorRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__View(soap, "ngwm:view", &(((_ngwm__createCursorRequest*)a)->view), "ngwt:View"))
				{	soap_flag_view1 = 0;
					continue;
				}
			if (soap_flag_filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Filter(soap, "ngwm:filter", &(((_ngwm__createCursorRequest*)a)->filter), "ngwt:Filter"))
				{	soap_flag_filter1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__createCursorRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createCursorRequest, 0, sizeof(_ngwm__createCursorRequest), 0, soap_copy__ngwm__createCursorRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__createCursorRequest * SOAP_FMAC6 soap_new__ngwm__createCursorRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__createCursorRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__createCursorRequest(struct soap *soap, _ngwm__createCursorRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__createCursorRequest * SOAP_FMAC6 soap_instantiate__ngwm__createCursorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__createCursorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__createCursorRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__createCursorRequest;
		if (size)
			*size = sizeof(_ngwm__createCursorRequest);
		((_ngwm__createCursorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__createCursorRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__createCursorRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__createCursorRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__createCursorRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__createCursorRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__createCursorRequest %p -> %p\n", q, p));
	*(_ngwm__createCursorRequest*)p = *(_ngwm__createCursorRequest*)q;
}

void _ngwm__completeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__completeResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__completeResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__completeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__completeResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__completeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__completeResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__completeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__completeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__completeResponse(struct soap *soap, const char *tag, int id, const _ngwm__completeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__completeResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__completeResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__completeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__completeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__completeResponse * SOAP_FMAC4 soap_get__ngwm__completeResponse(struct soap *soap, _ngwm__completeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__completeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__completeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__completeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__completeResponse * SOAP_FMAC4 soap_in__ngwm__completeResponse(struct soap *soap, const char *tag, _ngwm__completeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__completeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__completeResponse, sizeof(_ngwm__completeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__completeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__completeResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__completeResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__completeResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__completeResponse, 0, sizeof(_ngwm__completeResponse), 0, soap_copy__ngwm__completeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__completeResponse * SOAP_FMAC6 soap_new__ngwm__completeResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__completeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__completeResponse(struct soap *soap, _ngwm__completeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__completeResponse * SOAP_FMAC6 soap_instantiate__ngwm__completeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__completeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__completeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__completeResponse;
		if (size)
			*size = sizeof(_ngwm__completeResponse);
		((_ngwm__completeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__completeResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__completeResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__completeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__completeResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__completeResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__completeResponse %p -> %p\n", q, p));
	*(_ngwm__completeResponse*)p = *(_ngwm__completeResponse*)q;
}

void _ngwm__completeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__completeRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__completeRequest*)this)->items);
	/* transient soap skipped */
}

void _ngwm__completeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__completeRequest*)this)->items = NULL;
	/* transient soap skipped */
}

int _ngwm__completeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__completeRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__completeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__completeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__completeRequest(struct soap *soap, const char *tag, int id, const _ngwm__completeRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__completeRequest), type);
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__completeRequest*)a)->items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__completeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__completeRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__completeRequest * SOAP_FMAC4 soap_get__ngwm__completeRequest(struct soap *soap, _ngwm__completeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__completeRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__completeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__completeRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__completeRequest * SOAP_FMAC4 soap_in__ngwm__completeRequest(struct soap *soap, const char *tag, _ngwm__completeRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__completeRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__completeRequest, sizeof(_ngwm__completeRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__completeRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__completeRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__completeRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__completeRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__completeRequest, 0, sizeof(_ngwm__completeRequest), 0, soap_copy__ngwm__completeRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__completeRequest * SOAP_FMAC6 soap_new__ngwm__completeRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__completeRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__completeRequest(struct soap *soap, _ngwm__completeRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__completeRequest * SOAP_FMAC6 soap_instantiate__ngwm__completeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__completeRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__completeRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__completeRequest;
		if (size)
			*size = sizeof(_ngwm__completeRequest);
		((_ngwm__completeRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__completeRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__completeRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__completeRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__completeRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__completeRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__completeRequest %p -> %p\n", q, p));
	*(_ngwm__completeRequest*)p = *(_ngwm__completeRequest*)q;
}

void _ngwm__closeFreeBusySessionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__closeFreeBusySessionResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__closeFreeBusySessionResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__closeFreeBusySessionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__closeFreeBusySessionResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__closeFreeBusySessionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__closeFreeBusySessionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__closeFreeBusySessionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__closeFreeBusySessionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__closeFreeBusySessionResponse(struct soap *soap, const char *tag, int id, const _ngwm__closeFreeBusySessionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__closeFreeBusySessionResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__closeFreeBusySessionResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__closeFreeBusySessionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__closeFreeBusySessionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__closeFreeBusySessionResponse * SOAP_FMAC4 soap_get__ngwm__closeFreeBusySessionResponse(struct soap *soap, _ngwm__closeFreeBusySessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__closeFreeBusySessionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__closeFreeBusySessionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__closeFreeBusySessionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__closeFreeBusySessionResponse * SOAP_FMAC4 soap_in__ngwm__closeFreeBusySessionResponse(struct soap *soap, const char *tag, _ngwm__closeFreeBusySessionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__closeFreeBusySessionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__closeFreeBusySessionResponse, sizeof(_ngwm__closeFreeBusySessionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__closeFreeBusySessionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__closeFreeBusySessionResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__closeFreeBusySessionResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__closeFreeBusySessionResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__closeFreeBusySessionResponse, 0, sizeof(_ngwm__closeFreeBusySessionResponse), 0, soap_copy__ngwm__closeFreeBusySessionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__closeFreeBusySessionResponse * SOAP_FMAC6 soap_new__ngwm__closeFreeBusySessionResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__closeFreeBusySessionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__closeFreeBusySessionResponse(struct soap *soap, _ngwm__closeFreeBusySessionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__closeFreeBusySessionResponse * SOAP_FMAC6 soap_instantiate__ngwm__closeFreeBusySessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__closeFreeBusySessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__closeFreeBusySessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__closeFreeBusySessionResponse;
		if (size)
			*size = sizeof(_ngwm__closeFreeBusySessionResponse);
		((_ngwm__closeFreeBusySessionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__closeFreeBusySessionResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__closeFreeBusySessionResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__closeFreeBusySessionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__closeFreeBusySessionResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__closeFreeBusySessionResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__closeFreeBusySessionResponse %p -> %p\n", q, p));
	*(_ngwm__closeFreeBusySessionResponse*)p = *(_ngwm__closeFreeBusySessionResponse*)q;
}

void _ngwm__closeFreeBusySessionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__closeFreeBusySessionRequest*)this)->freeBusySessionId, SOAP_TYPE_int);
	/* transient soap skipped */
}

void _ngwm__closeFreeBusySessionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((_ngwm__closeFreeBusySessionRequest*)this)->freeBusySessionId);
	/* transient soap skipped */
}

int _ngwm__closeFreeBusySessionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__closeFreeBusySessionRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__closeFreeBusySessionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__closeFreeBusySessionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__closeFreeBusySessionRequest(struct soap *soap, const char *tag, int id, const _ngwm__closeFreeBusySessionRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__closeFreeBusySessionRequest), type);
	soap_out_int(soap, "ngwm:freeBusySessionId", -1, &(((_ngwm__closeFreeBusySessionRequest*)a)->freeBusySessionId), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__closeFreeBusySessionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__closeFreeBusySessionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__closeFreeBusySessionRequest * SOAP_FMAC4 soap_get__ngwm__closeFreeBusySessionRequest(struct soap *soap, _ngwm__closeFreeBusySessionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__closeFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__closeFreeBusySessionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__closeFreeBusySessionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__closeFreeBusySessionRequest * SOAP_FMAC4 soap_in__ngwm__closeFreeBusySessionRequest(struct soap *soap, const char *tag, _ngwm__closeFreeBusySessionRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__closeFreeBusySessionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__closeFreeBusySessionRequest, sizeof(_ngwm__closeFreeBusySessionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__closeFreeBusySessionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__closeFreeBusySessionRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_freeBusySessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_freeBusySessionId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwm:freeBusySessionId", &(((_ngwm__closeFreeBusySessionRequest*)a)->freeBusySessionId), ""))
				{	soap_flag_freeBusySessionId1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_freeBusySessionId1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__closeFreeBusySessionRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__closeFreeBusySessionRequest, 0, sizeof(_ngwm__closeFreeBusySessionRequest), 0, soap_copy__ngwm__closeFreeBusySessionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__closeFreeBusySessionRequest * SOAP_FMAC6 soap_new__ngwm__closeFreeBusySessionRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__closeFreeBusySessionRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__closeFreeBusySessionRequest(struct soap *soap, _ngwm__closeFreeBusySessionRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__closeFreeBusySessionRequest * SOAP_FMAC6 soap_instantiate__ngwm__closeFreeBusySessionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__closeFreeBusySessionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__closeFreeBusySessionRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__closeFreeBusySessionRequest;
		if (size)
			*size = sizeof(_ngwm__closeFreeBusySessionRequest);
		((_ngwm__closeFreeBusySessionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__closeFreeBusySessionRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__closeFreeBusySessionRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__closeFreeBusySessionRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__closeFreeBusySessionRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__closeFreeBusySessionRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__closeFreeBusySessionRequest %p -> %p\n", q, p));
	*(_ngwm__closeFreeBusySessionRequest*)p = *(_ngwm__closeFreeBusySessionRequest*)q;
}

void _ngwm__addMembersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__addMembersResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__addMembersResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__addMembersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__addMembersResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__addMembersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__addMembersResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__addMembersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__addMembersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__addMembersResponse(struct soap *soap, const char *tag, int id, const _ngwm__addMembersResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__addMembersResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__addMembersResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__addMembersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__addMembersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__addMembersResponse * SOAP_FMAC4 soap_get__ngwm__addMembersResponse(struct soap *soap, _ngwm__addMembersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__addMembersResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__addMembersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__addMembersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__addMembersResponse * SOAP_FMAC4 soap_in__ngwm__addMembersResponse(struct soap *soap, const char *tag, _ngwm__addMembersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__addMembersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__addMembersResponse, sizeof(_ngwm__addMembersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__addMembersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__addMembersResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__addMembersResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__addMembersResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addMembersResponse, 0, sizeof(_ngwm__addMembersResponse), 0, soap_copy__ngwm__addMembersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__addMembersResponse * SOAP_FMAC6 soap_new__ngwm__addMembersResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__addMembersResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__addMembersResponse(struct soap *soap, _ngwm__addMembersResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__addMembersResponse * SOAP_FMAC6 soap_instantiate__ngwm__addMembersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__addMembersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__addMembersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__addMembersResponse;
		if (size)
			*size = sizeof(_ngwm__addMembersResponse);
		((_ngwm__addMembersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__addMembersResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__addMembersResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__addMembersResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__addMembersResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__addMembersResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__addMembersResponse %p -> %p\n", q, p));
	*(_ngwm__addMembersResponse*)p = *(_ngwm__addMembersResponse*)q;
}

void _ngwm__addMembersRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__addMembersRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__addMembersRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__addMembersRequest*)this)->members, SOAP_TYPE_PointerTongwt__GroupMemberList);
	soap_serialize_PointerTongwt__GroupMemberList(soap, &((_ngwm__addMembersRequest*)this)->members);
	/* transient soap skipped */
}

void _ngwm__addMembersRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__addMembersRequest*)this)->container);
	((_ngwm__addMembersRequest*)this)->members = NULL;
	/* transient soap skipped */
}

int _ngwm__addMembersRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__addMembersRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__addMembersRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__addMembersRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__addMembersRequest(struct soap *soap, const char *tag, int id, const _ngwm__addMembersRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__addMembersRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__addMembersRequest*)a)->container), "");
	soap_out_PointerTongwt__GroupMemberList(soap, "ngwm:members", -1, &(((_ngwm__addMembersRequest*)a)->members), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__addMembersRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__addMembersRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__addMembersRequest * SOAP_FMAC4 soap_get__ngwm__addMembersRequest(struct soap *soap, _ngwm__addMembersRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__addMembersRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__addMembersRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__addMembersRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__addMembersRequest * SOAP_FMAC4 soap_in__ngwm__addMembersRequest(struct soap *soap, const char *tag, _ngwm__addMembersRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__addMembersRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__addMembersRequest, sizeof(_ngwm__addMembersRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__addMembersRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__addMembersRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_members1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__addMembersRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_members1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__GroupMemberList(soap, "ngwm:members", &(((_ngwm__addMembersRequest*)a)->members), "ngwt:GroupMemberList"))
				{	soap_flag_members1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_members1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__addMembersRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addMembersRequest, 0, sizeof(_ngwm__addMembersRequest), 0, soap_copy__ngwm__addMembersRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__addMembersRequest * SOAP_FMAC6 soap_new__ngwm__addMembersRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__addMembersRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__addMembersRequest(struct soap *soap, _ngwm__addMembersRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__addMembersRequest * SOAP_FMAC6 soap_instantiate__ngwm__addMembersRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__addMembersRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__addMembersRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__addMembersRequest;
		if (size)
			*size = sizeof(_ngwm__addMembersRequest);
		((_ngwm__addMembersRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__addMembersRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__addMembersRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__addMembersRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__addMembersRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__addMembersRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__addMembersRequest %p -> %p\n", q, p));
	*(_ngwm__addMembersRequest*)p = *(_ngwm__addMembersRequest*)q;
}

void _ngwm__addItemsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__addItemsResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__addItemsResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__addItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__addItemsResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__addItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__addItemsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__addItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__addItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__addItemsResponse(struct soap *soap, const char *tag, int id, const _ngwm__addItemsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__addItemsResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__addItemsResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__addItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__addItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__addItemsResponse * SOAP_FMAC4 soap_get__ngwm__addItemsResponse(struct soap *soap, _ngwm__addItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__addItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__addItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__addItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__addItemsResponse * SOAP_FMAC4 soap_in__ngwm__addItemsResponse(struct soap *soap, const char *tag, _ngwm__addItemsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__addItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__addItemsResponse, sizeof(_ngwm__addItemsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__addItemsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__addItemsResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__addItemsResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__addItemsResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addItemsResponse, 0, sizeof(_ngwm__addItemsResponse), 0, soap_copy__ngwm__addItemsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__addItemsResponse * SOAP_FMAC6 soap_new__ngwm__addItemsResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__addItemsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__addItemsResponse(struct soap *soap, _ngwm__addItemsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__addItemsResponse * SOAP_FMAC6 soap_instantiate__ngwm__addItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__addItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__addItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__addItemsResponse;
		if (size)
			*size = sizeof(_ngwm__addItemsResponse);
		((_ngwm__addItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__addItemsResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__addItemsResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__addItemsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__addItemsResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__addItemsResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__addItemsResponse %p -> %p\n", q, p));
	*(_ngwm__addItemsResponse*)p = *(_ngwm__addItemsResponse*)q;
}

void _ngwm__addItemsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__addItemsRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__addItemsRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__addItemsRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__addItemsRequest*)this)->items);
	/* transient soap skipped */
}

void _ngwm__addItemsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__addItemsRequest*)this)->container);
	((_ngwm__addItemsRequest*)this)->items = NULL;
	/* transient soap skipped */
}

int _ngwm__addItemsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__addItemsRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__addItemsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__addItemsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__addItemsRequest(struct soap *soap, const char *tag, int id, const _ngwm__addItemsRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__addItemsRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__addItemsRequest*)a)->container), "");
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__addItemsRequest*)a)->items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__addItemsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__addItemsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__addItemsRequest * SOAP_FMAC4 soap_get__ngwm__addItemsRequest(struct soap *soap, _ngwm__addItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__addItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__addItemsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__addItemsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__addItemsRequest * SOAP_FMAC4 soap_in__ngwm__addItemsRequest(struct soap *soap, const char *tag, _ngwm__addItemsRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__addItemsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__addItemsRequest, sizeof(_ngwm__addItemsRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__addItemsRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__addItemsRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_items1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__addItemsRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__addItemsRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__addItemsRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addItemsRequest, 0, sizeof(_ngwm__addItemsRequest), 0, soap_copy__ngwm__addItemsRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__addItemsRequest * SOAP_FMAC6 soap_new__ngwm__addItemsRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__addItemsRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__addItemsRequest(struct soap *soap, _ngwm__addItemsRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__addItemsRequest * SOAP_FMAC6 soap_instantiate__ngwm__addItemsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__addItemsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__addItemsRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__addItemsRequest;
		if (size)
			*size = sizeof(_ngwm__addItemsRequest);
		((_ngwm__addItemsRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__addItemsRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__addItemsRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__addItemsRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__addItemsRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__addItemsRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__addItemsRequest %p -> %p\n", q, p));
	*(_ngwm__addItemsRequest*)p = *(_ngwm__addItemsRequest*)q;
}

void _ngwm__addItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__addItemResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__addItemResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__addItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__addItemResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__addItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__addItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__addItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__addItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__addItemResponse(struct soap *soap, const char *tag, int id, const _ngwm__addItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__addItemResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__addItemResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__addItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__addItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__addItemResponse * SOAP_FMAC4 soap_get__ngwm__addItemResponse(struct soap *soap, _ngwm__addItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__addItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__addItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__addItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__addItemResponse * SOAP_FMAC4 soap_in__ngwm__addItemResponse(struct soap *soap, const char *tag, _ngwm__addItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__addItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__addItemResponse, sizeof(_ngwm__addItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__addItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__addItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__addItemResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__addItemResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addItemResponse, 0, sizeof(_ngwm__addItemResponse), 0, soap_copy__ngwm__addItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__addItemResponse * SOAP_FMAC6 soap_new__ngwm__addItemResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__addItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__addItemResponse(struct soap *soap, _ngwm__addItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__addItemResponse * SOAP_FMAC6 soap_instantiate__ngwm__addItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__addItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__addItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__addItemResponse;
		if (size)
			*size = sizeof(_ngwm__addItemResponse);
		((_ngwm__addItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__addItemResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__addItemResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__addItemResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__addItemResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__addItemResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__addItemResponse %p -> %p\n", q, p));
	*(_ngwm__addItemResponse*)p = *(_ngwm__addItemResponse*)q;
}

void _ngwm__addItemRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__addItemRequest*)this)->container, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__addItemRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__addItemRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__addItemRequest*)this)->id);
	/* transient soap skipped */
}

void _ngwm__addItemRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__addItemRequest*)this)->container);
	soap_default_ngwt__uid(soap, &((_ngwm__addItemRequest*)this)->id);
	/* transient soap skipped */
}

int _ngwm__addItemRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__addItemRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__addItemRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__addItemRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__addItemRequest(struct soap *soap, const char *tag, int id, const _ngwm__addItemRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__addItemRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:container", -1, &(((_ngwm__addItemRequest*)a)->container), "");
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__addItemRequest*)a)->id), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__addItemRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__addItemRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__addItemRequest * SOAP_FMAC4 soap_get__ngwm__addItemRequest(struct soap *soap, _ngwm__addItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__addItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__addItemRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__addItemRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__addItemRequest * SOAP_FMAC4 soap_in__ngwm__addItemRequest(struct soap *soap, const char *tag, _ngwm__addItemRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__addItemRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__addItemRequest, sizeof(_ngwm__addItemRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__addItemRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__addItemRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_container1 = 1, soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:container", &(((_ngwm__addItemRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__addItemRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_container1 || soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__addItemRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addItemRequest, 0, sizeof(_ngwm__addItemRequest), 0, soap_copy__ngwm__addItemRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__addItemRequest * SOAP_FMAC6 soap_new__ngwm__addItemRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__addItemRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__addItemRequest(struct soap *soap, _ngwm__addItemRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__addItemRequest * SOAP_FMAC6 soap_instantiate__ngwm__addItemRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__addItemRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__addItemRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__addItemRequest;
		if (size)
			*size = sizeof(_ngwm__addItemRequest);
		((_ngwm__addItemRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__addItemRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__addItemRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__addItemRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__addItemRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__addItemRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__addItemRequest %p -> %p\n", q, p));
	*(_ngwm__addItemRequest*)p = *(_ngwm__addItemRequest*)q;
}

void _ngwm__acceptShareResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__acceptShareResponse*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((_ngwm__acceptShareResponse*)this)->id);
	soap_embedded(soap, &((_ngwm__acceptShareResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__acceptShareResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__acceptShareResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__acceptShareResponse*)this)->id = NULL;
	((_ngwm__acceptShareResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__acceptShareResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__acceptShareResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__acceptShareResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__acceptShareResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__acceptShareResponse(struct soap *soap, const char *tag, int id, const _ngwm__acceptShareResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__acceptShareResponse), type);
	soap_out_PointerTongwt__uid(soap, "ngwm:id", -1, &(((_ngwm__acceptShareResponse*)a)->id), "");
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__acceptShareResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__acceptShareResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__acceptShareResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__acceptShareResponse * SOAP_FMAC4 soap_get__ngwm__acceptShareResponse(struct soap *soap, _ngwm__acceptShareResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__acceptShareResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__acceptShareResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__acceptShareResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__acceptShareResponse * SOAP_FMAC4 soap_in__ngwm__acceptShareResponse(struct soap *soap, const char *tag, _ngwm__acceptShareResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__acceptShareResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__acceptShareResponse, sizeof(_ngwm__acceptShareResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__acceptShareResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__acceptShareResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwm:id", &(((_ngwm__acceptShareResponse*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__acceptShareResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__acceptShareResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__acceptShareResponse, 0, sizeof(_ngwm__acceptShareResponse), 0, soap_copy__ngwm__acceptShareResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__acceptShareResponse * SOAP_FMAC6 soap_new__ngwm__acceptShareResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__acceptShareResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__acceptShareResponse(struct soap *soap, _ngwm__acceptShareResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__acceptShareResponse * SOAP_FMAC6 soap_instantiate__ngwm__acceptShareResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__acceptShareResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__acceptShareResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__acceptShareResponse;
		if (size)
			*size = sizeof(_ngwm__acceptShareResponse);
		((_ngwm__acceptShareResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__acceptShareResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__acceptShareResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__acceptShareResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__acceptShareResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__acceptShareResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__acceptShareResponse %p -> %p\n", q, p));
	*(_ngwm__acceptShareResponse*)p = *(_ngwm__acceptShareResponse*)q;
}

void _ngwm__acceptShareRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__acceptShareRequest*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((_ngwm__acceptShareRequest*)this)->id);
	soap_embedded(soap, &((_ngwm__acceptShareRequest*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__acceptShareRequest*)this)->name);
	soap_embedded(soap, &((_ngwm__acceptShareRequest*)this)->container, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((_ngwm__acceptShareRequest*)this)->container);
	soap_embedded(soap, &((_ngwm__acceptShareRequest*)this)->ngwt__description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__acceptShareRequest*)this)->ngwt__description);
	/* transient soap skipped */
}

void _ngwm__acceptShareRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((_ngwm__acceptShareRequest*)this)->id);
	((_ngwm__acceptShareRequest*)this)->name = NULL;
	((_ngwm__acceptShareRequest*)this)->container = NULL;
	((_ngwm__acceptShareRequest*)this)->ngwt__description = NULL;
	/* transient soap skipped */
}

int _ngwm__acceptShareRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__acceptShareRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__acceptShareRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__acceptShareRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__acceptShareRequest(struct soap *soap, const char *tag, int id, const _ngwm__acceptShareRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__acceptShareRequest), type);
	soap_out_ngwt__uid(soap, "ngwm:id", -1, &(((_ngwm__acceptShareRequest*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwm:name", -1, &(((_ngwm__acceptShareRequest*)a)->name), "");
	soap_out_PointerTongwt__uid(soap, "ngwm:container", -1, &(((_ngwm__acceptShareRequest*)a)->container), "");
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((_ngwm__acceptShareRequest*)a)->ngwt__description), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__acceptShareRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__acceptShareRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__acceptShareRequest * SOAP_FMAC4 soap_get__ngwm__acceptShareRequest(struct soap *soap, _ngwm__acceptShareRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__acceptShareRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__acceptShareRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__acceptShareRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__acceptShareRequest * SOAP_FMAC4 soap_in__ngwm__acceptShareRequest(struct soap *soap, const char *tag, _ngwm__acceptShareRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__acceptShareRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__acceptShareRequest, sizeof(_ngwm__acceptShareRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__acceptShareRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__acceptShareRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_name1 = 1, soap_flag_container1 = 1, soap_flag_ngwt__description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwm:id", &(((_ngwm__acceptShareRequest*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:name", &(((_ngwm__acceptShareRequest*)a)->name), ""))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwm:container", &(((_ngwm__acceptShareRequest*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_ngwt__description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((_ngwm__acceptShareRequest*)a)->ngwt__description), ""))
				{	soap_flag_ngwt__description1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__acceptShareRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__acceptShareRequest, 0, sizeof(_ngwm__acceptShareRequest), 0, soap_copy__ngwm__acceptShareRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__acceptShareRequest * SOAP_FMAC6 soap_new__ngwm__acceptShareRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__acceptShareRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__acceptShareRequest(struct soap *soap, _ngwm__acceptShareRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__acceptShareRequest * SOAP_FMAC6 soap_instantiate__ngwm__acceptShareRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__acceptShareRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__acceptShareRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__acceptShareRequest;
		if (size)
			*size = sizeof(_ngwm__acceptShareRequest);
		((_ngwm__acceptShareRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__acceptShareRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__acceptShareRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__acceptShareRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__acceptShareRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__acceptShareRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__acceptShareRequest %p -> %p\n", q, p));
	*(_ngwm__acceptShareRequest*)p = *(_ngwm__acceptShareRequest*)q;
}

void _ngwm__acceptResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__acceptResponse*)this)->status, SOAP_TYPE_PointerTongwt__Status);
	soap_serialize_PointerTongwt__Status(soap, &((_ngwm__acceptResponse*)this)->status);
	/* transient soap skipped */
}

void _ngwm__acceptResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__acceptResponse*)this)->status = NULL;
	/* transient soap skipped */
}

int _ngwm__acceptResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__acceptResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__acceptResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__acceptResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__acceptResponse(struct soap *soap, const char *tag, int id, const _ngwm__acceptResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__acceptResponse), type);
	soap_out_PointerTongwt__Status(soap, "ngwm:status", -1, &(((_ngwm__acceptResponse*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__acceptResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__acceptResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__acceptResponse * SOAP_FMAC4 soap_get__ngwm__acceptResponse(struct soap *soap, _ngwm__acceptResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__acceptResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__acceptResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__acceptResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__acceptResponse * SOAP_FMAC4 soap_in__ngwm__acceptResponse(struct soap *soap, const char *tag, _ngwm__acceptResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__acceptResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__acceptResponse, sizeof(_ngwm__acceptResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__acceptResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__acceptResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Status(soap, "ngwm:status", &(((_ngwm__acceptResponse*)a)->status), "ngwt:Status"))
				{	soap_flag_status1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__acceptResponse *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__acceptResponse, 0, sizeof(_ngwm__acceptResponse), 0, soap_copy__ngwm__acceptResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__acceptResponse * SOAP_FMAC6 soap_new__ngwm__acceptResponse(struct soap *soap, int n)
{	return soap_instantiate__ngwm__acceptResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__acceptResponse(struct soap *soap, _ngwm__acceptResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__acceptResponse * SOAP_FMAC6 soap_instantiate__ngwm__acceptResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__acceptResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__acceptResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__acceptResponse;
		if (size)
			*size = sizeof(_ngwm__acceptResponse);
		((_ngwm__acceptResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__acceptResponse[n];
		if (size)
			*size = n * sizeof(_ngwm__acceptResponse);
		for (int i = 0; i < n; i++)
			((_ngwm__acceptResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__acceptResponse*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__acceptResponse(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__acceptResponse %p -> %p\n", q, p));
	*(_ngwm__acceptResponse*)p = *(_ngwm__acceptResponse*)q;
}

void _ngwm__acceptRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((_ngwm__acceptRequest*)this)->items, SOAP_TYPE_PointerTongwt__ItemRefList);
	soap_serialize_PointerTongwt__ItemRefList(soap, &((_ngwm__acceptRequest*)this)->items);
	soap_embedded(soap, &((_ngwm__acceptRequest*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((_ngwm__acceptRequest*)this)->comment);
	soap_embedded(soap, &((_ngwm__acceptRequest*)this)->acceptLevel, SOAP_TYPE_PointerTongwt__AcceptLevel);
	soap_serialize_PointerTongwt__AcceptLevel(soap, &((_ngwm__acceptRequest*)this)->acceptLevel);
	soap_embedded(soap, &((_ngwm__acceptRequest*)this)->recurrenceAllInstances, SOAP_TYPE_unsignedLong);
	/* transient soap skipped */
}

void _ngwm__acceptRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ngwm__acceptRequest*)this)->items = NULL;
	((_ngwm__acceptRequest*)this)->comment = NULL;
	((_ngwm__acceptRequest*)this)->acceptLevel = NULL;
	((_ngwm__acceptRequest*)this)->recurrenceAllInstances = 0;
	/* transient soap skipped */
}

int _ngwm__acceptRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ngwm__acceptRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ngwm__acceptRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ngwm__acceptRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ngwm__acceptRequest(struct soap *soap, const char *tag, int id, const _ngwm__acceptRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ngwm__acceptRequest), type);
	soap_out_PointerTongwt__ItemRefList(soap, "ngwm:items", -1, &(((_ngwm__acceptRequest*)a)->items), "");
	soap_out_PointerTostd__string(soap, "ngwm:comment", -1, &(((_ngwm__acceptRequest*)a)->comment), "");
	soap_out_PointerTongwt__AcceptLevel(soap, "ngwm:acceptLevel", -1, &(((_ngwm__acceptRequest*)a)->acceptLevel), "");
	soap_out_unsignedLong(soap, "ngwm:recurrenceAllInstances", -1, &(((_ngwm__acceptRequest*)a)->recurrenceAllInstances), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ngwm__acceptRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ngwm__acceptRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ngwm__acceptRequest * SOAP_FMAC4 soap_get__ngwm__acceptRequest(struct soap *soap, _ngwm__acceptRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ngwm__acceptRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ngwm__acceptRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ngwm__acceptRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ngwm__acceptRequest * SOAP_FMAC4 soap_in__ngwm__acceptRequest(struct soap *soap, const char *tag, _ngwm__acceptRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (_ngwm__acceptRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ngwm__acceptRequest, sizeof(_ngwm__acceptRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ngwm__acceptRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ngwm__acceptRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_items1 = 1, soap_flag_comment1 = 1, soap_flag_acceptLevel1 = 1, soap_flag_recurrenceAllInstances1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRefList(soap, "ngwm:items", &(((_ngwm__acceptRequest*)a)->items), "ngwt:ItemRefList"))
				{	soap_flag_items1 = 0;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwm:comment", &(((_ngwm__acceptRequest*)a)->comment), ""))
				{	soap_flag_comment1 = 0;
					continue;
				}
			if (soap_flag_acceptLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AcceptLevel(soap, "ngwm:acceptLevel", &(((_ngwm__acceptRequest*)a)->acceptLevel), ""))
				{	soap_flag_acceptLevel1 = 0;
					continue;
				}
			if (soap_flag_recurrenceAllInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "ngwm:recurrenceAllInstances", &(((_ngwm__acceptRequest*)a)->recurrenceAllInstances), ""))
				{	soap_flag_recurrenceAllInstances1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_items1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ngwm__acceptRequest *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__acceptRequest, 0, sizeof(_ngwm__acceptRequest), 0, soap_copy__ngwm__acceptRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ngwm__acceptRequest * SOAP_FMAC6 soap_new__ngwm__acceptRequest(struct soap *soap, int n)
{	return soap_instantiate__ngwm__acceptRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ngwm__acceptRequest(struct soap *soap, _ngwm__acceptRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 _ngwm__acceptRequest * SOAP_FMAC6 soap_instantiate__ngwm__acceptRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ngwm__acceptRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ngwm__acceptRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ngwm__acceptRequest;
		if (size)
			*size = sizeof(_ngwm__acceptRequest);
		((_ngwm__acceptRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ngwm__acceptRequest[n];
		if (size)
			*size = n * sizeof(_ngwm__acceptRequest);
		for (int i = 0; i < n; i++)
			((_ngwm__acceptRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ngwm__acceptRequest*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy__ngwm__acceptRequest(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ngwm__acceptRequest %p -> %p\n", q, p));
	*(_ngwm__acceptRequest*)p = *(_ngwm__acceptRequest*)q;
}

void ngwt__VersionEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__VersionEvent*)this)->library, SOAP_TYPE_PointerTongwt__NameAndEmail);
	soap_serialize_PointerTongwt__NameAndEmail(soap, &((ngwt__VersionEvent*)this)->library);
	soap_embedded(soap, &((ngwt__VersionEvent*)this)->documentNumber, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ngwt__VersionEvent*)this)->versionNumber, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ngwt__VersionEvent*)this)->creator, SOAP_TYPE_PointerTongwt__NameAndEmail);
	soap_serialize_PointerTongwt__NameAndEmail(soap, &((ngwt__VersionEvent*)this)->creator);
	soap_embedded(soap, &((ngwt__VersionEvent*)this)->event, SOAP_TYPE_ngwt__VersionEventType);
	soap_embedded(soap, &((ngwt__VersionEvent*)this)->eventNumber, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__VersionEvent*)this)->eventNumber);
	soap_embedded(soap, &((ngwt__VersionEvent*)this)->filename, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__VersionEvent*)this)->filename);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__VersionEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__VersionEvent*)this)->library = NULL;
	soap_default_unsignedLong(soap, &((ngwt__VersionEvent*)this)->documentNumber);
	soap_default_unsignedLong(soap, &((ngwt__VersionEvent*)this)->versionNumber);
	((ngwt__VersionEvent*)this)->creator = NULL;
	soap_default_ngwt__VersionEventType(soap, &((ngwt__VersionEvent*)this)->event);
	((ngwt__VersionEvent*)this)->eventNumber = NULL;
	((ngwt__VersionEvent*)this)->filename = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__VersionEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__VersionEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__VersionEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__VersionEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__VersionEvent(struct soap *soap, const char *tag, int id, const ngwt__VersionEvent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__VersionEvent), "ngwt:VersionEvent");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__NameAndEmail(soap, "ngwt:library", -1, &(((ngwt__VersionEvent*)a)->library), "");
	soap_out_unsignedLong(soap, "ngwt:documentNumber", -1, &(((ngwt__VersionEvent*)a)->documentNumber), "");
	soap_out_unsignedLong(soap, "ngwt:versionNumber", -1, &(((ngwt__VersionEvent*)a)->versionNumber), "");
	soap_out_PointerTongwt__NameAndEmail(soap, "ngwt:creator", -1, &(((ngwt__VersionEvent*)a)->creator), "");
	soap_out_ngwt__VersionEventType(soap, "ngwt:event", -1, &(((ngwt__VersionEvent*)a)->event), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:eventNumber", -1, &(((ngwt__VersionEvent*)a)->eventNumber), "");
	soap_out_PointerTostd__string(soap, "ngwt:filename", -1, &(((ngwt__VersionEvent*)a)->filename), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__VersionEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__VersionEvent(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__VersionEvent * SOAP_FMAC4 soap_get_ngwt__VersionEvent(struct soap *soap, ngwt__VersionEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__VersionEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__VersionEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__VersionEvent(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__VersionEvent * SOAP_FMAC4 soap_in_ngwt__VersionEvent(struct soap *soap, const char *tag, ngwt__VersionEvent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__VersionEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__VersionEvent, sizeof(ngwt__VersionEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__VersionEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__VersionEvent *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_categories2 = 1, soap_flag_created2 = 1, soap_flag_customs2 = 1, soap_flag_library1 = 1, soap_flag_documentNumber1 = 1, soap_flag_versionNumber1 = 1, soap_flag_creator1 = 1, soap_flag_event1 = 1, soap_flag_eventNumber1 = 1, soap_flag_filename1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}
			if (soap_flag_name3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name3 = 0;
					continue;
				}
			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}
			if (soap_flag_modified3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}
			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories2 = 0;
					continue;
				}
			if (soap_flag_created2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created2 = 0;
					continue;
				}
			if (soap_flag_customs2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs2 = 0;
					continue;
				}
			if (soap_flag_library1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__NameAndEmail(soap, "ngwt:library", &(((ngwt__VersionEvent*)a)->library), "ngwt:NameAndEmail"))
				{	soap_flag_library1 = 0;
					continue;
				}
			if (soap_flag_documentNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "ngwt:documentNumber", &(((ngwt__VersionEvent*)a)->documentNumber), ""))
				{	soap_flag_documentNumber1 = 0;
					continue;
				}
			if (soap_flag_versionNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "ngwt:versionNumber", &(((ngwt__VersionEvent*)a)->versionNumber), ""))
				{	soap_flag_versionNumber1 = 0;
					continue;
				}
			if (soap_flag_creator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__NameAndEmail(soap, "ngwt:creator", &(((ngwt__VersionEvent*)a)->creator), "ngwt:NameAndEmail"))
				{	soap_flag_creator1 = 0;
					continue;
				}
			if (soap_flag_event1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__VersionEventType(soap, "ngwt:event", &(((ngwt__VersionEvent*)a)->event), ""))
				{	soap_flag_event1 = 0;
					continue;
				}
			if (soap_flag_eventNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:eventNumber", &(((ngwt__VersionEvent*)a)->eventNumber), ""))
				{	soap_flag_eventNumber1 = 0;
					continue;
				}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:filename", &(((ngwt__VersionEvent*)a)->filename), ""))
				{	soap_flag_filename1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_documentNumber1 || soap_flag_versionNumber1 || soap_flag_event1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__VersionEvent *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__VersionEvent, 0, sizeof(ngwt__VersionEvent), 0, soap_copy_ngwt__VersionEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__VersionEvent * SOAP_FMAC6 soap_new_ngwt__VersionEvent(struct soap *soap, int n)
{	return soap_instantiate_ngwt__VersionEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__VersionEvent(struct soap *soap, ngwt__VersionEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__VersionEvent * SOAP_FMAC6 soap_instantiate_ngwt__VersionEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__VersionEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__VersionEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__VersionEvent;
		if (size)
			*size = sizeof(ngwt__VersionEvent);
		((ngwt__VersionEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__VersionEvent[n];
		if (size)
			*size = n * sizeof(ngwt__VersionEvent);
		for (int i = 0; i < n; i++)
			((ngwt__VersionEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__VersionEvent*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__VersionEvent(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__VersionEvent %p -> %p\n", q, p));
	*(ngwt__VersionEvent*)p = *(ngwt__VersionEvent*)q;
}

void ngwt__Version::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Version*)this)->library, SOAP_TYPE_PointerTongwt__NameAndEmail);
	soap_serialize_PointerTongwt__NameAndEmail(soap, &((ngwt__Version*)this)->library);
	soap_embedded(soap, &((ngwt__Version*)this)->documentNumber, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Version*)this)->documentNumber);
	soap_embedded(soap, &((ngwt__Version*)this)->versionCreator, SOAP_TYPE_PointerTongwt__NameAndEmail);
	soap_serialize_PointerTongwt__NameAndEmail(soap, &((ngwt__Version*)this)->versionCreator);
	soap_embedded(soap, &((ngwt__Version*)this)->retrievedBy, SOAP_TYPE_PointerTongwt__NameAndEmail);
	soap_serialize_PointerTongwt__NameAndEmail(soap, &((ngwt__Version*)this)->retrievedBy);
	soap_embedded(soap, &((ngwt__Version*)this)->retrievedDate, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Version*)this)->retrievedDate);
	soap_embedded(soap, &((ngwt__Version*)this)->versionNumber, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ngwt__Version*)this)->versionDescription, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Version*)this)->versionDescription);
	soap_embedded(soap, &((ngwt__Version*)this)->versionStatus, SOAP_TYPE_PointerTongwt__VersionStatus);
	soap_serialize_PointerTongwt__VersionStatus(soap, &((ngwt__Version*)this)->versionStatus);
	soap_embedded(soap, &((ngwt__Version*)this)->life, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Version*)this)->life);
	soap_embedded(soap, &((ngwt__Version*)this)->ageAction, SOAP_TYPE_PointerTongwt__AgeAction);
	soap_serialize_PointerTongwt__AgeAction(soap, &((ngwt__Version*)this)->ageAction);
	soap_embedded(soap, &((ngwt__Version*)this)->fileSize, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Version*)this)->fileSize);
	soap_embedded(soap, &((ngwt__Version*)this)->filename, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Version*)this)->filename);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Version::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Version*)this)->library = NULL;
	((ngwt__Version*)this)->documentNumber = NULL;
	((ngwt__Version*)this)->versionCreator = NULL;
	((ngwt__Version*)this)->retrievedBy = NULL;
	soap_default_string(soap, &((ngwt__Version*)this)->retrievedDate);
	soap_default_unsignedLong(soap, &((ngwt__Version*)this)->versionNumber);
	((ngwt__Version*)this)->versionDescription = NULL;
	((ngwt__Version*)this)->versionStatus = NULL;
	((ngwt__Version*)this)->life = NULL;
	((ngwt__Version*)this)->ageAction = NULL;
	((ngwt__Version*)this)->fileSize = NULL;
	((ngwt__Version*)this)->filename = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Version::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Version);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Version::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Version(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Version(struct soap *soap, const char *tag, int id, const ngwt__Version *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Version), "ngwt:Version");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__NameAndEmail(soap, "ngwt:library", -1, &(((ngwt__Version*)a)->library), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:documentNumber", -1, &(((ngwt__Version*)a)->documentNumber), "");
	soap_out_PointerTongwt__NameAndEmail(soap, "ngwt:versionCreator", -1, &(((ngwt__Version*)a)->versionCreator), "");
	soap_out_PointerTongwt__NameAndEmail(soap, "ngwt:retrievedBy", -1, &(((ngwt__Version*)a)->retrievedBy), "");
	soap_out_string(soap, "ngwt:retrievedDate", -1, &(((ngwt__Version*)a)->retrievedDate), "");
	soap_out_unsignedLong(soap, "ngwt:versionNumber", -1, &(((ngwt__Version*)a)->versionNumber), "");
	soap_out_PointerTostd__string(soap, "ngwt:versionDescription", -1, &(((ngwt__Version*)a)->versionDescription), "");
	soap_out_PointerTongwt__VersionStatus(soap, "ngwt:versionStatus", -1, &(((ngwt__Version*)a)->versionStatus), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:life", -1, &(((ngwt__Version*)a)->life), "");
	soap_out_PointerTongwt__AgeAction(soap, "ngwt:ageAction", -1, &(((ngwt__Version*)a)->ageAction), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:fileSize", -1, &(((ngwt__Version*)a)->fileSize), "");
	soap_out_PointerTostd__string(soap, "ngwt:filename", -1, &(((ngwt__Version*)a)->filename), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Version::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Version(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Version * SOAP_FMAC4 soap_get_ngwt__Version(struct soap *soap, ngwt__Version *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Version(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Version::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Version(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Version * SOAP_FMAC4 soap_in_ngwt__Version(struct soap *soap, const char *tag, ngwt__Version *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Version *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Version, sizeof(ngwt__Version), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Version)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Version *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_categories2 = 1, soap_flag_created2 = 1, soap_flag_customs2 = 1, soap_flag_library1 = 1, soap_flag_documentNumber1 = 1, soap_flag_versionCreator1 = 1, soap_flag_retrievedBy1 = 1, soap_flag_retrievedDate1 = 1, soap_flag_versionNumber1 = 1, soap_flag_versionDescription1 = 1, soap_flag_versionStatus1 = 1, soap_flag_life1 = 1, soap_flag_ageAction1 = 1, soap_flag_fileSize1 = 1, soap_flag_filename1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}
			if (soap_flag_name3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name3 = 0;
					continue;
				}
			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}
			if (soap_flag_modified3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}
			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories2 = 0;
					continue;
				}
			if (soap_flag_created2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created2 = 0;
					continue;
				}
			if (soap_flag_customs2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs2 = 0;
					continue;
				}
			if (soap_flag_library1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__NameAndEmail(soap, "ngwt:library", &(((ngwt__Version*)a)->library), "ngwt:NameAndEmail"))
				{	soap_flag_library1 = 0;
					continue;
				}
			if (soap_flag_documentNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:documentNumber", &(((ngwt__Version*)a)->documentNumber), ""))
				{	soap_flag_documentNumber1 = 0;
					continue;
				}
			if (soap_flag_versionCreator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__NameAndEmail(soap, "ngwt:versionCreator", &(((ngwt__Version*)a)->versionCreator), "ngwt:NameAndEmail"))
				{	soap_flag_versionCreator1 = 0;
					continue;
				}
			if (soap_flag_retrievedBy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__NameAndEmail(soap, "ngwt:retrievedBy", &(((ngwt__Version*)a)->retrievedBy), "ngwt:NameAndEmail"))
				{	soap_flag_retrievedBy1 = 0;
					continue;
				}
			if (soap_flag_retrievedDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:retrievedDate", &(((ngwt__Version*)a)->retrievedDate), ""))
				{	soap_flag_retrievedDate1 = 0;
					continue;
				}
			if (soap_flag_versionNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "ngwt:versionNumber", &(((ngwt__Version*)a)->versionNumber), ""))
				{	soap_flag_versionNumber1 = 0;
					continue;
				}
			if (soap_flag_versionDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:versionDescription", &(((ngwt__Version*)a)->versionDescription), ""))
				{	soap_flag_versionDescription1 = 0;
					continue;
				}
			if (soap_flag_versionStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__VersionStatus(soap, "ngwt:versionStatus", &(((ngwt__Version*)a)->versionStatus), ""))
				{	soap_flag_versionStatus1 = 0;
					continue;
				}
			if (soap_flag_life1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:life", &(((ngwt__Version*)a)->life), ""))
				{	soap_flag_life1 = 0;
					continue;
				}
			if (soap_flag_ageAction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AgeAction(soap, "ngwt:ageAction", &(((ngwt__Version*)a)->ageAction), ""))
				{	soap_flag_ageAction1 = 0;
					continue;
				}
			if (soap_flag_fileSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:fileSize", &(((ngwt__Version*)a)->fileSize), ""))
				{	soap_flag_fileSize1 = 0;
					continue;
				}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:filename", &(((ngwt__Version*)a)->filename), ""))
				{	soap_flag_filename1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_versionNumber1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Version *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Version, 0, sizeof(ngwt__Version), 0, soap_copy_ngwt__Version);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Version * SOAP_FMAC6 soap_new_ngwt__Version(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Version(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Version(struct soap *soap, ngwt__Version *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Version * SOAP_FMAC6 soap_instantiate_ngwt__Version(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Version(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Version, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Version;
		if (size)
			*size = sizeof(ngwt__Version);
		((ngwt__Version*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Version[n];
		if (size)
			*size = n * sizeof(ngwt__Version);
		for (int i = 0; i < n; i++)
			((ngwt__Version*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Version*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Version(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Version %p -> %p\n", q, p));
	*(ngwt__Version*)p = *(ngwt__Version*)q;
}

void ngwt__UserList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__UserInfo(soap, &((ngwt__UserList*)this)->user);
	/* transient soap skipped */
}

void ngwt__UserList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__UserInfo(soap, &((ngwt__UserList*)this)->user);
	/* transient soap skipped */
}

int ngwt__UserList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__UserList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__UserList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__UserList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__UserList(struct soap *soap, const char *tag, int id, const ngwt__UserList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__UserList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__UserInfo(soap, "ngwt:user", -1, &(((ngwt__UserList*)a)->user), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__UserList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__UserList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__UserList * SOAP_FMAC4 soap_get_ngwt__UserList(struct soap *soap, ngwt__UserList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__UserList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__UserList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__UserList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__UserList * SOAP_FMAC4 soap_in_ngwt__UserList(struct soap *soap, const char *tag, ngwt__UserList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__UserList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__UserList, sizeof(ngwt__UserList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__UserList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__UserList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__UserInfo(soap, "ngwt:user", &(((ngwt__UserList*)a)->user), "ngwt:UserInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__UserList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__UserList, 0, sizeof(ngwt__UserList), 0, soap_copy_ngwt__UserList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__UserList * SOAP_FMAC6 soap_new_ngwt__UserList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__UserList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__UserList(struct soap *soap, ngwt__UserList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__UserList * SOAP_FMAC6 soap_instantiate_ngwt__UserList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__UserList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__UserList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__UserList;
		if (size)
			*size = sizeof(ngwt__UserList);
		((ngwt__UserList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__UserList[n];
		if (size)
			*size = n * sizeof(ngwt__UserList);
		for (int i = 0; i < n; i++)
			((ngwt__UserList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__UserList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__UserList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__UserList %p -> %p\n", q, p));
	*(ngwt__UserList*)p = *(ngwt__UserList*)q;
}

void ngwt__UserInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__UserInfo*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__UserInfo*)this)->name);
	soap_embedded(soap, &((ngwt__UserInfo*)this)->email, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__UserInfo*)this)->email);
	soap_embedded(soap, &((ngwt__UserInfo*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__UserInfo*)this)->uuid);
	soap_embedded(soap, &((ngwt__UserInfo*)this)->userid, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__UserInfo*)this)->userid);
	soap_embedded(soap, &((ngwt__UserInfo*)this)->recipType, SOAP_TYPE_PointerTongwt__RecipientType);
	soap_serialize_PointerTongwt__RecipientType(soap, &((ngwt__UserInfo*)this)->recipType);
	/* transient soap skipped */
}

void ngwt__UserInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwt__UserInfo*)this)->name);
	((ngwt__UserInfo*)this)->email = NULL;
	((ngwt__UserInfo*)this)->uuid = NULL;
	((ngwt__UserInfo*)this)->userid = NULL;
	((ngwt__UserInfo*)this)->recipType = NULL;
	/* transient soap skipped */
}

int ngwt__UserInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__UserInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__UserInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__UserInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__UserInfo(struct soap *soap, const char *tag, int id, const ngwt__UserInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__UserInfo), type);
	soap_out_std__string(soap, "ngwt:name", -1, &(((ngwt__UserInfo*)a)->name), "");
	soap_out_PointerTostd__string(soap, "ngwt:email", -1, &(((ngwt__UserInfo*)a)->email), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__UserInfo*)a)->uuid), "");
	soap_out_PointerTostd__string(soap, "ngwt:userid", -1, &(((ngwt__UserInfo*)a)->userid), "");
	soap_out_PointerTongwt__RecipientType(soap, "ngwt:recipType", -1, &(((ngwt__UserInfo*)a)->recipType), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__UserInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__UserInfo(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__UserInfo * SOAP_FMAC4 soap_get_ngwt__UserInfo(struct soap *soap, ngwt__UserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__UserInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__UserInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__UserInfo(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__UserInfo * SOAP_FMAC4 soap_in_ngwt__UserInfo(struct soap *soap, const char *tag, ngwt__UserInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__UserInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__UserInfo, sizeof(ngwt__UserInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__UserInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__UserInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1, soap_flag_email1 = 1, soap_flag_uuid1 = 1, soap_flag_userid1 = 1, soap_flag_recipType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:name", &(((ngwt__UserInfo*)a)->name), ""))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:email", &(((ngwt__UserInfo*)a)->email), ""))
				{	soap_flag_email1 = 0;
					continue;
				}
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__UserInfo*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid1 = 0;
					continue;
				}
			if (soap_flag_userid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:userid", &(((ngwt__UserInfo*)a)->userid), ""))
				{	soap_flag_userid1 = 0;
					continue;
				}
			if (soap_flag_recipType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecipientType(soap, "ngwt:recipType", &(((ngwt__UserInfo*)a)->recipType), ""))
				{	soap_flag_recipType1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__UserInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__UserInfo, 0, sizeof(ngwt__UserInfo), 0, soap_copy_ngwt__UserInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__UserInfo * SOAP_FMAC6 soap_new_ngwt__UserInfo(struct soap *soap, int n)
{	return soap_instantiate_ngwt__UserInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__UserInfo(struct soap *soap, ngwt__UserInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__UserInfo * SOAP_FMAC6 soap_instantiate_ngwt__UserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__UserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__UserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__UserInfo;
		if (size)
			*size = sizeof(ngwt__UserInfo);
		((ngwt__UserInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__UserInfo[n];
		if (size)
			*size = n * sizeof(ngwt__UserInfo);
		for (int i = 0; i < n; i++)
			((ngwt__UserInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__UserInfo*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__UserInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__UserInfo %p -> %p\n", q, p));
	*(ngwt__UserInfo*)p = *(ngwt__UserInfo*)q;
}

void ngwt__TrustedApplication::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__TrustedApplication*)this)->username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__TrustedApplication*)this)->username);
	soap_embedded(soap, &((ngwt__TrustedApplication*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__TrustedApplication*)this)->name);
	soap_embedded(soap, &((ngwt__TrustedApplication*)this)->key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__TrustedApplication*)this)->key);
	/* transient soap skipped */
}

void ngwt__TrustedApplication::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwt__TrustedApplication*)this)->username);
	soap_default_std__string(soap, &((ngwt__TrustedApplication*)this)->name);
	soap_default_std__string(soap, &((ngwt__TrustedApplication*)this)->key);
	/* transient soap skipped */
}

int ngwt__TrustedApplication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__TrustedApplication);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__TrustedApplication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__TrustedApplication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__TrustedApplication(struct soap *soap, const char *tag, int id, const ngwt__TrustedApplication *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__TrustedApplication), "ngwt:TrustedApplication");
	/* transient soap skipped */
	soap_out_std__string(soap, "ngwt:username", -1, &(((ngwt__TrustedApplication*)a)->username), "");
	soap_out_std__string(soap, "ngwt:name", -1, &(((ngwt__TrustedApplication*)a)->name), "");
	soap_out_std__string(soap, "ngwt:key", -1, &(((ngwt__TrustedApplication*)a)->key), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__TrustedApplication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__TrustedApplication(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__TrustedApplication * SOAP_FMAC4 soap_get_ngwt__TrustedApplication(struct soap *soap, ngwt__TrustedApplication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__TrustedApplication(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__TrustedApplication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__TrustedApplication(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__TrustedApplication * SOAP_FMAC4 soap_in_ngwt__TrustedApplication(struct soap *soap, const char *tag, ngwt__TrustedApplication *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__TrustedApplication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__TrustedApplication, sizeof(ngwt__TrustedApplication), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__TrustedApplication)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__TrustedApplication *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_username1 = 1, soap_flag_name1 = 1, soap_flag_key1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:username", &(((ngwt__TrustedApplication*)a)->username), ""))
				{	soap_flag_username1 = 0;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:name", &(((ngwt__TrustedApplication*)a)->name), ""))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:key", &(((ngwt__TrustedApplication*)a)->key), ""))
				{	soap_flag_key1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_username1 || soap_flag_name1 || soap_flag_key1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__TrustedApplication *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__TrustedApplication, 0, sizeof(ngwt__TrustedApplication), 0, soap_copy_ngwt__TrustedApplication);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__TrustedApplication * SOAP_FMAC6 soap_new_ngwt__TrustedApplication(struct soap *soap, int n)
{	return soap_instantiate_ngwt__TrustedApplication(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__TrustedApplication(struct soap *soap, ngwt__TrustedApplication *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__TrustedApplication * SOAP_FMAC6 soap_instantiate_ngwt__TrustedApplication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__TrustedApplication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__TrustedApplication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__TrustedApplication;
		if (size)
			*size = sizeof(ngwt__TrustedApplication);
		((ngwt__TrustedApplication*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__TrustedApplication[n];
		if (size)
			*size = n * sizeof(ngwt__TrustedApplication);
		for (int i = 0; i < n; i++)
			((ngwt__TrustedApplication*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__TrustedApplication*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__TrustedApplication(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__TrustedApplication %p -> %p\n", q, p));
	*(ngwt__TrustedApplication*)p = *(ngwt__TrustedApplication*)q;
}

void ngwt__TransferFailedStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->delivered);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->undeliverable, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->undeliverable);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->transferred, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->transferred);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->transferDelayed, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->transferDelayed);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->transferFailed, SOAP_TYPE_PointerTongwt__TransferFailedStatus);
	soap_serialize_PointerTongwt__TransferFailedStatus(soap, &((ngwt__RecipientStatus*)this)->transferFailed);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->downloaded, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->downloaded);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->downloadedByThirdParty, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->downloadedByThirdParty);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->retractRequested, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->retractRequested);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->retracted, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->retracted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->opened, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->opened);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->deleted, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->deleted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->undeleted, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->undeleted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->purged, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->purged);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->accepted, SOAP_TYPE_PointerTongwt__CommentStatus);
	soap_serialize_PointerTongwt__CommentStatus(soap, &((ngwt__RecipientStatus*)this)->accepted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->declined, SOAP_TYPE_PointerTongwt__CommentStatus);
	soap_serialize_PointerTongwt__CommentStatus(soap, &((ngwt__RecipientStatus*)this)->declined);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->replied, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->replied);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->forwarded, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->forwarded);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->shared, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->shared);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->started, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->started);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->completed, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->completed);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->incomplete, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->incomplete);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->delegated, SOAP_TYPE_PointerTongwt__DelegatedStatus);
	soap_serialize_PointerTongwt__DelegatedStatus(soap, &((ngwt__RecipientStatus*)this)->delegated);
	soap_serialize_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, &((ngwt__RecipientStatus*)this)->delegateeStatus);
	/* transient soap skipped */
}

void ngwt__TransferFailedStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__TransferFailedStatus*)this)->FailureReason = NULL;
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->delivered);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->undeliverable);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->transferred);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->transferDelayed);
	((ngwt__RecipientStatus*)this)->transferFailed = NULL;
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->downloaded);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->downloadedByThirdParty);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->retractRequested);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->retracted);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->opened);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->deleted);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->undeleted);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->purged);
	((ngwt__RecipientStatus*)this)->accepted = NULL;
	((ngwt__RecipientStatus*)this)->declined = NULL;
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->replied);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->forwarded);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->shared);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->started);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->completed);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->incomplete);
	((ngwt__RecipientStatus*)this)->delegated = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, &((ngwt__RecipientStatus*)this)->delegateeStatus);
	/* transient soap skipped */
}

int ngwt__TransferFailedStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__TransferFailedStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__TransferFailedStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__TransferFailedStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__TransferFailedStatus(struct soap *soap, const char *tag, int id, const ngwt__TransferFailedStatus *a, const char *type)
{
	if (((ngwt__TransferFailedStatus *)a)->FailureReason)
		soap_set_attr(soap, "FailureReason", ((ngwt__TransferFailedStatus *)a)->FailureReason->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__TransferFailedStatus), "ngwt:TransferFailedStatus");
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__RecipientStatus*)a)->delivered), "");
	soap_out_string(soap, "ngwt:undeliverable", -1, &(((ngwt__RecipientStatus*)a)->undeliverable), "");
	soap_out_string(soap, "ngwt:transferred", -1, &(((ngwt__RecipientStatus*)a)->transferred), "");
	soap_out_string(soap, "ngwt:transferDelayed", -1, &(((ngwt__RecipientStatus*)a)->transferDelayed), "");
	soap_out_PointerTongwt__TransferFailedStatus(soap, "ngwt:transferFailed", -1, &(((ngwt__RecipientStatus*)a)->transferFailed), "");
	soap_out_string(soap, "ngwt:downloaded", -1, &(((ngwt__RecipientStatus*)a)->downloaded), "");
	soap_out_string(soap, "ngwt:downloadedByThirdParty", -1, &(((ngwt__RecipientStatus*)a)->downloadedByThirdParty), "");
	soap_out_string(soap, "ngwt:retractRequested", -1, &(((ngwt__RecipientStatus*)a)->retractRequested), "");
	soap_out_string(soap, "ngwt:retracted", -1, &(((ngwt__RecipientStatus*)a)->retracted), "");
	soap_out_string(soap, "ngwt:opened", -1, &(((ngwt__RecipientStatus*)a)->opened), "");
	soap_out_string(soap, "ngwt:deleted", -1, &(((ngwt__RecipientStatus*)a)->deleted), "");
	soap_out_string(soap, "ngwt:undeleted", -1, &(((ngwt__RecipientStatus*)a)->undeleted), "");
	soap_out_string(soap, "ngwt:purged", -1, &(((ngwt__RecipientStatus*)a)->purged), "");
	soap_out_PointerTongwt__CommentStatus(soap, "ngwt:accepted", -1, &(((ngwt__RecipientStatus*)a)->accepted), "");
	soap_out_PointerTongwt__CommentStatus(soap, "ngwt:declined", -1, &(((ngwt__RecipientStatus*)a)->declined), "");
	soap_out_string(soap, "ngwt:replied", -1, &(((ngwt__RecipientStatus*)a)->replied), "");
	soap_out_string(soap, "ngwt:forwarded", -1, &(((ngwt__RecipientStatus*)a)->forwarded), "");
	soap_out_string(soap, "ngwt:shared", -1, &(((ngwt__RecipientStatus*)a)->shared), "");
	soap_out_string(soap, "ngwt:started", -1, &(((ngwt__RecipientStatus*)a)->started), "");
	soap_out_string(soap, "ngwt:completed", -1, &(((ngwt__RecipientStatus*)a)->completed), "");
	soap_out_string(soap, "ngwt:incomplete", -1, &(((ngwt__RecipientStatus*)a)->incomplete), "");
	soap_out_PointerTongwt__DelegatedStatus(soap, "ngwt:delegated", -1, &(((ngwt__RecipientStatus*)a)->delegated), "");
	soap_out_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, "ngwt:delegateeStatus", -1, &(((ngwt__RecipientStatus*)a)->delegateeStatus), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__TransferFailedStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__TransferFailedStatus(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__TransferFailedStatus * SOAP_FMAC4 soap_get_ngwt__TransferFailedStatus(struct soap *soap, ngwt__TransferFailedStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__TransferFailedStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__TransferFailedStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__TransferFailedStatus(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__TransferFailedStatus * SOAP_FMAC4 soap_in_ngwt__TransferFailedStatus(struct soap *soap, const char *tag, ngwt__TransferFailedStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__TransferFailedStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__TransferFailedStatus, sizeof(ngwt__TransferFailedStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__TransferFailedStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__TransferFailedStatus *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "FailureReason", 0);
		if (t)
		{	if (!(((ngwt__TransferFailedStatus *)a)->FailureReason = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__TransferFailedStatus *)a)->FailureReason = soap_new_std__string(soap, -1);
			((ngwt__TransferFailedStatus *)a)->FailureReason->assign(s);
		}
		}
	}
	short soap_flag_delivered2 = 1, soap_flag_undeliverable2 = 1, soap_flag_transferred2 = 1, soap_flag_transferDelayed2 = 1, soap_flag_transferFailed2 = 1, soap_flag_downloaded2 = 1, soap_flag_downloadedByThirdParty2 = 1, soap_flag_retractRequested2 = 1, soap_flag_retracted2 = 1, soap_flag_opened2 = 1, soap_flag_deleted2 = 1, soap_flag_undeleted2 = 1, soap_flag_purged2 = 1, soap_flag_accepted2 = 1, soap_flag_declined2 = 1, soap_flag_replied2 = 1, soap_flag_forwarded2 = 1, soap_flag_shared2 = 1, soap_flag_started2 = 1, soap_flag_completed2 = 1, soap_flag_incomplete2 = 1, soap_flag_delegated2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_delivered2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__RecipientStatus*)a)->delivered), ""))
				{	soap_flag_delivered2 = 0;
					continue;
				}
			if (soap_flag_undeliverable2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:undeliverable", &(((ngwt__RecipientStatus*)a)->undeliverable), ""))
				{	soap_flag_undeliverable2 = 0;
					continue;
				}
			if (soap_flag_transferred2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:transferred", &(((ngwt__RecipientStatus*)a)->transferred), ""))
				{	soap_flag_transferred2 = 0;
					continue;
				}
			if (soap_flag_transferDelayed2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:transferDelayed", &(((ngwt__RecipientStatus*)a)->transferDelayed), ""))
				{	soap_flag_transferDelayed2 = 0;
					continue;
				}
			if (soap_flag_transferFailed2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__TransferFailedStatus(soap, "ngwt:transferFailed", &(((ngwt__RecipientStatus*)a)->transferFailed), "ngwt:TransferFailedStatus"))
				{	soap_flag_transferFailed2 = 0;
					continue;
				}
			if (soap_flag_downloaded2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:downloaded", &(((ngwt__RecipientStatus*)a)->downloaded), ""))
				{	soap_flag_downloaded2 = 0;
					continue;
				}
			if (soap_flag_downloadedByThirdParty2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:downloadedByThirdParty", &(((ngwt__RecipientStatus*)a)->downloadedByThirdParty), ""))
				{	soap_flag_downloadedByThirdParty2 = 0;
					continue;
				}
			if (soap_flag_retractRequested2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:retractRequested", &(((ngwt__RecipientStatus*)a)->retractRequested), ""))
				{	soap_flag_retractRequested2 = 0;
					continue;
				}
			if (soap_flag_retracted2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:retracted", &(((ngwt__RecipientStatus*)a)->retracted), ""))
				{	soap_flag_retracted2 = 0;
					continue;
				}
			if (soap_flag_opened2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:opened", &(((ngwt__RecipientStatus*)a)->opened), ""))
				{	soap_flag_opened2 = 0;
					continue;
				}
			if (soap_flag_deleted2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:deleted", &(((ngwt__RecipientStatus*)a)->deleted), ""))
				{	soap_flag_deleted2 = 0;
					continue;
				}
			if (soap_flag_undeleted2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:undeleted", &(((ngwt__RecipientStatus*)a)->undeleted), ""))
				{	soap_flag_undeleted2 = 0;
					continue;
				}
			if (soap_flag_purged2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:purged", &(((ngwt__RecipientStatus*)a)->purged), ""))
				{	soap_flag_purged2 = 0;
					continue;
				}
			if (soap_flag_accepted2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CommentStatus(soap, "ngwt:accepted", &(((ngwt__RecipientStatus*)a)->accepted), "ngwt:CommentStatus"))
				{	soap_flag_accepted2 = 0;
					continue;
				}
			if (soap_flag_declined2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CommentStatus(soap, "ngwt:declined", &(((ngwt__RecipientStatus*)a)->declined), "ngwt:CommentStatus"))
				{	soap_flag_declined2 = 0;
					continue;
				}
			if (soap_flag_replied2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:replied", &(((ngwt__RecipientStatus*)a)->replied), ""))
				{	soap_flag_replied2 = 0;
					continue;
				}
			if (soap_flag_forwarded2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:forwarded", &(((ngwt__RecipientStatus*)a)->forwarded), ""))
				{	soap_flag_forwarded2 = 0;
					continue;
				}
			if (soap_flag_shared2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:shared", &(((ngwt__RecipientStatus*)a)->shared), ""))
				{	soap_flag_shared2 = 0;
					continue;
				}
			if (soap_flag_started2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:started", &(((ngwt__RecipientStatus*)a)->started), ""))
				{	soap_flag_started2 = 0;
					continue;
				}
			if (soap_flag_completed2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:completed", &(((ngwt__RecipientStatus*)a)->completed), ""))
				{	soap_flag_completed2 = 0;
					continue;
				}
			if (soap_flag_incomplete2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:incomplete", &(((ngwt__RecipientStatus*)a)->incomplete), ""))
				{	soap_flag_incomplete2 = 0;
					continue;
				}
			if (soap_flag_delegated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DelegatedStatus(soap, "ngwt:delegated", &(((ngwt__RecipientStatus*)a)->delegated), "ngwt:DelegatedStatus"))
				{	soap_flag_delegated2 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, "ngwt:delegateeStatus", &(((ngwt__RecipientStatus*)a)->delegateeStatus), "ngwt:DelegateeStatus"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__TransferFailedStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__TransferFailedStatus, 0, sizeof(ngwt__TransferFailedStatus), 0, soap_copy_ngwt__TransferFailedStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__TransferFailedStatus * SOAP_FMAC6 soap_new_ngwt__TransferFailedStatus(struct soap *soap, int n)
{	return soap_instantiate_ngwt__TransferFailedStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__TransferFailedStatus(struct soap *soap, ngwt__TransferFailedStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__TransferFailedStatus * SOAP_FMAC6 soap_instantiate_ngwt__TransferFailedStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__TransferFailedStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__TransferFailedStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__TransferFailedStatus;
		if (size)
			*size = sizeof(ngwt__TransferFailedStatus);
		((ngwt__TransferFailedStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__TransferFailedStatus[n];
		if (size)
			*size = n * sizeof(ngwt__TransferFailedStatus);
		for (int i = 0; i < n; i++)
			((ngwt__TransferFailedStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__TransferFailedStatus*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__TransferFailedStatus(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__TransferFailedStatus %p -> %p\n", q, p));
	*(ngwt__TransferFailedStatus*)p = *(ngwt__TransferFailedStatus*)q;
}

void ngwt__TimezoneList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Timezone(soap, &((ngwt__TimezoneList*)this)->timezone);
	/* transient soap skipped */
}

void ngwt__TimezoneList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Timezone(soap, &((ngwt__TimezoneList*)this)->timezone);
	/* transient soap skipped */
}

int ngwt__TimezoneList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__TimezoneList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__TimezoneList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__TimezoneList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__TimezoneList(struct soap *soap, const char *tag, int id, const ngwt__TimezoneList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__TimezoneList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Timezone(soap, "ngwt:timezone", -1, &(((ngwt__TimezoneList*)a)->timezone), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__TimezoneList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__TimezoneList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__TimezoneList * SOAP_FMAC4 soap_get_ngwt__TimezoneList(struct soap *soap, ngwt__TimezoneList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__TimezoneList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__TimezoneList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__TimezoneList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__TimezoneList * SOAP_FMAC4 soap_in_ngwt__TimezoneList(struct soap *soap, const char *tag, ngwt__TimezoneList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__TimezoneList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__TimezoneList, sizeof(ngwt__TimezoneList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__TimezoneList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__TimezoneList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Timezone(soap, "ngwt:timezone", &(((ngwt__TimezoneList*)a)->timezone), "ngwt:Timezone"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__TimezoneList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__TimezoneList, 0, sizeof(ngwt__TimezoneList), 0, soap_copy_ngwt__TimezoneList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__TimezoneList * SOAP_FMAC6 soap_new_ngwt__TimezoneList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__TimezoneList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__TimezoneList(struct soap *soap, ngwt__TimezoneList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__TimezoneList * SOAP_FMAC6 soap_instantiate_ngwt__TimezoneList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__TimezoneList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__TimezoneList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__TimezoneList;
		if (size)
			*size = sizeof(ngwt__TimezoneList);
		((ngwt__TimezoneList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__TimezoneList[n];
		if (size)
			*size = n * sizeof(ngwt__TimezoneList);
		for (int i = 0; i < n; i++)
			((ngwt__TimezoneList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__TimezoneList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__TimezoneList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__TimezoneList %p -> %p\n", q, p));
	*(ngwt__TimezoneList*)p = *(ngwt__TimezoneList*)q;
}

void ngwt__TimezoneComponent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__TimezoneComponent*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__TimezoneComponent*)this)->name);
	soap_embedded(soap, &((ngwt__TimezoneComponent*)this)->month, SOAP_TYPE_PointerTongwt__Month);
	soap_serialize_PointerTongwt__Month(soap, &((ngwt__TimezoneComponent*)this)->month);
	soap_embedded(soap, &((ngwt__TimezoneComponent*)this)->day, SOAP_TYPE_PointerTongwt__Day);
	soap_serialize_PointerTongwt__Day(soap, &((ngwt__TimezoneComponent*)this)->day);
	soap_embedded(soap, &((ngwt__TimezoneComponent*)this)->dayOfWeek, SOAP_TYPE_PointerTongwt__DayOfWeek);
	soap_serialize_PointerTongwt__DayOfWeek(soap, &((ngwt__TimezoneComponent*)this)->dayOfWeek);
	soap_embedded(soap, &((ngwt__TimezoneComponent*)this)->hour, SOAP_TYPE_PointerTongwt__Hour);
	soap_serialize_PointerTongwt__Hour(soap, &((ngwt__TimezoneComponent*)this)->hour);
	soap_embedded(soap, &((ngwt__TimezoneComponent*)this)->minute, SOAP_TYPE_PointerTongwt__Minute);
	soap_serialize_PointerTongwt__Minute(soap, &((ngwt__TimezoneComponent*)this)->minute);
	soap_embedded(soap, &((ngwt__TimezoneComponent*)this)->offset, SOAP_TYPE_ngwt__GMTOffset);
	/* transient soap skipped */
}

void ngwt__TimezoneComponent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwt__TimezoneComponent*)this)->name);
	((ngwt__TimezoneComponent*)this)->month = NULL;
	((ngwt__TimezoneComponent*)this)->day = NULL;
	((ngwt__TimezoneComponent*)this)->dayOfWeek = NULL;
	((ngwt__TimezoneComponent*)this)->hour = NULL;
	((ngwt__TimezoneComponent*)this)->minute = NULL;
	soap_default_ngwt__GMTOffset(soap, &((ngwt__TimezoneComponent*)this)->offset);
	/* transient soap skipped */
}

int ngwt__TimezoneComponent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__TimezoneComponent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__TimezoneComponent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__TimezoneComponent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__TimezoneComponent(struct soap *soap, const char *tag, int id, const ngwt__TimezoneComponent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__TimezoneComponent), type);
	soap_out_std__string(soap, "ngwt:name", -1, &(((ngwt__TimezoneComponent*)a)->name), "");
	soap_out_PointerTongwt__Month(soap, "ngwt:month", -1, &(((ngwt__TimezoneComponent*)a)->month), "");
	soap_out_PointerTongwt__Day(soap, "ngwt:day", -1, &(((ngwt__TimezoneComponent*)a)->day), "");
	soap_out_PointerTongwt__DayOfWeek(soap, "ngwt:dayOfWeek", -1, &(((ngwt__TimezoneComponent*)a)->dayOfWeek), "");
	soap_out_PointerTongwt__Hour(soap, "ngwt:hour", -1, &(((ngwt__TimezoneComponent*)a)->hour), "");
	soap_out_PointerTongwt__Minute(soap, "ngwt:minute", -1, &(((ngwt__TimezoneComponent*)a)->minute), "");
	soap_out_ngwt__GMTOffset(soap, "ngwt:offset", -1, &(((ngwt__TimezoneComponent*)a)->offset), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__TimezoneComponent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__TimezoneComponent(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__TimezoneComponent * SOAP_FMAC4 soap_get_ngwt__TimezoneComponent(struct soap *soap, ngwt__TimezoneComponent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__TimezoneComponent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__TimezoneComponent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__TimezoneComponent(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__TimezoneComponent * SOAP_FMAC4 soap_in_ngwt__TimezoneComponent(struct soap *soap, const char *tag, ngwt__TimezoneComponent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__TimezoneComponent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__TimezoneComponent, sizeof(ngwt__TimezoneComponent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__TimezoneComponent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__TimezoneComponent *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1, soap_flag_month1 = 1, soap_flag_day1 = 1, soap_flag_dayOfWeek1 = 1, soap_flag_hour1 = 1, soap_flag_minute1 = 1, soap_flag_offset1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:name", &(((ngwt__TimezoneComponent*)a)->name), ""))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_month1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Month(soap, "ngwt:month", &(((ngwt__TimezoneComponent*)a)->month), "ngwt:Month"))
				{	soap_flag_month1 = 0;
					continue;
				}
			if (soap_flag_day1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Day(soap, "ngwt:day", &(((ngwt__TimezoneComponent*)a)->day), "ngwt:Day"))
				{	soap_flag_day1 = 0;
					continue;
				}
			if (soap_flag_dayOfWeek1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DayOfWeek(soap, "ngwt:dayOfWeek", &(((ngwt__TimezoneComponent*)a)->dayOfWeek), "ngwt:DayOfWeek"))
				{	soap_flag_dayOfWeek1 = 0;
					continue;
				}
			if (soap_flag_hour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Hour(soap, "ngwt:hour", &(((ngwt__TimezoneComponent*)a)->hour), "ngwt:Hour"))
				{	soap_flag_hour1 = 0;
					continue;
				}
			if (soap_flag_minute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Minute(soap, "ngwt:minute", &(((ngwt__TimezoneComponent*)a)->minute), "ngwt:Minute"))
				{	soap_flag_minute1 = 0;
					continue;
				}
			if (soap_flag_offset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__GMTOffset(soap, "ngwt:offset", &(((ngwt__TimezoneComponent*)a)->offset), "ngwt:GMTOffset"))
				{	soap_flag_offset1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 || soap_flag_offset1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__TimezoneComponent *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__TimezoneComponent, 0, sizeof(ngwt__TimezoneComponent), 0, soap_copy_ngwt__TimezoneComponent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__TimezoneComponent * SOAP_FMAC6 soap_new_ngwt__TimezoneComponent(struct soap *soap, int n)
{	return soap_instantiate_ngwt__TimezoneComponent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__TimezoneComponent(struct soap *soap, ngwt__TimezoneComponent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__TimezoneComponent * SOAP_FMAC6 soap_instantiate_ngwt__TimezoneComponent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__TimezoneComponent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__TimezoneComponent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__TimezoneComponent;
		if (size)
			*size = sizeof(ngwt__TimezoneComponent);
		((ngwt__TimezoneComponent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__TimezoneComponent[n];
		if (size)
			*size = n * sizeof(ngwt__TimezoneComponent);
		for (int i = 0; i < n; i++)
			((ngwt__TimezoneComponent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__TimezoneComponent*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__TimezoneComponent(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__TimezoneComponent %p -> %p\n", q, p));
	*(ngwt__TimezoneComponent*)p = *(ngwt__TimezoneComponent*)q;
}

void ngwt__Timezone::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Timezone*)this)->id, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Timezone*)this)->id);
	soap_embedded(soap, &((ngwt__Timezone*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Timezone*)this)->description);
	soap_embedded(soap, &((ngwt__Timezone*)this)->daylight, SOAP_TYPE_PointerTongwt__TimezoneComponent);
	soap_serialize_PointerTongwt__TimezoneComponent(soap, &((ngwt__Timezone*)this)->daylight);
	soap_embedded(soap, &((ngwt__Timezone*)this)->standard, SOAP_TYPE_PointerTongwt__TimezoneComponent);
	soap_serialize_PointerTongwt__TimezoneComponent(soap, &((ngwt__Timezone*)this)->standard);
	/* transient soap skipped */
}

void ngwt__Timezone::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Timezone*)this)->id = NULL;
	((ngwt__Timezone*)this)->description = NULL;
	((ngwt__Timezone*)this)->daylight = NULL;
	((ngwt__Timezone*)this)->standard = NULL;
	/* transient soap skipped */
}

int ngwt__Timezone::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Timezone);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Timezone::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Timezone(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Timezone(struct soap *soap, const char *tag, int id, const ngwt__Timezone *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Timezone), type);
	soap_out_PointerTostd__string(soap, "ngwt:id", -1, &(((ngwt__Timezone*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__Timezone*)a)->description), "");
	soap_out_PointerTongwt__TimezoneComponent(soap, "ngwt:daylight", -1, &(((ngwt__Timezone*)a)->daylight), "");
	soap_out_PointerTongwt__TimezoneComponent(soap, "ngwt:standard", -1, &(((ngwt__Timezone*)a)->standard), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Timezone::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Timezone(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Timezone * SOAP_FMAC4 soap_get_ngwt__Timezone(struct soap *soap, ngwt__Timezone *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Timezone(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Timezone::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Timezone(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Timezone * SOAP_FMAC4 soap_in_ngwt__Timezone(struct soap *soap, const char *tag, ngwt__Timezone *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Timezone *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Timezone, sizeof(ngwt__Timezone), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Timezone)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Timezone *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_description1 = 1, soap_flag_daylight1 = 1, soap_flag_standard1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:id", &(((ngwt__Timezone*)a)->id), ""))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__Timezone*)a)->description), ""))
				{	soap_flag_description1 = 0;
					continue;
				}
			if (soap_flag_daylight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__TimezoneComponent(soap, "ngwt:daylight", &(((ngwt__Timezone*)a)->daylight), "ngwt:TimezoneComponent"))
				{	soap_flag_daylight1 = 0;
					continue;
				}
			if (soap_flag_standard1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__TimezoneComponent(soap, "ngwt:standard", &(((ngwt__Timezone*)a)->standard), "ngwt:TimezoneComponent"))
				{	soap_flag_standard1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Timezone *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Timezone, 0, sizeof(ngwt__Timezone), 0, soap_copy_ngwt__Timezone);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Timezone * SOAP_FMAC6 soap_new_ngwt__Timezone(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Timezone(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Timezone(struct soap *soap, ngwt__Timezone *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Timezone * SOAP_FMAC6 soap_instantiate_ngwt__Timezone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Timezone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Timezone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Timezone;
		if (size)
			*size = sizeof(ngwt__Timezone);
		((ngwt__Timezone*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Timezone[n];
		if (size)
			*size = n * sizeof(ngwt__Timezone);
		for (int i = 0; i < n; i++)
			((ngwt__Timezone*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Timezone*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Timezone(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Timezone %p -> %p\n", q, p));
	*(ngwt__Timezone*)p = *(ngwt__Timezone*)q;
}

void ngwt__Task::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Task*)this)->startDate, SOAP_TYPE_PointerToxsd__date);
	soap_serialize_PointerToxsd__date(soap, &((ngwt__Task*)this)->startDate);
	soap_embedded(soap, &((ngwt__Task*)this)->dueDate, SOAP_TYPE_PointerToxsd__date);
	soap_serialize_PointerToxsd__date(soap, &((ngwt__Task*)this)->dueDate);
	soap_embedded(soap, &((ngwt__Task*)this)->assignedDate, SOAP_TYPE_PointerToxsd__date);
	soap_serialize_PointerToxsd__date(soap, &((ngwt__Task*)this)->assignedDate);
	soap_embedded(soap, &((ngwt__Task*)this)->taskPriority, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Task*)this)->taskPriority);
	soap_embedded(soap, &((ngwt__Task*)this)->completed, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Task*)this)->completed);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->rdate, SOAP_TYPE_PointerTongwt__RecurrenceDateType);
	soap_serialize_PointerTongwt__RecurrenceDateType(soap, &((ngwt__CalendarItem*)this)->rdate);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->rrule, SOAP_TYPE_PointerTongwt__RecurrenceRule);
	soap_serialize_PointerTongwt__RecurrenceRule(soap, &((ngwt__CalendarItem*)this)->rrule);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->exdate, SOAP_TYPE_PointerTongwt__RecurrenceDateType);
	soap_serialize_PointerTongwt__RecurrenceDateType(soap, &((ngwt__CalendarItem*)this)->exdate);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->recurrenceKey, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__CalendarItem*)this)->recurrenceKey);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->iCalId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__CalendarItem*)this)->iCalId);
	soap_embedded(soap, &((ngwt__Mail*)this)->subject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subject);
	soap_embedded(soap, &((ngwt__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ngwt__Mail*)this)->subjectPrefix, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subjectPrefix);
	soap_embedded(soap, &((ngwt__Mail*)this)->distribution, SOAP_TYPE_PointerTongwt__Distribution);
	soap_serialize_PointerTongwt__Distribution(soap, &((ngwt__Mail*)this)->distribution);
	soap_embedded(soap, &((ngwt__Mail*)this)->message, SOAP_TYPE_PointerTongwt__MessageBody);
	soap_serialize_PointerTongwt__MessageBody(soap, &((ngwt__Mail*)this)->message);
	soap_embedded(soap, &((ngwt__Mail*)this)->attachments, SOAP_TYPE_PointerTongwt__AttachmentInfo);
	soap_serialize_PointerTongwt__AttachmentInfo(soap, &((ngwt__Mail*)this)->attachments);
	soap_embedded(soap, &((ngwt__Mail*)this)->options, SOAP_TYPE_PointerTongwt__ItemOptions);
	soap_serialize_PointerTongwt__ItemOptions(soap, &((ngwt__Mail*)this)->options);
	soap_embedded(soap, &((ngwt__Mail*)this)->link, SOAP_TYPE_PointerTongwt__LinkInfo);
	soap_serialize_PointerTongwt__LinkInfo(soap, &((ngwt__Mail*)this)->link);
	soap_embedded(soap, &((ngwt__Mail*)this)->hasAttachment, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwt__Mail*)this)->size, SOAP_TYPE_int);
	soap_embedded(soap, &((ngwt__Mail*)this)->subType, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subType);
	soap_embedded(soap, &((ngwt__Mail*)this)->nntpOrImap, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Mail*)this)->nntpOrImap);
	soap_embedded(soap, &((ngwt__Mail*)this)->smimeType, SOAP_TYPE_PointerTongwt__SMimeOperation);
	soap_serialize_PointerTongwt__SMimeOperation(soap, &((ngwt__Mail*)this)->smimeType);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->status, SOAP_TYPE_PointerTongwt__ItemStatus);
	soap_serialize_PointerTongwt__ItemStatus(soap, &((ngwt__BoxEntry*)this)->status);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->msgId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->msgId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->messageId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->messageId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->source, SOAP_TYPE_PointerTongwt__ItemSource);
	soap_serialize_PointerTongwt__ItemSource(soap, &((ngwt__BoxEntry*)this)->source);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->class_, SOAP_TYPE_PointerTongwt__ItemClass);
	soap_serialize_PointerTongwt__ItemClass(soap, &((ngwt__BoxEntry*)this)->class_);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->security, SOAP_TYPE_PointerTongwt__ItemSecurity);
	soap_serialize_PointerTongwt__ItemSecurity(soap, &((ngwt__BoxEntry*)this)->security);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->comment);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Task::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Task*)this)->startDate = NULL;
	((ngwt__Task*)this)->dueDate = NULL;
	((ngwt__Task*)this)->assignedDate = NULL;
	((ngwt__Task*)this)->taskPriority = NULL;
	((ngwt__Task*)this)->completed = NULL;
	((ngwt__CalendarItem*)this)->rdate = NULL;
	((ngwt__CalendarItem*)this)->rrule = NULL;
	((ngwt__CalendarItem*)this)->exdate = NULL;
	((ngwt__CalendarItem*)this)->recurrenceKey = NULL;
	((ngwt__CalendarItem*)this)->iCalId = NULL;
	((ngwt__Mail*)this)->subject = NULL;
	((ngwt__Mail*)this)->originalSubject = NULL;
	((ngwt__Mail*)this)->subjectPrefix = NULL;
	((ngwt__Mail*)this)->distribution = NULL;
	((ngwt__Mail*)this)->message = NULL;
	((ngwt__Mail*)this)->attachments = NULL;
	((ngwt__Mail*)this)->options = NULL;
	((ngwt__Mail*)this)->link = NULL;
	((ngwt__Mail*)this)->hasAttachment = (bool)0;
	((ngwt__Mail*)this)->size = 0;
	((ngwt__Mail*)this)->subType = NULL;
	((ngwt__Mail*)this)->nntpOrImap = NULL;
	((ngwt__Mail*)this)->smimeType = NULL;
	((ngwt__BoxEntry*)this)->status = NULL;
	((ngwt__BoxEntry*)this)->thread = NULL;
	((ngwt__BoxEntry*)this)->msgId = NULL;
	((ngwt__BoxEntry*)this)->messageId = NULL;
	((ngwt__BoxEntry*)this)->source = NULL;
	((ngwt__BoxEntry*)this)->returnSentItemsId = NULL;
	soap_default_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	((ngwt__BoxEntry*)this)->class_ = NULL;
	((ngwt__BoxEntry*)this)->security = NULL;
	((ngwt__BoxEntry*)this)->comment = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Task::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Task);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Task::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Task(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Task(struct soap *soap, const char *tag, int id, const ngwt__Task *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Task), "ngwt:Task");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__ItemStatus(soap, "ngwt:status", -1, &(((ngwt__BoxEntry*)a)->status), "");
	soap_out_PointerTostd__string(soap, "ngwt:thread", -1, &(((ngwt__BoxEntry*)a)->thread), "");
	soap_out_PointerTostd__string(soap, "ngwt:msgId", -1, &(((ngwt__BoxEntry*)a)->msgId), "");
	soap_out_PointerTostd__string(soap, "ngwt:messageId", -1, &(((ngwt__BoxEntry*)a)->messageId), "");
	soap_out_PointerTongwt__ItemSource(soap, "ngwt:source", -1, &(((ngwt__BoxEntry*)a)->source), "");
	soap_out_PointerTobool(soap, "ngwt:returnSentItemsId", -1, &(((ngwt__BoxEntry*)a)->returnSentItemsId), "");
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__BoxEntry*)a)->delivered), "");
	soap_out_PointerTongwt__ItemClass(soap, "ngwt:class", -1, &(((ngwt__BoxEntry*)a)->class_), "");
	soap_out_PointerTongwt__ItemSecurity(soap, "ngwt:security", -1, &(((ngwt__BoxEntry*)a)->security), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__BoxEntry*)a)->comment), "");
	soap_out_PointerTostd__string(soap, "ngwt:subject", -1, &(((ngwt__Mail*)a)->subject), "");
	soap_out_PointerTostd__string(soap, "ngwt:originalSubject", -1, &(((ngwt__Mail*)a)->originalSubject), "");
	soap_out_PointerTostd__string(soap, "ngwt:subjectPrefix", -1, &(((ngwt__Mail*)a)->subjectPrefix), "");
	soap_out_PointerTongwt__Distribution(soap, "ngwt:distribution", -1, &(((ngwt__Mail*)a)->distribution), "");
	soap_out_PointerTongwt__MessageBody(soap, "ngwt:message", -1, &(((ngwt__Mail*)a)->message), "");
	soap_out_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", -1, &(((ngwt__Mail*)a)->attachments), "");
	soap_out_PointerTongwt__ItemOptions(soap, "ngwt:options", -1, &(((ngwt__Mail*)a)->options), "");
	soap_out_PointerTongwt__LinkInfo(soap, "ngwt:link", -1, &(((ngwt__Mail*)a)->link), "");
	soap_out_bool(soap, "ngwt:hasAttachment", -1, &(((ngwt__Mail*)a)->hasAttachment), "");
	soap_out_int(soap, "ngwt:size", -1, &(((ngwt__Mail*)a)->size), "");
	soap_out_PointerTostd__string(soap, "ngwt:subType", -1, &(((ngwt__Mail*)a)->subType), "");
	soap_out_PointerTobool(soap, "ngwt:nntpOrImap", -1, &(((ngwt__Mail*)a)->nntpOrImap), "");
	soap_out_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", -1, &(((ngwt__Mail*)a)->smimeType), "");
	soap_out_PointerTongwt__RecurrenceDateType(soap, "ngwt:rdate", -1, &(((ngwt__CalendarItem*)a)->rdate), "");
	soap_out_PointerTongwt__RecurrenceRule(soap, "ngwt:rrule", -1, &(((ngwt__CalendarItem*)a)->rrule), "");
	soap_out_PointerTongwt__RecurrenceDateType(soap, "ngwt:exdate", -1, &(((ngwt__CalendarItem*)a)->exdate), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:recurrenceKey", -1, &(((ngwt__CalendarItem*)a)->recurrenceKey), "");
	soap_out_PointerTostd__string(soap, "ngwt:iCalId", -1, &(((ngwt__CalendarItem*)a)->iCalId), "");
	soap_out_PointerToxsd__date(soap, "ngwt:startDate", -1, &(((ngwt__Task*)a)->startDate), "");
	soap_out_PointerToxsd__date(soap, "ngwt:dueDate", -1, &(((ngwt__Task*)a)->dueDate), "");
	soap_out_PointerToxsd__date(soap, "ngwt:assignedDate", -1, &(((ngwt__Task*)a)->assignedDate), "");
	soap_out_PointerTostd__string(soap, "ngwt:taskPriority", -1, &(((ngwt__Task*)a)->taskPriority), "");
	soap_out_PointerTobool(soap, "ngwt:completed", -1, &(((ngwt__Task*)a)->completed), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Task::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Task(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Task * SOAP_FMAC4 soap_get_ngwt__Task(struct soap *soap, ngwt__Task *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Task(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Task::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Task(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Task * SOAP_FMAC4 soap_in_ngwt__Task(struct soap *soap, const char *tag, ngwt__Task *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Task *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Task, sizeof(ngwt__Task), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Task)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Task *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id6 = 1, soap_flag_name6 = 1, soap_flag_version6 = 1, soap_flag_modified6 = 1, soap_flag_changes6 = 1, soap_flag_categories5 = 1, soap_flag_created5 = 1, soap_flag_customs5 = 1, soap_flag_status4 = 1, soap_flag_thread4 = 1, soap_flag_msgId4 = 1, soap_flag_messageId4 = 1, soap_flag_source4 = 1, soap_flag_returnSentItemsId4 = 1, soap_flag_delivered4 = 1, soap_flag_class_4 = 1, soap_flag_security4 = 1, soap_flag_comment4 = 1, soap_flag_subject3 = 1, soap_flag_originalSubject3 = 1, soap_flag_subjectPrefix3 = 1, soap_flag_distribution3 = 1, soap_flag_message3 = 1, soap_flag_attachments3 = 1, soap_flag_options3 = 1, soap_flag_link3 = 1, soap_flag_hasAttachment3 = 1, soap_flag_size3 = 1, soap_flag_subType3 = 1, soap_flag_nntpOrImap3 = 1, soap_flag_smimeType3 = 1, soap_flag_rdate2 = 1, soap_flag_rrule2 = 1, soap_flag_exdate2 = 1, soap_flag_recurrenceKey2 = 1, soap_flag_iCalId2 = 1, soap_flag_startDate1 = 1, soap_flag_dueDate1 = 1, soap_flag_assignedDate1 = 1, soap_flag_taskPriority1 = 1, soap_flag_completed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id6 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id6 = 0;
					continue;
				}
			if (soap_flag_name6 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name6 = 0;
					continue;
				}
			if (soap_flag_version6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version6 = 0;
					continue;
				}
			if (soap_flag_modified6 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified6 = 0;
					continue;
				}
			if (soap_flag_changes6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes6 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories5 = 0;
					continue;
				}
			if (soap_flag_created5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created5 = 0;
					continue;
				}
			if (soap_flag_customs5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs5 = 0;
					continue;
				}
			if (soap_flag_status4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemStatus(soap, "ngwt:status", &(((ngwt__BoxEntry*)a)->status), "ngwt:ItemStatus"))
				{	soap_flag_status4 = 0;
					continue;
				}
			if (soap_flag_thread4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:thread", &(((ngwt__BoxEntry*)a)->thread), ""))
				{	soap_flag_thread4 = 0;
					continue;
				}
			if (soap_flag_msgId4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:msgId", &(((ngwt__BoxEntry*)a)->msgId), ""))
				{	soap_flag_msgId4 = 0;
					continue;
				}
			if (soap_flag_messageId4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:messageId", &(((ngwt__BoxEntry*)a)->messageId), ""))
				{	soap_flag_messageId4 = 0;
					continue;
				}
			if (soap_flag_source4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSource(soap, "ngwt:source", &(((ngwt__BoxEntry*)a)->source), ""))
				{	soap_flag_source4 = 0;
					continue;
				}
			if (soap_flag_returnSentItemsId4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:returnSentItemsId", &(((ngwt__BoxEntry*)a)->returnSentItemsId), ""))
				{	soap_flag_returnSentItemsId4 = 0;
					continue;
				}
			if (soap_flag_delivered4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered4 = 0;
					continue;
				}
			if (soap_flag_class_4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemClass(soap, "ngwt:class", &(((ngwt__BoxEntry*)a)->class_), ""))
				{	soap_flag_class_4 = 0;
					continue;
				}
			if (soap_flag_security4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSecurity(soap, "ngwt:security", &(((ngwt__BoxEntry*)a)->security), ""))
				{	soap_flag_security4 = 0;
					continue;
				}
			if (soap_flag_comment4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__BoxEntry*)a)->comment), ""))
				{	soap_flag_comment4 = 0;
					continue;
				}
			if (soap_flag_subject3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subject", &(((ngwt__Mail*)a)->subject), ""))
				{	soap_flag_subject3 = 0;
					continue;
				}
			if (soap_flag_originalSubject3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:originalSubject", &(((ngwt__Mail*)a)->originalSubject), ""))
				{	soap_flag_originalSubject3 = 0;
					continue;
				}
			if (soap_flag_subjectPrefix3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subjectPrefix", &(((ngwt__Mail*)a)->subjectPrefix), ""))
				{	soap_flag_subjectPrefix3 = 0;
					continue;
				}
			if (soap_flag_distribution3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Distribution(soap, "ngwt:distribution", &(((ngwt__Mail*)a)->distribution), "ngwt:Distribution"))
				{	soap_flag_distribution3 = 0;
					continue;
				}
			if (soap_flag_message3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessageBody(soap, "ngwt:message", &(((ngwt__Mail*)a)->message), "ngwt:MessageBody"))
				{	soap_flag_message3 = 0;
					continue;
				}
			if (soap_flag_attachments3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", &(((ngwt__Mail*)a)->attachments), "ngwt:AttachmentInfo"))
				{	soap_flag_attachments3 = 0;
					continue;
				}
			if (soap_flag_options3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemOptions(soap, "ngwt:options", &(((ngwt__Mail*)a)->options), "ngwt:ItemOptions"))
				{	soap_flag_options3 = 0;
					continue;
				}
			if (soap_flag_link3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__LinkInfo(soap, "ngwt:link", &(((ngwt__Mail*)a)->link), "ngwt:LinkInfo"))
				{	soap_flag_link3 = 0;
					continue;
				}
			if (soap_flag_hasAttachment3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:hasAttachment", &(((ngwt__Mail*)a)->hasAttachment), ""))
				{	soap_flag_hasAttachment3 = 0;
					continue;
				}
			if (soap_flag_size3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:size", &(((ngwt__Mail*)a)->size), ""))
				{	soap_flag_size3 = 0;
					continue;
				}
			if (soap_flag_subType3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subType", &(((ngwt__Mail*)a)->subType), ""))
				{	soap_flag_subType3 = 0;
					continue;
				}
			if (soap_flag_nntpOrImap3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:nntpOrImap", &(((ngwt__Mail*)a)->nntpOrImap), ""))
				{	soap_flag_nntpOrImap3 = 0;
					continue;
				}
			if (soap_flag_smimeType3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", &(((ngwt__Mail*)a)->smimeType), "ngwt:SMimeOperation"))
				{	soap_flag_smimeType3 = 0;
					continue;
				}
			if (soap_flag_rdate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceDateType(soap, "ngwt:rdate", &(((ngwt__CalendarItem*)a)->rdate), "ngwt:RecurrenceDateType"))
				{	soap_flag_rdate2 = 0;
					continue;
				}
			if (soap_flag_rrule2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceRule(soap, "ngwt:rrule", &(((ngwt__CalendarItem*)a)->rrule), "ngwt:RecurrenceRule"))
				{	soap_flag_rrule2 = 0;
					continue;
				}
			if (soap_flag_exdate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceDateType(soap, "ngwt:exdate", &(((ngwt__CalendarItem*)a)->exdate), "ngwt:RecurrenceDateType"))
				{	soap_flag_exdate2 = 0;
					continue;
				}
			if (soap_flag_recurrenceKey2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:recurrenceKey", &(((ngwt__CalendarItem*)a)->recurrenceKey), ""))
				{	soap_flag_recurrenceKey2 = 0;
					continue;
				}
			if (soap_flag_iCalId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:iCalId", &(((ngwt__CalendarItem*)a)->iCalId), ""))
				{	soap_flag_iCalId2 = 0;
					continue;
				}
			if (soap_flag_startDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__date(soap, "ngwt:startDate", &(((ngwt__Task*)a)->startDate), "xsd:date"))
				{	soap_flag_startDate1 = 0;
					continue;
				}
			if (soap_flag_dueDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__date(soap, "ngwt:dueDate", &(((ngwt__Task*)a)->dueDate), "xsd:date"))
				{	soap_flag_dueDate1 = 0;
					continue;
				}
			if (soap_flag_assignedDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__date(soap, "ngwt:assignedDate", &(((ngwt__Task*)a)->assignedDate), "xsd:date"))
				{	soap_flag_assignedDate1 = 0;
					continue;
				}
			if (soap_flag_taskPriority1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:taskPriority", &(((ngwt__Task*)a)->taskPriority), ""))
				{	soap_flag_taskPriority1 = 0;
					continue;
				}
			if (soap_flag_completed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:completed", &(((ngwt__Task*)a)->completed), ""))
				{	soap_flag_completed1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_delivered4))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Task *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Task, 0, sizeof(ngwt__Task), 0, soap_copy_ngwt__Task);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Task * SOAP_FMAC6 soap_new_ngwt__Task(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Task(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Task(struct soap *soap, ngwt__Task *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Task * SOAP_FMAC6 soap_instantiate_ngwt__Task(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Task(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Task, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Task;
		if (size)
			*size = sizeof(ngwt__Task);
		((ngwt__Task*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Task[n];
		if (size)
			*size = n * sizeof(ngwt__Task);
		for (int i = 0; i < n; i++)
			((ngwt__Task*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Task*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Task(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Task %p -> %p\n", q, p));
	*(ngwt__Task*)p = *(ngwt__Task*)q;
}

void ngwt__SystemFolder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__SystemFolder*)this)->isSystemFolder, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__SystemFolder*)this)->isSystemFolder);
	soap_embedded(soap, &((ngwt__SystemFolder*)this)->folderType, SOAP_TYPE_PointerTongwt__FolderType);
	soap_serialize_PointerTongwt__FolderType(soap, &((ngwt__SystemFolder*)this)->folderType);
	soap_embedded(soap, &((ngwt__SystemFolder*)this)->acl, SOAP_TYPE_PointerTongwt__FolderACL);
	soap_serialize_PointerTongwt__FolderACL(soap, &((ngwt__SystemFolder*)this)->acl);
	soap_embedded(soap, &((ngwt__SystemFolder*)this)->isSharedByMe, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__SystemFolder*)this)->isSharedByMe);
	soap_embedded(soap, &((ngwt__Folder*)this)->parent, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((ngwt__Folder*)this)->parent);
	soap_embedded(soap, &((ngwt__Folder*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Folder*)this)->description);
	soap_embedded(soap, &((ngwt__Folder*)this)->count, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__Folder*)this)->count);
	soap_embedded(soap, &((ngwt__Folder*)this)->hasUnread, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Folder*)this)->hasUnread);
	soap_embedded(soap, &((ngwt__Folder*)this)->unreadCount, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__Folder*)this)->unreadCount);
	soap_embedded(soap, &((ngwt__Folder*)this)->sequence, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Folder*)this)->sequence);
	soap_embedded(soap, &((ngwt__Folder*)this)->settings, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Folder*)this)->settings);
	soap_embedded(soap, &((ngwt__Folder*)this)->calendarAttribute, SOAP_TYPE_PointerTongwt__CalendarFolderAttribute);
	soap_serialize_PointerTongwt__CalendarFolderAttribute(soap, &((ngwt__Folder*)this)->calendarAttribute);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__SystemFolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__SystemFolder*)this)->isSystemFolder = NULL;
	((ngwt__SystemFolder*)this)->folderType = NULL;
	((ngwt__SystemFolder*)this)->acl = NULL;
	((ngwt__SystemFolder*)this)->isSharedByMe = NULL;
	soap_default_ngwt__uid(soap, &((ngwt__Folder*)this)->parent);
	((ngwt__Folder*)this)->description = NULL;
	((ngwt__Folder*)this)->count = NULL;
	((ngwt__Folder*)this)->hasUnread = NULL;
	((ngwt__Folder*)this)->unreadCount = NULL;
	((ngwt__Folder*)this)->sequence = NULL;
	((ngwt__Folder*)this)->settings = NULL;
	((ngwt__Folder*)this)->calendarAttribute = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__SystemFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__SystemFolder);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__SystemFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__SystemFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__SystemFolder(struct soap *soap, const char *tag, int id, const ngwt__SystemFolder *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__SystemFolder), "ngwt:SystemFolder");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_ngwt__uid(soap, "ngwt:parent", -1, &(((ngwt__Folder*)a)->parent), "");
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__Folder*)a)->description), "");
	soap_out_PointerToint(soap, "ngwt:count", -1, &(((ngwt__Folder*)a)->count), "");
	soap_out_PointerTobool(soap, "ngwt:hasUnread", -1, &(((ngwt__Folder*)a)->hasUnread), "");
	soap_out_PointerToint(soap, "ngwt:unreadCount", -1, &(((ngwt__Folder*)a)->unreadCount), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:sequence", -1, &(((ngwt__Folder*)a)->sequence), "");
	soap_out_PointerTongwt__uid(soap, "ngwt:settings", -1, &(((ngwt__Folder*)a)->settings), "");
	soap_out_PointerTongwt__CalendarFolderAttribute(soap, "ngwt:calendarAttribute", -1, &(((ngwt__Folder*)a)->calendarAttribute), "");
	soap_out_PointerTobool(soap, "ngwt:isSystemFolder", -1, &(((ngwt__SystemFolder*)a)->isSystemFolder), "");
	soap_out_PointerTongwt__FolderType(soap, "ngwt:folderType", -1, &(((ngwt__SystemFolder*)a)->folderType), "");
	soap_out_PointerTongwt__FolderACL(soap, "ngwt:acl", -1, &(((ngwt__SystemFolder*)a)->acl), "");
	soap_out_PointerTobool(soap, "ngwt:isSharedByMe", -1, &(((ngwt__SystemFolder*)a)->isSharedByMe), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__SystemFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__SystemFolder(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__SystemFolder * SOAP_FMAC4 soap_get_ngwt__SystemFolder(struct soap *soap, ngwt__SystemFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__SystemFolder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__SystemFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__SystemFolder(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__SystemFolder * SOAP_FMAC4 soap_in_ngwt__SystemFolder(struct soap *soap, const char *tag, ngwt__SystemFolder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__SystemFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__SystemFolder, sizeof(ngwt__SystemFolder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__SystemFolder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__SystemFolder *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_parent2 = 1, soap_flag_description2 = 1, soap_flag_count2 = 1, soap_flag_hasUnread2 = 1, soap_flag_unreadCount2 = 1, soap_flag_sequence2 = 1, soap_flag_settings2 = 1, soap_flag_calendarAttribute2 = 1, soap_flag_isSystemFolder1 = 1, soap_flag_folderType1 = 1, soap_flag_acl1 = 1, soap_flag_isSharedByMe1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}
			if (soap_flag_name3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name3 = 0;
					continue;
				}
			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}
			if (soap_flag_modified3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}
			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_parent2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwt:parent", &(((ngwt__Folder*)a)->parent), "ngwt:uid"))
				{	soap_flag_parent2 = 0;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__Folder*)a)->description), ""))
				{	soap_flag_description2 = 0;
					continue;
				}
			if (soap_flag_count2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:count", &(((ngwt__Folder*)a)->count), ""))
				{	soap_flag_count2 = 0;
					continue;
				}
			if (soap_flag_hasUnread2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:hasUnread", &(((ngwt__Folder*)a)->hasUnread), ""))
				{	soap_flag_hasUnread2 = 0;
					continue;
				}
			if (soap_flag_unreadCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:unreadCount", &(((ngwt__Folder*)a)->unreadCount), ""))
				{	soap_flag_unreadCount2 = 0;
					continue;
				}
			if (soap_flag_sequence2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:sequence", &(((ngwt__Folder*)a)->sequence), ""))
				{	soap_flag_sequence2 = 0;
					continue;
				}
			if (soap_flag_settings2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:settings", &(((ngwt__Folder*)a)->settings), "ngwt:uid"))
				{	soap_flag_settings2 = 0;
					continue;
				}
			if (soap_flag_calendarAttribute2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CalendarFolderAttribute(soap, "ngwt:calendarAttribute", &(((ngwt__Folder*)a)->calendarAttribute), "ngwt:CalendarFolderAttribute"))
				{	soap_flag_calendarAttribute2 = 0;
					continue;
				}
			if (soap_flag_isSystemFolder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:isSystemFolder", &(((ngwt__SystemFolder*)a)->isSystemFolder), ""))
				{	soap_flag_isSystemFolder1 = 0;
					continue;
				}
			if (soap_flag_folderType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FolderType(soap, "ngwt:folderType", &(((ngwt__SystemFolder*)a)->folderType), ""))
				{	soap_flag_folderType1 = 0;
					continue;
				}
			if (soap_flag_acl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FolderACL(soap, "ngwt:acl", &(((ngwt__SystemFolder*)a)->acl), "ngwt:FolderACL"))
				{	soap_flag_acl1 = 0;
					continue;
				}
			if (soap_flag_isSharedByMe1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:isSharedByMe", &(((ngwt__SystemFolder*)a)->isSharedByMe), ""))
				{	soap_flag_isSharedByMe1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__SystemFolder *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SystemFolder, 0, sizeof(ngwt__SystemFolder), 0, soap_copy_ngwt__SystemFolder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__SystemFolder * SOAP_FMAC6 soap_new_ngwt__SystemFolder(struct soap *soap, int n)
{	return soap_instantiate_ngwt__SystemFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__SystemFolder(struct soap *soap, ngwt__SystemFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__SystemFolder * SOAP_FMAC6 soap_instantiate_ngwt__SystemFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__SystemFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__SystemFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:ContactFolder"))
	{	cp->type = SOAP_TYPE_ngwt__ContactFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__ContactFolder;
			if (size)
				*size = sizeof(ngwt__ContactFolder);
			((ngwt__ContactFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__ContactFolder[n];
			if (size)
				*size = n * sizeof(ngwt__ContactFolder);
			for (int i = 0; i < n; i++)
				((ngwt__ContactFolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__ContactFolder*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__SystemFolder;
		if (size)
			*size = sizeof(ngwt__SystemFolder);
		((ngwt__SystemFolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__SystemFolder[n];
		if (size)
			*size = n * sizeof(ngwt__SystemFolder);
		for (int i = 0; i < n; i++)
			((ngwt__SystemFolder*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__SystemFolder*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__SystemFolder(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__SystemFolder %p -> %p\n", q, p));
	*(ngwt__SystemFolder*)p = *(ngwt__SystemFolder*)q;
}

void ngwt__StatusTracking::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__StatusTracking*)this)->__item, SOAP_TYPE_ngwt__StatusTrackingOptions);
	/* transient soap skipped */
}

void ngwt__StatusTracking::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__StatusTrackingOptions(soap, &((ngwt__StatusTracking*)this)->__item);
	((ngwt__StatusTracking*)this)->autoDelete = NULL;
	/* transient soap skipped */
}

int ngwt__StatusTracking::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__StatusTracking);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__StatusTracking::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__StatusTracking(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__StatusTracking(struct soap *soap, const char *tag, int id, const ngwt__StatusTracking *a, const char *type)
{
	if (((ngwt__StatusTracking *)a)->autoDelete)
		soap_set_attr(soap, "autoDelete", soap_bool2s(soap, *((ngwt__StatusTracking *)a)->autoDelete));
	soap_out_ngwt__StatusTrackingOptions(soap, tag, id, &(((ngwt__StatusTracking*)a)->__item), "");
	return SOAP_OK;
}

void *ngwt__StatusTracking::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__StatusTracking(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__StatusTracking * SOAP_FMAC4 soap_get_ngwt__StatusTracking(struct soap *soap, ngwt__StatusTracking *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__StatusTracking(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__StatusTracking::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__StatusTracking(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__StatusTracking * SOAP_FMAC4 soap_in_ngwt__StatusTracking(struct soap *soap, const char *tag, ngwt__StatusTracking *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ngwt__StatusTracking *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__StatusTracking, sizeof(ngwt__StatusTracking), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__StatusTracking)
			return (ngwt__StatusTracking *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "autoDelete", 0);
		if (t)
		{	if (!(((ngwt__StatusTracking *)a)->autoDelete = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ngwt__StatusTracking *)a)->autoDelete))
		return NULL;
		}
	}
	if (!soap_in_ngwt__StatusTrackingOptions(soap, tag, &(((ngwt__StatusTracking*)a)->__item), "ngwt:StatusTracking"))
		return NULL;
	return a;
}

SOAP_FMAC5 ngwt__StatusTracking * SOAP_FMAC6 soap_new_ngwt__StatusTracking(struct soap *soap, int n)
{	return soap_instantiate_ngwt__StatusTracking(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__StatusTracking(struct soap *soap, ngwt__StatusTracking *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__StatusTracking * SOAP_FMAC6 soap_instantiate_ngwt__StatusTracking(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__StatusTracking(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__StatusTracking, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__StatusTracking;
		if (size)
			*size = sizeof(ngwt__StatusTracking);
		((ngwt__StatusTracking*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__StatusTracking[n];
		if (size)
			*size = n * sizeof(ngwt__StatusTracking);
		for (int i = 0; i < n; i++)
			((ngwt__StatusTracking*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__StatusTracking*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__StatusTracking(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__StatusTracking %p -> %p\n", q, p));
	*(ngwt__StatusTracking*)p = *(ngwt__StatusTracking*)q;
}

void ngwt__Status::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Status*)this)->code, SOAP_TYPE_int);
	soap_embedded(soap, &((ngwt__Status*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Status*)this)->description);
	soap_embedded(soap, &((ngwt__Status*)this)->info, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Status*)this)->info);
	soap_embedded(soap, &((ngwt__Status*)this)->problems, SOAP_TYPE_PointerTongwt__ProblemList);
	soap_serialize_PointerTongwt__ProblemList(soap, &((ngwt__Status*)this)->problems);
	/* transient soap skipped */
}

void ngwt__Status::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ngwt__Status*)this)->code);
	((ngwt__Status*)this)->description = NULL;
	((ngwt__Status*)this)->info = NULL;
	((ngwt__Status*)this)->problems = NULL;
	/* transient soap skipped */
}

int ngwt__Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Status);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Status(struct soap *soap, const char *tag, int id, const ngwt__Status *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Status), type);
	soap_out_int(soap, "ngwt:code", -1, &(((ngwt__Status*)a)->code), "");
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__Status*)a)->description), "");
	soap_out_PointerTostd__string(soap, "ngwt:info", -1, &(((ngwt__Status*)a)->info), "");
	soap_out_PointerTongwt__ProblemList(soap, "ngwt:problems", -1, &(((ngwt__Status*)a)->problems), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Status(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Status * SOAP_FMAC4 soap_get_ngwt__Status(struct soap *soap, ngwt__Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Status(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Status::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Status(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Status * SOAP_FMAC4 soap_in_ngwt__Status(struct soap *soap, const char *tag, ngwt__Status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Status *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Status, sizeof(ngwt__Status), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Status)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Status *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_code1 = 1, soap_flag_description1 = 1, soap_flag_info1 = 1, soap_flag_problems1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:code", &(((ngwt__Status*)a)->code), ""))
				{	soap_flag_code1 = 0;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__Status*)a)->description), ""))
				{	soap_flag_description1 = 0;
					continue;
				}
			if (soap_flag_info1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:info", &(((ngwt__Status*)a)->info), ""))
				{	soap_flag_info1 = 0;
					continue;
				}
			if (soap_flag_problems1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ProblemList(soap, "ngwt:problems", &(((ngwt__Status*)a)->problems), "ngwt:ProblemList"))
				{	soap_flag_problems1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Status *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Status, 0, sizeof(ngwt__Status), 0, soap_copy_ngwt__Status);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Status * SOAP_FMAC6 soap_new_ngwt__Status(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Status(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Status(struct soap *soap, ngwt__Status *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Status * SOAP_FMAC6 soap_instantiate_ngwt__Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Status(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Status, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Status;
		if (size)
			*size = sizeof(ngwt__Status);
		((ngwt__Status*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Status[n];
		if (size)
			*size = n * sizeof(ngwt__Status);
		for (int i = 0; i < n; i++)
			((ngwt__Status*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Status*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Status(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Status %p -> %p\n", q, p));
	*(ngwt__Status*)p = *(ngwt__Status*)q;
}

void ngwt__SMimeOperation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__SMimeOperation*)this)->signed_, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__SMimeOperation*)this)->signed_);
	soap_embedded(soap, &((ngwt__SMimeOperation*)this)->encrypted, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__SMimeOperation*)this)->encrypted);
	/* transient soap skipped */
}

void ngwt__SMimeOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__SMimeOperation*)this)->signed_ = NULL;
	((ngwt__SMimeOperation*)this)->encrypted = NULL;
	/* transient soap skipped */
}

int ngwt__SMimeOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__SMimeOperation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__SMimeOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__SMimeOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__SMimeOperation(struct soap *soap, const char *tag, int id, const ngwt__SMimeOperation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__SMimeOperation), type);
	soap_out_PointerTobool(soap, "ngwt:signed", -1, &(((ngwt__SMimeOperation*)a)->signed_), "");
	soap_out_PointerTobool(soap, "ngwt:encrypted", -1, &(((ngwt__SMimeOperation*)a)->encrypted), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__SMimeOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__SMimeOperation(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__SMimeOperation * SOAP_FMAC4 soap_get_ngwt__SMimeOperation(struct soap *soap, ngwt__SMimeOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__SMimeOperation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__SMimeOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__SMimeOperation(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__SMimeOperation * SOAP_FMAC4 soap_in_ngwt__SMimeOperation(struct soap *soap, const char *tag, ngwt__SMimeOperation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__SMimeOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__SMimeOperation, sizeof(ngwt__SMimeOperation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__SMimeOperation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__SMimeOperation *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_signed_1 = 1, soap_flag_encrypted1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_signed_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:signed", &(((ngwt__SMimeOperation*)a)->signed_), ""))
				{	soap_flag_signed_1 = 0;
					continue;
				}
			if (soap_flag_encrypted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:encrypted", &(((ngwt__SMimeOperation*)a)->encrypted), ""))
				{	soap_flag_encrypted1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__SMimeOperation *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SMimeOperation, 0, sizeof(ngwt__SMimeOperation), 0, soap_copy_ngwt__SMimeOperation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__SMimeOperation * SOAP_FMAC6 soap_new_ngwt__SMimeOperation(struct soap *soap, int n)
{	return soap_instantiate_ngwt__SMimeOperation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__SMimeOperation(struct soap *soap, ngwt__SMimeOperation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__SMimeOperation * SOAP_FMAC6 soap_instantiate_ngwt__SMimeOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__SMimeOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__SMimeOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__SMimeOperation;
		if (size)
			*size = sizeof(ngwt__SMimeOperation);
		((ngwt__SMimeOperation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__SMimeOperation[n];
		if (size)
			*size = n * sizeof(ngwt__SMimeOperation);
		for (int i = 0; i < n; i++)
			((ngwt__SMimeOperation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__SMimeOperation*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__SMimeOperation(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__SMimeOperation %p -> %p\n", q, p));
	*(ngwt__SMimeOperation*)p = *(ngwt__SMimeOperation*)q;
}

void ngwt__SignatureData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__SignatureData*)this)->size, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__SignatureData*)this)->size);
	soap_embedded(soap, &((ngwt__SignatureData*)this)->data, SOAP_TYPE_PointerToxsd__base64Binary);
	soap_serialize_PointerToxsd__base64Binary(soap, &((ngwt__SignatureData*)this)->data);
	/* transient soap skipped */
}

void ngwt__SignatureData::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__SignatureData*)this)->size = NULL;
	((ngwt__SignatureData*)this)->data = NULL;
	/* transient soap skipped */
}

int ngwt__SignatureData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__SignatureData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__SignatureData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__SignatureData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__SignatureData(struct soap *soap, const char *tag, int id, const ngwt__SignatureData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__SignatureData), type);
	soap_out_PointerTounsignedLong(soap, "ngwt:size", -1, &(((ngwt__SignatureData*)a)->size), "");
	soap_out_PointerToxsd__base64Binary(soap, "ngwt:data", -1, &(((ngwt__SignatureData*)a)->data), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__SignatureData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__SignatureData(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__SignatureData * SOAP_FMAC4 soap_get_ngwt__SignatureData(struct soap *soap, ngwt__SignatureData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__SignatureData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__SignatureData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__SignatureData(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__SignatureData * SOAP_FMAC4 soap_in_ngwt__SignatureData(struct soap *soap, const char *tag, ngwt__SignatureData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__SignatureData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__SignatureData, sizeof(ngwt__SignatureData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__SignatureData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__SignatureData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_size1 = 1, soap_flag_data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_size1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:size", &(((ngwt__SignatureData*)a)->size), ""))
				{	soap_flag_size1 = 0;
					continue;
				}
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ngwt:data", &(((ngwt__SignatureData*)a)->data), "xsd:base64Binary"))
				{	soap_flag_data1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__SignatureData *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SignatureData, 0, sizeof(ngwt__SignatureData), 0, soap_copy_ngwt__SignatureData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__SignatureData * SOAP_FMAC6 soap_new_ngwt__SignatureData(struct soap *soap, int n)
{	return soap_instantiate_ngwt__SignatureData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__SignatureData(struct soap *soap, ngwt__SignatureData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__SignatureData * SOAP_FMAC6 soap_instantiate_ngwt__SignatureData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__SignatureData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__SignatureData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__SignatureData;
		if (size)
			*size = sizeof(ngwt__SignatureData);
		((ngwt__SignatureData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__SignatureData[n];
		if (size)
			*size = n * sizeof(ngwt__SignatureData);
		for (int i = 0; i < n; i++)
			((ngwt__SignatureData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__SignatureData*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__SignatureData(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__SignatureData %p -> %p\n", q, p));
	*(ngwt__SignatureData*)p = *(ngwt__SignatureData*)q;
}

void ngwt__Signatures::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Signature(soap, &((ngwt__Signatures*)this)->signature);
	/* transient soap skipped */
}

void ngwt__Signatures::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Signature(soap, &((ngwt__Signatures*)this)->signature);
	/* transient soap skipped */
}

int ngwt__Signatures::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Signatures);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Signatures::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Signatures(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Signatures(struct soap *soap, const char *tag, int id, const ngwt__Signatures *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Signatures), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Signature(soap, "ngwt:signature", -1, &(((ngwt__Signatures*)a)->signature), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Signatures::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Signatures(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Signatures * SOAP_FMAC4 soap_get_ngwt__Signatures(struct soap *soap, ngwt__Signatures *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Signatures(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Signatures::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Signatures(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Signatures * SOAP_FMAC4 soap_in_ngwt__Signatures(struct soap *soap, const char *tag, ngwt__Signatures *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Signatures *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Signatures, sizeof(ngwt__Signatures), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Signatures)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Signatures *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Signature(soap, "ngwt:signature", &(((ngwt__Signatures*)a)->signature), "ngwt:Signature"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Signatures *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Signatures, 0, sizeof(ngwt__Signatures), 0, soap_copy_ngwt__Signatures);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Signatures * SOAP_FMAC6 soap_new_ngwt__Signatures(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Signatures(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Signatures(struct soap *soap, ngwt__Signatures *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Signatures * SOAP_FMAC6 soap_instantiate_ngwt__Signatures(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Signatures(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Signatures, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Signatures;
		if (size)
			*size = sizeof(ngwt__Signatures);
		((ngwt__Signatures*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Signatures[n];
		if (size)
			*size = n * sizeof(ngwt__Signatures);
		for (int i = 0; i < n; i++)
			((ngwt__Signatures*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Signatures*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Signatures(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Signatures %p -> %p\n", q, p));
	*(ngwt__Signatures*)p = *(ngwt__Signatures*)q;
}

void ngwt__Signature::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Signature*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Signature*)this)->id);
	soap_embedded(soap, &((ngwt__Signature*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Signature*)this)->name);
	soap_embedded(soap, &((ngwt__Signature*)this)->default_, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwt__Signature*)this)->part, SOAP_TYPE_PointerTongwt__SignatureData);
	soap_serialize_PointerTongwt__SignatureData(soap, &((ngwt__Signature*)this)->part);
	soap_embedded(soap, &((ngwt__Signature*)this)->global, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void ngwt__Signature::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Signature*)this)->id = NULL;
	((ngwt__Signature*)this)->name = NULL;
	((ngwt__Signature*)this)->default_ = (bool)0;
	((ngwt__Signature*)this)->part = NULL;
	((ngwt__Signature*)this)->global = (bool)0;
	/* transient soap skipped */
}

int ngwt__Signature::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Signature);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Signature::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Signature(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Signature(struct soap *soap, const char *tag, int id, const ngwt__Signature *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Signature), type);
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Signature*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Signature*)a)->name), "");
	soap_out_bool(soap, "ngwt:default", -1, &(((ngwt__Signature*)a)->default_), "");
	soap_out_PointerTongwt__SignatureData(soap, "ngwt:part", -1, &(((ngwt__Signature*)a)->part), "");
	soap_out_bool(soap, "ngwt:global", -1, &(((ngwt__Signature*)a)->global), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Signature::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Signature(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Signature * SOAP_FMAC4 soap_get_ngwt__Signature(struct soap *soap, ngwt__Signature *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Signature(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Signature::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Signature(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Signature * SOAP_FMAC4 soap_in_ngwt__Signature(struct soap *soap, const char *tag, ngwt__Signature *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Signature *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Signature, sizeof(ngwt__Signature), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Signature)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Signature *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_name1 = 1, soap_flag_default_1 = 1, soap_flag_part1 = 1, soap_flag_global1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Signature*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Signature*)a)->name), ""))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_default_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:default", &(((ngwt__Signature*)a)->default_), ""))
				{	soap_flag_default_1 = 0;
					continue;
				}
			if (soap_flag_part1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SignatureData(soap, "ngwt:part", &(((ngwt__Signature*)a)->part), "ngwt:SignatureData"))
				{	soap_flag_part1 = 0;
					continue;
				}
			if (soap_flag_global1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:global", &(((ngwt__Signature*)a)->global), ""))
				{	soap_flag_global1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Signature *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Signature, 0, sizeof(ngwt__Signature), 0, soap_copy_ngwt__Signature);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Signature * SOAP_FMAC6 soap_new_ngwt__Signature(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Signature(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Signature(struct soap *soap, ngwt__Signature *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Signature * SOAP_FMAC6 soap_instantiate_ngwt__Signature(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Signature(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Signature, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Signature;
		if (size)
			*size = sizeof(ngwt__Signature);
		((ngwt__Signature*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Signature[n];
		if (size)
			*size = n * sizeof(ngwt__Signature);
		for (int i = 0; i < n; i++)
			((ngwt__Signature*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Signature*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Signature(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Signature %p -> %p\n", q, p));
	*(ngwt__Signature*)p = *(ngwt__Signature*)q;
}

void ngwt__SharedNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__SharedNotification*)this)->notification, SOAP_TYPE_ngwt__NotificationType);
	soap_embedded(soap, &((ngwt__SharedNotification*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__SharedNotification*)this)->description);
	soap_embedded(soap, &((ngwt__SharedNotification*)this)->rights, SOAP_TYPE_PointerTongwt__Rights);
	soap_serialize_PointerTongwt__Rights(soap, &((ngwt__SharedNotification*)this)->rights);
	soap_embedded(soap, &((ngwt__Mail*)this)->subject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subject);
	soap_embedded(soap, &((ngwt__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ngwt__Mail*)this)->subjectPrefix, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subjectPrefix);
	soap_embedded(soap, &((ngwt__Mail*)this)->distribution, SOAP_TYPE_PointerTongwt__Distribution);
	soap_serialize_PointerTongwt__Distribution(soap, &((ngwt__Mail*)this)->distribution);
	soap_embedded(soap, &((ngwt__Mail*)this)->message, SOAP_TYPE_PointerTongwt__MessageBody);
	soap_serialize_PointerTongwt__MessageBody(soap, &((ngwt__Mail*)this)->message);
	soap_embedded(soap, &((ngwt__Mail*)this)->attachments, SOAP_TYPE_PointerTongwt__AttachmentInfo);
	soap_serialize_PointerTongwt__AttachmentInfo(soap, &((ngwt__Mail*)this)->attachments);
	soap_embedded(soap, &((ngwt__Mail*)this)->options, SOAP_TYPE_PointerTongwt__ItemOptions);
	soap_serialize_PointerTongwt__ItemOptions(soap, &((ngwt__Mail*)this)->options);
	soap_embedded(soap, &((ngwt__Mail*)this)->link, SOAP_TYPE_PointerTongwt__LinkInfo);
	soap_serialize_PointerTongwt__LinkInfo(soap, &((ngwt__Mail*)this)->link);
	soap_embedded(soap, &((ngwt__Mail*)this)->hasAttachment, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwt__Mail*)this)->size, SOAP_TYPE_int);
	soap_embedded(soap, &((ngwt__Mail*)this)->subType, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subType);
	soap_embedded(soap, &((ngwt__Mail*)this)->nntpOrImap, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Mail*)this)->nntpOrImap);
	soap_embedded(soap, &((ngwt__Mail*)this)->smimeType, SOAP_TYPE_PointerTongwt__SMimeOperation);
	soap_serialize_PointerTongwt__SMimeOperation(soap, &((ngwt__Mail*)this)->smimeType);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->status, SOAP_TYPE_PointerTongwt__ItemStatus);
	soap_serialize_PointerTongwt__ItemStatus(soap, &((ngwt__BoxEntry*)this)->status);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->msgId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->msgId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->messageId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->messageId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->source, SOAP_TYPE_PointerTongwt__ItemSource);
	soap_serialize_PointerTongwt__ItemSource(soap, &((ngwt__BoxEntry*)this)->source);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->class_, SOAP_TYPE_PointerTongwt__ItemClass);
	soap_serialize_PointerTongwt__ItemClass(soap, &((ngwt__BoxEntry*)this)->class_);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->security, SOAP_TYPE_PointerTongwt__ItemSecurity);
	soap_serialize_PointerTongwt__ItemSecurity(soap, &((ngwt__BoxEntry*)this)->security);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->comment);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__SharedNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__NotificationType(soap, &((ngwt__SharedNotification*)this)->notification);
	((ngwt__SharedNotification*)this)->description = NULL;
	((ngwt__SharedNotification*)this)->rights = NULL;
	((ngwt__Mail*)this)->subject = NULL;
	((ngwt__Mail*)this)->originalSubject = NULL;
	((ngwt__Mail*)this)->subjectPrefix = NULL;
	((ngwt__Mail*)this)->distribution = NULL;
	((ngwt__Mail*)this)->message = NULL;
	((ngwt__Mail*)this)->attachments = NULL;
	((ngwt__Mail*)this)->options = NULL;
	((ngwt__Mail*)this)->link = NULL;
	((ngwt__Mail*)this)->hasAttachment = (bool)0;
	((ngwt__Mail*)this)->size = 0;
	((ngwt__Mail*)this)->subType = NULL;
	((ngwt__Mail*)this)->nntpOrImap = NULL;
	((ngwt__Mail*)this)->smimeType = NULL;
	((ngwt__BoxEntry*)this)->status = NULL;
	((ngwt__BoxEntry*)this)->thread = NULL;
	((ngwt__BoxEntry*)this)->msgId = NULL;
	((ngwt__BoxEntry*)this)->messageId = NULL;
	((ngwt__BoxEntry*)this)->source = NULL;
	((ngwt__BoxEntry*)this)->returnSentItemsId = NULL;
	soap_default_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	((ngwt__BoxEntry*)this)->class_ = NULL;
	((ngwt__BoxEntry*)this)->security = NULL;
	((ngwt__BoxEntry*)this)->comment = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__SharedNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__SharedNotification);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__SharedNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__SharedNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__SharedNotification(struct soap *soap, const char *tag, int id, const ngwt__SharedNotification *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__SharedNotification), "ngwt:SharedNotification");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__ItemStatus(soap, "ngwt:status", -1, &(((ngwt__BoxEntry*)a)->status), "");
	soap_out_PointerTostd__string(soap, "ngwt:thread", -1, &(((ngwt__BoxEntry*)a)->thread), "");
	soap_out_PointerTostd__string(soap, "ngwt:msgId", -1, &(((ngwt__BoxEntry*)a)->msgId), "");
	soap_out_PointerTostd__string(soap, "ngwt:messageId", -1, &(((ngwt__BoxEntry*)a)->messageId), "");
	soap_out_PointerTongwt__ItemSource(soap, "ngwt:source", -1, &(((ngwt__BoxEntry*)a)->source), "");
	soap_out_PointerTobool(soap, "ngwt:returnSentItemsId", -1, &(((ngwt__BoxEntry*)a)->returnSentItemsId), "");
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__BoxEntry*)a)->delivered), "");
	soap_out_PointerTongwt__ItemClass(soap, "ngwt:class", -1, &(((ngwt__BoxEntry*)a)->class_), "");
	soap_out_PointerTongwt__ItemSecurity(soap, "ngwt:security", -1, &(((ngwt__BoxEntry*)a)->security), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__BoxEntry*)a)->comment), "");
	soap_out_PointerTostd__string(soap, "ngwt:subject", -1, &(((ngwt__Mail*)a)->subject), "");
	soap_out_PointerTostd__string(soap, "ngwt:originalSubject", -1, &(((ngwt__Mail*)a)->originalSubject), "");
	soap_out_PointerTostd__string(soap, "ngwt:subjectPrefix", -1, &(((ngwt__Mail*)a)->subjectPrefix), "");
	soap_out_PointerTongwt__Distribution(soap, "ngwt:distribution", -1, &(((ngwt__Mail*)a)->distribution), "");
	soap_out_PointerTongwt__MessageBody(soap, "ngwt:message", -1, &(((ngwt__Mail*)a)->message), "");
	soap_out_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", -1, &(((ngwt__Mail*)a)->attachments), "");
	soap_out_PointerTongwt__ItemOptions(soap, "ngwt:options", -1, &(((ngwt__Mail*)a)->options), "");
	soap_out_PointerTongwt__LinkInfo(soap, "ngwt:link", -1, &(((ngwt__Mail*)a)->link), "");
	soap_out_bool(soap, "ngwt:hasAttachment", -1, &(((ngwt__Mail*)a)->hasAttachment), "");
	soap_out_int(soap, "ngwt:size", -1, &(((ngwt__Mail*)a)->size), "");
	soap_out_PointerTostd__string(soap, "ngwt:subType", -1, &(((ngwt__Mail*)a)->subType), "");
	soap_out_PointerTobool(soap, "ngwt:nntpOrImap", -1, &(((ngwt__Mail*)a)->nntpOrImap), "");
	soap_out_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", -1, &(((ngwt__Mail*)a)->smimeType), "");
	soap_out_ngwt__NotificationType(soap, "ngwt:notification", -1, &(((ngwt__SharedNotification*)a)->notification), "");
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__SharedNotification*)a)->description), "");
	soap_out_PointerTongwt__Rights(soap, "ngwt:rights", -1, &(((ngwt__SharedNotification*)a)->rights), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__SharedNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__SharedNotification(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__SharedNotification * SOAP_FMAC4 soap_get_ngwt__SharedNotification(struct soap *soap, ngwt__SharedNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__SharedNotification(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__SharedNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__SharedNotification(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__SharedNotification * SOAP_FMAC4 soap_in_ngwt__SharedNotification(struct soap *soap, const char *tag, ngwt__SharedNotification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__SharedNotification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__SharedNotification, sizeof(ngwt__SharedNotification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__SharedNotification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__SharedNotification *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id5 = 1, soap_flag_name5 = 1, soap_flag_version5 = 1, soap_flag_modified5 = 1, soap_flag_changes5 = 1, soap_flag_categories4 = 1, soap_flag_created4 = 1, soap_flag_customs4 = 1, soap_flag_status3 = 1, soap_flag_thread3 = 1, soap_flag_msgId3 = 1, soap_flag_messageId3 = 1, soap_flag_source3 = 1, soap_flag_returnSentItemsId3 = 1, soap_flag_delivered3 = 1, soap_flag_class_3 = 1, soap_flag_security3 = 1, soap_flag_comment3 = 1, soap_flag_subject2 = 1, soap_flag_originalSubject2 = 1, soap_flag_subjectPrefix2 = 1, soap_flag_distribution2 = 1, soap_flag_message2 = 1, soap_flag_attachments2 = 1, soap_flag_options2 = 1, soap_flag_link2 = 1, soap_flag_hasAttachment2 = 1, soap_flag_size2 = 1, soap_flag_subType2 = 1, soap_flag_nntpOrImap2 = 1, soap_flag_smimeType2 = 1, soap_flag_notification1 = 1, soap_flag_description1 = 1, soap_flag_rights1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id5 = 0;
					continue;
				}
			if (soap_flag_name5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name5 = 0;
					continue;
				}
			if (soap_flag_version5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version5 = 0;
					continue;
				}
			if (soap_flag_modified5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified5 = 0;
					continue;
				}
			if (soap_flag_changes5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes5 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories4 = 0;
					continue;
				}
			if (soap_flag_created4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created4 = 0;
					continue;
				}
			if (soap_flag_customs4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs4 = 0;
					continue;
				}
			if (soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemStatus(soap, "ngwt:status", &(((ngwt__BoxEntry*)a)->status), "ngwt:ItemStatus"))
				{	soap_flag_status3 = 0;
					continue;
				}
			if (soap_flag_thread3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:thread", &(((ngwt__BoxEntry*)a)->thread), ""))
				{	soap_flag_thread3 = 0;
					continue;
				}
			if (soap_flag_msgId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:msgId", &(((ngwt__BoxEntry*)a)->msgId), ""))
				{	soap_flag_msgId3 = 0;
					continue;
				}
			if (soap_flag_messageId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:messageId", &(((ngwt__BoxEntry*)a)->messageId), ""))
				{	soap_flag_messageId3 = 0;
					continue;
				}
			if (soap_flag_source3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSource(soap, "ngwt:source", &(((ngwt__BoxEntry*)a)->source), ""))
				{	soap_flag_source3 = 0;
					continue;
				}
			if (soap_flag_returnSentItemsId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:returnSentItemsId", &(((ngwt__BoxEntry*)a)->returnSentItemsId), ""))
				{	soap_flag_returnSentItemsId3 = 0;
					continue;
				}
			if (soap_flag_delivered3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered3 = 0;
					continue;
				}
			if (soap_flag_class_3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemClass(soap, "ngwt:class", &(((ngwt__BoxEntry*)a)->class_), ""))
				{	soap_flag_class_3 = 0;
					continue;
				}
			if (soap_flag_security3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSecurity(soap, "ngwt:security", &(((ngwt__BoxEntry*)a)->security), ""))
				{	soap_flag_security3 = 0;
					continue;
				}
			if (soap_flag_comment3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__BoxEntry*)a)->comment), ""))
				{	soap_flag_comment3 = 0;
					continue;
				}
			if (soap_flag_subject2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subject", &(((ngwt__Mail*)a)->subject), ""))
				{	soap_flag_subject2 = 0;
					continue;
				}
			if (soap_flag_originalSubject2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:originalSubject", &(((ngwt__Mail*)a)->originalSubject), ""))
				{	soap_flag_originalSubject2 = 0;
					continue;
				}
			if (soap_flag_subjectPrefix2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subjectPrefix", &(((ngwt__Mail*)a)->subjectPrefix), ""))
				{	soap_flag_subjectPrefix2 = 0;
					continue;
				}
			if (soap_flag_distribution2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Distribution(soap, "ngwt:distribution", &(((ngwt__Mail*)a)->distribution), "ngwt:Distribution"))
				{	soap_flag_distribution2 = 0;
					continue;
				}
			if (soap_flag_message2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessageBody(soap, "ngwt:message", &(((ngwt__Mail*)a)->message), "ngwt:MessageBody"))
				{	soap_flag_message2 = 0;
					continue;
				}
			if (soap_flag_attachments2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", &(((ngwt__Mail*)a)->attachments), "ngwt:AttachmentInfo"))
				{	soap_flag_attachments2 = 0;
					continue;
				}
			if (soap_flag_options2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemOptions(soap, "ngwt:options", &(((ngwt__Mail*)a)->options), "ngwt:ItemOptions"))
				{	soap_flag_options2 = 0;
					continue;
				}
			if (soap_flag_link2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__LinkInfo(soap, "ngwt:link", &(((ngwt__Mail*)a)->link), "ngwt:LinkInfo"))
				{	soap_flag_link2 = 0;
					continue;
				}
			if (soap_flag_hasAttachment2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:hasAttachment", &(((ngwt__Mail*)a)->hasAttachment), ""))
				{	soap_flag_hasAttachment2 = 0;
					continue;
				}
			if (soap_flag_size2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:size", &(((ngwt__Mail*)a)->size), ""))
				{	soap_flag_size2 = 0;
					continue;
				}
			if (soap_flag_subType2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subType", &(((ngwt__Mail*)a)->subType), ""))
				{	soap_flag_subType2 = 0;
					continue;
				}
			if (soap_flag_nntpOrImap2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:nntpOrImap", &(((ngwt__Mail*)a)->nntpOrImap), ""))
				{	soap_flag_nntpOrImap2 = 0;
					continue;
				}
			if (soap_flag_smimeType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", &(((ngwt__Mail*)a)->smimeType), "ngwt:SMimeOperation"))
				{	soap_flag_smimeType2 = 0;
					continue;
				}
			if (soap_flag_notification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__NotificationType(soap, "ngwt:notification", &(((ngwt__SharedNotification*)a)->notification), ""))
				{	soap_flag_notification1 = 0;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__SharedNotification*)a)->description), ""))
				{	soap_flag_description1 = 0;
					continue;
				}
			if (soap_flag_rights1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Rights(soap, "ngwt:rights", &(((ngwt__SharedNotification*)a)->rights), "ngwt:Rights"))
				{	soap_flag_rights1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_delivered3 || soap_flag_notification1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__SharedNotification *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SharedNotification, 0, sizeof(ngwt__SharedNotification), 0, soap_copy_ngwt__SharedNotification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__SharedNotification * SOAP_FMAC6 soap_new_ngwt__SharedNotification(struct soap *soap, int n)
{	return soap_instantiate_ngwt__SharedNotification(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__SharedNotification(struct soap *soap, ngwt__SharedNotification *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__SharedNotification * SOAP_FMAC6 soap_instantiate_ngwt__SharedNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__SharedNotification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__SharedNotification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__SharedNotification;
		if (size)
			*size = sizeof(ngwt__SharedNotification);
		((ngwt__SharedNotification*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__SharedNotification[n];
		if (size)
			*size = n * sizeof(ngwt__SharedNotification);
		for (int i = 0; i < n; i++)
			((ngwt__SharedNotification*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__SharedNotification*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__SharedNotification(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__SharedNotification %p -> %p\n", q, p));
	*(ngwt__SharedNotification*)p = *(ngwt__SharedNotification*)q;
}

void ngwt__SharedFolderNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__SharedFolderNotification*)this)->subject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__SharedFolderNotification*)this)->subject);
	soap_embedded(soap, &((ngwt__SharedFolderNotification*)this)->message, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__SharedFolderNotification*)this)->message);
	soap_embedded(soap, &((ngwt__SharedFolderNotification*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__SharedFolderNotification*)this)->description);
	/* transient soap skipped */
}

void ngwt__SharedFolderNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__SharedFolderNotification*)this)->subject = NULL;
	((ngwt__SharedFolderNotification*)this)->message = NULL;
	((ngwt__SharedFolderNotification*)this)->description = NULL;
	/* transient soap skipped */
}

int ngwt__SharedFolderNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__SharedFolderNotification);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__SharedFolderNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__SharedFolderNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__SharedFolderNotification(struct soap *soap, const char *tag, int id, const ngwt__SharedFolderNotification *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__SharedFolderNotification), type);
	soap_out_PointerTostd__string(soap, "ngwt:subject", -1, &(((ngwt__SharedFolderNotification*)a)->subject), "");
	soap_out_PointerTostd__string(soap, "ngwt:message", -1, &(((ngwt__SharedFolderNotification*)a)->message), "");
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__SharedFolderNotification*)a)->description), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__SharedFolderNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__SharedFolderNotification(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__SharedFolderNotification * SOAP_FMAC4 soap_get_ngwt__SharedFolderNotification(struct soap *soap, ngwt__SharedFolderNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__SharedFolderNotification(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__SharedFolderNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__SharedFolderNotification(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__SharedFolderNotification * SOAP_FMAC4 soap_in_ngwt__SharedFolderNotification(struct soap *soap, const char *tag, ngwt__SharedFolderNotification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__SharedFolderNotification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__SharedFolderNotification, sizeof(ngwt__SharedFolderNotification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__SharedFolderNotification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__SharedFolderNotification *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_subject1 = 1, soap_flag_message1 = 1, soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subject", &(((ngwt__SharedFolderNotification*)a)->subject), ""))
				{	soap_flag_subject1 = 0;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:message", &(((ngwt__SharedFolderNotification*)a)->message), ""))
				{	soap_flag_message1 = 0;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__SharedFolderNotification*)a)->description), ""))
				{	soap_flag_description1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__SharedFolderNotification *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SharedFolderNotification, 0, sizeof(ngwt__SharedFolderNotification), 0, soap_copy_ngwt__SharedFolderNotification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__SharedFolderNotification * SOAP_FMAC6 soap_new_ngwt__SharedFolderNotification(struct soap *soap, int n)
{	return soap_instantiate_ngwt__SharedFolderNotification(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__SharedFolderNotification(struct soap *soap, ngwt__SharedFolderNotification *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__SharedFolderNotification * SOAP_FMAC6 soap_instantiate_ngwt__SharedFolderNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__SharedFolderNotification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__SharedFolderNotification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__SharedFolderNotification;
		if (size)
			*size = sizeof(ngwt__SharedFolderNotification);
		((ngwt__SharedFolderNotification*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__SharedFolderNotification[n];
		if (size)
			*size = n * sizeof(ngwt__SharedFolderNotification);
		for (int i = 0; i < n; i++)
			((ngwt__SharedFolderNotification*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__SharedFolderNotification*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__SharedFolderNotification(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__SharedFolderNotification %p -> %p\n", q, p));
	*(ngwt__SharedFolderNotification*)p = *(ngwt__SharedFolderNotification*)q;
}

void ngwt__SharedFolder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__SharedFolder*)this)->rights, SOAP_TYPE_PointerTongwt__Rights);
	soap_serialize_PointerTongwt__Rights(soap, &((ngwt__SharedFolder*)this)->rights);
	soap_embedded(soap, &((ngwt__SharedFolder*)this)->acl, SOAP_TYPE_PointerTongwt__FolderACL);
	soap_serialize_PointerTongwt__FolderACL(soap, &((ngwt__SharedFolder*)this)->acl);
	soap_embedded(soap, &((ngwt__SharedFolder*)this)->owner, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__SharedFolder*)this)->owner);
	soap_embedded(soap, &((ngwt__SharedFolder*)this)->isSharedByMe, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__SharedFolder*)this)->isSharedByMe);
	soap_embedded(soap, &((ngwt__SharedFolder*)this)->isSharedToMe, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__SharedFolder*)this)->isSharedToMe);
	soap_embedded(soap, &((ngwt__Folder*)this)->parent, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((ngwt__Folder*)this)->parent);
	soap_embedded(soap, &((ngwt__Folder*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Folder*)this)->description);
	soap_embedded(soap, &((ngwt__Folder*)this)->count, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__Folder*)this)->count);
	soap_embedded(soap, &((ngwt__Folder*)this)->hasUnread, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Folder*)this)->hasUnread);
	soap_embedded(soap, &((ngwt__Folder*)this)->unreadCount, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__Folder*)this)->unreadCount);
	soap_embedded(soap, &((ngwt__Folder*)this)->sequence, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Folder*)this)->sequence);
	soap_embedded(soap, &((ngwt__Folder*)this)->settings, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Folder*)this)->settings);
	soap_embedded(soap, &((ngwt__Folder*)this)->calendarAttribute, SOAP_TYPE_PointerTongwt__CalendarFolderAttribute);
	soap_serialize_PointerTongwt__CalendarFolderAttribute(soap, &((ngwt__Folder*)this)->calendarAttribute);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__SharedFolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__SharedFolder*)this)->rights = NULL;
	((ngwt__SharedFolder*)this)->acl = NULL;
	((ngwt__SharedFolder*)this)->owner = NULL;
	((ngwt__SharedFolder*)this)->isSharedByMe = NULL;
	((ngwt__SharedFolder*)this)->isSharedToMe = NULL;
	soap_default_ngwt__uid(soap, &((ngwt__Folder*)this)->parent);
	((ngwt__Folder*)this)->description = NULL;
	((ngwt__Folder*)this)->count = NULL;
	((ngwt__Folder*)this)->hasUnread = NULL;
	((ngwt__Folder*)this)->unreadCount = NULL;
	((ngwt__Folder*)this)->sequence = NULL;
	((ngwt__Folder*)this)->settings = NULL;
	((ngwt__Folder*)this)->calendarAttribute = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__SharedFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__SharedFolder);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__SharedFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__SharedFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__SharedFolder(struct soap *soap, const char *tag, int id, const ngwt__SharedFolder *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__SharedFolder), "ngwt:SharedFolder");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_ngwt__uid(soap, "ngwt:parent", -1, &(((ngwt__Folder*)a)->parent), "");
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__Folder*)a)->description), "");
	soap_out_PointerToint(soap, "ngwt:count", -1, &(((ngwt__Folder*)a)->count), "");
	soap_out_PointerTobool(soap, "ngwt:hasUnread", -1, &(((ngwt__Folder*)a)->hasUnread), "");
	soap_out_PointerToint(soap, "ngwt:unreadCount", -1, &(((ngwt__Folder*)a)->unreadCount), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:sequence", -1, &(((ngwt__Folder*)a)->sequence), "");
	soap_out_PointerTongwt__uid(soap, "ngwt:settings", -1, &(((ngwt__Folder*)a)->settings), "");
	soap_out_PointerTongwt__CalendarFolderAttribute(soap, "ngwt:calendarAttribute", -1, &(((ngwt__Folder*)a)->calendarAttribute), "");
	soap_out_PointerTongwt__Rights(soap, "ngwt:rights", -1, &(((ngwt__SharedFolder*)a)->rights), "");
	soap_out_PointerTongwt__FolderACL(soap, "ngwt:acl", -1, &(((ngwt__SharedFolder*)a)->acl), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:owner", -1, &(((ngwt__SharedFolder*)a)->owner), "");
	soap_out_PointerTobool(soap, "ngwt:isSharedByMe", -1, &(((ngwt__SharedFolder*)a)->isSharedByMe), "");
	soap_out_PointerTobool(soap, "ngwt:isSharedToMe", -1, &(((ngwt__SharedFolder*)a)->isSharedToMe), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__SharedFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__SharedFolder(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__SharedFolder * SOAP_FMAC4 soap_get_ngwt__SharedFolder(struct soap *soap, ngwt__SharedFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__SharedFolder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__SharedFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__SharedFolder(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__SharedFolder * SOAP_FMAC4 soap_in_ngwt__SharedFolder(struct soap *soap, const char *tag, ngwt__SharedFolder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__SharedFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__SharedFolder, sizeof(ngwt__SharedFolder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__SharedFolder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__SharedFolder *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_parent2 = 1, soap_flag_description2 = 1, soap_flag_count2 = 1, soap_flag_hasUnread2 = 1, soap_flag_unreadCount2 = 1, soap_flag_sequence2 = 1, soap_flag_settings2 = 1, soap_flag_calendarAttribute2 = 1, soap_flag_rights1 = 1, soap_flag_acl1 = 1, soap_flag_owner1 = 1, soap_flag_isSharedByMe1 = 1, soap_flag_isSharedToMe1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}
			if (soap_flag_name3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name3 = 0;
					continue;
				}
			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}
			if (soap_flag_modified3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}
			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_parent2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwt:parent", &(((ngwt__Folder*)a)->parent), "ngwt:uid"))
				{	soap_flag_parent2 = 0;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__Folder*)a)->description), ""))
				{	soap_flag_description2 = 0;
					continue;
				}
			if (soap_flag_count2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:count", &(((ngwt__Folder*)a)->count), ""))
				{	soap_flag_count2 = 0;
					continue;
				}
			if (soap_flag_hasUnread2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:hasUnread", &(((ngwt__Folder*)a)->hasUnread), ""))
				{	soap_flag_hasUnread2 = 0;
					continue;
				}
			if (soap_flag_unreadCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:unreadCount", &(((ngwt__Folder*)a)->unreadCount), ""))
				{	soap_flag_unreadCount2 = 0;
					continue;
				}
			if (soap_flag_sequence2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:sequence", &(((ngwt__Folder*)a)->sequence), ""))
				{	soap_flag_sequence2 = 0;
					continue;
				}
			if (soap_flag_settings2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:settings", &(((ngwt__Folder*)a)->settings), "ngwt:uid"))
				{	soap_flag_settings2 = 0;
					continue;
				}
			if (soap_flag_calendarAttribute2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CalendarFolderAttribute(soap, "ngwt:calendarAttribute", &(((ngwt__Folder*)a)->calendarAttribute), "ngwt:CalendarFolderAttribute"))
				{	soap_flag_calendarAttribute2 = 0;
					continue;
				}
			if (soap_flag_rights1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Rights(soap, "ngwt:rights", &(((ngwt__SharedFolder*)a)->rights), "ngwt:Rights"))
				{	soap_flag_rights1 = 0;
					continue;
				}
			if (soap_flag_acl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FolderACL(soap, "ngwt:acl", &(((ngwt__SharedFolder*)a)->acl), "ngwt:FolderACL"))
				{	soap_flag_acl1 = 0;
					continue;
				}
			if (soap_flag_owner1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:owner", &(((ngwt__SharedFolder*)a)->owner), "ngwt:UUID"))
				{	soap_flag_owner1 = 0;
					continue;
				}
			if (soap_flag_isSharedByMe1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:isSharedByMe", &(((ngwt__SharedFolder*)a)->isSharedByMe), ""))
				{	soap_flag_isSharedByMe1 = 0;
					continue;
				}
			if (soap_flag_isSharedToMe1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:isSharedToMe", &(((ngwt__SharedFolder*)a)->isSharedToMe), ""))
				{	soap_flag_isSharedToMe1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__SharedFolder *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SharedFolder, 0, sizeof(ngwt__SharedFolder), 0, soap_copy_ngwt__SharedFolder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__SharedFolder * SOAP_FMAC6 soap_new_ngwt__SharedFolder(struct soap *soap, int n)
{	return soap_instantiate_ngwt__SharedFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__SharedFolder(struct soap *soap, ngwt__SharedFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__SharedFolder * SOAP_FMAC6 soap_instantiate_ngwt__SharedFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__SharedFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__SharedFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__SharedFolder;
		if (size)
			*size = sizeof(ngwt__SharedFolder);
		((ngwt__SharedFolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__SharedFolder[n];
		if (size)
			*size = n * sizeof(ngwt__SharedFolder);
		for (int i = 0; i < n; i++)
			((ngwt__SharedFolder*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__SharedFolder*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__SharedFolder(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__SharedFolder %p -> %p\n", q, p));
	*(ngwt__SharedFolder*)p = *(ngwt__SharedFolder*)q;
}

void ngwt__SettingsList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Custom(soap, &((ngwt__SettingsList*)this)->setting);
	/* transient soap skipped */
}

void ngwt__SettingsList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Custom(soap, &((ngwt__SettingsList*)this)->setting);
	/* transient soap skipped */
}

int ngwt__SettingsList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__SettingsList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__SettingsList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__SettingsList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__SettingsList(struct soap *soap, const char *tag, int id, const ngwt__SettingsList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__SettingsList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Custom(soap, "ngwt:setting", -1, &(((ngwt__SettingsList*)a)->setting), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__SettingsList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__SettingsList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__SettingsList * SOAP_FMAC4 soap_get_ngwt__SettingsList(struct soap *soap, ngwt__SettingsList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__SettingsList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__SettingsList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__SettingsList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__SettingsList * SOAP_FMAC4 soap_in_ngwt__SettingsList(struct soap *soap, const char *tag, ngwt__SettingsList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__SettingsList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__SettingsList, sizeof(ngwt__SettingsList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__SettingsList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__SettingsList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Custom(soap, "ngwt:setting", &(((ngwt__SettingsList*)a)->setting), "ngwt:Custom"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__SettingsList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SettingsList, 0, sizeof(ngwt__SettingsList), 0, soap_copy_ngwt__SettingsList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__SettingsList * SOAP_FMAC6 soap_new_ngwt__SettingsList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__SettingsList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__SettingsList(struct soap *soap, ngwt__SettingsList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__SettingsList * SOAP_FMAC6 soap_instantiate_ngwt__SettingsList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__SettingsList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__SettingsList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__SettingsList;
		if (size)
			*size = sizeof(ngwt__SettingsList);
		((ngwt__SettingsList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__SettingsList[n];
		if (size)
			*size = n * sizeof(ngwt__SettingsList);
		for (int i = 0; i < n; i++)
			((ngwt__SettingsList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__SettingsList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__SettingsList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__SettingsList %p -> %p\n", q, p));
	*(ngwt__SettingsList*)p = *(ngwt__SettingsList*)q;
}

void ngwt__SettingsGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Custom(soap, &((ngwt__SettingsGroup*)this)->setting);
	/* transient soap skipped */
}

void ngwt__SettingsGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Custom(soap, &((ngwt__SettingsGroup*)this)->setting);
	((ngwt__SettingsGroup*)this)->type = NULL;
	/* transient soap skipped */
}

int ngwt__SettingsGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__SettingsGroup);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__SettingsGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__SettingsGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__SettingsGroup(struct soap *soap, const char *tag, int id, const ngwt__SettingsGroup *a, const char *type)
{
	if (((ngwt__SettingsGroup *)a)->type)
		soap_set_attr(soap, "type", ((ngwt__SettingsGroup *)a)->type->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__SettingsGroup), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Custom(soap, "ngwt:setting", -1, &(((ngwt__SettingsGroup*)a)->setting), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__SettingsGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__SettingsGroup(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__SettingsGroup * SOAP_FMAC4 soap_get_ngwt__SettingsGroup(struct soap *soap, ngwt__SettingsGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__SettingsGroup(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__SettingsGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__SettingsGroup(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__SettingsGroup * SOAP_FMAC4 soap_in_ngwt__SettingsGroup(struct soap *soap, const char *tag, ngwt__SettingsGroup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__SettingsGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__SettingsGroup, sizeof(ngwt__SettingsGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__SettingsGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__SettingsGroup *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "type", 0);
		if (t)
		{	if (!(((ngwt__SettingsGroup *)a)->type = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__SettingsGroup *)a)->type = soap_new_std__string(soap, -1);
			((ngwt__SettingsGroup *)a)->type->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Custom(soap, "ngwt:setting", &(((ngwt__SettingsGroup*)a)->setting), "ngwt:Custom"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__SettingsGroup *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SettingsGroup, 0, sizeof(ngwt__SettingsGroup), 0, soap_copy_ngwt__SettingsGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__SettingsGroup * SOAP_FMAC6 soap_new_ngwt__SettingsGroup(struct soap *soap, int n)
{	return soap_instantiate_ngwt__SettingsGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__SettingsGroup(struct soap *soap, ngwt__SettingsGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__SettingsGroup * SOAP_FMAC6 soap_instantiate_ngwt__SettingsGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__SettingsGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__SettingsGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__SettingsGroup;
		if (size)
			*size = sizeof(ngwt__SettingsGroup);
		((ngwt__SettingsGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__SettingsGroup[n];
		if (size)
			*size = n * sizeof(ngwt__SettingsGroup);
		for (int i = 0; i < n; i++)
			((ngwt__SettingsGroup*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__SettingsGroup*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__SettingsGroup(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__SettingsGroup %p -> %p\n", q, p));
	*(ngwt__SettingsGroup*)p = *(ngwt__SettingsGroup*)q;
}

void ngwt__Settings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__SettingsGroup(soap, &((ngwt__Settings*)this)->group);
	soap_serialize_std__vectorTemplateOfPointerTongwt__Custom(soap, &((ngwt__Settings*)this)->setting);
	/* transient soap skipped */
}

void ngwt__Settings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__SettingsGroup(soap, &((ngwt__Settings*)this)->group);
	soap_default_std__vectorTemplateOfPointerTongwt__Custom(soap, &((ngwt__Settings*)this)->setting);
	/* transient soap skipped */
}

int ngwt__Settings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Settings);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Settings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Settings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Settings(struct soap *soap, const char *tag, int id, const ngwt__Settings *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Settings), type);
	soap_out_std__vectorTemplateOfPointerTongwt__SettingsGroup(soap, "ngwt:group", -1, &(((ngwt__Settings*)a)->group), "");
	soap_out_std__vectorTemplateOfPointerTongwt__Custom(soap, "ngwt:setting", -1, &(((ngwt__Settings*)a)->setting), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Settings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Settings(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Settings * SOAP_FMAC4 soap_get_ngwt__Settings(struct soap *soap, ngwt__Settings *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Settings(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Settings::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Settings(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Settings * SOAP_FMAC4 soap_in_ngwt__Settings(struct soap *soap, const char *tag, ngwt__Settings *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Settings *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Settings, sizeof(ngwt__Settings), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Settings)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Settings *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__SettingsGroup(soap, "ngwt:group", &(((ngwt__Settings*)a)->group), "ngwt:SettingsGroup"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Custom(soap, "ngwt:setting", &(((ngwt__Settings*)a)->setting), "ngwt:Custom"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Settings *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Settings, 0, sizeof(ngwt__Settings), 0, soap_copy_ngwt__Settings);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Settings * SOAP_FMAC6 soap_new_ngwt__Settings(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Settings(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Settings(struct soap *soap, ngwt__Settings *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Settings * SOAP_FMAC6 soap_instantiate_ngwt__Settings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Settings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Settings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Settings;
		if (size)
			*size = sizeof(ngwt__Settings);
		((ngwt__Settings*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Settings[n];
		if (size)
			*size = n * sizeof(ngwt__Settings);
		for (int i = 0; i < n; i++)
			((ngwt__Settings*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Settings*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Settings(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Settings %p -> %p\n", q, p));
	*(ngwt__Settings*)p = *(ngwt__Settings*)q;
}

void ngwt__SendOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__SendOptions*)this)->requestReply, SOAP_TYPE_PointerTongwt__SendOptionsRequestReply);
	soap_serialize_PointerTongwt__SendOptionsRequestReply(soap, &((ngwt__SendOptions*)this)->requestReply);
	soap_embedded(soap, &((ngwt__SendOptions*)this)->mimeEncoding, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__SendOptions*)this)->mimeEncoding);
	soap_embedded(soap, &((ngwt__SendOptions*)this)->statusTracking, SOAP_TYPE_PointerTongwt__StatusTracking);
	soap_serialize_PointerTongwt__StatusTracking(soap, &((ngwt__SendOptions*)this)->statusTracking);
	soap_embedded(soap, &((ngwt__SendOptions*)this)->notification, SOAP_TYPE_PointerTongwt__ReturnNotification);
	soap_serialize_PointerTongwt__ReturnNotification(soap, &((ngwt__SendOptions*)this)->notification);
	soap_embedded(soap, &((ngwt__SendOptions*)this)->updateFrequentContacts, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void ngwt__SendOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__SendOptions*)this)->requestReply = NULL;
	((ngwt__SendOptions*)this)->mimeEncoding = NULL;
	((ngwt__SendOptions*)this)->statusTracking = NULL;
	((ngwt__SendOptions*)this)->notification = NULL;
	((ngwt__SendOptions*)this)->updateFrequentContacts = (bool)1;
	/* transient soap skipped */
}

int ngwt__SendOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__SendOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__SendOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__SendOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__SendOptions(struct soap *soap, const char *tag, int id, const ngwt__SendOptions *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__SendOptions), type);
	soap_out_PointerTongwt__SendOptionsRequestReply(soap, "ngwt:requestReply", -1, &(((ngwt__SendOptions*)a)->requestReply), "");
	soap_out_PointerTostd__string(soap, "ngwt:mimeEncoding", -1, &(((ngwt__SendOptions*)a)->mimeEncoding), "");
	soap_out_PointerTongwt__StatusTracking(soap, "ngwt:statusTracking", -1, &(((ngwt__SendOptions*)a)->statusTracking), "");
	soap_out_PointerTongwt__ReturnNotification(soap, "ngwt:notification", -1, &(((ngwt__SendOptions*)a)->notification), "");
	soap_out_bool(soap, "ngwt:updateFrequentContacts", -1, &(((ngwt__SendOptions*)a)->updateFrequentContacts), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__SendOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__SendOptions(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__SendOptions * SOAP_FMAC4 soap_get_ngwt__SendOptions(struct soap *soap, ngwt__SendOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__SendOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__SendOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__SendOptions(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__SendOptions * SOAP_FMAC4 soap_in_ngwt__SendOptions(struct soap *soap, const char *tag, ngwt__SendOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__SendOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__SendOptions, sizeof(ngwt__SendOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__SendOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__SendOptions *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_requestReply1 = 1, soap_flag_mimeEncoding1 = 1, soap_flag_statusTracking1 = 1, soap_flag_notification1 = 1, soap_flag_updateFrequentContacts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SendOptionsRequestReply(soap, "ngwt:requestReply", &(((ngwt__SendOptions*)a)->requestReply), "ngwt:SendOptionsRequestReply"))
				{	soap_flag_requestReply1 = 0;
					continue;
				}
			if (soap_flag_mimeEncoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:mimeEncoding", &(((ngwt__SendOptions*)a)->mimeEncoding), ""))
				{	soap_flag_mimeEncoding1 = 0;
					continue;
				}
			if (soap_flag_statusTracking1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__StatusTracking(soap, "ngwt:statusTracking", &(((ngwt__SendOptions*)a)->statusTracking), "ngwt:StatusTracking"))
				{	soap_flag_statusTracking1 = 0;
					continue;
				}
			if (soap_flag_notification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ReturnNotification(soap, "ngwt:notification", &(((ngwt__SendOptions*)a)->notification), "ngwt:ReturnNotification"))
				{	soap_flag_notification1 = 0;
					continue;
				}
			if (soap_flag_updateFrequentContacts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:updateFrequentContacts", &(((ngwt__SendOptions*)a)->updateFrequentContacts), ""))
				{	soap_flag_updateFrequentContacts1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__SendOptions *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SendOptions, 0, sizeof(ngwt__SendOptions), 0, soap_copy_ngwt__SendOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__SendOptions * SOAP_FMAC6 soap_new_ngwt__SendOptions(struct soap *soap, int n)
{	return soap_instantiate_ngwt__SendOptions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__SendOptions(struct soap *soap, ngwt__SendOptions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__SendOptions * SOAP_FMAC6 soap_instantiate_ngwt__SendOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__SendOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__SendOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__SendOptions;
		if (size)
			*size = sizeof(ngwt__SendOptions);
		((ngwt__SendOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__SendOptions[n];
		if (size)
			*size = n * sizeof(ngwt__SendOptions);
		for (int i = 0; i < n; i++)
			((ngwt__SendOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__SendOptions*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__SendOptions(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__SendOptions %p -> %p\n", q, p));
	*(ngwt__SendOptions*)p = *(ngwt__SendOptions*)q;
}

void ngwt__SendOptionsRequestReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__SendOptionsRequestReply*)this)->whenConvenient, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__SendOptionsRequestReply*)this)->whenConvenient);
	soap_embedded(soap, &((ngwt__SendOptionsRequestReply*)this)->byDate, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__SendOptionsRequestReply*)this)->byDate);
	/* transient soap skipped */
}

void ngwt__SendOptionsRequestReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__SendOptionsRequestReply*)this)->whenConvenient = NULL;
	soap_default_string(soap, &((ngwt__SendOptionsRequestReply*)this)->byDate);
	/* transient soap skipped */
}

int ngwt__SendOptionsRequestReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__SendOptionsRequestReply);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__SendOptionsRequestReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__SendOptionsRequestReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__SendOptionsRequestReply(struct soap *soap, const char *tag, int id, const ngwt__SendOptionsRequestReply *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__SendOptionsRequestReply), type);
	soap_out_PointerTobool(soap, "ngwt:whenConvenient", -1, &(((ngwt__SendOptionsRequestReply*)a)->whenConvenient), "");
	soap_out_string(soap, "ngwt:byDate", -1, &(((ngwt__SendOptionsRequestReply*)a)->byDate), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__SendOptionsRequestReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__SendOptionsRequestReply(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__SendOptionsRequestReply * SOAP_FMAC4 soap_get_ngwt__SendOptionsRequestReply(struct soap *soap, ngwt__SendOptionsRequestReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__SendOptionsRequestReply(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__SendOptionsRequestReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__SendOptionsRequestReply(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__SendOptionsRequestReply * SOAP_FMAC4 soap_in_ngwt__SendOptionsRequestReply(struct soap *soap, const char *tag, ngwt__SendOptionsRequestReply *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__SendOptionsRequestReply *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__SendOptionsRequestReply, sizeof(ngwt__SendOptionsRequestReply), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__SendOptionsRequestReply)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__SendOptionsRequestReply *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_whenConvenient1 = 1, soap_flag_byDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_whenConvenient1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:whenConvenient", &(((ngwt__SendOptionsRequestReply*)a)->whenConvenient), ""))
				{	soap_flag_whenConvenient1 = 0;
					continue;
				}
			if (soap_flag_byDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:byDate", &(((ngwt__SendOptionsRequestReply*)a)->byDate), ""))
				{	soap_flag_byDate1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__SendOptionsRequestReply *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SendOptionsRequestReply, 0, sizeof(ngwt__SendOptionsRequestReply), 0, soap_copy_ngwt__SendOptionsRequestReply);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__SendOptionsRequestReply * SOAP_FMAC6 soap_new_ngwt__SendOptionsRequestReply(struct soap *soap, int n)
{	return soap_instantiate_ngwt__SendOptionsRequestReply(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__SendOptionsRequestReply(struct soap *soap, ngwt__SendOptionsRequestReply *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__SendOptionsRequestReply * SOAP_FMAC6 soap_instantiate_ngwt__SendOptionsRequestReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__SendOptionsRequestReply(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__SendOptionsRequestReply, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__SendOptionsRequestReply;
		if (size)
			*size = sizeof(ngwt__SendOptionsRequestReply);
		((ngwt__SendOptionsRequestReply*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__SendOptionsRequestReply[n];
		if (size)
			*size = n * sizeof(ngwt__SendOptionsRequestReply);
		for (int i = 0; i < n; i++)
			((ngwt__SendOptionsRequestReply*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__SendOptionsRequestReply*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__SendOptionsRequestReply(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__SendOptionsRequestReply %p -> %p\n", q, p));
	*(ngwt__SendOptionsRequestReply*)p = *(ngwt__SendOptionsRequestReply*)q;
}

void ngwt__RuleList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Rule(soap, &((ngwt__RuleList*)this)->rule);
	/* transient soap skipped */
}

void ngwt__RuleList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Rule(soap, &((ngwt__RuleList*)this)->rule);
	/* transient soap skipped */
}

int ngwt__RuleList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__RuleList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__RuleList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__RuleList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__RuleList(struct soap *soap, const char *tag, int id, const ngwt__RuleList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__RuleList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Rule(soap, "ngwt:rule", -1, &(((ngwt__RuleList*)a)->rule), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__RuleList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__RuleList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__RuleList * SOAP_FMAC4 soap_get_ngwt__RuleList(struct soap *soap, ngwt__RuleList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__RuleList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__RuleList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__RuleList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__RuleList * SOAP_FMAC4 soap_in_ngwt__RuleList(struct soap *soap, const char *tag, ngwt__RuleList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__RuleList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__RuleList, sizeof(ngwt__RuleList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__RuleList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__RuleList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Rule(soap, "ngwt:rule", &(((ngwt__RuleList*)a)->rule), "ngwt:Rule"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__RuleList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RuleList, 0, sizeof(ngwt__RuleList), 0, soap_copy_ngwt__RuleList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__RuleList * SOAP_FMAC6 soap_new_ngwt__RuleList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__RuleList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__RuleList(struct soap *soap, ngwt__RuleList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__RuleList * SOAP_FMAC6 soap_instantiate_ngwt__RuleList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__RuleList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__RuleList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__RuleList;
		if (size)
			*size = sizeof(ngwt__RuleList);
		((ngwt__RuleList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__RuleList[n];
		if (size)
			*size = n * sizeof(ngwt__RuleList);
		for (int i = 0; i < n; i++)
			((ngwt__RuleList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__RuleList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__RuleList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__RuleList %p -> %p\n", q, p));
	*(ngwt__RuleList*)p = *(ngwt__RuleList*)q;
}

void ngwt__RuleActionList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__RuleAction(soap, &((ngwt__RuleActionList*)this)->action);
	/* transient soap skipped */
}

void ngwt__RuleActionList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__RuleAction(soap, &((ngwt__RuleActionList*)this)->action);
	/* transient soap skipped */
}

int ngwt__RuleActionList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__RuleActionList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__RuleActionList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__RuleActionList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__RuleActionList(struct soap *soap, const char *tag, int id, const ngwt__RuleActionList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__RuleActionList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__RuleAction(soap, "ngwt:action", -1, &(((ngwt__RuleActionList*)a)->action), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__RuleActionList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__RuleActionList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__RuleActionList * SOAP_FMAC4 soap_get_ngwt__RuleActionList(struct soap *soap, ngwt__RuleActionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__RuleActionList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__RuleActionList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__RuleActionList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__RuleActionList * SOAP_FMAC4 soap_in_ngwt__RuleActionList(struct soap *soap, const char *tag, ngwt__RuleActionList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__RuleActionList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__RuleActionList, sizeof(ngwt__RuleActionList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__RuleActionList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__RuleActionList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__RuleAction(soap, "ngwt:action", &(((ngwt__RuleActionList*)a)->action), "ngwt:RuleAction"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__RuleActionList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RuleActionList, 0, sizeof(ngwt__RuleActionList), 0, soap_copy_ngwt__RuleActionList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__RuleActionList * SOAP_FMAC6 soap_new_ngwt__RuleActionList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__RuleActionList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__RuleActionList(struct soap *soap, ngwt__RuleActionList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__RuleActionList * SOAP_FMAC6 soap_instantiate_ngwt__RuleActionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__RuleActionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__RuleActionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__RuleActionList;
		if (size)
			*size = sizeof(ngwt__RuleActionList);
		((ngwt__RuleActionList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__RuleActionList[n];
		if (size)
			*size = n * sizeof(ngwt__RuleActionList);
		for (int i = 0; i < n; i++)
			((ngwt__RuleActionList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__RuleActionList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__RuleActionList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__RuleActionList %p -> %p\n", q, p));
	*(ngwt__RuleActionList*)p = *(ngwt__RuleActionList*)q;
}

void ngwt__RuleAction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__RuleAction*)this)->type, SOAP_TYPE_ngwt__RuleActionType);
	soap_embedded(soap, &((ngwt__RuleAction*)this)->container, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__RuleAction*)this)->container);
	soap_embedded(soap, &((ngwt__RuleAction*)this)->item, SOAP_TYPE_PointerTongwt__Mail);
	soap_serialize_PointerTongwt__Mail(soap, &((ngwt__RuleAction*)this)->item);
	soap_embedded(soap, &((ngwt__RuleAction*)this)->message, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__RuleAction*)this)->message);
	soap_embedded(soap, &((ngwt__RuleAction*)this)->acceptLevel, SOAP_TYPE_PointerTongwt__AcceptLevel);
	soap_serialize_PointerTongwt__AcceptLevel(soap, &((ngwt__RuleAction*)this)->acceptLevel);
	soap_embedded(soap, &((ngwt__RuleAction*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__RuleAction*)this)->categories);
	/* transient soap skipped */
}

void ngwt__RuleAction::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__RuleActionType(soap, &((ngwt__RuleAction*)this)->type);
	((ngwt__RuleAction*)this)->container = NULL;
	((ngwt__RuleAction*)this)->item = NULL;
	((ngwt__RuleAction*)this)->message = NULL;
	((ngwt__RuleAction*)this)->acceptLevel = NULL;
	((ngwt__RuleAction*)this)->categories = NULL;
	/* transient soap skipped */
}

int ngwt__RuleAction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__RuleAction);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__RuleAction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__RuleAction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__RuleAction(struct soap *soap, const char *tag, int id, const ngwt__RuleAction *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__RuleAction), type);
	soap_out_ngwt__RuleActionType(soap, "ngwt:type", -1, &(((ngwt__RuleAction*)a)->type), "");
	soap_out_PointerTongwt__uid(soap, "ngwt:container", -1, &(((ngwt__RuleAction*)a)->container), "");
	soap_out_PointerTongwt__Mail(soap, "ngwt:item", -1, &(((ngwt__RuleAction*)a)->item), "");
	soap_out_PointerTostd__string(soap, "ngwt:message", -1, &(((ngwt__RuleAction*)a)->message), "");
	soap_out_PointerTongwt__AcceptLevel(soap, "ngwt:acceptLevel", -1, &(((ngwt__RuleAction*)a)->acceptLevel), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__RuleAction*)a)->categories), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__RuleAction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__RuleAction(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__RuleAction * SOAP_FMAC4 soap_get_ngwt__RuleAction(struct soap *soap, ngwt__RuleAction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__RuleAction(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__RuleAction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__RuleAction(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__RuleAction * SOAP_FMAC4 soap_in_ngwt__RuleAction(struct soap *soap, const char *tag, ngwt__RuleAction *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__RuleAction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__RuleAction, sizeof(ngwt__RuleAction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__RuleAction)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__RuleAction *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_type1 = 1, soap_flag_container1 = 1, soap_flag_item1 = 1, soap_flag_message1 = 1, soap_flag_acceptLevel1 = 1, soap_flag_categories1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__RuleActionType(soap, "ngwt:type", &(((ngwt__RuleAction*)a)->type), ""))
				{	soap_flag_type1 = 0;
					continue;
				}
			if (soap_flag_container1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:container", &(((ngwt__RuleAction*)a)->container), "ngwt:uid"))
				{	soap_flag_container1 = 0;
					continue;
				}
			if (soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Mail(soap, "ngwt:item", &(((ngwt__RuleAction*)a)->item), "ngwt:Mail"))
				{	soap_flag_item1 = 0;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:message", &(((ngwt__RuleAction*)a)->message), ""))
				{	soap_flag_message1 = 0;
					continue;
				}
			if (soap_flag_acceptLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AcceptLevel(soap, "ngwt:acceptLevel", &(((ngwt__RuleAction*)a)->acceptLevel), ""))
				{	soap_flag_acceptLevel1 = 0;
					continue;
				}
			if (soap_flag_categories1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__RuleAction*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__RuleAction *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RuleAction, 0, sizeof(ngwt__RuleAction), 0, soap_copy_ngwt__RuleAction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__RuleAction * SOAP_FMAC6 soap_new_ngwt__RuleAction(struct soap *soap, int n)
{	return soap_instantiate_ngwt__RuleAction(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__RuleAction(struct soap *soap, ngwt__RuleAction *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__RuleAction * SOAP_FMAC6 soap_instantiate_ngwt__RuleAction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__RuleAction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__RuleAction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__RuleAction;
		if (size)
			*size = sizeof(ngwt__RuleAction);
		((ngwt__RuleAction*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__RuleAction[n];
		if (size)
			*size = n * sizeof(ngwt__RuleAction);
		for (int i = 0; i < n; i++)
			((ngwt__RuleAction*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__RuleAction*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__RuleAction(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__RuleAction %p -> %p\n", q, p));
	*(ngwt__RuleAction*)p = *(ngwt__RuleAction*)q;
}

void ngwt__Rule::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Rule*)this)->execution, SOAP_TYPE_PointerTongwt__Execution);
	soap_serialize_PointerTongwt__Execution(soap, &((ngwt__Rule*)this)->execution);
	soap_embedded(soap, &((ngwt__Rule*)this)->sequence, SOAP_TYPE_unsignedLong);
	soap_embedded(soap, &((ngwt__Rule*)this)->enabled, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwt__Rule*)this)->types, SOAP_TYPE_PointerTongwt__MessageTypeList);
	soap_serialize_PointerTongwt__MessageTypeList(soap, &((ngwt__Rule*)this)->types);
	soap_embedded(soap, &((ngwt__Rule*)this)->source, SOAP_TYPE_PointerTongwt__ItemSourceList);
	soap_serialize_PointerTongwt__ItemSourceList(soap, &((ngwt__Rule*)this)->source);
	soap_embedded(soap, &((ngwt__Rule*)this)->conflict, SOAP_TYPE_ngwt__AppointmentConflict);
	soap_embedded(soap, &((ngwt__Rule*)this)->filter, SOAP_TYPE_PointerTongwt__Filter);
	soap_serialize_PointerTongwt__Filter(soap, &((ngwt__Rule*)this)->filter);
	soap_embedded(soap, &((ngwt__Rule*)this)->actions, SOAP_TYPE_PointerTongwt__RuleActionList);
	soap_serialize_PointerTongwt__RuleActionList(soap, &((ngwt__Rule*)this)->actions);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Rule::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Rule*)this)->execution = NULL;
	soap_default_unsignedLong(soap, &((ngwt__Rule*)this)->sequence);
	((ngwt__Rule*)this)->enabled = (bool)0;
	((ngwt__Rule*)this)->types = NULL;
	((ngwt__Rule*)this)->source = NULL;
	((ngwt__Rule*)this)->conflict = (enum ngwt__AppointmentConflict)2;
	((ngwt__Rule*)this)->filter = NULL;
	((ngwt__Rule*)this)->actions = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Rule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Rule);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Rule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Rule(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Rule(struct soap *soap, const char *tag, int id, const ngwt__Rule *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Rule), "ngwt:Rule");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__Execution(soap, "ngwt:execution", -1, &(((ngwt__Rule*)a)->execution), "");
	soap_out_unsignedLong(soap, "ngwt:sequence", -1, &(((ngwt__Rule*)a)->sequence), "");
	soap_out_bool(soap, "ngwt:enabled", -1, &(((ngwt__Rule*)a)->enabled), "");
	soap_out_PointerTongwt__MessageTypeList(soap, "ngwt:types", -1, &(((ngwt__Rule*)a)->types), "");
	soap_out_PointerTongwt__ItemSourceList(soap, "ngwt:source", -1, &(((ngwt__Rule*)a)->source), "");
	soap_out_ngwt__AppointmentConflict(soap, "ngwt:conflict", -1, &(((ngwt__Rule*)a)->conflict), "");
	soap_out_PointerTongwt__Filter(soap, "ngwt:filter", -1, &(((ngwt__Rule*)a)->filter), "");
	soap_out_PointerTongwt__RuleActionList(soap, "ngwt:actions", -1, &(((ngwt__Rule*)a)->actions), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Rule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Rule(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Rule * SOAP_FMAC4 soap_get_ngwt__Rule(struct soap *soap, ngwt__Rule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Rule(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Rule::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Rule(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Rule * SOAP_FMAC4 soap_in_ngwt__Rule(struct soap *soap, const char *tag, ngwt__Rule *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Rule *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Rule, sizeof(ngwt__Rule), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Rule)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Rule *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_categories2 = 1, soap_flag_created2 = 1, soap_flag_customs2 = 1, soap_flag_execution1 = 1, soap_flag_sequence1 = 1, soap_flag_enabled1 = 1, soap_flag_types1 = 1, soap_flag_source1 = 1, soap_flag_conflict1 = 1, soap_flag_filter1 = 1, soap_flag_actions1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}
			if (soap_flag_name3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name3 = 0;
					continue;
				}
			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}
			if (soap_flag_modified3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}
			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories2 = 0;
					continue;
				}
			if (soap_flag_created2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created2 = 0;
					continue;
				}
			if (soap_flag_customs2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs2 = 0;
					continue;
				}
			if (soap_flag_execution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Execution(soap, "ngwt:execution", &(((ngwt__Rule*)a)->execution), ""))
				{	soap_flag_execution1 = 0;
					continue;
				}
			if (soap_flag_sequence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "ngwt:sequence", &(((ngwt__Rule*)a)->sequence), ""))
				{	soap_flag_sequence1 = 0;
					continue;
				}
			if (soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:enabled", &(((ngwt__Rule*)a)->enabled), ""))
				{	soap_flag_enabled1 = 0;
					continue;
				}
			if (soap_flag_types1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessageTypeList(soap, "ngwt:types", &(((ngwt__Rule*)a)->types), ""))
				{	soap_flag_types1 = 0;
					continue;
				}
			if (soap_flag_source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSourceList(soap, "ngwt:source", &(((ngwt__Rule*)a)->source), ""))
				{	soap_flag_source1 = 0;
					continue;
				}
			if (soap_flag_conflict1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__AppointmentConflict(soap, "ngwt:conflict", &(((ngwt__Rule*)a)->conflict), ""))
				{	soap_flag_conflict1 = 0;
					continue;
				}
			if (soap_flag_filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Filter(soap, "ngwt:filter", &(((ngwt__Rule*)a)->filter), "ngwt:Filter"))
				{	soap_flag_filter1 = 0;
					continue;
				}
			if (soap_flag_actions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RuleActionList(soap, "ngwt:actions", &(((ngwt__Rule*)a)->actions), "ngwt:RuleActionList"))
				{	soap_flag_actions1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sequence1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Rule *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Rule, 0, sizeof(ngwt__Rule), 0, soap_copy_ngwt__Rule);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Rule * SOAP_FMAC6 soap_new_ngwt__Rule(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Rule(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Rule(struct soap *soap, ngwt__Rule *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Rule * SOAP_FMAC6 soap_instantiate_ngwt__Rule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Rule(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Rule, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Rule;
		if (size)
			*size = sizeof(ngwt__Rule);
		((ngwt__Rule*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Rule[n];
		if (size)
			*size = n * sizeof(ngwt__Rule);
		for (int i = 0; i < n; i++)
			((ngwt__Rule*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Rule*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Rule(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Rule %p -> %p\n", q, p));
	*(ngwt__Rule*)p = *(ngwt__Rule*)q;
}

void ngwt__Rights::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Rights*)this)->read, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Rights*)this)->read);
	soap_embedded(soap, &((ngwt__Rights*)this)->add, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Rights*)this)->add);
	soap_embedded(soap, &((ngwt__Rights*)this)->edit, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Rights*)this)->edit);
	soap_embedded(soap, &((ngwt__Rights*)this)->_delete, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Rights*)this)->_delete);
	soap_embedded(soap, &((ngwt__Rights*)this)->share, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Rights*)this)->share);
	soap_embedded(soap, &((ngwt__Rights*)this)->manage, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Rights*)this)->manage);
	/* transient soap skipped */
}

void ngwt__Rights::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Rights*)this)->read = NULL;
	((ngwt__Rights*)this)->add = NULL;
	((ngwt__Rights*)this)->edit = NULL;
	((ngwt__Rights*)this)->_delete = NULL;
	((ngwt__Rights*)this)->share = NULL;
	((ngwt__Rights*)this)->manage = NULL;
	/* transient soap skipped */
}

int ngwt__Rights::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Rights);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Rights::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Rights(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Rights(struct soap *soap, const char *tag, int id, const ngwt__Rights *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Rights), type);
	soap_out_PointerTobool(soap, "ngwt:read", -1, &(((ngwt__Rights*)a)->read), "");
	soap_out_PointerTobool(soap, "ngwt:add", -1, &(((ngwt__Rights*)a)->add), "");
	soap_out_PointerTobool(soap, "ngwt:edit", -1, &(((ngwt__Rights*)a)->edit), "");
	soap_out_PointerTobool(soap, "ngwt:delete", -1, &(((ngwt__Rights*)a)->_delete), "");
	soap_out_PointerTobool(soap, "ngwt:share", -1, &(((ngwt__Rights*)a)->share), "");
	soap_out_PointerTobool(soap, "ngwt:manage", -1, &(((ngwt__Rights*)a)->manage), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Rights::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Rights(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Rights * SOAP_FMAC4 soap_get_ngwt__Rights(struct soap *soap, ngwt__Rights *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Rights(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Rights::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Rights(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Rights * SOAP_FMAC4 soap_in_ngwt__Rights(struct soap *soap, const char *tag, ngwt__Rights *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Rights *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Rights, sizeof(ngwt__Rights), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Rights)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Rights *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_read1 = 1, soap_flag_add1 = 1, soap_flag_edit1 = 1, soap_flag_delete1 = 1, soap_flag_share1 = 1, soap_flag_manage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_read1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:read", &(((ngwt__Rights*)a)->read), ""))
				{	soap_flag_read1 = 0;
					continue;
				}
			if (soap_flag_add1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:add", &(((ngwt__Rights*)a)->add), ""))
				{	soap_flag_add1 = 0;
					continue;
				}
			if (soap_flag_edit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:edit", &(((ngwt__Rights*)a)->edit), ""))
				{	soap_flag_edit1 = 0;
					continue;
				}
			if (soap_flag_delete1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:delete", &(((ngwt__Rights*)a)->_delete), ""))
				{	soap_flag_delete1 = 0;
					continue;
				}
			if (soap_flag_share1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:share", &(((ngwt__Rights*)a)->share), ""))
				{	soap_flag_share1 = 0;
					continue;
				}
			if (soap_flag_manage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:manage", &(((ngwt__Rights*)a)->manage), ""))
				{	soap_flag_manage1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Rights *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Rights, 0, sizeof(ngwt__Rights), 0, soap_copy_ngwt__Rights);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Rights * SOAP_FMAC6 soap_new_ngwt__Rights(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Rights(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Rights(struct soap *soap, ngwt__Rights *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Rights * SOAP_FMAC6 soap_instantiate_ngwt__Rights(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Rights(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Rights, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Rights;
		if (size)
			*size = sizeof(ngwt__Rights);
		((ngwt__Rights*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Rights[n];
		if (size)
			*size = n * sizeof(ngwt__Rights);
		for (int i = 0; i < n; i++)
			((ngwt__Rights*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Rights*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Rights(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Rights %p -> %p\n", q, p));
	*(ngwt__Rights*)p = *(ngwt__Rights*)q;
}

void ngwt__ReturnNotificationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ReturnNotificationOptions*)this)->mail, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwt__ReturnNotificationOptions*)this)->notify, SOAP_TYPE_bool);
	/* transient soap skipped */
}

void ngwt__ReturnNotificationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__ReturnNotificationOptions*)this)->mail = (bool)0;
	((ngwt__ReturnNotificationOptions*)this)->notify = (bool)0;
	/* transient soap skipped */
}

int ngwt__ReturnNotificationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ReturnNotificationOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ReturnNotificationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ReturnNotificationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ReturnNotificationOptions(struct soap *soap, const char *tag, int id, const ngwt__ReturnNotificationOptions *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ReturnNotificationOptions), type);
	soap_out_bool(soap, "ngwt:mail", -1, &(((ngwt__ReturnNotificationOptions*)a)->mail), "");
	soap_out_bool(soap, "ngwt:notify", -1, &(((ngwt__ReturnNotificationOptions*)a)->notify), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ReturnNotificationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ReturnNotificationOptions(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ReturnNotificationOptions * SOAP_FMAC4 soap_get_ngwt__ReturnNotificationOptions(struct soap *soap, ngwt__ReturnNotificationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ReturnNotificationOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ReturnNotificationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ReturnNotificationOptions(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ReturnNotificationOptions * SOAP_FMAC4 soap_in_ngwt__ReturnNotificationOptions(struct soap *soap, const char *tag, ngwt__ReturnNotificationOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ReturnNotificationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ReturnNotificationOptions, sizeof(ngwt__ReturnNotificationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ReturnNotificationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ReturnNotificationOptions *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_mail1 = 1, soap_flag_notify1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mail1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:mail", &(((ngwt__ReturnNotificationOptions*)a)->mail), ""))
				{	soap_flag_mail1 = 0;
					continue;
				}
			if (soap_flag_notify1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:notify", &(((ngwt__ReturnNotificationOptions*)a)->notify), ""))
				{	soap_flag_notify1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ReturnNotificationOptions *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ReturnNotificationOptions, 0, sizeof(ngwt__ReturnNotificationOptions), 0, soap_copy_ngwt__ReturnNotificationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ReturnNotificationOptions * SOAP_FMAC6 soap_new_ngwt__ReturnNotificationOptions(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ReturnNotificationOptions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ReturnNotificationOptions(struct soap *soap, ngwt__ReturnNotificationOptions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ReturnNotificationOptions * SOAP_FMAC6 soap_instantiate_ngwt__ReturnNotificationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ReturnNotificationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ReturnNotificationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ReturnNotificationOptions;
		if (size)
			*size = sizeof(ngwt__ReturnNotificationOptions);
		((ngwt__ReturnNotificationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ReturnNotificationOptions[n];
		if (size)
			*size = n * sizeof(ngwt__ReturnNotificationOptions);
		for (int i = 0; i < n; i++)
			((ngwt__ReturnNotificationOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ReturnNotificationOptions*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ReturnNotificationOptions(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ReturnNotificationOptions %p -> %p\n", q, p));
	*(ngwt__ReturnNotificationOptions*)p = *(ngwt__ReturnNotificationOptions*)q;
}

void ngwt__ReturnNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ReturnNotification*)this)->opened, SOAP_TYPE_PointerTongwt__ReturnNotificationOptions);
	soap_serialize_PointerTongwt__ReturnNotificationOptions(soap, &((ngwt__ReturnNotification*)this)->opened);
	soap_embedded(soap, &((ngwt__ReturnNotification*)this)->deleted, SOAP_TYPE_PointerTongwt__ReturnNotificationOptions);
	soap_serialize_PointerTongwt__ReturnNotificationOptions(soap, &((ngwt__ReturnNotification*)this)->deleted);
	soap_embedded(soap, &((ngwt__ReturnNotification*)this)->accepted, SOAP_TYPE_PointerTongwt__ReturnNotificationOptions);
	soap_serialize_PointerTongwt__ReturnNotificationOptions(soap, &((ngwt__ReturnNotification*)this)->accepted);
	soap_embedded(soap, &((ngwt__ReturnNotification*)this)->declined, SOAP_TYPE_PointerTongwt__ReturnNotificationOptions);
	soap_serialize_PointerTongwt__ReturnNotificationOptions(soap, &((ngwt__ReturnNotification*)this)->declined);
	soap_embedded(soap, &((ngwt__ReturnNotification*)this)->completed, SOAP_TYPE_PointerTongwt__ReturnNotificationOptions);
	soap_serialize_PointerTongwt__ReturnNotificationOptions(soap, &((ngwt__ReturnNotification*)this)->completed);
	/* transient soap skipped */
}

void ngwt__ReturnNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__ReturnNotification*)this)->opened = NULL;
	((ngwt__ReturnNotification*)this)->deleted = NULL;
	((ngwt__ReturnNotification*)this)->accepted = NULL;
	((ngwt__ReturnNotification*)this)->declined = NULL;
	((ngwt__ReturnNotification*)this)->completed = NULL;
	/* transient soap skipped */
}

int ngwt__ReturnNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ReturnNotification);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ReturnNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ReturnNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ReturnNotification(struct soap *soap, const char *tag, int id, const ngwt__ReturnNotification *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ReturnNotification), type);
	soap_out_PointerTongwt__ReturnNotificationOptions(soap, "ngwt:opened", -1, &(((ngwt__ReturnNotification*)a)->opened), "");
	soap_out_PointerTongwt__ReturnNotificationOptions(soap, "ngwt:deleted", -1, &(((ngwt__ReturnNotification*)a)->deleted), "");
	soap_out_PointerTongwt__ReturnNotificationOptions(soap, "ngwt:accepted", -1, &(((ngwt__ReturnNotification*)a)->accepted), "");
	soap_out_PointerTongwt__ReturnNotificationOptions(soap, "ngwt:declined", -1, &(((ngwt__ReturnNotification*)a)->declined), "");
	soap_out_PointerTongwt__ReturnNotificationOptions(soap, "ngwt:completed", -1, &(((ngwt__ReturnNotification*)a)->completed), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ReturnNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ReturnNotification(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ReturnNotification * SOAP_FMAC4 soap_get_ngwt__ReturnNotification(struct soap *soap, ngwt__ReturnNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ReturnNotification(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ReturnNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ReturnNotification(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ReturnNotification * SOAP_FMAC4 soap_in_ngwt__ReturnNotification(struct soap *soap, const char *tag, ngwt__ReturnNotification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ReturnNotification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ReturnNotification, sizeof(ngwt__ReturnNotification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ReturnNotification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ReturnNotification *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_opened1 = 1, soap_flag_deleted1 = 1, soap_flag_accepted1 = 1, soap_flag_declined1 = 1, soap_flag_completed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_opened1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ReturnNotificationOptions(soap, "ngwt:opened", &(((ngwt__ReturnNotification*)a)->opened), "ngwt:ReturnNotificationOptions"))
				{	soap_flag_opened1 = 0;
					continue;
				}
			if (soap_flag_deleted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ReturnNotificationOptions(soap, "ngwt:deleted", &(((ngwt__ReturnNotification*)a)->deleted), "ngwt:ReturnNotificationOptions"))
				{	soap_flag_deleted1 = 0;
					continue;
				}
			if (soap_flag_accepted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ReturnNotificationOptions(soap, "ngwt:accepted", &(((ngwt__ReturnNotification*)a)->accepted), "ngwt:ReturnNotificationOptions"))
				{	soap_flag_accepted1 = 0;
					continue;
				}
			if (soap_flag_declined1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ReturnNotificationOptions(soap, "ngwt:declined", &(((ngwt__ReturnNotification*)a)->declined), "ngwt:ReturnNotificationOptions"))
				{	soap_flag_declined1 = 0;
					continue;
				}
			if (soap_flag_completed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ReturnNotificationOptions(soap, "ngwt:completed", &(((ngwt__ReturnNotification*)a)->completed), "ngwt:ReturnNotificationOptions"))
				{	soap_flag_completed1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ReturnNotification *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ReturnNotification, 0, sizeof(ngwt__ReturnNotification), 0, soap_copy_ngwt__ReturnNotification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ReturnNotification * SOAP_FMAC6 soap_new_ngwt__ReturnNotification(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ReturnNotification(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ReturnNotification(struct soap *soap, ngwt__ReturnNotification *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ReturnNotification * SOAP_FMAC6 soap_instantiate_ngwt__ReturnNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ReturnNotification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ReturnNotification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ReturnNotification;
		if (size)
			*size = sizeof(ngwt__ReturnNotification);
		((ngwt__ReturnNotification*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ReturnNotification[n];
		if (size)
			*size = n * sizeof(ngwt__ReturnNotification);
		for (int i = 0; i < n; i++)
			((ngwt__ReturnNotification*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ReturnNotification*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ReturnNotification(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ReturnNotification %p -> %p\n", q, p));
	*(ngwt__ReturnNotification*)p = *(ngwt__ReturnNotification*)q;
}

void ngwt__Resource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Resource*)this)->phone, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Resource*)this)->phone);
	soap_embedded(soap, &((ngwt__Resource*)this)->resourceType, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Resource*)this)->resourceType);
	soap_embedded(soap, &((ngwt__Resource*)this)->email, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Resource*)this)->email);
	soap_embedded(soap, &((ngwt__Resource*)this)->owner, SOAP_TYPE_PointerTongwt__ItemRef);
	soap_serialize_PointerTongwt__ItemRef(soap, &((ngwt__Resource*)this)->owner);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__AddressBookItem*)this)->uuid);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->comment);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->sync, SOAP_TYPE_PointerTongwt__DeltaSyncType);
	soap_serialize_PointerTongwt__DeltaSyncType(soap, &((ngwt__AddressBookItem*)this)->sync);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->domain, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->domain);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->postOffice, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->postOffice);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->distinguishedName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->distinguishedName);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->userid, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->userid);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Resource::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Resource*)this)->phone = NULL;
	((ngwt__Resource*)this)->resourceType = NULL;
	((ngwt__Resource*)this)->email = NULL;
	((ngwt__Resource*)this)->owner = NULL;
	((ngwt__AddressBookItem*)this)->uuid = NULL;
	((ngwt__AddressBookItem*)this)->comment = NULL;
	((ngwt__AddressBookItem*)this)->sync = NULL;
	((ngwt__AddressBookItem*)this)->domain = NULL;
	((ngwt__AddressBookItem*)this)->postOffice = NULL;
	((ngwt__AddressBookItem*)this)->distinguishedName = NULL;
	((ngwt__AddressBookItem*)this)->userid = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Resource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Resource);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Resource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Resource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Resource(struct soap *soap, const char *tag, int id, const ngwt__Resource *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Resource), "ngwt:Resource");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__AddressBookItem*)a)->uuid), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__AddressBookItem*)a)->comment), "");
	soap_out_PointerTongwt__DeltaSyncType(soap, "ngwt:sync", -1, &(((ngwt__AddressBookItem*)a)->sync), "");
	soap_out_PointerTostd__string(soap, "ngwt:domain", -1, &(((ngwt__AddressBookItem*)a)->domain), "");
	soap_out_PointerTostd__string(soap, "ngwt:postOffice", -1, &(((ngwt__AddressBookItem*)a)->postOffice), "");
	soap_out_PointerTostd__string(soap, "ngwt:distinguishedName", -1, &(((ngwt__AddressBookItem*)a)->distinguishedName), "");
	soap_out_PointerTostd__string(soap, "ngwt:userid", -1, &(((ngwt__AddressBookItem*)a)->userid), "");
	soap_out_PointerTostd__string(soap, "ngwt:phone", -1, &(((ngwt__Resource*)a)->phone), "");
	soap_out_PointerTostd__string(soap, "ngwt:resourceType", -1, &(((ngwt__Resource*)a)->resourceType), "");
	soap_out_PointerTostd__string(soap, "ngwt:email", -1, &(((ngwt__Resource*)a)->email), "");
	soap_out_PointerTongwt__ItemRef(soap, "ngwt:owner", -1, &(((ngwt__Resource*)a)->owner), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Resource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Resource(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Resource * SOAP_FMAC4 soap_get_ngwt__Resource(struct soap *soap, ngwt__Resource *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Resource(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Resource::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Resource(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Resource * SOAP_FMAC4 soap_in_ngwt__Resource(struct soap *soap, const char *tag, ngwt__Resource *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Resource *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Resource, sizeof(ngwt__Resource), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Resource)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Resource *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_categories3 = 1, soap_flag_created3 = 1, soap_flag_customs3 = 1, soap_flag_uuid2 = 1, soap_flag_comment2 = 1, soap_flag_sync2 = 1, soap_flag_domain2 = 1, soap_flag_postOffice2 = 1, soap_flag_distinguishedName2 = 1, soap_flag_userid2 = 1, soap_flag_phone1 = 1, soap_flag_resourceType1 = 1, soap_flag_email1 = 1, soap_flag_owner1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}
			if (soap_flag_name4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name4 = 0;
					continue;
				}
			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}
			if (soap_flag_modified4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}
			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories3 = 0;
					continue;
				}
			if (soap_flag_created3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created3 = 0;
					continue;
				}
			if (soap_flag_customs3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs3 = 0;
					continue;
				}
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__AddressBookItem*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}
			if (soap_flag_comment2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__AddressBookItem*)a)->comment), ""))
				{	soap_flag_comment2 = 0;
					continue;
				}
			if (soap_flag_sync2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DeltaSyncType(soap, "ngwt:sync", &(((ngwt__AddressBookItem*)a)->sync), ""))
				{	soap_flag_sync2 = 0;
					continue;
				}
			if (soap_flag_domain2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:domain", &(((ngwt__AddressBookItem*)a)->domain), ""))
				{	soap_flag_domain2 = 0;
					continue;
				}
			if (soap_flag_postOffice2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:postOffice", &(((ngwt__AddressBookItem*)a)->postOffice), ""))
				{	soap_flag_postOffice2 = 0;
					continue;
				}
			if (soap_flag_distinguishedName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:distinguishedName", &(((ngwt__AddressBookItem*)a)->distinguishedName), ""))
				{	soap_flag_distinguishedName2 = 0;
					continue;
				}
			if (soap_flag_userid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:userid", &(((ngwt__AddressBookItem*)a)->userid), ""))
				{	soap_flag_userid2 = 0;
					continue;
				}
			if (soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:phone", &(((ngwt__Resource*)a)->phone), ""))
				{	soap_flag_phone1 = 0;
					continue;
				}
			if (soap_flag_resourceType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:resourceType", &(((ngwt__Resource*)a)->resourceType), ""))
				{	soap_flag_resourceType1 = 0;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:email", &(((ngwt__Resource*)a)->email), ""))
				{	soap_flag_email1 = 0;
					continue;
				}
			if (soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRef(soap, "ngwt:owner", &(((ngwt__Resource*)a)->owner), "ngwt:ItemRef"))
				{	soap_flag_owner1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Resource *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Resource, 0, sizeof(ngwt__Resource), 0, soap_copy_ngwt__Resource);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Resource * SOAP_FMAC6 soap_new_ngwt__Resource(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Resource(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Resource(struct soap *soap, ngwt__Resource *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Resource * SOAP_FMAC6 soap_instantiate_ngwt__Resource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Resource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Resource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Resource;
		if (size)
			*size = sizeof(ngwt__Resource);
		((ngwt__Resource*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Resource[n];
		if (size)
			*size = n * sizeof(ngwt__Resource);
		for (int i = 0; i < n; i++)
			((ngwt__Resource*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Resource*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Resource(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Resource %p -> %p\n", q, p));
	*(ngwt__Resource*)p = *(ngwt__Resource*)q;
}

void ngwt__ReferenceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ReferenceInfo*)this)->lastReferenceDate, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ReferenceInfo*)this)->lastReferenceDate);
	soap_embedded(soap, &((ngwt__ReferenceInfo*)this)->referenceCount, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__ReferenceInfo*)this)->referenceCount);
	/* transient soap skipped */
}

void ngwt__ReferenceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ngwt__ReferenceInfo*)this)->lastReferenceDate);
	((ngwt__ReferenceInfo*)this)->referenceCount = NULL;
	/* transient soap skipped */
}

int ngwt__ReferenceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ReferenceInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ReferenceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ReferenceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ReferenceInfo(struct soap *soap, const char *tag, int id, const ngwt__ReferenceInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ReferenceInfo), type);
	soap_out_string(soap, "ngwt:lastReferenceDate", -1, &(((ngwt__ReferenceInfo*)a)->lastReferenceDate), "");
	soap_out_PointerToint(soap, "ngwt:referenceCount", -1, &(((ngwt__ReferenceInfo*)a)->referenceCount), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ReferenceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ReferenceInfo(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ReferenceInfo * SOAP_FMAC4 soap_get_ngwt__ReferenceInfo(struct soap *soap, ngwt__ReferenceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ReferenceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ReferenceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ReferenceInfo(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ReferenceInfo * SOAP_FMAC4 soap_in_ngwt__ReferenceInfo(struct soap *soap, const char *tag, ngwt__ReferenceInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ReferenceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ReferenceInfo, sizeof(ngwt__ReferenceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ReferenceInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ReferenceInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_lastReferenceDate1 = 1, soap_flag_referenceCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lastReferenceDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:lastReferenceDate", &(((ngwt__ReferenceInfo*)a)->lastReferenceDate), ""))
				{	soap_flag_lastReferenceDate1 = 0;
					continue;
				}
			if (soap_flag_referenceCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:referenceCount", &(((ngwt__ReferenceInfo*)a)->referenceCount), ""))
				{	soap_flag_referenceCount1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ReferenceInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ReferenceInfo, 0, sizeof(ngwt__ReferenceInfo), 0, soap_copy_ngwt__ReferenceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ReferenceInfo * SOAP_FMAC6 soap_new_ngwt__ReferenceInfo(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ReferenceInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ReferenceInfo(struct soap *soap, ngwt__ReferenceInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ReferenceInfo * SOAP_FMAC6 soap_instantiate_ngwt__ReferenceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ReferenceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ReferenceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ReferenceInfo;
		if (size)
			*size = sizeof(ngwt__ReferenceInfo);
		((ngwt__ReferenceInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ReferenceInfo[n];
		if (size)
			*size = n * sizeof(ngwt__ReferenceInfo);
		for (int i = 0; i < n; i++)
			((ngwt__ReferenceInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ReferenceInfo*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ReferenceInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ReferenceInfo %p -> %p\n", q, p));
	*(ngwt__ReferenceInfo*)p = *(ngwt__ReferenceInfo*)q;
}

void ngwt__RecurrenceRule::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__RecurrenceRule*)this)->frequency, SOAP_TYPE_PointerTongwt__Frequency);
	soap_serialize_PointerTongwt__Frequency(soap, &((ngwt__RecurrenceRule*)this)->frequency);
	soap_embedded(soap, &((ngwt__RecurrenceRule*)this)->count, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__RecurrenceRule*)this)->count);
	soap_embedded(soap, &((ngwt__RecurrenceRule*)this)->until, SOAP_TYPE_PointerToxsd__date);
	soap_serialize_PointerToxsd__date(soap, &((ngwt__RecurrenceRule*)this)->until);
	soap_embedded(soap, &((ngwt__RecurrenceRule*)this)->interval, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__RecurrenceRule*)this)->interval);
	soap_embedded(soap, &((ngwt__RecurrenceRule*)this)->byDay, SOAP_TYPE_PointerTongwt__DayOfYearWeekList);
	soap_serialize_PointerTongwt__DayOfYearWeekList(soap, &((ngwt__RecurrenceRule*)this)->byDay);
	soap_embedded(soap, &((ngwt__RecurrenceRule*)this)->byMonthDay, SOAP_TYPE_PointerTongwt__DayOfMonthList);
	soap_serialize_PointerTongwt__DayOfMonthList(soap, &((ngwt__RecurrenceRule*)this)->byMonthDay);
	soap_embedded(soap, &((ngwt__RecurrenceRule*)this)->byYearDay, SOAP_TYPE_PointerTongwt__DayOfYearList);
	soap_serialize_PointerTongwt__DayOfYearList(soap, &((ngwt__RecurrenceRule*)this)->byYearDay);
	soap_embedded(soap, &((ngwt__RecurrenceRule*)this)->byMonth, SOAP_TYPE_PointerTongwt__MonthList);
	soap_serialize_PointerTongwt__MonthList(soap, &((ngwt__RecurrenceRule*)this)->byMonth);
	/* transient soap skipped */
}

void ngwt__RecurrenceRule::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__RecurrenceRule*)this)->frequency = NULL;
	((ngwt__RecurrenceRule*)this)->count = NULL;
	((ngwt__RecurrenceRule*)this)->until = NULL;
	((ngwt__RecurrenceRule*)this)->interval = NULL;
	((ngwt__RecurrenceRule*)this)->byDay = NULL;
	((ngwt__RecurrenceRule*)this)->byMonthDay = NULL;
	((ngwt__RecurrenceRule*)this)->byYearDay = NULL;
	((ngwt__RecurrenceRule*)this)->byMonth = NULL;
	/* transient soap skipped */
}

int ngwt__RecurrenceRule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__RecurrenceRule);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__RecurrenceRule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__RecurrenceRule(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__RecurrenceRule(struct soap *soap, const char *tag, int id, const ngwt__RecurrenceRule *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__RecurrenceRule), type);
	soap_out_PointerTongwt__Frequency(soap, "ngwt:frequency", -1, &(((ngwt__RecurrenceRule*)a)->frequency), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:count", -1, &(((ngwt__RecurrenceRule*)a)->count), "");
	soap_out_PointerToxsd__date(soap, "ngwt:until", -1, &(((ngwt__RecurrenceRule*)a)->until), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:interval", -1, &(((ngwt__RecurrenceRule*)a)->interval), "");
	soap_out_PointerTongwt__DayOfYearWeekList(soap, "ngwt:byDay", -1, &(((ngwt__RecurrenceRule*)a)->byDay), "");
	soap_out_PointerTongwt__DayOfMonthList(soap, "ngwt:byMonthDay", -1, &(((ngwt__RecurrenceRule*)a)->byMonthDay), "");
	soap_out_PointerTongwt__DayOfYearList(soap, "ngwt:byYearDay", -1, &(((ngwt__RecurrenceRule*)a)->byYearDay), "");
	soap_out_PointerTongwt__MonthList(soap, "ngwt:byMonth", -1, &(((ngwt__RecurrenceRule*)a)->byMonth), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__RecurrenceRule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__RecurrenceRule(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__RecurrenceRule * SOAP_FMAC4 soap_get_ngwt__RecurrenceRule(struct soap *soap, ngwt__RecurrenceRule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__RecurrenceRule(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__RecurrenceRule::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__RecurrenceRule(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__RecurrenceRule * SOAP_FMAC4 soap_in_ngwt__RecurrenceRule(struct soap *soap, const char *tag, ngwt__RecurrenceRule *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__RecurrenceRule *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__RecurrenceRule, sizeof(ngwt__RecurrenceRule), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__RecurrenceRule)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__RecurrenceRule *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_frequency1 = 1, soap_flag_count1 = 1, soap_flag_until1 = 1, soap_flag_interval1 = 1, soap_flag_byDay1 = 1, soap_flag_byMonthDay1 = 1, soap_flag_byYearDay1 = 1, soap_flag_byMonth1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_frequency1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Frequency(soap, "ngwt:frequency", &(((ngwt__RecurrenceRule*)a)->frequency), ""))
				{	soap_flag_frequency1 = 0;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:count", &(((ngwt__RecurrenceRule*)a)->count), ""))
				{	soap_flag_count1 = 0;
					continue;
				}
			if (soap_flag_until1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__date(soap, "ngwt:until", &(((ngwt__RecurrenceRule*)a)->until), "xsd:date"))
				{	soap_flag_until1 = 0;
					continue;
				}
			if (soap_flag_interval1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:interval", &(((ngwt__RecurrenceRule*)a)->interval), ""))
				{	soap_flag_interval1 = 0;
					continue;
				}
			if (soap_flag_byDay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DayOfYearWeekList(soap, "ngwt:byDay", &(((ngwt__RecurrenceRule*)a)->byDay), "ngwt:DayOfYearWeekList"))
				{	soap_flag_byDay1 = 0;
					continue;
				}
			if (soap_flag_byMonthDay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DayOfMonthList(soap, "ngwt:byMonthDay", &(((ngwt__RecurrenceRule*)a)->byMonthDay), "ngwt:DayOfMonthList"))
				{	soap_flag_byMonthDay1 = 0;
					continue;
				}
			if (soap_flag_byYearDay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DayOfYearList(soap, "ngwt:byYearDay", &(((ngwt__RecurrenceRule*)a)->byYearDay), "ngwt:DayOfYearList"))
				{	soap_flag_byYearDay1 = 0;
					continue;
				}
			if (soap_flag_byMonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MonthList(soap, "ngwt:byMonth", &(((ngwt__RecurrenceRule*)a)->byMonth), "ngwt:MonthList"))
				{	soap_flag_byMonth1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__RecurrenceRule *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RecurrenceRule, 0, sizeof(ngwt__RecurrenceRule), 0, soap_copy_ngwt__RecurrenceRule);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__RecurrenceRule * SOAP_FMAC6 soap_new_ngwt__RecurrenceRule(struct soap *soap, int n)
{	return soap_instantiate_ngwt__RecurrenceRule(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__RecurrenceRule(struct soap *soap, ngwt__RecurrenceRule *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__RecurrenceRule * SOAP_FMAC6 soap_instantiate_ngwt__RecurrenceRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__RecurrenceRule(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__RecurrenceRule, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__RecurrenceRule;
		if (size)
			*size = sizeof(ngwt__RecurrenceRule);
		((ngwt__RecurrenceRule*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__RecurrenceRule[n];
		if (size)
			*size = n * sizeof(ngwt__RecurrenceRule);
		for (int i = 0; i < n; i++)
			((ngwt__RecurrenceRule*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__RecurrenceRule*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__RecurrenceRule(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__RecurrenceRule %p -> %p\n", q, p));
	*(ngwt__RecurrenceRule*)p = *(ngwt__RecurrenceRule*)q;
}

void ngwt__RecurrenceDateType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__date(soap, &((ngwt__RecurrenceDateType*)this)->date);
	/* transient soap skipped */
}

void ngwt__RecurrenceDateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__date(soap, &((ngwt__RecurrenceDateType*)this)->date);
	/* transient soap skipped */
}

int ngwt__RecurrenceDateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__RecurrenceDateType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__RecurrenceDateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__RecurrenceDateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__RecurrenceDateType(struct soap *soap, const char *tag, int id, const ngwt__RecurrenceDateType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__RecurrenceDateType), type);
	soap_out_std__vectorTemplateOfxsd__date(soap, "ngwt:date", -1, &(((ngwt__RecurrenceDateType*)a)->date), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__RecurrenceDateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__RecurrenceDateType(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__RecurrenceDateType * SOAP_FMAC4 soap_get_ngwt__RecurrenceDateType(struct soap *soap, ngwt__RecurrenceDateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__RecurrenceDateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__RecurrenceDateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__RecurrenceDateType(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__RecurrenceDateType * SOAP_FMAC4 soap_in_ngwt__RecurrenceDateType(struct soap *soap, const char *tag, ngwt__RecurrenceDateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__RecurrenceDateType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__RecurrenceDateType, sizeof(ngwt__RecurrenceDateType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__RecurrenceDateType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__RecurrenceDateType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__date(soap, "ngwt:date", &(((ngwt__RecurrenceDateType*)a)->date), "xsd:date"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__RecurrenceDateType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RecurrenceDateType, 0, sizeof(ngwt__RecurrenceDateType), 0, soap_copy_ngwt__RecurrenceDateType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__RecurrenceDateType * SOAP_FMAC6 soap_new_ngwt__RecurrenceDateType(struct soap *soap, int n)
{	return soap_instantiate_ngwt__RecurrenceDateType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__RecurrenceDateType(struct soap *soap, ngwt__RecurrenceDateType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__RecurrenceDateType * SOAP_FMAC6 soap_instantiate_ngwt__RecurrenceDateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__RecurrenceDateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__RecurrenceDateType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__RecurrenceDateType;
		if (size)
			*size = sizeof(ngwt__RecurrenceDateType);
		((ngwt__RecurrenceDateType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__RecurrenceDateType[n];
		if (size)
			*size = n * sizeof(ngwt__RecurrenceDateType);
		for (int i = 0; i < n; i++)
			((ngwt__RecurrenceDateType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__RecurrenceDateType*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__RecurrenceDateType(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__RecurrenceDateType %p -> %p\n", q, p));
	*(ngwt__RecurrenceDateType*)p = *(ngwt__RecurrenceDateType*)q;
}

void ngwt__RecipientStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->delivered);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->undeliverable, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->undeliverable);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->transferred, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->transferred);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->transferDelayed, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->transferDelayed);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->transferFailed, SOAP_TYPE_PointerTongwt__TransferFailedStatus);
	soap_serialize_PointerTongwt__TransferFailedStatus(soap, &((ngwt__RecipientStatus*)this)->transferFailed);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->downloaded, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->downloaded);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->downloadedByThirdParty, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->downloadedByThirdParty);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->retractRequested, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->retractRequested);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->retracted, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->retracted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->opened, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->opened);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->deleted, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->deleted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->undeleted, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->undeleted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->purged, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->purged);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->accepted, SOAP_TYPE_PointerTongwt__CommentStatus);
	soap_serialize_PointerTongwt__CommentStatus(soap, &((ngwt__RecipientStatus*)this)->accepted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->declined, SOAP_TYPE_PointerTongwt__CommentStatus);
	soap_serialize_PointerTongwt__CommentStatus(soap, &((ngwt__RecipientStatus*)this)->declined);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->replied, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->replied);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->forwarded, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->forwarded);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->shared, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->shared);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->started, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->started);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->completed, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->completed);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->incomplete, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->incomplete);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->delegated, SOAP_TYPE_PointerTongwt__DelegatedStatus);
	soap_serialize_PointerTongwt__DelegatedStatus(soap, &((ngwt__RecipientStatus*)this)->delegated);
	soap_serialize_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, &((ngwt__RecipientStatus*)this)->delegateeStatus);
	/* transient soap skipped */
}

void ngwt__RecipientStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->delivered);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->undeliverable);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->transferred);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->transferDelayed);
	((ngwt__RecipientStatus*)this)->transferFailed = NULL;
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->downloaded);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->downloadedByThirdParty);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->retractRequested);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->retracted);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->opened);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->deleted);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->undeleted);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->purged);
	((ngwt__RecipientStatus*)this)->accepted = NULL;
	((ngwt__RecipientStatus*)this)->declined = NULL;
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->replied);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->forwarded);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->shared);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->started);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->completed);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->incomplete);
	((ngwt__RecipientStatus*)this)->delegated = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, &((ngwt__RecipientStatus*)this)->delegateeStatus);
	/* transient soap skipped */
}

int ngwt__RecipientStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__RecipientStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__RecipientStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__RecipientStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__RecipientStatus(struct soap *soap, const char *tag, int id, const ngwt__RecipientStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__RecipientStatus), type);
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__RecipientStatus*)a)->delivered), "");
	soap_out_string(soap, "ngwt:undeliverable", -1, &(((ngwt__RecipientStatus*)a)->undeliverable), "");
	soap_out_string(soap, "ngwt:transferred", -1, &(((ngwt__RecipientStatus*)a)->transferred), "");
	soap_out_string(soap, "ngwt:transferDelayed", -1, &(((ngwt__RecipientStatus*)a)->transferDelayed), "");
	soap_out_PointerTongwt__TransferFailedStatus(soap, "ngwt:transferFailed", -1, &(((ngwt__RecipientStatus*)a)->transferFailed), "");
	soap_out_string(soap, "ngwt:downloaded", -1, &(((ngwt__RecipientStatus*)a)->downloaded), "");
	soap_out_string(soap, "ngwt:downloadedByThirdParty", -1, &(((ngwt__RecipientStatus*)a)->downloadedByThirdParty), "");
	soap_out_string(soap, "ngwt:retractRequested", -1, &(((ngwt__RecipientStatus*)a)->retractRequested), "");
	soap_out_string(soap, "ngwt:retracted", -1, &(((ngwt__RecipientStatus*)a)->retracted), "");
	soap_out_string(soap, "ngwt:opened", -1, &(((ngwt__RecipientStatus*)a)->opened), "");
	soap_out_string(soap, "ngwt:deleted", -1, &(((ngwt__RecipientStatus*)a)->deleted), "");
	soap_out_string(soap, "ngwt:undeleted", -1, &(((ngwt__RecipientStatus*)a)->undeleted), "");
	soap_out_string(soap, "ngwt:purged", -1, &(((ngwt__RecipientStatus*)a)->purged), "");
	soap_out_PointerTongwt__CommentStatus(soap, "ngwt:accepted", -1, &(((ngwt__RecipientStatus*)a)->accepted), "");
	soap_out_PointerTongwt__CommentStatus(soap, "ngwt:declined", -1, &(((ngwt__RecipientStatus*)a)->declined), "");
	soap_out_string(soap, "ngwt:replied", -1, &(((ngwt__RecipientStatus*)a)->replied), "");
	soap_out_string(soap, "ngwt:forwarded", -1, &(((ngwt__RecipientStatus*)a)->forwarded), "");
	soap_out_string(soap, "ngwt:shared", -1, &(((ngwt__RecipientStatus*)a)->shared), "");
	soap_out_string(soap, "ngwt:started", -1, &(((ngwt__RecipientStatus*)a)->started), "");
	soap_out_string(soap, "ngwt:completed", -1, &(((ngwt__RecipientStatus*)a)->completed), "");
	soap_out_string(soap, "ngwt:incomplete", -1, &(((ngwt__RecipientStatus*)a)->incomplete), "");
	soap_out_PointerTongwt__DelegatedStatus(soap, "ngwt:delegated", -1, &(((ngwt__RecipientStatus*)a)->delegated), "");
	soap_out_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, "ngwt:delegateeStatus", -1, &(((ngwt__RecipientStatus*)a)->delegateeStatus), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__RecipientStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__RecipientStatus(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__RecipientStatus * SOAP_FMAC4 soap_get_ngwt__RecipientStatus(struct soap *soap, ngwt__RecipientStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__RecipientStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__RecipientStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__RecipientStatus(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__RecipientStatus * SOAP_FMAC4 soap_in_ngwt__RecipientStatus(struct soap *soap, const char *tag, ngwt__RecipientStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__RecipientStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__RecipientStatus, sizeof(ngwt__RecipientStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__RecipientStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__RecipientStatus *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_delivered1 = 1, soap_flag_undeliverable1 = 1, soap_flag_transferred1 = 1, soap_flag_transferDelayed1 = 1, soap_flag_transferFailed1 = 1, soap_flag_downloaded1 = 1, soap_flag_downloadedByThirdParty1 = 1, soap_flag_retractRequested1 = 1, soap_flag_retracted1 = 1, soap_flag_opened1 = 1, soap_flag_deleted1 = 1, soap_flag_undeleted1 = 1, soap_flag_purged1 = 1, soap_flag_accepted1 = 1, soap_flag_declined1 = 1, soap_flag_replied1 = 1, soap_flag_forwarded1 = 1, soap_flag_shared1 = 1, soap_flag_started1 = 1, soap_flag_completed1 = 1, soap_flag_incomplete1 = 1, soap_flag_delegated1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_delivered1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__RecipientStatus*)a)->delivered), ""))
				{	soap_flag_delivered1 = 0;
					continue;
				}
			if (soap_flag_undeliverable1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:undeliverable", &(((ngwt__RecipientStatus*)a)->undeliverable), ""))
				{	soap_flag_undeliverable1 = 0;
					continue;
				}
			if (soap_flag_transferred1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:transferred", &(((ngwt__RecipientStatus*)a)->transferred), ""))
				{	soap_flag_transferred1 = 0;
					continue;
				}
			if (soap_flag_transferDelayed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:transferDelayed", &(((ngwt__RecipientStatus*)a)->transferDelayed), ""))
				{	soap_flag_transferDelayed1 = 0;
					continue;
				}
			if (soap_flag_transferFailed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__TransferFailedStatus(soap, "ngwt:transferFailed", &(((ngwt__RecipientStatus*)a)->transferFailed), "ngwt:TransferFailedStatus"))
				{	soap_flag_transferFailed1 = 0;
					continue;
				}
			if (soap_flag_downloaded1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:downloaded", &(((ngwt__RecipientStatus*)a)->downloaded), ""))
				{	soap_flag_downloaded1 = 0;
					continue;
				}
			if (soap_flag_downloadedByThirdParty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:downloadedByThirdParty", &(((ngwt__RecipientStatus*)a)->downloadedByThirdParty), ""))
				{	soap_flag_downloadedByThirdParty1 = 0;
					continue;
				}
			if (soap_flag_retractRequested1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:retractRequested", &(((ngwt__RecipientStatus*)a)->retractRequested), ""))
				{	soap_flag_retractRequested1 = 0;
					continue;
				}
			if (soap_flag_retracted1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:retracted", &(((ngwt__RecipientStatus*)a)->retracted), ""))
				{	soap_flag_retracted1 = 0;
					continue;
				}
			if (soap_flag_opened1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:opened", &(((ngwt__RecipientStatus*)a)->opened), ""))
				{	soap_flag_opened1 = 0;
					continue;
				}
			if (soap_flag_deleted1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:deleted", &(((ngwt__RecipientStatus*)a)->deleted), ""))
				{	soap_flag_deleted1 = 0;
					continue;
				}
			if (soap_flag_undeleted1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:undeleted", &(((ngwt__RecipientStatus*)a)->undeleted), ""))
				{	soap_flag_undeleted1 = 0;
					continue;
				}
			if (soap_flag_purged1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:purged", &(((ngwt__RecipientStatus*)a)->purged), ""))
				{	soap_flag_purged1 = 0;
					continue;
				}
			if (soap_flag_accepted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CommentStatus(soap, "ngwt:accepted", &(((ngwt__RecipientStatus*)a)->accepted), "ngwt:CommentStatus"))
				{	soap_flag_accepted1 = 0;
					continue;
				}
			if (soap_flag_declined1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CommentStatus(soap, "ngwt:declined", &(((ngwt__RecipientStatus*)a)->declined), "ngwt:CommentStatus"))
				{	soap_flag_declined1 = 0;
					continue;
				}
			if (soap_flag_replied1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:replied", &(((ngwt__RecipientStatus*)a)->replied), ""))
				{	soap_flag_replied1 = 0;
					continue;
				}
			if (soap_flag_forwarded1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:forwarded", &(((ngwt__RecipientStatus*)a)->forwarded), ""))
				{	soap_flag_forwarded1 = 0;
					continue;
				}
			if (soap_flag_shared1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:shared", &(((ngwt__RecipientStatus*)a)->shared), ""))
				{	soap_flag_shared1 = 0;
					continue;
				}
			if (soap_flag_started1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:started", &(((ngwt__RecipientStatus*)a)->started), ""))
				{	soap_flag_started1 = 0;
					continue;
				}
			if (soap_flag_completed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:completed", &(((ngwt__RecipientStatus*)a)->completed), ""))
				{	soap_flag_completed1 = 0;
					continue;
				}
			if (soap_flag_incomplete1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:incomplete", &(((ngwt__RecipientStatus*)a)->incomplete), ""))
				{	soap_flag_incomplete1 = 0;
					continue;
				}
			if (soap_flag_delegated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DelegatedStatus(soap, "ngwt:delegated", &(((ngwt__RecipientStatus*)a)->delegated), "ngwt:DelegatedStatus"))
				{	soap_flag_delegated1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, "ngwt:delegateeStatus", &(((ngwt__RecipientStatus*)a)->delegateeStatus), "ngwt:DelegateeStatus"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__RecipientStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RecipientStatus, 0, sizeof(ngwt__RecipientStatus), 0, soap_copy_ngwt__RecipientStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__RecipientStatus * SOAP_FMAC6 soap_new_ngwt__RecipientStatus(struct soap *soap, int n)
{	return soap_instantiate_ngwt__RecipientStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__RecipientStatus(struct soap *soap, ngwt__RecipientStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__RecipientStatus * SOAP_FMAC6 soap_instantiate_ngwt__RecipientStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__RecipientStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__RecipientStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:DelegateeStatus"))
	{	cp->type = SOAP_TYPE_ngwt__DelegateeStatus;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__DelegateeStatus;
			if (size)
				*size = sizeof(ngwt__DelegateeStatus);
			((ngwt__DelegateeStatus*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__DelegateeStatus[n];
			if (size)
				*size = n * sizeof(ngwt__DelegateeStatus);
			for (int i = 0; i < n; i++)
				((ngwt__DelegateeStatus*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__DelegateeStatus*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:TransferFailedStatus"))
	{	cp->type = SOAP_TYPE_ngwt__TransferFailedStatus;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__TransferFailedStatus;
			if (size)
				*size = sizeof(ngwt__TransferFailedStatus);
			((ngwt__TransferFailedStatus*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__TransferFailedStatus[n];
			if (size)
				*size = n * sizeof(ngwt__TransferFailedStatus);
			for (int i = 0; i < n; i++)
				((ngwt__TransferFailedStatus*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__TransferFailedStatus*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__RecipientStatus;
		if (size)
			*size = sizeof(ngwt__RecipientStatus);
		((ngwt__RecipientStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__RecipientStatus[n];
		if (size)
			*size = n * sizeof(ngwt__RecipientStatus);
		for (int i = 0; i < n; i++)
			((ngwt__RecipientStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__RecipientStatus*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__RecipientStatus(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__RecipientStatus %p -> %p\n", q, p));
	*(ngwt__RecipientStatus*)p = *(ngwt__RecipientStatus*)q;
}

void ngwt__RecipientList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Recipient(soap, &((ngwt__RecipientList*)this)->recipient);
	/* transient soap skipped */
}

void ngwt__RecipientList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Recipient(soap, &((ngwt__RecipientList*)this)->recipient);
	/* transient soap skipped */
}

int ngwt__RecipientList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__RecipientList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__RecipientList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__RecipientList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__RecipientList(struct soap *soap, const char *tag, int id, const ngwt__RecipientList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__RecipientList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Recipient(soap, "ngwt:recipient", -1, &(((ngwt__RecipientList*)a)->recipient), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__RecipientList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__RecipientList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__RecipientList * SOAP_FMAC4 soap_get_ngwt__RecipientList(struct soap *soap, ngwt__RecipientList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__RecipientList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__RecipientList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__RecipientList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__RecipientList * SOAP_FMAC4 soap_in_ngwt__RecipientList(struct soap *soap, const char *tag, ngwt__RecipientList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__RecipientList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__RecipientList, sizeof(ngwt__RecipientList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__RecipientList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__RecipientList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Recipient(soap, "ngwt:recipient", &(((ngwt__RecipientList*)a)->recipient), "ngwt:Recipient"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__RecipientList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RecipientList, 0, sizeof(ngwt__RecipientList), 0, soap_copy_ngwt__RecipientList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__RecipientList * SOAP_FMAC6 soap_new_ngwt__RecipientList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__RecipientList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__RecipientList(struct soap *soap, ngwt__RecipientList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__RecipientList * SOAP_FMAC6 soap_instantiate_ngwt__RecipientList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__RecipientList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__RecipientList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__RecipientList;
		if (size)
			*size = sizeof(ngwt__RecipientList);
		((ngwt__RecipientList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__RecipientList[n];
		if (size)
			*size = n * sizeof(ngwt__RecipientList);
		for (int i = 0; i < n; i++)
			((ngwt__RecipientList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__RecipientList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__RecipientList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__RecipientList %p -> %p\n", q, p));
	*(ngwt__RecipientList*)p = *(ngwt__RecipientList*)q;
}

void ngwt__Recipient::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Recipient*)this)->distType, SOAP_TYPE_ngwt__DistributionType);
	soap_embedded(soap, &((ngwt__Recipient*)this)->recipType, SOAP_TYPE_ngwt__RecipientType);
	soap_embedded(soap, &((ngwt__Recipient*)this)->recipientStatus, SOAP_TYPE_PointerTongwt__RecipientStatus);
	soap_serialize_PointerTongwt__RecipientStatus(soap, &((ngwt__Recipient*)this)->recipientStatus);
	soap_embedded(soap, &((ngwt__Recipient*)this)->acceptLevel, SOAP_TYPE_PointerTongwt__AcceptLevel);
	soap_serialize_PointerTongwt__AcceptLevel(soap, &((ngwt__Recipient*)this)->acceptLevel);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->displayName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->email, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ngwt__Recipient::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Recipient*)this)->distType = (enum ngwt__DistributionType)0;
	((ngwt__Recipient*)this)->recipType = (enum ngwt__RecipientType)0;
	((ngwt__Recipient*)this)->recipientStatus = NULL;
	((ngwt__Recipient*)this)->acceptLevel = NULL;
	((ngwt__NameAndEmail*)this)->displayName = NULL;
	((ngwt__NameAndEmail*)this)->email = NULL;
	((ngwt__NameAndEmail*)this)->uuid = NULL;
	/* transient soap skipped */
}

int ngwt__Recipient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Recipient);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Recipient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Recipient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Recipient(struct soap *soap, const char *tag, int id, const ngwt__Recipient *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Recipient), "ngwt:Recipient");
	soap_out_PointerTostd__string(soap, "ngwt:displayName", -1, &(((ngwt__NameAndEmail*)a)->displayName), "");
	soap_out_PointerTostd__string(soap, "ngwt:email", -1, &(((ngwt__NameAndEmail*)a)->email), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__NameAndEmail*)a)->uuid), "");
	/* transient soap skipped */
	soap_out_ngwt__DistributionType(soap, "ngwt:distType", -1, &(((ngwt__Recipient*)a)->distType), "");
	soap_out_ngwt__RecipientType(soap, "ngwt:recipType", -1, &(((ngwt__Recipient*)a)->recipType), "");
	soap_out_PointerTongwt__RecipientStatus(soap, "ngwt:recipientStatus", -1, &(((ngwt__Recipient*)a)->recipientStatus), "");
	soap_out_PointerTongwt__AcceptLevel(soap, "ngwt:acceptLevel", -1, &(((ngwt__Recipient*)a)->acceptLevel), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Recipient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Recipient(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Recipient * SOAP_FMAC4 soap_get_ngwt__Recipient(struct soap *soap, ngwt__Recipient *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Recipient(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Recipient::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Recipient(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Recipient * SOAP_FMAC4 soap_in_ngwt__Recipient(struct soap *soap, const char *tag, ngwt__Recipient *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Recipient *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Recipient, sizeof(ngwt__Recipient), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Recipient)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Recipient *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_displayName2 = 1, soap_flag_email2 = 1, soap_flag_uuid2 = 1, soap_flag_distType1 = 1, soap_flag_recipType1 = 1, soap_flag_recipientStatus1 = 1, soap_flag_acceptLevel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_displayName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:displayName", &(((ngwt__NameAndEmail*)a)->displayName), ""))
				{	soap_flag_displayName2 = 0;
					continue;
				}
			if (soap_flag_email2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:email", &(((ngwt__NameAndEmail*)a)->email), ""))
				{	soap_flag_email2 = 0;
					continue;
				}
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__NameAndEmail*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_distType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__DistributionType(soap, "ngwt:distType", &(((ngwt__Recipient*)a)->distType), ""))
				{	soap_flag_distType1 = 0;
					continue;
				}
			if (soap_flag_recipType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__RecipientType(soap, "ngwt:recipType", &(((ngwt__Recipient*)a)->recipType), ""))
				{	soap_flag_recipType1 = 0;
					continue;
				}
			if (soap_flag_recipientStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecipientStatus(soap, "ngwt:recipientStatus", &(((ngwt__Recipient*)a)->recipientStatus), "ngwt:RecipientStatus"))
				{	soap_flag_recipientStatus1 = 0;
					continue;
				}
			if (soap_flag_acceptLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AcceptLevel(soap, "ngwt:acceptLevel", &(((ngwt__Recipient*)a)->acceptLevel), ""))
				{	soap_flag_acceptLevel1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Recipient *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Recipient, 0, sizeof(ngwt__Recipient), 0, soap_copy_ngwt__Recipient);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Recipient * SOAP_FMAC6 soap_new_ngwt__Recipient(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Recipient(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Recipient(struct soap *soap, ngwt__Recipient *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Recipient * SOAP_FMAC6 soap_instantiate_ngwt__Recipient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Recipient(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Recipient, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Recipient;
		if (size)
			*size = sizeof(ngwt__Recipient);
		((ngwt__Recipient*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Recipient[n];
		if (size)
			*size = n * sizeof(ngwt__Recipient);
		for (int i = 0; i < n; i++)
			((ngwt__Recipient*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Recipient*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Recipient(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Recipient %p -> %p\n", q, p));
	*(ngwt__Recipient*)p = *(ngwt__Recipient*)q;
}

void ngwt__QueryTarget::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__QueryTarget*)this)->source, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__QueryTarget*)this)->source);
	soap_serialize_std__vectorTemplateOfngwt__uid(soap, &((ngwt__QueryTarget*)this)->container);
	/* transient soap skipped */
}

void ngwt__QueryTarget::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__QueryTarget*)this)->source = NULL;
	soap_default_std__vectorTemplateOfngwt__uid(soap, &((ngwt__QueryTarget*)this)->container);
	/* transient soap skipped */
}

int ngwt__QueryTarget::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__QueryTarget);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__QueryTarget::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__QueryTarget(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__QueryTarget(struct soap *soap, const char *tag, int id, const ngwt__QueryTarget *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__QueryTarget), type);
	soap_out_PointerTongwt__uid(soap, "ngwt:source", -1, &(((ngwt__QueryTarget*)a)->source), "");
	soap_out_std__vectorTemplateOfngwt__uid(soap, "ngwt:container", -1, &(((ngwt__QueryTarget*)a)->container), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__QueryTarget::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__QueryTarget(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__QueryTarget * SOAP_FMAC4 soap_get_ngwt__QueryTarget(struct soap *soap, ngwt__QueryTarget *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__QueryTarget(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__QueryTarget::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__QueryTarget(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__QueryTarget * SOAP_FMAC4 soap_in_ngwt__QueryTarget(struct soap *soap, const char *tag, ngwt__QueryTarget *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__QueryTarget *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__QueryTarget, sizeof(ngwt__QueryTarget), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__QueryTarget)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__QueryTarget *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_source1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_source1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:source", &(((ngwt__QueryTarget*)a)->source), "ngwt:uid"))
				{	soap_flag_source1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__uid(soap, "ngwt:container", &(((ngwt__QueryTarget*)a)->container), "ngwt:uid"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__QueryTarget *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__QueryTarget, 0, sizeof(ngwt__QueryTarget), 0, soap_copy_ngwt__QueryTarget);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__QueryTarget * SOAP_FMAC6 soap_new_ngwt__QueryTarget(struct soap *soap, int n)
{	return soap_instantiate_ngwt__QueryTarget(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__QueryTarget(struct soap *soap, ngwt__QueryTarget *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__QueryTarget * SOAP_FMAC6 soap_instantiate_ngwt__QueryTarget(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__QueryTarget(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__QueryTarget, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__QueryTarget;
		if (size)
			*size = sizeof(ngwt__QueryTarget);
		((ngwt__QueryTarget*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__QueryTarget[n];
		if (size)
			*size = n * sizeof(ngwt__QueryTarget);
		for (int i = 0; i < n; i++)
			((ngwt__QueryTarget*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__QueryTarget*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__QueryTarget(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__QueryTarget %p -> %p\n", q, p));
	*(ngwt__QueryTarget*)p = *(ngwt__QueryTarget*)q;
}

void ngwt__QueryFolder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__QueryFolder*)this)->folderType, SOAP_TYPE_PointerTongwt__FolderType);
	soap_serialize_PointerTongwt__FolderType(soap, &((ngwt__QueryFolder*)this)->folderType);
	soap_embedded(soap, &((ngwt__QueryFolder*)this)->query, SOAP_TYPE_PointerTongwt__Query);
	soap_serialize_PointerTongwt__Query(soap, &((ngwt__QueryFolder*)this)->query);
	soap_embedded(soap, &((ngwt__Folder*)this)->parent, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((ngwt__Folder*)this)->parent);
	soap_embedded(soap, &((ngwt__Folder*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Folder*)this)->description);
	soap_embedded(soap, &((ngwt__Folder*)this)->count, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__Folder*)this)->count);
	soap_embedded(soap, &((ngwt__Folder*)this)->hasUnread, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Folder*)this)->hasUnread);
	soap_embedded(soap, &((ngwt__Folder*)this)->unreadCount, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__Folder*)this)->unreadCount);
	soap_embedded(soap, &((ngwt__Folder*)this)->sequence, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Folder*)this)->sequence);
	soap_embedded(soap, &((ngwt__Folder*)this)->settings, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Folder*)this)->settings);
	soap_embedded(soap, &((ngwt__Folder*)this)->calendarAttribute, SOAP_TYPE_PointerTongwt__CalendarFolderAttribute);
	soap_serialize_PointerTongwt__CalendarFolderAttribute(soap, &((ngwt__Folder*)this)->calendarAttribute);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__QueryFolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__QueryFolder*)this)->folderType = NULL;
	((ngwt__QueryFolder*)this)->query = NULL;
	soap_default_ngwt__uid(soap, &((ngwt__Folder*)this)->parent);
	((ngwt__Folder*)this)->description = NULL;
	((ngwt__Folder*)this)->count = NULL;
	((ngwt__Folder*)this)->hasUnread = NULL;
	((ngwt__Folder*)this)->unreadCount = NULL;
	((ngwt__Folder*)this)->sequence = NULL;
	((ngwt__Folder*)this)->settings = NULL;
	((ngwt__Folder*)this)->calendarAttribute = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__QueryFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__QueryFolder);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__QueryFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__QueryFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__QueryFolder(struct soap *soap, const char *tag, int id, const ngwt__QueryFolder *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__QueryFolder), "ngwt:QueryFolder");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_ngwt__uid(soap, "ngwt:parent", -1, &(((ngwt__Folder*)a)->parent), "");
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__Folder*)a)->description), "");
	soap_out_PointerToint(soap, "ngwt:count", -1, &(((ngwt__Folder*)a)->count), "");
	soap_out_PointerTobool(soap, "ngwt:hasUnread", -1, &(((ngwt__Folder*)a)->hasUnread), "");
	soap_out_PointerToint(soap, "ngwt:unreadCount", -1, &(((ngwt__Folder*)a)->unreadCount), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:sequence", -1, &(((ngwt__Folder*)a)->sequence), "");
	soap_out_PointerTongwt__uid(soap, "ngwt:settings", -1, &(((ngwt__Folder*)a)->settings), "");
	soap_out_PointerTongwt__CalendarFolderAttribute(soap, "ngwt:calendarAttribute", -1, &(((ngwt__Folder*)a)->calendarAttribute), "");
	soap_out_PointerTongwt__FolderType(soap, "ngwt:folderType", -1, &(((ngwt__QueryFolder*)a)->folderType), "");
	soap_out_PointerTongwt__Query(soap, "ngwt:query", -1, &(((ngwt__QueryFolder*)a)->query), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__QueryFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__QueryFolder(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__QueryFolder * SOAP_FMAC4 soap_get_ngwt__QueryFolder(struct soap *soap, ngwt__QueryFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__QueryFolder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__QueryFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__QueryFolder(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__QueryFolder * SOAP_FMAC4 soap_in_ngwt__QueryFolder(struct soap *soap, const char *tag, ngwt__QueryFolder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__QueryFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__QueryFolder, sizeof(ngwt__QueryFolder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__QueryFolder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__QueryFolder *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_parent2 = 1, soap_flag_description2 = 1, soap_flag_count2 = 1, soap_flag_hasUnread2 = 1, soap_flag_unreadCount2 = 1, soap_flag_sequence2 = 1, soap_flag_settings2 = 1, soap_flag_calendarAttribute2 = 1, soap_flag_folderType1 = 1, soap_flag_query1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}
			if (soap_flag_name3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name3 = 0;
					continue;
				}
			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}
			if (soap_flag_modified3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}
			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_parent2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwt:parent", &(((ngwt__Folder*)a)->parent), "ngwt:uid"))
				{	soap_flag_parent2 = 0;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__Folder*)a)->description), ""))
				{	soap_flag_description2 = 0;
					continue;
				}
			if (soap_flag_count2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:count", &(((ngwt__Folder*)a)->count), ""))
				{	soap_flag_count2 = 0;
					continue;
				}
			if (soap_flag_hasUnread2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:hasUnread", &(((ngwt__Folder*)a)->hasUnread), ""))
				{	soap_flag_hasUnread2 = 0;
					continue;
				}
			if (soap_flag_unreadCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:unreadCount", &(((ngwt__Folder*)a)->unreadCount), ""))
				{	soap_flag_unreadCount2 = 0;
					continue;
				}
			if (soap_flag_sequence2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:sequence", &(((ngwt__Folder*)a)->sequence), ""))
				{	soap_flag_sequence2 = 0;
					continue;
				}
			if (soap_flag_settings2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:settings", &(((ngwt__Folder*)a)->settings), "ngwt:uid"))
				{	soap_flag_settings2 = 0;
					continue;
				}
			if (soap_flag_calendarAttribute2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CalendarFolderAttribute(soap, "ngwt:calendarAttribute", &(((ngwt__Folder*)a)->calendarAttribute), "ngwt:CalendarFolderAttribute"))
				{	soap_flag_calendarAttribute2 = 0;
					continue;
				}
			if (soap_flag_folderType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FolderType(soap, "ngwt:folderType", &(((ngwt__QueryFolder*)a)->folderType), ""))
				{	soap_flag_folderType1 = 0;
					continue;
				}
			if (soap_flag_query1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Query(soap, "ngwt:query", &(((ngwt__QueryFolder*)a)->query), "ngwt:Query"))
				{	soap_flag_query1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__QueryFolder *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__QueryFolder, 0, sizeof(ngwt__QueryFolder), 0, soap_copy_ngwt__QueryFolder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__QueryFolder * SOAP_FMAC6 soap_new_ngwt__QueryFolder(struct soap *soap, int n)
{	return soap_instantiate_ngwt__QueryFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__QueryFolder(struct soap *soap, ngwt__QueryFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__QueryFolder * SOAP_FMAC6 soap_instantiate_ngwt__QueryFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__QueryFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__QueryFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__QueryFolder;
		if (size)
			*size = sizeof(ngwt__QueryFolder);
		((ngwt__QueryFolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__QueryFolder[n];
		if (size)
			*size = n * sizeof(ngwt__QueryFolder);
		for (int i = 0; i < n; i++)
			((ngwt__QueryFolder*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__QueryFolder*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__QueryFolder(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__QueryFolder %p -> %p\n", q, p));
	*(ngwt__QueryFolder*)p = *(ngwt__QueryFolder*)q;
}

void ngwt__Query::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Query*)this)->target, SOAP_TYPE_PointerTongwt__QueryTarget);
	soap_serialize_PointerTongwt__QueryTarget(soap, &((ngwt__Query*)this)->target);
	soap_embedded(soap, &((ngwt__Query*)this)->filter, SOAP_TYPE_PointerTongwt__Filter);
	soap_serialize_PointerTongwt__Filter(soap, &((ngwt__Query*)this)->filter);
	/* transient soap skipped */
}

void ngwt__Query::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Query*)this)->target = NULL;
	((ngwt__Query*)this)->filter = NULL;
	/* transient soap skipped */
}

int ngwt__Query::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Query);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Query::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Query(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Query(struct soap *soap, const char *tag, int id, const ngwt__Query *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Query), type);
	soap_out_PointerTongwt__QueryTarget(soap, "ngwt:target", -1, &(((ngwt__Query*)a)->target), "");
	soap_out_PointerTongwt__Filter(soap, "ngwt:filter", -1, &(((ngwt__Query*)a)->filter), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Query::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Query(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Query * SOAP_FMAC4 soap_get_ngwt__Query(struct soap *soap, ngwt__Query *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Query(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Query::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Query(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Query * SOAP_FMAC4 soap_in_ngwt__Query(struct soap *soap, const char *tag, ngwt__Query *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Query *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Query, sizeof(ngwt__Query), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Query)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Query *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_target1 = 1, soap_flag_filter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_target1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__QueryTarget(soap, "ngwt:target", &(((ngwt__Query*)a)->target), "ngwt:QueryTarget"))
				{	soap_flag_target1 = 0;
					continue;
				}
			if (soap_flag_filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Filter(soap, "ngwt:filter", &(((ngwt__Query*)a)->filter), "ngwt:Filter"))
				{	soap_flag_filter1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_target1 || soap_flag_filter1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Query *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Query, 0, sizeof(ngwt__Query), 0, soap_copy_ngwt__Query);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Query * SOAP_FMAC6 soap_new_ngwt__Query(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Query(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Query(struct soap *soap, ngwt__Query *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Query * SOAP_FMAC6 soap_instantiate_ngwt__Query(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Query(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Query, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Query;
		if (size)
			*size = sizeof(ngwt__Query);
		((ngwt__Query*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Query[n];
		if (size)
			*size = n * sizeof(ngwt__Query);
		for (int i = 0; i < n; i++)
			((ngwt__Query*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Query*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Query(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Query %p -> %p\n", q, p));
	*(ngwt__Query*)p = *(ngwt__Query*)q;
}

void ngwt__ProxyList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__ProxyUser(soap, &((ngwt__ProxyList*)this)->proxy);
	/* transient soap skipped */
}

void ngwt__ProxyList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__ProxyUser(soap, &((ngwt__ProxyList*)this)->proxy);
	/* transient soap skipped */
}

int ngwt__ProxyList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ProxyList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ProxyList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ProxyList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ProxyList(struct soap *soap, const char *tag, int id, const ngwt__ProxyList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ProxyList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__ProxyUser(soap, "ngwt:proxy", -1, &(((ngwt__ProxyList*)a)->proxy), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ProxyList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ProxyList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ProxyList * SOAP_FMAC4 soap_get_ngwt__ProxyList(struct soap *soap, ngwt__ProxyList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ProxyList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ProxyList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ProxyList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ProxyList * SOAP_FMAC4 soap_in_ngwt__ProxyList(struct soap *soap, const char *tag, ngwt__ProxyList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ProxyList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ProxyList, sizeof(ngwt__ProxyList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ProxyList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ProxyList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ProxyUser(soap, "ngwt:proxy", &(((ngwt__ProxyList*)a)->proxy), "ngwt:ProxyUser"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ProxyList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ProxyList, 0, sizeof(ngwt__ProxyList), 0, soap_copy_ngwt__ProxyList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ProxyList * SOAP_FMAC6 soap_new_ngwt__ProxyList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ProxyList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ProxyList(struct soap *soap, ngwt__ProxyList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ProxyList * SOAP_FMAC6 soap_instantiate_ngwt__ProxyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ProxyList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ProxyList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ProxyList;
		if (size)
			*size = sizeof(ngwt__ProxyList);
		((ngwt__ProxyList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ProxyList[n];
		if (size)
			*size = n * sizeof(ngwt__ProxyList);
		for (int i = 0; i < n; i++)
			((ngwt__ProxyList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ProxyList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ProxyList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ProxyList %p -> %p\n", q, p));
	*(ngwt__ProxyList*)p = *(ngwt__ProxyList*)q;
}

void ngwt__ProxyUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ProxyUser*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__ProxyUser*)this)->id);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->displayName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->email, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ngwt__ProxyUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__ProxyUser*)this)->id = NULL;
	((ngwt__NameAndEmail*)this)->displayName = NULL;
	((ngwt__NameAndEmail*)this)->email = NULL;
	((ngwt__NameAndEmail*)this)->uuid = NULL;
	/* transient soap skipped */
}

int ngwt__ProxyUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ProxyUser);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ProxyUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ProxyUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ProxyUser(struct soap *soap, const char *tag, int id, const ngwt__ProxyUser *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ProxyUser), "ngwt:ProxyUser");
	soap_out_PointerTostd__string(soap, "ngwt:displayName", -1, &(((ngwt__NameAndEmail*)a)->displayName), "");
	soap_out_PointerTostd__string(soap, "ngwt:email", -1, &(((ngwt__NameAndEmail*)a)->email), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__NameAndEmail*)a)->uuid), "");
	/* transient soap skipped */
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__ProxyUser*)a)->id), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ProxyUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ProxyUser(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ProxyUser * SOAP_FMAC4 soap_get_ngwt__ProxyUser(struct soap *soap, ngwt__ProxyUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ProxyUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ProxyUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ProxyUser(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ProxyUser * SOAP_FMAC4 soap_in_ngwt__ProxyUser(struct soap *soap, const char *tag, ngwt__ProxyUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ProxyUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ProxyUser, sizeof(ngwt__ProxyUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ProxyUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ProxyUser *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_displayName2 = 1, soap_flag_email2 = 1, soap_flag_uuid2 = 1, soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_displayName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:displayName", &(((ngwt__NameAndEmail*)a)->displayName), ""))
				{	soap_flag_displayName2 = 0;
					continue;
				}
			if (soap_flag_email2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:email", &(((ngwt__NameAndEmail*)a)->email), ""))
				{	soap_flag_email2 = 0;
					continue;
				}
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__NameAndEmail*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__ProxyUser*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ProxyUser *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ProxyUser, 0, sizeof(ngwt__ProxyUser), 0, soap_copy_ngwt__ProxyUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ProxyUser * SOAP_FMAC6 soap_new_ngwt__ProxyUser(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ProxyUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ProxyUser(struct soap *soap, ngwt__ProxyUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ProxyUser * SOAP_FMAC6 soap_instantiate_ngwt__ProxyUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ProxyUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ProxyUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ProxyUser;
		if (size)
			*size = sizeof(ngwt__ProxyUser);
		((ngwt__ProxyUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ProxyUser[n];
		if (size)
			*size = n * sizeof(ngwt__ProxyUser);
		for (int i = 0; i < n; i++)
			((ngwt__ProxyUser*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ProxyUser*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ProxyUser(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ProxyUser %p -> %p\n", q, p));
	*(ngwt__ProxyUser*)p = *(ngwt__ProxyUser*)q;
}

void ngwt__Proxy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Proxy*)this)->username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__Proxy*)this)->username);
	soap_embedded(soap, &((ngwt__Proxy*)this)->password, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Proxy*)this)->password);
	soap_embedded(soap, &((ngwt__Proxy*)this)->proxy, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__Proxy*)this)->proxy);
	/* transient soap skipped */
}

void ngwt__Proxy::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwt__Proxy*)this)->username);
	((ngwt__Proxy*)this)->password = NULL;
	soap_default_std__string(soap, &((ngwt__Proxy*)this)->proxy);
	/* transient soap skipped */
}

int ngwt__Proxy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Proxy);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Proxy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Proxy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Proxy(struct soap *soap, const char *tag, int id, const ngwt__Proxy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Proxy), "ngwt:Proxy");
	/* transient soap skipped */
	soap_out_std__string(soap, "ngwt:username", -1, &(((ngwt__Proxy*)a)->username), "");
	soap_out_PointerTostd__string(soap, "ngwt:password", -1, &(((ngwt__Proxy*)a)->password), "");
	soap_out_std__string(soap, "ngwt:proxy", -1, &(((ngwt__Proxy*)a)->proxy), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Proxy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Proxy(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Proxy * SOAP_FMAC4 soap_get_ngwt__Proxy(struct soap *soap, ngwt__Proxy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Proxy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Proxy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Proxy(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Proxy * SOAP_FMAC4 soap_in_ngwt__Proxy(struct soap *soap, const char *tag, ngwt__Proxy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Proxy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Proxy, sizeof(ngwt__Proxy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Proxy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Proxy *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_username1 = 1, soap_flag_password1 = 1, soap_flag_proxy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:username", &(((ngwt__Proxy*)a)->username), ""))
				{	soap_flag_username1 = 0;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:password", &(((ngwt__Proxy*)a)->password), ""))
				{	soap_flag_password1 = 0;
					continue;
				}
			if (soap_flag_proxy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:proxy", &(((ngwt__Proxy*)a)->proxy), ""))
				{	soap_flag_proxy1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_username1 || soap_flag_proxy1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Proxy *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Proxy, 0, sizeof(ngwt__Proxy), 0, soap_copy_ngwt__Proxy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Proxy * SOAP_FMAC6 soap_new_ngwt__Proxy(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Proxy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Proxy(struct soap *soap, ngwt__Proxy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Proxy * SOAP_FMAC6 soap_instantiate_ngwt__Proxy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Proxy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Proxy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Proxy;
		if (size)
			*size = sizeof(ngwt__Proxy);
		((ngwt__Proxy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Proxy[n];
		if (size)
			*size = n * sizeof(ngwt__Proxy);
		for (int i = 0; i < n; i++)
			((ngwt__Proxy*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Proxy*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Proxy(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Proxy %p -> %p\n", q, p));
	*(ngwt__Proxy*)p = *(ngwt__Proxy*)q;
}

void ngwt__ProblemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__ProblemEntry(soap, &((ngwt__ProblemList*)this)->entry);
	/* transient soap skipped */
}

void ngwt__ProblemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__ProblemEntry(soap, &((ngwt__ProblemList*)this)->entry);
	/* transient soap skipped */
}

int ngwt__ProblemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ProblemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ProblemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ProblemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ProblemList(struct soap *soap, const char *tag, int id, const ngwt__ProblemList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ProblemList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__ProblemEntry(soap, "ngwt:entry", -1, &(((ngwt__ProblemList*)a)->entry), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ProblemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ProblemList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ProblemList * SOAP_FMAC4 soap_get_ngwt__ProblemList(struct soap *soap, ngwt__ProblemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ProblemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ProblemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ProblemList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ProblemList * SOAP_FMAC4 soap_in_ngwt__ProblemList(struct soap *soap, const char *tag, ngwt__ProblemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ProblemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ProblemList, sizeof(ngwt__ProblemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ProblemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ProblemList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ProblemEntry(soap, "ngwt:entry", &(((ngwt__ProblemList*)a)->entry), "ngwt:ProblemEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ProblemList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ProblemList, 0, sizeof(ngwt__ProblemList), 0, soap_copy_ngwt__ProblemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ProblemList * SOAP_FMAC6 soap_new_ngwt__ProblemList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ProblemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ProblemList(struct soap *soap, ngwt__ProblemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ProblemList * SOAP_FMAC6 soap_instantiate_ngwt__ProblemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ProblemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ProblemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ProblemList;
		if (size)
			*size = sizeof(ngwt__ProblemList);
		((ngwt__ProblemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ProblemList[n];
		if (size)
			*size = n * sizeof(ngwt__ProblemList);
		for (int i = 0; i < n; i++)
			((ngwt__ProblemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ProblemList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ProblemList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ProblemList %p -> %p\n", q, p));
	*(ngwt__ProblemList*)p = *(ngwt__ProblemList*)q;
}

void ngwt__ProblemEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ProblemEntry*)this)->element, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__ProblemEntry*)this)->element);
	soap_embedded(soap, &((ngwt__ProblemEntry*)this)->code, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__ProblemEntry*)this)->code);
	soap_embedded(soap, &((ngwt__ProblemEntry*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__ProblemEntry*)this)->description);
	/* transient soap skipped */
}

void ngwt__ProblemEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__ProblemEntry*)this)->element = NULL;
	((ngwt__ProblemEntry*)this)->code = NULL;
	((ngwt__ProblemEntry*)this)->description = NULL;
	/* transient soap skipped */
}

int ngwt__ProblemEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ProblemEntry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ProblemEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ProblemEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ProblemEntry(struct soap *soap, const char *tag, int id, const ngwt__ProblemEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ProblemEntry), type);
	soap_out_PointerTostd__string(soap, "ngwt:element", -1, &(((ngwt__ProblemEntry*)a)->element), "");
	soap_out_PointerToint(soap, "ngwt:code", -1, &(((ngwt__ProblemEntry*)a)->code), "");
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__ProblemEntry*)a)->description), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ProblemEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ProblemEntry(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ProblemEntry * SOAP_FMAC4 soap_get_ngwt__ProblemEntry(struct soap *soap, ngwt__ProblemEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ProblemEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ProblemEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ProblemEntry(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ProblemEntry * SOAP_FMAC4 soap_in_ngwt__ProblemEntry(struct soap *soap, const char *tag, ngwt__ProblemEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ProblemEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ProblemEntry, sizeof(ngwt__ProblemEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ProblemEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ProblemEntry *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_element1 = 1, soap_flag_code1 = 1, soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_element1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:element", &(((ngwt__ProblemEntry*)a)->element), ""))
				{	soap_flag_element1 = 0;
					continue;
				}
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:code", &(((ngwt__ProblemEntry*)a)->code), ""))
				{	soap_flag_code1 = 0;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__ProblemEntry*)a)->description), ""))
				{	soap_flag_description1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ProblemEntry *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ProblemEntry, 0, sizeof(ngwt__ProblemEntry), 0, soap_copy_ngwt__ProblemEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ProblemEntry * SOAP_FMAC6 soap_new_ngwt__ProblemEntry(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ProblemEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ProblemEntry(struct soap *soap, ngwt__ProblemEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ProblemEntry * SOAP_FMAC6 soap_instantiate_ngwt__ProblemEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ProblemEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ProblemEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ProblemEntry;
		if (size)
			*size = sizeof(ngwt__ProblemEntry);
		((ngwt__ProblemEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ProblemEntry[n];
		if (size)
			*size = n * sizeof(ngwt__ProblemEntry);
		for (int i = 0; i < n; i++)
			((ngwt__ProblemEntry*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ProblemEntry*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ProblemEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ProblemEntry %p -> %p\n", q, p));
	*(ngwt__ProblemEntry*)p = *(ngwt__ProblemEntry*)q;
}

void ngwt__PostalAddressList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__PostalAddress(soap, &((ngwt__PostalAddressList*)this)->address);
	/* transient soap skipped */
}

void ngwt__PostalAddressList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__PostalAddress(soap, &((ngwt__PostalAddressList*)this)->address);
	/* transient soap skipped */
}

int ngwt__PostalAddressList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__PostalAddressList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__PostalAddressList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__PostalAddressList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__PostalAddressList(struct soap *soap, const char *tag, int id, const ngwt__PostalAddressList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__PostalAddressList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__PostalAddress(soap, "ngwt:address", -1, &(((ngwt__PostalAddressList*)a)->address), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__PostalAddressList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__PostalAddressList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__PostalAddressList * SOAP_FMAC4 soap_get_ngwt__PostalAddressList(struct soap *soap, ngwt__PostalAddressList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__PostalAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__PostalAddressList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__PostalAddressList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__PostalAddressList * SOAP_FMAC4 soap_in_ngwt__PostalAddressList(struct soap *soap, const char *tag, ngwt__PostalAddressList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__PostalAddressList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__PostalAddressList, sizeof(ngwt__PostalAddressList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__PostalAddressList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__PostalAddressList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__PostalAddress(soap, "ngwt:address", &(((ngwt__PostalAddressList*)a)->address), "ngwt:PostalAddress"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__PostalAddressList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PostalAddressList, 0, sizeof(ngwt__PostalAddressList), 0, soap_copy_ngwt__PostalAddressList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__PostalAddressList * SOAP_FMAC6 soap_new_ngwt__PostalAddressList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__PostalAddressList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__PostalAddressList(struct soap *soap, ngwt__PostalAddressList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__PostalAddressList * SOAP_FMAC6 soap_instantiate_ngwt__PostalAddressList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__PostalAddressList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__PostalAddressList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__PostalAddressList;
		if (size)
			*size = sizeof(ngwt__PostalAddressList);
		((ngwt__PostalAddressList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__PostalAddressList[n];
		if (size)
			*size = n * sizeof(ngwt__PostalAddressList);
		for (int i = 0; i < n; i++)
			((ngwt__PostalAddressList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__PostalAddressList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__PostalAddressList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__PostalAddressList %p -> %p\n", q, p));
	*(ngwt__PostalAddressList*)p = *(ngwt__PostalAddressList*)q;
}

void ngwt__PostalAddress::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__PostalAddress*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PostalAddress*)this)->description);
	soap_embedded(soap, &((ngwt__PostalAddress*)this)->streetAddress, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PostalAddress*)this)->streetAddress);
	soap_embedded(soap, &((ngwt__PostalAddress*)this)->location, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PostalAddress*)this)->location);
	soap_embedded(soap, &((ngwt__PostalAddress*)this)->city, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PostalAddress*)this)->city);
	soap_embedded(soap, &((ngwt__PostalAddress*)this)->state, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PostalAddress*)this)->state);
	soap_embedded(soap, &((ngwt__PostalAddress*)this)->postalCode, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PostalAddress*)this)->postalCode);
	soap_embedded(soap, &((ngwt__PostalAddress*)this)->country, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PostalAddress*)this)->country);
	/* transient soap skipped */
}

void ngwt__PostalAddress::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__PostalAddress*)this)->description = NULL;
	((ngwt__PostalAddress*)this)->streetAddress = NULL;
	((ngwt__PostalAddress*)this)->location = NULL;
	((ngwt__PostalAddress*)this)->city = NULL;
	((ngwt__PostalAddress*)this)->state = NULL;
	((ngwt__PostalAddress*)this)->postalCode = NULL;
	((ngwt__PostalAddress*)this)->country = NULL;
	soap_default_ngwt__PostalAddressType(soap, &((ngwt__PostalAddress*)this)->type);
	/* transient soap skipped */
}

int ngwt__PostalAddress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__PostalAddress);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__PostalAddress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__PostalAddress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__PostalAddress(struct soap *soap, const char *tag, int id, const ngwt__PostalAddress *a, const char *type)
{
	soap_set_attr(soap, "type", soap_ngwt__PostalAddressType2s(soap, ((ngwt__PostalAddress *)a)->type));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__PostalAddress), type);
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__PostalAddress*)a)->description), "");
	soap_out_PointerTostd__string(soap, "ngwt:streetAddress", -1, &(((ngwt__PostalAddress*)a)->streetAddress), "");
	soap_out_PointerTostd__string(soap, "ngwt:location", -1, &(((ngwt__PostalAddress*)a)->location), "");
	soap_out_PointerTostd__string(soap, "ngwt:city", -1, &(((ngwt__PostalAddress*)a)->city), "");
	soap_out_PointerTostd__string(soap, "ngwt:state", -1, &(((ngwt__PostalAddress*)a)->state), "");
	soap_out_PointerTostd__string(soap, "ngwt:postalCode", -1, &(((ngwt__PostalAddress*)a)->postalCode), "");
	soap_out_PointerTostd__string(soap, "ngwt:country", -1, &(((ngwt__PostalAddress*)a)->country), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__PostalAddress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__PostalAddress(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__PostalAddress * SOAP_FMAC4 soap_get_ngwt__PostalAddress(struct soap *soap, ngwt__PostalAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__PostalAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__PostalAddress::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__PostalAddress(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__PostalAddress * SOAP_FMAC4 soap_in_ngwt__PostalAddress(struct soap *soap, const char *tag, ngwt__PostalAddress *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__PostalAddress *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__PostalAddress, sizeof(ngwt__PostalAddress), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__PostalAddress)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__PostalAddress *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2ngwt__PostalAddressType(soap, soap_attr_value(soap, "type", 1), &((ngwt__PostalAddress *)a)->type))
		return NULL;
	short soap_flag_description1 = 1, soap_flag_streetAddress1 = 1, soap_flag_location1 = 1, soap_flag_city1 = 1, soap_flag_state1 = 1, soap_flag_postalCode1 = 1, soap_flag_country1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__PostalAddress*)a)->description), ""))
				{	soap_flag_description1 = 0;
					continue;
				}
			if (soap_flag_streetAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:streetAddress", &(((ngwt__PostalAddress*)a)->streetAddress), ""))
				{	soap_flag_streetAddress1 = 0;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:location", &(((ngwt__PostalAddress*)a)->location), ""))
				{	soap_flag_location1 = 0;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:city", &(((ngwt__PostalAddress*)a)->city), ""))
				{	soap_flag_city1 = 0;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:state", &(((ngwt__PostalAddress*)a)->state), ""))
				{	soap_flag_state1 = 0;
					continue;
				}
			if (soap_flag_postalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:postalCode", &(((ngwt__PostalAddress*)a)->postalCode), ""))
				{	soap_flag_postalCode1 = 0;
					continue;
				}
			if (soap_flag_country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:country", &(((ngwt__PostalAddress*)a)->country), ""))
				{	soap_flag_country1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__PostalAddress *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PostalAddress, 0, sizeof(ngwt__PostalAddress), 0, soap_copy_ngwt__PostalAddress);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__PostalAddress * SOAP_FMAC6 soap_new_ngwt__PostalAddress(struct soap *soap, int n)
{	return soap_instantiate_ngwt__PostalAddress(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__PostalAddress(struct soap *soap, ngwt__PostalAddress *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__PostalAddress * SOAP_FMAC6 soap_instantiate_ngwt__PostalAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__PostalAddress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__PostalAddress, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__PostalAddress;
		if (size)
			*size = sizeof(ngwt__PostalAddress);
		((ngwt__PostalAddress*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__PostalAddress[n];
		if (size)
			*size = n * sizeof(ngwt__PostalAddress);
		for (int i = 0; i < n; i++)
			((ngwt__PostalAddress*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__PostalAddress*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__PostalAddress(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__PostalAddress %p -> %p\n", q, p));
	*(ngwt__PostalAddress*)p = *(ngwt__PostalAddress*)q;
}

void ngwt__PlainText::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__PlainText*)this)->username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__PlainText*)this)->username);
	soap_embedded(soap, &((ngwt__PlainText*)this)->password, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PlainText*)this)->password);
	/* transient soap skipped */
}

void ngwt__PlainText::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwt__PlainText*)this)->username);
	((ngwt__PlainText*)this)->password = NULL;
	/* transient soap skipped */
}

int ngwt__PlainText::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__PlainText);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__PlainText::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__PlainText(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__PlainText(struct soap *soap, const char *tag, int id, const ngwt__PlainText *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__PlainText), "ngwt:PlainText");
	/* transient soap skipped */
	soap_out_std__string(soap, "ngwt:username", -1, &(((ngwt__PlainText*)a)->username), "");
	soap_out_PointerTostd__string(soap, "ngwt:password", -1, &(((ngwt__PlainText*)a)->password), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__PlainText::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__PlainText(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__PlainText * SOAP_FMAC4 soap_get_ngwt__PlainText(struct soap *soap, ngwt__PlainText *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__PlainText(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__PlainText::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__PlainText(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__PlainText * SOAP_FMAC4 soap_in_ngwt__PlainText(struct soap *soap, const char *tag, ngwt__PlainText *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__PlainText *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__PlainText, sizeof(ngwt__PlainText), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__PlainText)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__PlainText *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_username1 = 1, soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:username", &(((ngwt__PlainText*)a)->username), ""))
				{	soap_flag_username1 = 0;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:password", &(((ngwt__PlainText*)a)->password), ""))
				{	soap_flag_password1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_username1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__PlainText *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PlainText, 0, sizeof(ngwt__PlainText), 0, soap_copy_ngwt__PlainText);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__PlainText * SOAP_FMAC6 soap_new_ngwt__PlainText(struct soap *soap, int n)
{	return soap_instantiate_ngwt__PlainText(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__PlainText(struct soap *soap, ngwt__PlainText *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__PlainText * SOAP_FMAC6 soap_instantiate_ngwt__PlainText(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__PlainText(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__PlainText, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__PlainText;
		if (size)
			*size = sizeof(ngwt__PlainText);
		((ngwt__PlainText*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__PlainText[n];
		if (size)
			*size = n * sizeof(ngwt__PlainText);
		for (int i = 0; i < n; i++)
			((ngwt__PlainText*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__PlainText*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__PlainText(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__PlainText %p -> %p\n", q, p));
	*(ngwt__PlainText*)p = *(ngwt__PlainText*)q;
}

void ngwt__PhoneNumber::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__PhoneNumber*)this)->__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__PhoneNumber*)this)->__item);
	/* transient soap skipped */
}

void ngwt__PhoneNumber::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwt__PhoneNumber*)this)->__item);
	soap_default_ngwt__PhoneNumberType(soap, &((ngwt__PhoneNumber*)this)->type);
	/* transient soap skipped */
}

int ngwt__PhoneNumber::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__PhoneNumber);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__PhoneNumber::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__PhoneNumber(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__PhoneNumber(struct soap *soap, const char *tag, int id, const ngwt__PhoneNumber *a, const char *type)
{
	soap_set_attr(soap, "type", soap_ngwt__PhoneNumberType2s(soap, ((ngwt__PhoneNumber *)a)->type));
	soap_out_std__string(soap, tag, id, &(((ngwt__PhoneNumber*)a)->__item), "");
	return SOAP_OK;
}

void *ngwt__PhoneNumber::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__PhoneNumber(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__PhoneNumber * SOAP_FMAC4 soap_get_ngwt__PhoneNumber(struct soap *soap, ngwt__PhoneNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__PhoneNumber(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__PhoneNumber::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__PhoneNumber(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__PhoneNumber * SOAP_FMAC4 soap_in_ngwt__PhoneNumber(struct soap *soap, const char *tag, ngwt__PhoneNumber *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ngwt__PhoneNumber *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__PhoneNumber, sizeof(ngwt__PhoneNumber), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__PhoneNumber)
			return (ngwt__PhoneNumber *)a->soap_in(soap, tag, type);
	}
	if (soap_s2ngwt__PhoneNumberType(soap, soap_attr_value(soap, "type", 1), &((ngwt__PhoneNumber *)a)->type))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(((ngwt__PhoneNumber*)a)->__item), "ngwt:PhoneNumber"))
		return NULL;
	return a;
}

SOAP_FMAC5 ngwt__PhoneNumber * SOAP_FMAC6 soap_new_ngwt__PhoneNumber(struct soap *soap, int n)
{	return soap_instantiate_ngwt__PhoneNumber(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__PhoneNumber(struct soap *soap, ngwt__PhoneNumber *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__PhoneNumber * SOAP_FMAC6 soap_instantiate_ngwt__PhoneNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__PhoneNumber(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__PhoneNumber, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__PhoneNumber;
		if (size)
			*size = sizeof(ngwt__PhoneNumber);
		((ngwt__PhoneNumber*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__PhoneNumber[n];
		if (size)
			*size = n * sizeof(ngwt__PhoneNumber);
		for (int i = 0; i < n; i++)
			((ngwt__PhoneNumber*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__PhoneNumber*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__PhoneNumber(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__PhoneNumber %p -> %p\n", q, p));
	*(ngwt__PhoneNumber*)p = *(ngwt__PhoneNumber*)q;
}

void ngwt__PhoneMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__PhoneMessage*)this)->caller, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PhoneMessage*)this)->caller);
	soap_embedded(soap, &((ngwt__PhoneMessage*)this)->company, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PhoneMessage*)this)->company);
	soap_embedded(soap, &((ngwt__PhoneMessage*)this)->phone, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PhoneMessage*)this)->phone);
	soap_embedded(soap, &((ngwt__PhoneMessage*)this)->flags, SOAP_TYPE_PointerTongwt__PhoneFlags);
	soap_serialize_PointerTongwt__PhoneFlags(soap, &((ngwt__PhoneMessage*)this)->flags);
	soap_embedded(soap, &((ngwt__Mail*)this)->subject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subject);
	soap_embedded(soap, &((ngwt__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ngwt__Mail*)this)->subjectPrefix, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subjectPrefix);
	soap_embedded(soap, &((ngwt__Mail*)this)->distribution, SOAP_TYPE_PointerTongwt__Distribution);
	soap_serialize_PointerTongwt__Distribution(soap, &((ngwt__Mail*)this)->distribution);
	soap_embedded(soap, &((ngwt__Mail*)this)->message, SOAP_TYPE_PointerTongwt__MessageBody);
	soap_serialize_PointerTongwt__MessageBody(soap, &((ngwt__Mail*)this)->message);
	soap_embedded(soap, &((ngwt__Mail*)this)->attachments, SOAP_TYPE_PointerTongwt__AttachmentInfo);
	soap_serialize_PointerTongwt__AttachmentInfo(soap, &((ngwt__Mail*)this)->attachments);
	soap_embedded(soap, &((ngwt__Mail*)this)->options, SOAP_TYPE_PointerTongwt__ItemOptions);
	soap_serialize_PointerTongwt__ItemOptions(soap, &((ngwt__Mail*)this)->options);
	soap_embedded(soap, &((ngwt__Mail*)this)->link, SOAP_TYPE_PointerTongwt__LinkInfo);
	soap_serialize_PointerTongwt__LinkInfo(soap, &((ngwt__Mail*)this)->link);
	soap_embedded(soap, &((ngwt__Mail*)this)->hasAttachment, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwt__Mail*)this)->size, SOAP_TYPE_int);
	soap_embedded(soap, &((ngwt__Mail*)this)->subType, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subType);
	soap_embedded(soap, &((ngwt__Mail*)this)->nntpOrImap, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Mail*)this)->nntpOrImap);
	soap_embedded(soap, &((ngwt__Mail*)this)->smimeType, SOAP_TYPE_PointerTongwt__SMimeOperation);
	soap_serialize_PointerTongwt__SMimeOperation(soap, &((ngwt__Mail*)this)->smimeType);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->status, SOAP_TYPE_PointerTongwt__ItemStatus);
	soap_serialize_PointerTongwt__ItemStatus(soap, &((ngwt__BoxEntry*)this)->status);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->msgId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->msgId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->messageId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->messageId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->source, SOAP_TYPE_PointerTongwt__ItemSource);
	soap_serialize_PointerTongwt__ItemSource(soap, &((ngwt__BoxEntry*)this)->source);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->class_, SOAP_TYPE_PointerTongwt__ItemClass);
	soap_serialize_PointerTongwt__ItemClass(soap, &((ngwt__BoxEntry*)this)->class_);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->security, SOAP_TYPE_PointerTongwt__ItemSecurity);
	soap_serialize_PointerTongwt__ItemSecurity(soap, &((ngwt__BoxEntry*)this)->security);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->comment);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__PhoneMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__PhoneMessage*)this)->caller = NULL;
	((ngwt__PhoneMessage*)this)->company = NULL;
	((ngwt__PhoneMessage*)this)->phone = NULL;
	((ngwt__PhoneMessage*)this)->flags = NULL;
	((ngwt__Mail*)this)->subject = NULL;
	((ngwt__Mail*)this)->originalSubject = NULL;
	((ngwt__Mail*)this)->subjectPrefix = NULL;
	((ngwt__Mail*)this)->distribution = NULL;
	((ngwt__Mail*)this)->message = NULL;
	((ngwt__Mail*)this)->attachments = NULL;
	((ngwt__Mail*)this)->options = NULL;
	((ngwt__Mail*)this)->link = NULL;
	((ngwt__Mail*)this)->hasAttachment = (bool)0;
	((ngwt__Mail*)this)->size = 0;
	((ngwt__Mail*)this)->subType = NULL;
	((ngwt__Mail*)this)->nntpOrImap = NULL;
	((ngwt__Mail*)this)->smimeType = NULL;
	((ngwt__BoxEntry*)this)->status = NULL;
	((ngwt__BoxEntry*)this)->thread = NULL;
	((ngwt__BoxEntry*)this)->msgId = NULL;
	((ngwt__BoxEntry*)this)->messageId = NULL;
	((ngwt__BoxEntry*)this)->source = NULL;
	((ngwt__BoxEntry*)this)->returnSentItemsId = NULL;
	soap_default_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	((ngwt__BoxEntry*)this)->class_ = NULL;
	((ngwt__BoxEntry*)this)->security = NULL;
	((ngwt__BoxEntry*)this)->comment = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__PhoneMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__PhoneMessage);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__PhoneMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__PhoneMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__PhoneMessage(struct soap *soap, const char *tag, int id, const ngwt__PhoneMessage *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__PhoneMessage), "ngwt:PhoneMessage");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__ItemStatus(soap, "ngwt:status", -1, &(((ngwt__BoxEntry*)a)->status), "");
	soap_out_PointerTostd__string(soap, "ngwt:thread", -1, &(((ngwt__BoxEntry*)a)->thread), "");
	soap_out_PointerTostd__string(soap, "ngwt:msgId", -1, &(((ngwt__BoxEntry*)a)->msgId), "");
	soap_out_PointerTostd__string(soap, "ngwt:messageId", -1, &(((ngwt__BoxEntry*)a)->messageId), "");
	soap_out_PointerTongwt__ItemSource(soap, "ngwt:source", -1, &(((ngwt__BoxEntry*)a)->source), "");
	soap_out_PointerTobool(soap, "ngwt:returnSentItemsId", -1, &(((ngwt__BoxEntry*)a)->returnSentItemsId), "");
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__BoxEntry*)a)->delivered), "");
	soap_out_PointerTongwt__ItemClass(soap, "ngwt:class", -1, &(((ngwt__BoxEntry*)a)->class_), "");
	soap_out_PointerTongwt__ItemSecurity(soap, "ngwt:security", -1, &(((ngwt__BoxEntry*)a)->security), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__BoxEntry*)a)->comment), "");
	soap_out_PointerTostd__string(soap, "ngwt:subject", -1, &(((ngwt__Mail*)a)->subject), "");
	soap_out_PointerTostd__string(soap, "ngwt:originalSubject", -1, &(((ngwt__Mail*)a)->originalSubject), "");
	soap_out_PointerTostd__string(soap, "ngwt:subjectPrefix", -1, &(((ngwt__Mail*)a)->subjectPrefix), "");
	soap_out_PointerTongwt__Distribution(soap, "ngwt:distribution", -1, &(((ngwt__Mail*)a)->distribution), "");
	soap_out_PointerTongwt__MessageBody(soap, "ngwt:message", -1, &(((ngwt__Mail*)a)->message), "");
	soap_out_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", -1, &(((ngwt__Mail*)a)->attachments), "");
	soap_out_PointerTongwt__ItemOptions(soap, "ngwt:options", -1, &(((ngwt__Mail*)a)->options), "");
	soap_out_PointerTongwt__LinkInfo(soap, "ngwt:link", -1, &(((ngwt__Mail*)a)->link), "");
	soap_out_bool(soap, "ngwt:hasAttachment", -1, &(((ngwt__Mail*)a)->hasAttachment), "");
	soap_out_int(soap, "ngwt:size", -1, &(((ngwt__Mail*)a)->size), "");
	soap_out_PointerTostd__string(soap, "ngwt:subType", -1, &(((ngwt__Mail*)a)->subType), "");
	soap_out_PointerTobool(soap, "ngwt:nntpOrImap", -1, &(((ngwt__Mail*)a)->nntpOrImap), "");
	soap_out_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", -1, &(((ngwt__Mail*)a)->smimeType), "");
	soap_out_PointerTostd__string(soap, "ngwt:caller", -1, &(((ngwt__PhoneMessage*)a)->caller), "");
	soap_out_PointerTostd__string(soap, "ngwt:company", -1, &(((ngwt__PhoneMessage*)a)->company), "");
	soap_out_PointerTostd__string(soap, "ngwt:phone", -1, &(((ngwt__PhoneMessage*)a)->phone), "");
	soap_out_PointerTongwt__PhoneFlags(soap, "ngwt:flags", -1, &(((ngwt__PhoneMessage*)a)->flags), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__PhoneMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__PhoneMessage(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__PhoneMessage * SOAP_FMAC4 soap_get_ngwt__PhoneMessage(struct soap *soap, ngwt__PhoneMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__PhoneMessage(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__PhoneMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__PhoneMessage(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__PhoneMessage * SOAP_FMAC4 soap_in_ngwt__PhoneMessage(struct soap *soap, const char *tag, ngwt__PhoneMessage *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__PhoneMessage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__PhoneMessage, sizeof(ngwt__PhoneMessage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__PhoneMessage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__PhoneMessage *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id5 = 1, soap_flag_name5 = 1, soap_flag_version5 = 1, soap_flag_modified5 = 1, soap_flag_changes5 = 1, soap_flag_categories4 = 1, soap_flag_created4 = 1, soap_flag_customs4 = 1, soap_flag_status3 = 1, soap_flag_thread3 = 1, soap_flag_msgId3 = 1, soap_flag_messageId3 = 1, soap_flag_source3 = 1, soap_flag_returnSentItemsId3 = 1, soap_flag_delivered3 = 1, soap_flag_class_3 = 1, soap_flag_security3 = 1, soap_flag_comment3 = 1, soap_flag_subject2 = 1, soap_flag_originalSubject2 = 1, soap_flag_subjectPrefix2 = 1, soap_flag_distribution2 = 1, soap_flag_message2 = 1, soap_flag_attachments2 = 1, soap_flag_options2 = 1, soap_flag_link2 = 1, soap_flag_hasAttachment2 = 1, soap_flag_size2 = 1, soap_flag_subType2 = 1, soap_flag_nntpOrImap2 = 1, soap_flag_smimeType2 = 1, soap_flag_caller1 = 1, soap_flag_company1 = 1, soap_flag_phone1 = 1, soap_flag_flags1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id5 = 0;
					continue;
				}
			if (soap_flag_name5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name5 = 0;
					continue;
				}
			if (soap_flag_version5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version5 = 0;
					continue;
				}
			if (soap_flag_modified5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified5 = 0;
					continue;
				}
			if (soap_flag_changes5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes5 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories4 = 0;
					continue;
				}
			if (soap_flag_created4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created4 = 0;
					continue;
				}
			if (soap_flag_customs4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs4 = 0;
					continue;
				}
			if (soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemStatus(soap, "ngwt:status", &(((ngwt__BoxEntry*)a)->status), "ngwt:ItemStatus"))
				{	soap_flag_status3 = 0;
					continue;
				}
			if (soap_flag_thread3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:thread", &(((ngwt__BoxEntry*)a)->thread), ""))
				{	soap_flag_thread3 = 0;
					continue;
				}
			if (soap_flag_msgId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:msgId", &(((ngwt__BoxEntry*)a)->msgId), ""))
				{	soap_flag_msgId3 = 0;
					continue;
				}
			if (soap_flag_messageId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:messageId", &(((ngwt__BoxEntry*)a)->messageId), ""))
				{	soap_flag_messageId3 = 0;
					continue;
				}
			if (soap_flag_source3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSource(soap, "ngwt:source", &(((ngwt__BoxEntry*)a)->source), ""))
				{	soap_flag_source3 = 0;
					continue;
				}
			if (soap_flag_returnSentItemsId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:returnSentItemsId", &(((ngwt__BoxEntry*)a)->returnSentItemsId), ""))
				{	soap_flag_returnSentItemsId3 = 0;
					continue;
				}
			if (soap_flag_delivered3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered3 = 0;
					continue;
				}
			if (soap_flag_class_3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemClass(soap, "ngwt:class", &(((ngwt__BoxEntry*)a)->class_), ""))
				{	soap_flag_class_3 = 0;
					continue;
				}
			if (soap_flag_security3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSecurity(soap, "ngwt:security", &(((ngwt__BoxEntry*)a)->security), ""))
				{	soap_flag_security3 = 0;
					continue;
				}
			if (soap_flag_comment3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__BoxEntry*)a)->comment), ""))
				{	soap_flag_comment3 = 0;
					continue;
				}
			if (soap_flag_subject2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subject", &(((ngwt__Mail*)a)->subject), ""))
				{	soap_flag_subject2 = 0;
					continue;
				}
			if (soap_flag_originalSubject2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:originalSubject", &(((ngwt__Mail*)a)->originalSubject), ""))
				{	soap_flag_originalSubject2 = 0;
					continue;
				}
			if (soap_flag_subjectPrefix2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subjectPrefix", &(((ngwt__Mail*)a)->subjectPrefix), ""))
				{	soap_flag_subjectPrefix2 = 0;
					continue;
				}
			if (soap_flag_distribution2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Distribution(soap, "ngwt:distribution", &(((ngwt__Mail*)a)->distribution), "ngwt:Distribution"))
				{	soap_flag_distribution2 = 0;
					continue;
				}
			if (soap_flag_message2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessageBody(soap, "ngwt:message", &(((ngwt__Mail*)a)->message), "ngwt:MessageBody"))
				{	soap_flag_message2 = 0;
					continue;
				}
			if (soap_flag_attachments2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", &(((ngwt__Mail*)a)->attachments), "ngwt:AttachmentInfo"))
				{	soap_flag_attachments2 = 0;
					continue;
				}
			if (soap_flag_options2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemOptions(soap, "ngwt:options", &(((ngwt__Mail*)a)->options), "ngwt:ItemOptions"))
				{	soap_flag_options2 = 0;
					continue;
				}
			if (soap_flag_link2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__LinkInfo(soap, "ngwt:link", &(((ngwt__Mail*)a)->link), "ngwt:LinkInfo"))
				{	soap_flag_link2 = 0;
					continue;
				}
			if (soap_flag_hasAttachment2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:hasAttachment", &(((ngwt__Mail*)a)->hasAttachment), ""))
				{	soap_flag_hasAttachment2 = 0;
					continue;
				}
			if (soap_flag_size2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:size", &(((ngwt__Mail*)a)->size), ""))
				{	soap_flag_size2 = 0;
					continue;
				}
			if (soap_flag_subType2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subType", &(((ngwt__Mail*)a)->subType), ""))
				{	soap_flag_subType2 = 0;
					continue;
				}
			if (soap_flag_nntpOrImap2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:nntpOrImap", &(((ngwt__Mail*)a)->nntpOrImap), ""))
				{	soap_flag_nntpOrImap2 = 0;
					continue;
				}
			if (soap_flag_smimeType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", &(((ngwt__Mail*)a)->smimeType), "ngwt:SMimeOperation"))
				{	soap_flag_smimeType2 = 0;
					continue;
				}
			if (soap_flag_caller1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:caller", &(((ngwt__PhoneMessage*)a)->caller), ""))
				{	soap_flag_caller1 = 0;
					continue;
				}
			if (soap_flag_company1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:company", &(((ngwt__PhoneMessage*)a)->company), ""))
				{	soap_flag_company1 = 0;
					continue;
				}
			if (soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:phone", &(((ngwt__PhoneMessage*)a)->phone), ""))
				{	soap_flag_phone1 = 0;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__PhoneFlags(soap, "ngwt:flags", &(((ngwt__PhoneMessage*)a)->flags), "ngwt:PhoneFlags"))
				{	soap_flag_flags1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_delivered3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__PhoneMessage *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PhoneMessage, 0, sizeof(ngwt__PhoneMessage), 0, soap_copy_ngwt__PhoneMessage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__PhoneMessage * SOAP_FMAC6 soap_new_ngwt__PhoneMessage(struct soap *soap, int n)
{	return soap_instantiate_ngwt__PhoneMessage(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__PhoneMessage(struct soap *soap, ngwt__PhoneMessage *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__PhoneMessage * SOAP_FMAC6 soap_instantiate_ngwt__PhoneMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__PhoneMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__PhoneMessage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__PhoneMessage;
		if (size)
			*size = sizeof(ngwt__PhoneMessage);
		((ngwt__PhoneMessage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__PhoneMessage[n];
		if (size)
			*size = n * sizeof(ngwt__PhoneMessage);
		for (int i = 0; i < n; i++)
			((ngwt__PhoneMessage*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__PhoneMessage*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__PhoneMessage(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__PhoneMessage %p -> %p\n", q, p));
	*(ngwt__PhoneMessage*)p = *(ngwt__PhoneMessage*)q;
}

void ngwt__PhoneList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__PhoneNumber(soap, &((ngwt__PhoneList*)this)->phone);
	/* transient soap skipped */
}

void ngwt__PhoneList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__PhoneNumber(soap, &((ngwt__PhoneList*)this)->phone);
	((ngwt__PhoneList*)this)->default_ = NULL;
	/* transient soap skipped */
}

int ngwt__PhoneList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__PhoneList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__PhoneList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__PhoneList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__PhoneList(struct soap *soap, const char *tag, int id, const ngwt__PhoneList *a, const char *type)
{
	if (((ngwt__PhoneList *)a)->default_)
		soap_set_attr(soap, "default", ((ngwt__PhoneList *)a)->default_->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__PhoneList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__PhoneNumber(soap, "ngwt:phone", -1, &(((ngwt__PhoneList*)a)->phone), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__PhoneList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__PhoneList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__PhoneList * SOAP_FMAC4 soap_get_ngwt__PhoneList(struct soap *soap, ngwt__PhoneList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__PhoneList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__PhoneList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__PhoneList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__PhoneList * SOAP_FMAC4 soap_in_ngwt__PhoneList(struct soap *soap, const char *tag, ngwt__PhoneList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__PhoneList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__PhoneList, sizeof(ngwt__PhoneList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__PhoneList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__PhoneList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "default", 0);
		if (t)
		{	if (!(((ngwt__PhoneList *)a)->default_ = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__PhoneList *)a)->default_ = soap_new_std__string(soap, -1);
			((ngwt__PhoneList *)a)->default_->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__PhoneNumber(soap, "ngwt:phone", &(((ngwt__PhoneList*)a)->phone), "ngwt:PhoneNumber"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__PhoneList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PhoneList, 0, sizeof(ngwt__PhoneList), 0, soap_copy_ngwt__PhoneList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__PhoneList * SOAP_FMAC6 soap_new_ngwt__PhoneList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__PhoneList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__PhoneList(struct soap *soap, ngwt__PhoneList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__PhoneList * SOAP_FMAC6 soap_instantiate_ngwt__PhoneList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__PhoneList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__PhoneList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__PhoneList;
		if (size)
			*size = sizeof(ngwt__PhoneList);
		((ngwt__PhoneList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__PhoneList[n];
		if (size)
			*size = n * sizeof(ngwt__PhoneList);
		for (int i = 0; i < n; i++)
			((ngwt__PhoneList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__PhoneList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__PhoneList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__PhoneList %p -> %p\n", q, p));
	*(ngwt__PhoneList*)p = *(ngwt__PhoneList*)q;
}

void ngwt__PhoneFlags::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__PhoneFlags*)this)->called, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__PhoneFlags*)this)->called);
	soap_embedded(soap, &((ngwt__PhoneFlags*)this)->pleaseCall, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__PhoneFlags*)this)->pleaseCall);
	soap_embedded(soap, &((ngwt__PhoneFlags*)this)->willCall, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__PhoneFlags*)this)->willCall);
	soap_embedded(soap, &((ngwt__PhoneFlags*)this)->returnedYourCall, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__PhoneFlags*)this)->returnedYourCall);
	soap_embedded(soap, &((ngwt__PhoneFlags*)this)->wantsToSeeYou, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__PhoneFlags*)this)->wantsToSeeYou);
	soap_embedded(soap, &((ngwt__PhoneFlags*)this)->cameToSeeYou, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__PhoneFlags*)this)->cameToSeeYou);
	soap_embedded(soap, &((ngwt__PhoneFlags*)this)->urgent, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__PhoneFlags*)this)->urgent);
	/* transient soap skipped */
}

void ngwt__PhoneFlags::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__PhoneFlags*)this)->called = NULL;
	((ngwt__PhoneFlags*)this)->pleaseCall = NULL;
	((ngwt__PhoneFlags*)this)->willCall = NULL;
	((ngwt__PhoneFlags*)this)->returnedYourCall = NULL;
	((ngwt__PhoneFlags*)this)->wantsToSeeYou = NULL;
	((ngwt__PhoneFlags*)this)->cameToSeeYou = NULL;
	((ngwt__PhoneFlags*)this)->urgent = NULL;
	/* transient soap skipped */
}

int ngwt__PhoneFlags::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__PhoneFlags);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__PhoneFlags::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__PhoneFlags(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__PhoneFlags(struct soap *soap, const char *tag, int id, const ngwt__PhoneFlags *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__PhoneFlags), type);
	soap_out_PointerTobool(soap, "ngwt:called", -1, &(((ngwt__PhoneFlags*)a)->called), "");
	soap_out_PointerTobool(soap, "ngwt:pleaseCall", -1, &(((ngwt__PhoneFlags*)a)->pleaseCall), "");
	soap_out_PointerTobool(soap, "ngwt:willCall", -1, &(((ngwt__PhoneFlags*)a)->willCall), "");
	soap_out_PointerTobool(soap, "ngwt:returnedYourCall", -1, &(((ngwt__PhoneFlags*)a)->returnedYourCall), "");
	soap_out_PointerTobool(soap, "ngwt:wantsToSeeYou", -1, &(((ngwt__PhoneFlags*)a)->wantsToSeeYou), "");
	soap_out_PointerTobool(soap, "ngwt:cameToSeeYou", -1, &(((ngwt__PhoneFlags*)a)->cameToSeeYou), "");
	soap_out_PointerTobool(soap, "ngwt:urgent", -1, &(((ngwt__PhoneFlags*)a)->urgent), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__PhoneFlags::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__PhoneFlags(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__PhoneFlags * SOAP_FMAC4 soap_get_ngwt__PhoneFlags(struct soap *soap, ngwt__PhoneFlags *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__PhoneFlags(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__PhoneFlags::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__PhoneFlags(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__PhoneFlags * SOAP_FMAC4 soap_in_ngwt__PhoneFlags(struct soap *soap, const char *tag, ngwt__PhoneFlags *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__PhoneFlags *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__PhoneFlags, sizeof(ngwt__PhoneFlags), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__PhoneFlags)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__PhoneFlags *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_called1 = 1, soap_flag_pleaseCall1 = 1, soap_flag_willCall1 = 1, soap_flag_returnedYourCall1 = 1, soap_flag_wantsToSeeYou1 = 1, soap_flag_cameToSeeYou1 = 1, soap_flag_urgent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_called1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:called", &(((ngwt__PhoneFlags*)a)->called), ""))
				{	soap_flag_called1 = 0;
					continue;
				}
			if (soap_flag_pleaseCall1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:pleaseCall", &(((ngwt__PhoneFlags*)a)->pleaseCall), ""))
				{	soap_flag_pleaseCall1 = 0;
					continue;
				}
			if (soap_flag_willCall1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:willCall", &(((ngwt__PhoneFlags*)a)->willCall), ""))
				{	soap_flag_willCall1 = 0;
					continue;
				}
			if (soap_flag_returnedYourCall1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:returnedYourCall", &(((ngwt__PhoneFlags*)a)->returnedYourCall), ""))
				{	soap_flag_returnedYourCall1 = 0;
					continue;
				}
			if (soap_flag_wantsToSeeYou1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:wantsToSeeYou", &(((ngwt__PhoneFlags*)a)->wantsToSeeYou), ""))
				{	soap_flag_wantsToSeeYou1 = 0;
					continue;
				}
			if (soap_flag_cameToSeeYou1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:cameToSeeYou", &(((ngwt__PhoneFlags*)a)->cameToSeeYou), ""))
				{	soap_flag_cameToSeeYou1 = 0;
					continue;
				}
			if (soap_flag_urgent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:urgent", &(((ngwt__PhoneFlags*)a)->urgent), ""))
				{	soap_flag_urgent1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__PhoneFlags *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PhoneFlags, 0, sizeof(ngwt__PhoneFlags), 0, soap_copy_ngwt__PhoneFlags);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__PhoneFlags * SOAP_FMAC6 soap_new_ngwt__PhoneFlags(struct soap *soap, int n)
{	return soap_instantiate_ngwt__PhoneFlags(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__PhoneFlags(struct soap *soap, ngwt__PhoneFlags *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__PhoneFlags * SOAP_FMAC6 soap_instantiate_ngwt__PhoneFlags(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__PhoneFlags(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__PhoneFlags, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__PhoneFlags;
		if (size)
			*size = sizeof(ngwt__PhoneFlags);
		((ngwt__PhoneFlags*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__PhoneFlags[n];
		if (size)
			*size = n * sizeof(ngwt__PhoneFlags);
		for (int i = 0; i < n; i++)
			((ngwt__PhoneFlags*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__PhoneFlags*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__PhoneFlags(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__PhoneFlags %p -> %p\n", q, p));
	*(ngwt__PhoneFlags*)p = *(ngwt__PhoneFlags*)q;
}

void ngwt__PersonalInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__PersonalInfo*)this)->birthday, SOAP_TYPE_PointerToxsd__date);
	soap_serialize_PointerToxsd__date(soap, &((ngwt__PersonalInfo*)this)->birthday);
	soap_embedded(soap, &((ngwt__PersonalInfo*)this)->website, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__PersonalInfo*)this)->website);
	/* transient soap skipped */
}

void ngwt__PersonalInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__PersonalInfo*)this)->birthday = NULL;
	((ngwt__PersonalInfo*)this)->website = NULL;
	/* transient soap skipped */
}

int ngwt__PersonalInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__PersonalInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__PersonalInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__PersonalInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__PersonalInfo(struct soap *soap, const char *tag, int id, const ngwt__PersonalInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__PersonalInfo), type);
	soap_out_PointerToxsd__date(soap, "ngwt:birthday", -1, &(((ngwt__PersonalInfo*)a)->birthday), "");
	soap_out_PointerTostd__string(soap, "ngwt:website", -1, &(((ngwt__PersonalInfo*)a)->website), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__PersonalInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__PersonalInfo(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__PersonalInfo * SOAP_FMAC4 soap_get_ngwt__PersonalInfo(struct soap *soap, ngwt__PersonalInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__PersonalInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__PersonalInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__PersonalInfo(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__PersonalInfo * SOAP_FMAC4 soap_in_ngwt__PersonalInfo(struct soap *soap, const char *tag, ngwt__PersonalInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__PersonalInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__PersonalInfo, sizeof(ngwt__PersonalInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__PersonalInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__PersonalInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_birthday1 = 1, soap_flag_website1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_birthday1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__date(soap, "ngwt:birthday", &(((ngwt__PersonalInfo*)a)->birthday), "xsd:date"))
				{	soap_flag_birthday1 = 0;
					continue;
				}
			if (soap_flag_website1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:website", &(((ngwt__PersonalInfo*)a)->website), ""))
				{	soap_flag_website1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__PersonalInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PersonalInfo, 0, sizeof(ngwt__PersonalInfo), 0, soap_copy_ngwt__PersonalInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__PersonalInfo * SOAP_FMAC6 soap_new_ngwt__PersonalInfo(struct soap *soap, int n)
{	return soap_instantiate_ngwt__PersonalInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__PersonalInfo(struct soap *soap, ngwt__PersonalInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__PersonalInfo * SOAP_FMAC6 soap_instantiate_ngwt__PersonalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__PersonalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__PersonalInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__PersonalInfo;
		if (size)
			*size = sizeof(ngwt__PersonalInfo);
		((ngwt__PersonalInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__PersonalInfo[n];
		if (size)
			*size = n * sizeof(ngwt__PersonalInfo);
		for (int i = 0; i < n; i++)
			((ngwt__PersonalInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__PersonalInfo*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__PersonalInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__PersonalInfo %p -> %p\n", q, p));
	*(ngwt__PersonalInfo*)p = *(ngwt__PersonalInfo*)q;
}

void ngwt__Organization::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Organization*)this)->contact, SOAP_TYPE_PointerTongwt__ItemRef);
	soap_serialize_PointerTongwt__ItemRef(soap, &((ngwt__Organization*)this)->contact);
	soap_embedded(soap, &((ngwt__Organization*)this)->phone, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Organization*)this)->phone);
	soap_embedded(soap, &((ngwt__Organization*)this)->fax, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Organization*)this)->fax);
	soap_embedded(soap, &((ngwt__Organization*)this)->address, SOAP_TYPE_PointerTongwt__PostalAddress);
	soap_serialize_PointerTongwt__PostalAddress(soap, &((ngwt__Organization*)this)->address);
	soap_embedded(soap, &((ngwt__Organization*)this)->website, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Organization*)this)->website);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__AddressBookItem*)this)->uuid);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->comment);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->sync, SOAP_TYPE_PointerTongwt__DeltaSyncType);
	soap_serialize_PointerTongwt__DeltaSyncType(soap, &((ngwt__AddressBookItem*)this)->sync);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->domain, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->domain);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->postOffice, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->postOffice);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->distinguishedName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->distinguishedName);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->userid, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->userid);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Organization::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Organization*)this)->contact = NULL;
	((ngwt__Organization*)this)->phone = NULL;
	((ngwt__Organization*)this)->fax = NULL;
	((ngwt__Organization*)this)->address = NULL;
	((ngwt__Organization*)this)->website = NULL;
	((ngwt__AddressBookItem*)this)->uuid = NULL;
	((ngwt__AddressBookItem*)this)->comment = NULL;
	((ngwt__AddressBookItem*)this)->sync = NULL;
	((ngwt__AddressBookItem*)this)->domain = NULL;
	((ngwt__AddressBookItem*)this)->postOffice = NULL;
	((ngwt__AddressBookItem*)this)->distinguishedName = NULL;
	((ngwt__AddressBookItem*)this)->userid = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Organization::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Organization);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Organization::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Organization(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Organization(struct soap *soap, const char *tag, int id, const ngwt__Organization *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Organization), "ngwt:Organization");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__AddressBookItem*)a)->uuid), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__AddressBookItem*)a)->comment), "");
	soap_out_PointerTongwt__DeltaSyncType(soap, "ngwt:sync", -1, &(((ngwt__AddressBookItem*)a)->sync), "");
	soap_out_PointerTostd__string(soap, "ngwt:domain", -1, &(((ngwt__AddressBookItem*)a)->domain), "");
	soap_out_PointerTostd__string(soap, "ngwt:postOffice", -1, &(((ngwt__AddressBookItem*)a)->postOffice), "");
	soap_out_PointerTostd__string(soap, "ngwt:distinguishedName", -1, &(((ngwt__AddressBookItem*)a)->distinguishedName), "");
	soap_out_PointerTostd__string(soap, "ngwt:userid", -1, &(((ngwt__AddressBookItem*)a)->userid), "");
	soap_out_PointerTongwt__ItemRef(soap, "ngwt:contact", -1, &(((ngwt__Organization*)a)->contact), "");
	soap_out_PointerTostd__string(soap, "ngwt:phone", -1, &(((ngwt__Organization*)a)->phone), "");
	soap_out_PointerTostd__string(soap, "ngwt:fax", -1, &(((ngwt__Organization*)a)->fax), "");
	soap_out_PointerTongwt__PostalAddress(soap, "ngwt:address", -1, &(((ngwt__Organization*)a)->address), "");
	soap_out_PointerTostd__string(soap, "ngwt:website", -1, &(((ngwt__Organization*)a)->website), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Organization::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Organization(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Organization * SOAP_FMAC4 soap_get_ngwt__Organization(struct soap *soap, ngwt__Organization *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Organization(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Organization::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Organization(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Organization * SOAP_FMAC4 soap_in_ngwt__Organization(struct soap *soap, const char *tag, ngwt__Organization *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Organization *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Organization, sizeof(ngwt__Organization), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Organization)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Organization *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_categories3 = 1, soap_flag_created3 = 1, soap_flag_customs3 = 1, soap_flag_uuid2 = 1, soap_flag_comment2 = 1, soap_flag_sync2 = 1, soap_flag_domain2 = 1, soap_flag_postOffice2 = 1, soap_flag_distinguishedName2 = 1, soap_flag_userid2 = 1, soap_flag_contact1 = 1, soap_flag_phone1 = 1, soap_flag_fax1 = 1, soap_flag_address1 = 1, soap_flag_website1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}
			if (soap_flag_name4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name4 = 0;
					continue;
				}
			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}
			if (soap_flag_modified4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}
			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories3 = 0;
					continue;
				}
			if (soap_flag_created3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created3 = 0;
					continue;
				}
			if (soap_flag_customs3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs3 = 0;
					continue;
				}
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__AddressBookItem*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}
			if (soap_flag_comment2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__AddressBookItem*)a)->comment), ""))
				{	soap_flag_comment2 = 0;
					continue;
				}
			if (soap_flag_sync2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DeltaSyncType(soap, "ngwt:sync", &(((ngwt__AddressBookItem*)a)->sync), ""))
				{	soap_flag_sync2 = 0;
					continue;
				}
			if (soap_flag_domain2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:domain", &(((ngwt__AddressBookItem*)a)->domain), ""))
				{	soap_flag_domain2 = 0;
					continue;
				}
			if (soap_flag_postOffice2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:postOffice", &(((ngwt__AddressBookItem*)a)->postOffice), ""))
				{	soap_flag_postOffice2 = 0;
					continue;
				}
			if (soap_flag_distinguishedName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:distinguishedName", &(((ngwt__AddressBookItem*)a)->distinguishedName), ""))
				{	soap_flag_distinguishedName2 = 0;
					continue;
				}
			if (soap_flag_userid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:userid", &(((ngwt__AddressBookItem*)a)->userid), ""))
				{	soap_flag_userid2 = 0;
					continue;
				}
			if (soap_flag_contact1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRef(soap, "ngwt:contact", &(((ngwt__Organization*)a)->contact), "ngwt:ItemRef"))
				{	soap_flag_contact1 = 0;
					continue;
				}
			if (soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:phone", &(((ngwt__Organization*)a)->phone), ""))
				{	soap_flag_phone1 = 0;
					continue;
				}
			if (soap_flag_fax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:fax", &(((ngwt__Organization*)a)->fax), ""))
				{	soap_flag_fax1 = 0;
					continue;
				}
			if (soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__PostalAddress(soap, "ngwt:address", &(((ngwt__Organization*)a)->address), "ngwt:PostalAddress"))
				{	soap_flag_address1 = 0;
					continue;
				}
			if (soap_flag_website1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:website", &(((ngwt__Organization*)a)->website), ""))
				{	soap_flag_website1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Organization *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Organization, 0, sizeof(ngwt__Organization), 0, soap_copy_ngwt__Organization);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Organization * SOAP_FMAC6 soap_new_ngwt__Organization(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Organization(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Organization(struct soap *soap, ngwt__Organization *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Organization * SOAP_FMAC6 soap_instantiate_ngwt__Organization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Organization(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Organization, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Organization;
		if (size)
			*size = sizeof(ngwt__Organization);
		((ngwt__Organization*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Organization[n];
		if (size)
			*size = n * sizeof(ngwt__Organization);
		for (int i = 0; i < n; i++)
			((ngwt__Organization*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Organization*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Organization(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Organization %p -> %p\n", q, p));
	*(ngwt__Organization*)p = *(ngwt__Organization*)q;
}

void ngwt__OfficeInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__OfficeInfo*)this)->organization, SOAP_TYPE_PointerTongwt__ItemRef);
	soap_serialize_PointerTongwt__ItemRef(soap, &((ngwt__OfficeInfo*)this)->organization);
	soap_embedded(soap, &((ngwt__OfficeInfo*)this)->department, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__OfficeInfo*)this)->department);
	soap_embedded(soap, &((ngwt__OfficeInfo*)this)->title, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__OfficeInfo*)this)->title);
	soap_embedded(soap, &((ngwt__OfficeInfo*)this)->website, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__OfficeInfo*)this)->website);
	/* transient soap skipped */
}

void ngwt__OfficeInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__OfficeInfo*)this)->organization = NULL;
	((ngwt__OfficeInfo*)this)->department = NULL;
	((ngwt__OfficeInfo*)this)->title = NULL;
	((ngwt__OfficeInfo*)this)->website = NULL;
	/* transient soap skipped */
}

int ngwt__OfficeInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__OfficeInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__OfficeInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__OfficeInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__OfficeInfo(struct soap *soap, const char *tag, int id, const ngwt__OfficeInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__OfficeInfo), type);
	soap_out_PointerTongwt__ItemRef(soap, "ngwt:organization", -1, &(((ngwt__OfficeInfo*)a)->organization), "");
	soap_out_PointerTostd__string(soap, "ngwt:department", -1, &(((ngwt__OfficeInfo*)a)->department), "");
	soap_out_PointerTostd__string(soap, "ngwt:title", -1, &(((ngwt__OfficeInfo*)a)->title), "");
	soap_out_PointerTostd__string(soap, "ngwt:website", -1, &(((ngwt__OfficeInfo*)a)->website), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__OfficeInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__OfficeInfo(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__OfficeInfo * SOAP_FMAC4 soap_get_ngwt__OfficeInfo(struct soap *soap, ngwt__OfficeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__OfficeInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__OfficeInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__OfficeInfo(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__OfficeInfo * SOAP_FMAC4 soap_in_ngwt__OfficeInfo(struct soap *soap, const char *tag, ngwt__OfficeInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__OfficeInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__OfficeInfo, sizeof(ngwt__OfficeInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__OfficeInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__OfficeInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_organization1 = 1, soap_flag_department1 = 1, soap_flag_title1 = 1, soap_flag_website1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_organization1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemRef(soap, "ngwt:organization", &(((ngwt__OfficeInfo*)a)->organization), "ngwt:ItemRef"))
				{	soap_flag_organization1 = 0;
					continue;
				}
			if (soap_flag_department1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:department", &(((ngwt__OfficeInfo*)a)->department), ""))
				{	soap_flag_department1 = 0;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:title", &(((ngwt__OfficeInfo*)a)->title), ""))
				{	soap_flag_title1 = 0;
					continue;
				}
			if (soap_flag_website1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:website", &(((ngwt__OfficeInfo*)a)->website), ""))
				{	soap_flag_website1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__OfficeInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__OfficeInfo, 0, sizeof(ngwt__OfficeInfo), 0, soap_copy_ngwt__OfficeInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__OfficeInfo * SOAP_FMAC6 soap_new_ngwt__OfficeInfo(struct soap *soap, int n)
{	return soap_instantiate_ngwt__OfficeInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__OfficeInfo(struct soap *soap, ngwt__OfficeInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__OfficeInfo * SOAP_FMAC6 soap_instantiate_ngwt__OfficeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__OfficeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__OfficeInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__OfficeInfo;
		if (size)
			*size = sizeof(ngwt__OfficeInfo);
		((ngwt__OfficeInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__OfficeInfo[n];
		if (size)
			*size = n * sizeof(ngwt__OfficeInfo);
		for (int i = 0; i < n; i++)
			((ngwt__OfficeInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__OfficeInfo*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__OfficeInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__OfficeInfo %p -> %p\n", q, p));
	*(ngwt__OfficeInfo*)p = *(ngwt__OfficeInfo*)q;
}

void ngwt__Note::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Note*)this)->startDate, SOAP_TYPE_PointerToxsd__date);
	soap_serialize_PointerToxsd__date(soap, &((ngwt__Note*)this)->startDate);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->rdate, SOAP_TYPE_PointerTongwt__RecurrenceDateType);
	soap_serialize_PointerTongwt__RecurrenceDateType(soap, &((ngwt__CalendarItem*)this)->rdate);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->rrule, SOAP_TYPE_PointerTongwt__RecurrenceRule);
	soap_serialize_PointerTongwt__RecurrenceRule(soap, &((ngwt__CalendarItem*)this)->rrule);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->exdate, SOAP_TYPE_PointerTongwt__RecurrenceDateType);
	soap_serialize_PointerTongwt__RecurrenceDateType(soap, &((ngwt__CalendarItem*)this)->exdate);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->recurrenceKey, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__CalendarItem*)this)->recurrenceKey);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->iCalId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__CalendarItem*)this)->iCalId);
	soap_embedded(soap, &((ngwt__Mail*)this)->subject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subject);
	soap_embedded(soap, &((ngwt__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ngwt__Mail*)this)->subjectPrefix, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subjectPrefix);
	soap_embedded(soap, &((ngwt__Mail*)this)->distribution, SOAP_TYPE_PointerTongwt__Distribution);
	soap_serialize_PointerTongwt__Distribution(soap, &((ngwt__Mail*)this)->distribution);
	soap_embedded(soap, &((ngwt__Mail*)this)->message, SOAP_TYPE_PointerTongwt__MessageBody);
	soap_serialize_PointerTongwt__MessageBody(soap, &((ngwt__Mail*)this)->message);
	soap_embedded(soap, &((ngwt__Mail*)this)->attachments, SOAP_TYPE_PointerTongwt__AttachmentInfo);
	soap_serialize_PointerTongwt__AttachmentInfo(soap, &((ngwt__Mail*)this)->attachments);
	soap_embedded(soap, &((ngwt__Mail*)this)->options, SOAP_TYPE_PointerTongwt__ItemOptions);
	soap_serialize_PointerTongwt__ItemOptions(soap, &((ngwt__Mail*)this)->options);
	soap_embedded(soap, &((ngwt__Mail*)this)->link, SOAP_TYPE_PointerTongwt__LinkInfo);
	soap_serialize_PointerTongwt__LinkInfo(soap, &((ngwt__Mail*)this)->link);
	soap_embedded(soap, &((ngwt__Mail*)this)->hasAttachment, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwt__Mail*)this)->size, SOAP_TYPE_int);
	soap_embedded(soap, &((ngwt__Mail*)this)->subType, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subType);
	soap_embedded(soap, &((ngwt__Mail*)this)->nntpOrImap, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Mail*)this)->nntpOrImap);
	soap_embedded(soap, &((ngwt__Mail*)this)->smimeType, SOAP_TYPE_PointerTongwt__SMimeOperation);
	soap_serialize_PointerTongwt__SMimeOperation(soap, &((ngwt__Mail*)this)->smimeType);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->status, SOAP_TYPE_PointerTongwt__ItemStatus);
	soap_serialize_PointerTongwt__ItemStatus(soap, &((ngwt__BoxEntry*)this)->status);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->msgId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->msgId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->messageId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->messageId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->source, SOAP_TYPE_PointerTongwt__ItemSource);
	soap_serialize_PointerTongwt__ItemSource(soap, &((ngwt__BoxEntry*)this)->source);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->class_, SOAP_TYPE_PointerTongwt__ItemClass);
	soap_serialize_PointerTongwt__ItemClass(soap, &((ngwt__BoxEntry*)this)->class_);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->security, SOAP_TYPE_PointerTongwt__ItemSecurity);
	soap_serialize_PointerTongwt__ItemSecurity(soap, &((ngwt__BoxEntry*)this)->security);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->comment);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Note::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Note*)this)->startDate = NULL;
	((ngwt__CalendarItem*)this)->rdate = NULL;
	((ngwt__CalendarItem*)this)->rrule = NULL;
	((ngwt__CalendarItem*)this)->exdate = NULL;
	((ngwt__CalendarItem*)this)->recurrenceKey = NULL;
	((ngwt__CalendarItem*)this)->iCalId = NULL;
	((ngwt__Mail*)this)->subject = NULL;
	((ngwt__Mail*)this)->originalSubject = NULL;
	((ngwt__Mail*)this)->subjectPrefix = NULL;
	((ngwt__Mail*)this)->distribution = NULL;
	((ngwt__Mail*)this)->message = NULL;
	((ngwt__Mail*)this)->attachments = NULL;
	((ngwt__Mail*)this)->options = NULL;
	((ngwt__Mail*)this)->link = NULL;
	((ngwt__Mail*)this)->hasAttachment = (bool)0;
	((ngwt__Mail*)this)->size = 0;
	((ngwt__Mail*)this)->subType = NULL;
	((ngwt__Mail*)this)->nntpOrImap = NULL;
	((ngwt__Mail*)this)->smimeType = NULL;
	((ngwt__BoxEntry*)this)->status = NULL;
	((ngwt__BoxEntry*)this)->thread = NULL;
	((ngwt__BoxEntry*)this)->msgId = NULL;
	((ngwt__BoxEntry*)this)->messageId = NULL;
	((ngwt__BoxEntry*)this)->source = NULL;
	((ngwt__BoxEntry*)this)->returnSentItemsId = NULL;
	soap_default_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	((ngwt__BoxEntry*)this)->class_ = NULL;
	((ngwt__BoxEntry*)this)->security = NULL;
	((ngwt__BoxEntry*)this)->comment = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Note::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Note);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Note::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Note(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Note(struct soap *soap, const char *tag, int id, const ngwt__Note *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Note), "ngwt:Note");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__ItemStatus(soap, "ngwt:status", -1, &(((ngwt__BoxEntry*)a)->status), "");
	soap_out_PointerTostd__string(soap, "ngwt:thread", -1, &(((ngwt__BoxEntry*)a)->thread), "");
	soap_out_PointerTostd__string(soap, "ngwt:msgId", -1, &(((ngwt__BoxEntry*)a)->msgId), "");
	soap_out_PointerTostd__string(soap, "ngwt:messageId", -1, &(((ngwt__BoxEntry*)a)->messageId), "");
	soap_out_PointerTongwt__ItemSource(soap, "ngwt:source", -1, &(((ngwt__BoxEntry*)a)->source), "");
	soap_out_PointerTobool(soap, "ngwt:returnSentItemsId", -1, &(((ngwt__BoxEntry*)a)->returnSentItemsId), "");
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__BoxEntry*)a)->delivered), "");
	soap_out_PointerTongwt__ItemClass(soap, "ngwt:class", -1, &(((ngwt__BoxEntry*)a)->class_), "");
	soap_out_PointerTongwt__ItemSecurity(soap, "ngwt:security", -1, &(((ngwt__BoxEntry*)a)->security), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__BoxEntry*)a)->comment), "");
	soap_out_PointerTostd__string(soap, "ngwt:subject", -1, &(((ngwt__Mail*)a)->subject), "");
	soap_out_PointerTostd__string(soap, "ngwt:originalSubject", -1, &(((ngwt__Mail*)a)->originalSubject), "");
	soap_out_PointerTostd__string(soap, "ngwt:subjectPrefix", -1, &(((ngwt__Mail*)a)->subjectPrefix), "");
	soap_out_PointerTongwt__Distribution(soap, "ngwt:distribution", -1, &(((ngwt__Mail*)a)->distribution), "");
	soap_out_PointerTongwt__MessageBody(soap, "ngwt:message", -1, &(((ngwt__Mail*)a)->message), "");
	soap_out_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", -1, &(((ngwt__Mail*)a)->attachments), "");
	soap_out_PointerTongwt__ItemOptions(soap, "ngwt:options", -1, &(((ngwt__Mail*)a)->options), "");
	soap_out_PointerTongwt__LinkInfo(soap, "ngwt:link", -1, &(((ngwt__Mail*)a)->link), "");
	soap_out_bool(soap, "ngwt:hasAttachment", -1, &(((ngwt__Mail*)a)->hasAttachment), "");
	soap_out_int(soap, "ngwt:size", -1, &(((ngwt__Mail*)a)->size), "");
	soap_out_PointerTostd__string(soap, "ngwt:subType", -1, &(((ngwt__Mail*)a)->subType), "");
	soap_out_PointerTobool(soap, "ngwt:nntpOrImap", -1, &(((ngwt__Mail*)a)->nntpOrImap), "");
	soap_out_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", -1, &(((ngwt__Mail*)a)->smimeType), "");
	soap_out_PointerTongwt__RecurrenceDateType(soap, "ngwt:rdate", -1, &(((ngwt__CalendarItem*)a)->rdate), "");
	soap_out_PointerTongwt__RecurrenceRule(soap, "ngwt:rrule", -1, &(((ngwt__CalendarItem*)a)->rrule), "");
	soap_out_PointerTongwt__RecurrenceDateType(soap, "ngwt:exdate", -1, &(((ngwt__CalendarItem*)a)->exdate), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:recurrenceKey", -1, &(((ngwt__CalendarItem*)a)->recurrenceKey), "");
	soap_out_PointerTostd__string(soap, "ngwt:iCalId", -1, &(((ngwt__CalendarItem*)a)->iCalId), "");
	soap_out_PointerToxsd__date(soap, "ngwt:startDate", -1, &(((ngwt__Note*)a)->startDate), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Note::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Note(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Note * SOAP_FMAC4 soap_get_ngwt__Note(struct soap *soap, ngwt__Note *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Note(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Note::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Note(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Note * SOAP_FMAC4 soap_in_ngwt__Note(struct soap *soap, const char *tag, ngwt__Note *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Note *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Note, sizeof(ngwt__Note), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Note)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Note *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id6 = 1, soap_flag_name6 = 1, soap_flag_version6 = 1, soap_flag_modified6 = 1, soap_flag_changes6 = 1, soap_flag_categories5 = 1, soap_flag_created5 = 1, soap_flag_customs5 = 1, soap_flag_status4 = 1, soap_flag_thread4 = 1, soap_flag_msgId4 = 1, soap_flag_messageId4 = 1, soap_flag_source4 = 1, soap_flag_returnSentItemsId4 = 1, soap_flag_delivered4 = 1, soap_flag_class_4 = 1, soap_flag_security4 = 1, soap_flag_comment4 = 1, soap_flag_subject3 = 1, soap_flag_originalSubject3 = 1, soap_flag_subjectPrefix3 = 1, soap_flag_distribution3 = 1, soap_flag_message3 = 1, soap_flag_attachments3 = 1, soap_flag_options3 = 1, soap_flag_link3 = 1, soap_flag_hasAttachment3 = 1, soap_flag_size3 = 1, soap_flag_subType3 = 1, soap_flag_nntpOrImap3 = 1, soap_flag_smimeType3 = 1, soap_flag_rdate2 = 1, soap_flag_rrule2 = 1, soap_flag_exdate2 = 1, soap_flag_recurrenceKey2 = 1, soap_flag_iCalId2 = 1, soap_flag_startDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id6 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id6 = 0;
					continue;
				}
			if (soap_flag_name6 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name6 = 0;
					continue;
				}
			if (soap_flag_version6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version6 = 0;
					continue;
				}
			if (soap_flag_modified6 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified6 = 0;
					continue;
				}
			if (soap_flag_changes6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes6 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories5 = 0;
					continue;
				}
			if (soap_flag_created5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created5 = 0;
					continue;
				}
			if (soap_flag_customs5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs5 = 0;
					continue;
				}
			if (soap_flag_status4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemStatus(soap, "ngwt:status", &(((ngwt__BoxEntry*)a)->status), "ngwt:ItemStatus"))
				{	soap_flag_status4 = 0;
					continue;
				}
			if (soap_flag_thread4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:thread", &(((ngwt__BoxEntry*)a)->thread), ""))
				{	soap_flag_thread4 = 0;
					continue;
				}
			if (soap_flag_msgId4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:msgId", &(((ngwt__BoxEntry*)a)->msgId), ""))
				{	soap_flag_msgId4 = 0;
					continue;
				}
			if (soap_flag_messageId4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:messageId", &(((ngwt__BoxEntry*)a)->messageId), ""))
				{	soap_flag_messageId4 = 0;
					continue;
				}
			if (soap_flag_source4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSource(soap, "ngwt:source", &(((ngwt__BoxEntry*)a)->source), ""))
				{	soap_flag_source4 = 0;
					continue;
				}
			if (soap_flag_returnSentItemsId4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:returnSentItemsId", &(((ngwt__BoxEntry*)a)->returnSentItemsId), ""))
				{	soap_flag_returnSentItemsId4 = 0;
					continue;
				}
			if (soap_flag_delivered4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered4 = 0;
					continue;
				}
			if (soap_flag_class_4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemClass(soap, "ngwt:class", &(((ngwt__BoxEntry*)a)->class_), ""))
				{	soap_flag_class_4 = 0;
					continue;
				}
			if (soap_flag_security4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSecurity(soap, "ngwt:security", &(((ngwt__BoxEntry*)a)->security), ""))
				{	soap_flag_security4 = 0;
					continue;
				}
			if (soap_flag_comment4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__BoxEntry*)a)->comment), ""))
				{	soap_flag_comment4 = 0;
					continue;
				}
			if (soap_flag_subject3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subject", &(((ngwt__Mail*)a)->subject), ""))
				{	soap_flag_subject3 = 0;
					continue;
				}
			if (soap_flag_originalSubject3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:originalSubject", &(((ngwt__Mail*)a)->originalSubject), ""))
				{	soap_flag_originalSubject3 = 0;
					continue;
				}
			if (soap_flag_subjectPrefix3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subjectPrefix", &(((ngwt__Mail*)a)->subjectPrefix), ""))
				{	soap_flag_subjectPrefix3 = 0;
					continue;
				}
			if (soap_flag_distribution3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Distribution(soap, "ngwt:distribution", &(((ngwt__Mail*)a)->distribution), "ngwt:Distribution"))
				{	soap_flag_distribution3 = 0;
					continue;
				}
			if (soap_flag_message3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessageBody(soap, "ngwt:message", &(((ngwt__Mail*)a)->message), "ngwt:MessageBody"))
				{	soap_flag_message3 = 0;
					continue;
				}
			if (soap_flag_attachments3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", &(((ngwt__Mail*)a)->attachments), "ngwt:AttachmentInfo"))
				{	soap_flag_attachments3 = 0;
					continue;
				}
			if (soap_flag_options3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemOptions(soap, "ngwt:options", &(((ngwt__Mail*)a)->options), "ngwt:ItemOptions"))
				{	soap_flag_options3 = 0;
					continue;
				}
			if (soap_flag_link3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__LinkInfo(soap, "ngwt:link", &(((ngwt__Mail*)a)->link), "ngwt:LinkInfo"))
				{	soap_flag_link3 = 0;
					continue;
				}
			if (soap_flag_hasAttachment3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:hasAttachment", &(((ngwt__Mail*)a)->hasAttachment), ""))
				{	soap_flag_hasAttachment3 = 0;
					continue;
				}
			if (soap_flag_size3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:size", &(((ngwt__Mail*)a)->size), ""))
				{	soap_flag_size3 = 0;
					continue;
				}
			if (soap_flag_subType3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subType", &(((ngwt__Mail*)a)->subType), ""))
				{	soap_flag_subType3 = 0;
					continue;
				}
			if (soap_flag_nntpOrImap3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:nntpOrImap", &(((ngwt__Mail*)a)->nntpOrImap), ""))
				{	soap_flag_nntpOrImap3 = 0;
					continue;
				}
			if (soap_flag_smimeType3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", &(((ngwt__Mail*)a)->smimeType), "ngwt:SMimeOperation"))
				{	soap_flag_smimeType3 = 0;
					continue;
				}
			if (soap_flag_rdate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceDateType(soap, "ngwt:rdate", &(((ngwt__CalendarItem*)a)->rdate), "ngwt:RecurrenceDateType"))
				{	soap_flag_rdate2 = 0;
					continue;
				}
			if (soap_flag_rrule2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceRule(soap, "ngwt:rrule", &(((ngwt__CalendarItem*)a)->rrule), "ngwt:RecurrenceRule"))
				{	soap_flag_rrule2 = 0;
					continue;
				}
			if (soap_flag_exdate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceDateType(soap, "ngwt:exdate", &(((ngwt__CalendarItem*)a)->exdate), "ngwt:RecurrenceDateType"))
				{	soap_flag_exdate2 = 0;
					continue;
				}
			if (soap_flag_recurrenceKey2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:recurrenceKey", &(((ngwt__CalendarItem*)a)->recurrenceKey), ""))
				{	soap_flag_recurrenceKey2 = 0;
					continue;
				}
			if (soap_flag_iCalId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:iCalId", &(((ngwt__CalendarItem*)a)->iCalId), ""))
				{	soap_flag_iCalId2 = 0;
					continue;
				}
			if (soap_flag_startDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__date(soap, "ngwt:startDate", &(((ngwt__Note*)a)->startDate), "xsd:date"))
				{	soap_flag_startDate1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_delivered4))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Note *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Note, 0, sizeof(ngwt__Note), 0, soap_copy_ngwt__Note);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Note * SOAP_FMAC6 soap_new_ngwt__Note(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Note(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Note(struct soap *soap, ngwt__Note *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Note * SOAP_FMAC6 soap_instantiate_ngwt__Note(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Note(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Note, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Note;
		if (size)
			*size = sizeof(ngwt__Note);
		((ngwt__Note*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Note[n];
		if (size)
			*size = n * sizeof(ngwt__Note);
		for (int i = 0; i < n; i++)
			((ngwt__Note*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Note*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Note(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Note %p -> %p\n", q, p));
	*(ngwt__Note*)p = *(ngwt__Note*)q;
}

void ngwt__NameAndEmail::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->displayName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->email, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ngwt__NameAndEmail::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__NameAndEmail*)this)->displayName = NULL;
	((ngwt__NameAndEmail*)this)->email = NULL;
	((ngwt__NameAndEmail*)this)->uuid = NULL;
	/* transient soap skipped */
}

int ngwt__NameAndEmail::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__NameAndEmail);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__NameAndEmail::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__NameAndEmail(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__NameAndEmail(struct soap *soap, const char *tag, int id, const ngwt__NameAndEmail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__NameAndEmail), type);
	soap_out_PointerTostd__string(soap, "ngwt:displayName", -1, &(((ngwt__NameAndEmail*)a)->displayName), "");
	soap_out_PointerTostd__string(soap, "ngwt:email", -1, &(((ngwt__NameAndEmail*)a)->email), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__NameAndEmail*)a)->uuid), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__NameAndEmail::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__NameAndEmail(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__NameAndEmail * SOAP_FMAC4 soap_get_ngwt__NameAndEmail(struct soap *soap, ngwt__NameAndEmail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__NameAndEmail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__NameAndEmail::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__NameAndEmail(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__NameAndEmail * SOAP_FMAC4 soap_in_ngwt__NameAndEmail(struct soap *soap, const char *tag, ngwt__NameAndEmail *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__NameAndEmail *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__NameAndEmail, sizeof(ngwt__NameAndEmail), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__NameAndEmail)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__NameAndEmail *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_displayName1 = 1, soap_flag_email1 = 1, soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_displayName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:displayName", &(((ngwt__NameAndEmail*)a)->displayName), ""))
				{	soap_flag_displayName1 = 0;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:email", &(((ngwt__NameAndEmail*)a)->email), ""))
				{	soap_flag_email1 = 0;
					continue;
				}
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__NameAndEmail*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__NameAndEmail *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__NameAndEmail, 0, sizeof(ngwt__NameAndEmail), 0, soap_copy_ngwt__NameAndEmail);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__NameAndEmail * SOAP_FMAC6 soap_new_ngwt__NameAndEmail(struct soap *soap, int n)
{	return soap_instantiate_ngwt__NameAndEmail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__NameAndEmail(struct soap *soap, ngwt__NameAndEmail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__NameAndEmail * SOAP_FMAC6 soap_instantiate_ngwt__NameAndEmail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__NameAndEmail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__NameAndEmail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:AccessControlListEntry"))
	{	cp->type = SOAP_TYPE_ngwt__AccessControlListEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__AccessControlListEntry;
			if (size)
				*size = sizeof(ngwt__AccessControlListEntry);
			((ngwt__AccessControlListEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__AccessControlListEntry[n];
			if (size)
				*size = n * sizeof(ngwt__AccessControlListEntry);
			for (int i = 0; i < n; i++)
				((ngwt__AccessControlListEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__AccessControlListEntry*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:AccessRightEntry"))
	{	cp->type = SOAP_TYPE_ngwt__AccessRightEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__AccessRightEntry;
			if (size)
				*size = sizeof(ngwt__AccessRightEntry);
			((ngwt__AccessRightEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__AccessRightEntry[n];
			if (size)
				*size = n * sizeof(ngwt__AccessRightEntry);
			for (int i = 0; i < n; i++)
				((ngwt__AccessRightEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__AccessRightEntry*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:FreeBusyInfo"))
	{	cp->type = SOAP_TYPE_ngwt__FreeBusyInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__FreeBusyInfo;
			if (size)
				*size = sizeof(ngwt__FreeBusyInfo);
			((ngwt__FreeBusyInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__FreeBusyInfo[n];
			if (size)
				*size = n * sizeof(ngwt__FreeBusyInfo);
			for (int i = 0; i < n; i++)
				((ngwt__FreeBusyInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__FreeBusyInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:From"))
	{	cp->type = SOAP_TYPE_ngwt__From;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__From;
			if (size)
				*size = sizeof(ngwt__From);
			((ngwt__From*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__From[n];
			if (size)
				*size = n * sizeof(ngwt__From);
			for (int i = 0; i < n; i++)
				((ngwt__From*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__From*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:ProxyUser"))
	{	cp->type = SOAP_TYPE_ngwt__ProxyUser;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__ProxyUser;
			if (size)
				*size = sizeof(ngwt__ProxyUser);
			((ngwt__ProxyUser*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__ProxyUser[n];
			if (size)
				*size = n * sizeof(ngwt__ProxyUser);
			for (int i = 0; i < n; i++)
				((ngwt__ProxyUser*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__ProxyUser*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Recipient"))
	{	cp->type = SOAP_TYPE_ngwt__Recipient;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Recipient;
			if (size)
				*size = sizeof(ngwt__Recipient);
			((ngwt__Recipient*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Recipient[n];
			if (size)
				*size = n * sizeof(ngwt__Recipient);
			for (int i = 0; i < n; i++)
				((ngwt__Recipient*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Recipient*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:FolderACLEntry"))
	{	cp->type = SOAP_TYPE_ngwt__FolderACLEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__FolderACLEntry;
			if (size)
				*size = sizeof(ngwt__FolderACLEntry);
			((ngwt__FolderACLEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__FolderACLEntry[n];
			if (size)
				*size = n * sizeof(ngwt__FolderACLEntry);
			for (int i = 0; i < n; i++)
				((ngwt__FolderACLEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__FolderACLEntry*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__NameAndEmail;
		if (size)
			*size = sizeof(ngwt__NameAndEmail);
		((ngwt__NameAndEmail*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__NameAndEmail[n];
		if (size)
			*size = n * sizeof(ngwt__NameAndEmail);
		for (int i = 0; i < n; i++)
			((ngwt__NameAndEmail*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__NameAndEmail*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__NameAndEmail(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__NameAndEmail %p -> %p\n", q, p));
	*(ngwt__NameAndEmail*)p = *(ngwt__NameAndEmail*)q;
}

void ngwt__MonthList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfngwt__Month(soap, &((ngwt__MonthList*)this)->month);
	/* transient soap skipped */
}

void ngwt__MonthList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfngwt__Month(soap, &((ngwt__MonthList*)this)->month);
	/* transient soap skipped */
}

int ngwt__MonthList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__MonthList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__MonthList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__MonthList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__MonthList(struct soap *soap, const char *tag, int id, const ngwt__MonthList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__MonthList), type);
	soap_out_std__vectorTemplateOfngwt__Month(soap, "ngwt:month", -1, &(((ngwt__MonthList*)a)->month), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__MonthList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__MonthList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__MonthList * SOAP_FMAC4 soap_get_ngwt__MonthList(struct soap *soap, ngwt__MonthList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__MonthList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__MonthList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__MonthList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__MonthList * SOAP_FMAC4 soap_in_ngwt__MonthList(struct soap *soap, const char *tag, ngwt__MonthList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__MonthList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__MonthList, sizeof(ngwt__MonthList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__MonthList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__MonthList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__Month(soap, "ngwt:month", &(((ngwt__MonthList*)a)->month), "ngwt:Month"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__MonthList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__MonthList, 0, sizeof(ngwt__MonthList), 0, soap_copy_ngwt__MonthList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__MonthList * SOAP_FMAC6 soap_new_ngwt__MonthList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__MonthList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__MonthList(struct soap *soap, ngwt__MonthList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__MonthList * SOAP_FMAC6 soap_instantiate_ngwt__MonthList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__MonthList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__MonthList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__MonthList;
		if (size)
			*size = sizeof(ngwt__MonthList);
		((ngwt__MonthList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__MonthList[n];
		if (size)
			*size = n * sizeof(ngwt__MonthList);
		for (int i = 0; i < n; i++)
			((ngwt__MonthList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__MonthList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__MonthList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__MonthList %p -> %p\n", q, p));
	*(ngwt__MonthList*)p = *(ngwt__MonthList*)q;
}

void ngwt__ModifyItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ModifyItem*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((ngwt__ModifyItem*)this)->id);
	soap_embedded(soap, &((ngwt__ModifyItem*)this)->notification, SOAP_TYPE_PointerTongwt__SharedFolderNotification);
	soap_serialize_PointerTongwt__SharedFolderNotification(soap, &((ngwt__ModifyItem*)this)->notification);
	soap_embedded(soap, &((ngwt__ModifyItem*)this)->updates, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__ModifyItem*)this)->updates);
	/* transient soap skipped */
}

void ngwt__ModifyItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((ngwt__ModifyItem*)this)->id);
	((ngwt__ModifyItem*)this)->notification = NULL;
	((ngwt__ModifyItem*)this)->updates = NULL;
	/* transient soap skipped */
}

int ngwt__ModifyItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ModifyItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ModifyItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ModifyItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ModifyItem(struct soap *soap, const char *tag, int id, const ngwt__ModifyItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ModifyItem), type);
	soap_out_ngwt__uid(soap, "ngwt:id", -1, &(((ngwt__ModifyItem*)a)->id), "");
	soap_out_PointerTongwt__SharedFolderNotification(soap, "ngwt:notification", -1, &(((ngwt__ModifyItem*)a)->notification), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:updates", -1, &(((ngwt__ModifyItem*)a)->updates), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ModifyItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ModifyItem(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ModifyItem * SOAP_FMAC4 soap_get_ngwt__ModifyItem(struct soap *soap, ngwt__ModifyItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ModifyItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ModifyItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ModifyItem(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ModifyItem * SOAP_FMAC4 soap_in_ngwt__ModifyItem(struct soap *soap, const char *tag, ngwt__ModifyItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ModifyItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ModifyItem, sizeof(ngwt__ModifyItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ModifyItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ModifyItem *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_notification1 = 1, soap_flag_updates1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwt:id", &(((ngwt__ModifyItem*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_notification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SharedFolderNotification(soap, "ngwt:notification", &(((ngwt__ModifyItem*)a)->notification), "ngwt:SharedFolderNotification"))
				{	soap_flag_notification1 = 0;
					continue;
				}
			if (soap_flag_updates1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:updates", &(((ngwt__ModifyItem*)a)->updates), "ngwt:ItemChanges"))
				{	soap_flag_updates1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_updates1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ModifyItem *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ModifyItem, 0, sizeof(ngwt__ModifyItem), 0, soap_copy_ngwt__ModifyItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ModifyItem * SOAP_FMAC6 soap_new_ngwt__ModifyItem(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ModifyItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ModifyItem(struct soap *soap, ngwt__ModifyItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ModifyItem * SOAP_FMAC6 soap_instantiate_ngwt__ModifyItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ModifyItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ModifyItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ModifyItem;
		if (size)
			*size = sizeof(ngwt__ModifyItem);
		((ngwt__ModifyItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ModifyItem[n];
		if (size)
			*size = n * sizeof(ngwt__ModifyItem);
		for (int i = 0; i < n; i++)
			((ngwt__ModifyItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ModifyItem*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ModifyItem(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ModifyItem %p -> %p\n", q, p));
	*(ngwt__ModifyItem*)p = *(ngwt__ModifyItem*)q;
}

void ngwt__MessagePart::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__MessagePart*)this)->__item, SOAP_TYPE_xsd__base64Binary);
	((ngwt__MessagePart*)this)->__item.soap_serialize(soap);
	/* transient soap skipped */
}

void ngwt__MessagePart::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__MessagePart*)this)->__item.xsd__base64Binary::soap_default(soap);
	((ngwt__MessagePart*)this)->id = NULL;
	((ngwt__MessagePart*)this)->contentId = NULL;
	((ngwt__MessagePart*)this)->contentType = NULL;
	((ngwt__MessagePart*)this)->length = NULL;
	((ngwt__MessagePart*)this)->offset = NULL;
	/* transient soap skipped */
}

int ngwt__MessagePart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__MessagePart);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__MessagePart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__MessagePart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__MessagePart(struct soap *soap, const char *tag, int id, const ngwt__MessagePart *a, const char *type)
{
	if (((ngwt__MessagePart *)a)->id)
		soap_set_attr(soap, "id", ((ngwt__MessagePart *)a)->id->c_str());
	if (((ngwt__MessagePart *)a)->contentId)
		soap_set_attr(soap, "contentId", ((ngwt__MessagePart *)a)->contentId->c_str());
	if (((ngwt__MessagePart *)a)->contentType)
		soap_set_attr(soap, "contentType", ((ngwt__MessagePart *)a)->contentType->c_str());
	if (((ngwt__MessagePart *)a)->length)
		soap_set_attr(soap, "length", soap_int2s(soap, *((ngwt__MessagePart *)a)->length));
	if (((ngwt__MessagePart *)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ngwt__MessagePart *)a)->offset));
	(((ngwt__MessagePart*)a)->__item).soap_out(soap, tag, id, "");
	return SOAP_OK;
}

void *ngwt__MessagePart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__MessagePart(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__MessagePart * SOAP_FMAC4 soap_get_ngwt__MessagePart(struct soap *soap, ngwt__MessagePart *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__MessagePart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__MessagePart::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__MessagePart(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__MessagePart * SOAP_FMAC4 soap_in_ngwt__MessagePart(struct soap *soap, const char *tag, ngwt__MessagePart *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ngwt__MessagePart *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__MessagePart, sizeof(ngwt__MessagePart), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__MessagePart)
			return (ngwt__MessagePart *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{	if (!(((ngwt__MessagePart *)a)->id = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__MessagePart *)a)->id = soap_new_std__string(soap, -1);
			((ngwt__MessagePart *)a)->id->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "contentId", 0);
		if (t)
		{	if (!(((ngwt__MessagePart *)a)->contentId = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__MessagePart *)a)->contentId = soap_new_std__string(soap, -1);
			((ngwt__MessagePart *)a)->contentId->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "contentType", 0);
		if (t)
		{	if (!(((ngwt__MessagePart *)a)->contentType = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__MessagePart *)a)->contentType = soap_new_std__string(soap, -1);
			((ngwt__MessagePart *)a)->contentType->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "length", 0);
		if (t)
		{	if (!(((ngwt__MessagePart *)a)->length = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((ngwt__MessagePart *)a)->length))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if (t)
		{	if (!(((ngwt__MessagePart *)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((ngwt__MessagePart *)a)->offset))
		return NULL;
		}
	}
	if (!(((ngwt__MessagePart*)a)->__item).soap_in(soap, tag, "ngwt:MessagePart"))
		return NULL;
	return a;
}

SOAP_FMAC5 ngwt__MessagePart * SOAP_FMAC6 soap_new_ngwt__MessagePart(struct soap *soap, int n)
{	return soap_instantiate_ngwt__MessagePart(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__MessagePart(struct soap *soap, ngwt__MessagePart *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__MessagePart * SOAP_FMAC6 soap_instantiate_ngwt__MessagePart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__MessagePart(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__MessagePart, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__MessagePart;
		if (size)
			*size = sizeof(ngwt__MessagePart);
		((ngwt__MessagePart*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__MessagePart[n];
		if (size)
			*size = n * sizeof(ngwt__MessagePart);
		for (int i = 0; i < n; i++)
			((ngwt__MessagePart*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__MessagePart*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__MessagePart(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__MessagePart %p -> %p\n", q, p));
	*(ngwt__MessagePart*)p = *(ngwt__MessagePart*)q;
}

void ngwt__MessageBody::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__MessagePart(soap, &((ngwt__MessageBody*)this)->part);
	/* transient soap skipped */
}

void ngwt__MessageBody::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__MessagePart(soap, &((ngwt__MessageBody*)this)->part);
	/* transient soap skipped */
}

int ngwt__MessageBody::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__MessageBody);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__MessageBody::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__MessageBody(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__MessageBody(struct soap *soap, const char *tag, int id, const ngwt__MessageBody *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__MessageBody), type);
	soap_out_std__vectorTemplateOfPointerTongwt__MessagePart(soap, "ngwt:part", -1, &(((ngwt__MessageBody*)a)->part), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__MessageBody::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__MessageBody(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__MessageBody * SOAP_FMAC4 soap_get_ngwt__MessageBody(struct soap *soap, ngwt__MessageBody *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__MessageBody(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__MessageBody::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__MessageBody(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__MessageBody * SOAP_FMAC4 soap_in_ngwt__MessageBody(struct soap *soap, const char *tag, ngwt__MessageBody *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__MessageBody *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__MessageBody, sizeof(ngwt__MessageBody), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__MessageBody)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__MessageBody *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__MessagePart(soap, "ngwt:part", &(((ngwt__MessageBody*)a)->part), "ngwt:MessagePart"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__MessageBody *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__MessageBody, 0, sizeof(ngwt__MessageBody), 0, soap_copy_ngwt__MessageBody);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__MessageBody * SOAP_FMAC6 soap_new_ngwt__MessageBody(struct soap *soap, int n)
{	return soap_instantiate_ngwt__MessageBody(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__MessageBody(struct soap *soap, ngwt__MessageBody *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__MessageBody * SOAP_FMAC6 soap_instantiate_ngwt__MessageBody(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__MessageBody(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__MessageBody, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__MessageBody;
		if (size)
			*size = sizeof(ngwt__MessageBody);
		((ngwt__MessageBody*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__MessageBody[n];
		if (size)
			*size = n * sizeof(ngwt__MessageBody);
		for (int i = 0; i < n; i++)
			((ngwt__MessageBody*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__MessageBody*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__MessageBody(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__MessageBody %p -> %p\n", q, p));
	*(ngwt__MessageBody*)p = *(ngwt__MessageBody*)q;
}

void ngwt__Mail::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Mail*)this)->subject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subject);
	soap_embedded(soap, &((ngwt__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ngwt__Mail*)this)->subjectPrefix, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subjectPrefix);
	soap_embedded(soap, &((ngwt__Mail*)this)->distribution, SOAP_TYPE_PointerTongwt__Distribution);
	soap_serialize_PointerTongwt__Distribution(soap, &((ngwt__Mail*)this)->distribution);
	soap_embedded(soap, &((ngwt__Mail*)this)->message, SOAP_TYPE_PointerTongwt__MessageBody);
	soap_serialize_PointerTongwt__MessageBody(soap, &((ngwt__Mail*)this)->message);
	soap_embedded(soap, &((ngwt__Mail*)this)->attachments, SOAP_TYPE_PointerTongwt__AttachmentInfo);
	soap_serialize_PointerTongwt__AttachmentInfo(soap, &((ngwt__Mail*)this)->attachments);
	soap_embedded(soap, &((ngwt__Mail*)this)->options, SOAP_TYPE_PointerTongwt__ItemOptions);
	soap_serialize_PointerTongwt__ItemOptions(soap, &((ngwt__Mail*)this)->options);
	soap_embedded(soap, &((ngwt__Mail*)this)->link, SOAP_TYPE_PointerTongwt__LinkInfo);
	soap_serialize_PointerTongwt__LinkInfo(soap, &((ngwt__Mail*)this)->link);
	soap_embedded(soap, &((ngwt__Mail*)this)->hasAttachment, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwt__Mail*)this)->size, SOAP_TYPE_int);
	soap_embedded(soap, &((ngwt__Mail*)this)->subType, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subType);
	soap_embedded(soap, &((ngwt__Mail*)this)->nntpOrImap, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Mail*)this)->nntpOrImap);
	soap_embedded(soap, &((ngwt__Mail*)this)->smimeType, SOAP_TYPE_PointerTongwt__SMimeOperation);
	soap_serialize_PointerTongwt__SMimeOperation(soap, &((ngwt__Mail*)this)->smimeType);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->status, SOAP_TYPE_PointerTongwt__ItemStatus);
	soap_serialize_PointerTongwt__ItemStatus(soap, &((ngwt__BoxEntry*)this)->status);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->msgId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->msgId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->messageId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->messageId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->source, SOAP_TYPE_PointerTongwt__ItemSource);
	soap_serialize_PointerTongwt__ItemSource(soap, &((ngwt__BoxEntry*)this)->source);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->class_, SOAP_TYPE_PointerTongwt__ItemClass);
	soap_serialize_PointerTongwt__ItemClass(soap, &((ngwt__BoxEntry*)this)->class_);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->security, SOAP_TYPE_PointerTongwt__ItemSecurity);
	soap_serialize_PointerTongwt__ItemSecurity(soap, &((ngwt__BoxEntry*)this)->security);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->comment);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Mail::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Mail*)this)->subject = NULL;
	((ngwt__Mail*)this)->originalSubject = NULL;
	((ngwt__Mail*)this)->subjectPrefix = NULL;
	((ngwt__Mail*)this)->distribution = NULL;
	((ngwt__Mail*)this)->message = NULL;
	((ngwt__Mail*)this)->attachments = NULL;
	((ngwt__Mail*)this)->options = NULL;
	((ngwt__Mail*)this)->link = NULL;
	((ngwt__Mail*)this)->hasAttachment = (bool)0;
	((ngwt__Mail*)this)->size = 0;
	((ngwt__Mail*)this)->subType = NULL;
	((ngwt__Mail*)this)->nntpOrImap = NULL;
	((ngwt__Mail*)this)->smimeType = NULL;
	((ngwt__BoxEntry*)this)->status = NULL;
	((ngwt__BoxEntry*)this)->thread = NULL;
	((ngwt__BoxEntry*)this)->msgId = NULL;
	((ngwt__BoxEntry*)this)->messageId = NULL;
	((ngwt__BoxEntry*)this)->source = NULL;
	((ngwt__BoxEntry*)this)->returnSentItemsId = NULL;
	soap_default_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	((ngwt__BoxEntry*)this)->class_ = NULL;
	((ngwt__BoxEntry*)this)->security = NULL;
	((ngwt__BoxEntry*)this)->comment = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Mail::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Mail);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Mail::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Mail(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Mail(struct soap *soap, const char *tag, int id, const ngwt__Mail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Mail), "ngwt:Mail");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__ItemStatus(soap, "ngwt:status", -1, &(((ngwt__BoxEntry*)a)->status), "");
	soap_out_PointerTostd__string(soap, "ngwt:thread", -1, &(((ngwt__BoxEntry*)a)->thread), "");
	soap_out_PointerTostd__string(soap, "ngwt:msgId", -1, &(((ngwt__BoxEntry*)a)->msgId), "");
	soap_out_PointerTostd__string(soap, "ngwt:messageId", -1, &(((ngwt__BoxEntry*)a)->messageId), "");
	soap_out_PointerTongwt__ItemSource(soap, "ngwt:source", -1, &(((ngwt__BoxEntry*)a)->source), "");
	soap_out_PointerTobool(soap, "ngwt:returnSentItemsId", -1, &(((ngwt__BoxEntry*)a)->returnSentItemsId), "");
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__BoxEntry*)a)->delivered), "");
	soap_out_PointerTongwt__ItemClass(soap, "ngwt:class", -1, &(((ngwt__BoxEntry*)a)->class_), "");
	soap_out_PointerTongwt__ItemSecurity(soap, "ngwt:security", -1, &(((ngwt__BoxEntry*)a)->security), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__BoxEntry*)a)->comment), "");
	soap_out_PointerTostd__string(soap, "ngwt:subject", -1, &(((ngwt__Mail*)a)->subject), "");
	soap_out_PointerTostd__string(soap, "ngwt:originalSubject", -1, &(((ngwt__Mail*)a)->originalSubject), "");
	soap_out_PointerTostd__string(soap, "ngwt:subjectPrefix", -1, &(((ngwt__Mail*)a)->subjectPrefix), "");
	soap_out_PointerTongwt__Distribution(soap, "ngwt:distribution", -1, &(((ngwt__Mail*)a)->distribution), "");
	soap_out_PointerTongwt__MessageBody(soap, "ngwt:message", -1, &(((ngwt__Mail*)a)->message), "");
	soap_out_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", -1, &(((ngwt__Mail*)a)->attachments), "");
	soap_out_PointerTongwt__ItemOptions(soap, "ngwt:options", -1, &(((ngwt__Mail*)a)->options), "");
	soap_out_PointerTongwt__LinkInfo(soap, "ngwt:link", -1, &(((ngwt__Mail*)a)->link), "");
	soap_out_bool(soap, "ngwt:hasAttachment", -1, &(((ngwt__Mail*)a)->hasAttachment), "");
	soap_out_int(soap, "ngwt:size", -1, &(((ngwt__Mail*)a)->size), "");
	soap_out_PointerTostd__string(soap, "ngwt:subType", -1, &(((ngwt__Mail*)a)->subType), "");
	soap_out_PointerTobool(soap, "ngwt:nntpOrImap", -1, &(((ngwt__Mail*)a)->nntpOrImap), "");
	soap_out_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", -1, &(((ngwt__Mail*)a)->smimeType), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Mail::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Mail(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Mail * SOAP_FMAC4 soap_get_ngwt__Mail(struct soap *soap, ngwt__Mail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Mail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Mail::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Mail(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Mail * SOAP_FMAC4 soap_in_ngwt__Mail(struct soap *soap, const char *tag, ngwt__Mail *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Mail *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Mail, sizeof(ngwt__Mail), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Mail)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Mail *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_categories3 = 1, soap_flag_created3 = 1, soap_flag_customs3 = 1, soap_flag_status2 = 1, soap_flag_thread2 = 1, soap_flag_msgId2 = 1, soap_flag_messageId2 = 1, soap_flag_source2 = 1, soap_flag_returnSentItemsId2 = 1, soap_flag_delivered2 = 1, soap_flag_class_2 = 1, soap_flag_security2 = 1, soap_flag_comment2 = 1, soap_flag_subject1 = 1, soap_flag_originalSubject1 = 1, soap_flag_subjectPrefix1 = 1, soap_flag_distribution1 = 1, soap_flag_message1 = 1, soap_flag_attachments1 = 1, soap_flag_options1 = 1, soap_flag_link1 = 1, soap_flag_hasAttachment1 = 1, soap_flag_size1 = 1, soap_flag_subType1 = 1, soap_flag_nntpOrImap1 = 1, soap_flag_smimeType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}
			if (soap_flag_name4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name4 = 0;
					continue;
				}
			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}
			if (soap_flag_modified4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}
			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories3 = 0;
					continue;
				}
			if (soap_flag_created3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created3 = 0;
					continue;
				}
			if (soap_flag_customs3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs3 = 0;
					continue;
				}
			if (soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemStatus(soap, "ngwt:status", &(((ngwt__BoxEntry*)a)->status), "ngwt:ItemStatus"))
				{	soap_flag_status2 = 0;
					continue;
				}
			if (soap_flag_thread2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:thread", &(((ngwt__BoxEntry*)a)->thread), ""))
				{	soap_flag_thread2 = 0;
					continue;
				}
			if (soap_flag_msgId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:msgId", &(((ngwt__BoxEntry*)a)->msgId), ""))
				{	soap_flag_msgId2 = 0;
					continue;
				}
			if (soap_flag_messageId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:messageId", &(((ngwt__BoxEntry*)a)->messageId), ""))
				{	soap_flag_messageId2 = 0;
					continue;
				}
			if (soap_flag_source2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSource(soap, "ngwt:source", &(((ngwt__BoxEntry*)a)->source), ""))
				{	soap_flag_source2 = 0;
					continue;
				}
			if (soap_flag_returnSentItemsId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:returnSentItemsId", &(((ngwt__BoxEntry*)a)->returnSentItemsId), ""))
				{	soap_flag_returnSentItemsId2 = 0;
					continue;
				}
			if (soap_flag_delivered2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered2 = 0;
					continue;
				}
			if (soap_flag_class_2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemClass(soap, "ngwt:class", &(((ngwt__BoxEntry*)a)->class_), ""))
				{	soap_flag_class_2 = 0;
					continue;
				}
			if (soap_flag_security2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSecurity(soap, "ngwt:security", &(((ngwt__BoxEntry*)a)->security), ""))
				{	soap_flag_security2 = 0;
					continue;
				}
			if (soap_flag_comment2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__BoxEntry*)a)->comment), ""))
				{	soap_flag_comment2 = 0;
					continue;
				}
			if (soap_flag_subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subject", &(((ngwt__Mail*)a)->subject), ""))
				{	soap_flag_subject1 = 0;
					continue;
				}
			if (soap_flag_originalSubject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:originalSubject", &(((ngwt__Mail*)a)->originalSubject), ""))
				{	soap_flag_originalSubject1 = 0;
					continue;
				}
			if (soap_flag_subjectPrefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subjectPrefix", &(((ngwt__Mail*)a)->subjectPrefix), ""))
				{	soap_flag_subjectPrefix1 = 0;
					continue;
				}
			if (soap_flag_distribution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Distribution(soap, "ngwt:distribution", &(((ngwt__Mail*)a)->distribution), "ngwt:Distribution"))
				{	soap_flag_distribution1 = 0;
					continue;
				}
			if (soap_flag_message1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessageBody(soap, "ngwt:message", &(((ngwt__Mail*)a)->message), "ngwt:MessageBody"))
				{	soap_flag_message1 = 0;
					continue;
				}
			if (soap_flag_attachments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", &(((ngwt__Mail*)a)->attachments), "ngwt:AttachmentInfo"))
				{	soap_flag_attachments1 = 0;
					continue;
				}
			if (soap_flag_options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemOptions(soap, "ngwt:options", &(((ngwt__Mail*)a)->options), "ngwt:ItemOptions"))
				{	soap_flag_options1 = 0;
					continue;
				}
			if (soap_flag_link1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__LinkInfo(soap, "ngwt:link", &(((ngwt__Mail*)a)->link), "ngwt:LinkInfo"))
				{	soap_flag_link1 = 0;
					continue;
				}
			if (soap_flag_hasAttachment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:hasAttachment", &(((ngwt__Mail*)a)->hasAttachment), ""))
				{	soap_flag_hasAttachment1 = 0;
					continue;
				}
			if (soap_flag_size1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:size", &(((ngwt__Mail*)a)->size), ""))
				{	soap_flag_size1 = 0;
					continue;
				}
			if (soap_flag_subType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subType", &(((ngwt__Mail*)a)->subType), ""))
				{	soap_flag_subType1 = 0;
					continue;
				}
			if (soap_flag_nntpOrImap1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:nntpOrImap", &(((ngwt__Mail*)a)->nntpOrImap), ""))
				{	soap_flag_nntpOrImap1 = 0;
					continue;
				}
			if (soap_flag_smimeType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", &(((ngwt__Mail*)a)->smimeType), "ngwt:SMimeOperation"))
				{	soap_flag_smimeType1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_delivered2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Mail *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Mail, 0, sizeof(ngwt__Mail), 0, soap_copy_ngwt__Mail);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Mail * SOAP_FMAC6 soap_new_ngwt__Mail(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Mail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Mail(struct soap *soap, ngwt__Mail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Mail * SOAP_FMAC6 soap_instantiate_ngwt__Mail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Mail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Mail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:CalendarItem"))
	{	cp->type = SOAP_TYPE_ngwt__CalendarItem;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__CalendarItem;
			if (size)
				*size = sizeof(ngwt__CalendarItem);
			((ngwt__CalendarItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__CalendarItem[n];
			if (size)
				*size = n * sizeof(ngwt__CalendarItem);
			for (int i = 0; i < n; i++)
				((ngwt__CalendarItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__CalendarItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:DocumentRef"))
	{	cp->type = SOAP_TYPE_ngwt__DocumentRef;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__DocumentRef;
			if (size)
				*size = sizeof(ngwt__DocumentRef);
			((ngwt__DocumentRef*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__DocumentRef[n];
			if (size)
				*size = n * sizeof(ngwt__DocumentRef);
			for (int i = 0; i < n; i++)
				((ngwt__DocumentRef*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__DocumentRef*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:PhoneMessage"))
	{	cp->type = SOAP_TYPE_ngwt__PhoneMessage;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__PhoneMessage;
			if (size)
				*size = sizeof(ngwt__PhoneMessage);
			((ngwt__PhoneMessage*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__PhoneMessage[n];
			if (size)
				*size = n * sizeof(ngwt__PhoneMessage);
			for (int i = 0; i < n; i++)
				((ngwt__PhoneMessage*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__PhoneMessage*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:SharedNotification"))
	{	cp->type = SOAP_TYPE_ngwt__SharedNotification;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__SharedNotification;
			if (size)
				*size = sizeof(ngwt__SharedNotification);
			((ngwt__SharedNotification*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__SharedNotification[n];
			if (size)
				*size = n * sizeof(ngwt__SharedNotification);
			for (int i = 0; i < n; i++)
				((ngwt__SharedNotification*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__SharedNotification*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Appointment"))
	{	cp->type = SOAP_TYPE_ngwt__Appointment;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Appointment;
			if (size)
				*size = sizeof(ngwt__Appointment);
			((ngwt__Appointment*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Appointment[n];
			if (size)
				*size = n * sizeof(ngwt__Appointment);
			for (int i = 0; i < n; i++)
				((ngwt__Appointment*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Appointment*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Note"))
	{	cp->type = SOAP_TYPE_ngwt__Note;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Note;
			if (size)
				*size = sizeof(ngwt__Note);
			((ngwt__Note*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Note[n];
			if (size)
				*size = n * sizeof(ngwt__Note);
			for (int i = 0; i < n; i++)
				((ngwt__Note*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Note*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Task"))
	{	cp->type = SOAP_TYPE_ngwt__Task;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Task;
			if (size)
				*size = sizeof(ngwt__Task);
			((ngwt__Task*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Task[n];
			if (size)
				*size = n * sizeof(ngwt__Task);
			for (int i = 0; i < n; i++)
				((ngwt__Task*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Task*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Mail;
		if (size)
			*size = sizeof(ngwt__Mail);
		((ngwt__Mail*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Mail[n];
		if (size)
			*size = n * sizeof(ngwt__Mail);
		for (int i = 0; i < n; i++)
			((ngwt__Mail*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Mail*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Mail(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Mail %p -> %p\n", q, p));
	*(ngwt__Mail*)p = *(ngwt__Mail*)q;
}

void ngwt__LinkInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__LinkInfo*)this)->id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__LinkInfo*)this)->id);
	soap_embedded(soap, &((ngwt__LinkInfo*)this)->type, SOAP_TYPE_ngwt__LinkType);
	/* transient soap skipped */
}

void ngwt__LinkInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwt__LinkInfo*)this)->id);
	soap_default_ngwt__LinkType(soap, &((ngwt__LinkInfo*)this)->type);
	/* transient soap skipped */
}

int ngwt__LinkInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__LinkInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__LinkInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__LinkInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__LinkInfo(struct soap *soap, const char *tag, int id, const ngwt__LinkInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__LinkInfo), type);
	soap_out_std__string(soap, "ngwt:id", -1, &(((ngwt__LinkInfo*)a)->id), "");
	soap_out_ngwt__LinkType(soap, "ngwt:type", -1, &(((ngwt__LinkInfo*)a)->type), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__LinkInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__LinkInfo(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__LinkInfo * SOAP_FMAC4 soap_get_ngwt__LinkInfo(struct soap *soap, ngwt__LinkInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__LinkInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__LinkInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__LinkInfo(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__LinkInfo * SOAP_FMAC4 soap_in_ngwt__LinkInfo(struct soap *soap, const char *tag, ngwt__LinkInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__LinkInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__LinkInfo, sizeof(ngwt__LinkInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__LinkInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__LinkInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:id", &(((ngwt__LinkInfo*)a)->id), ""))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__LinkType(soap, "ngwt:type", &(((ngwt__LinkInfo*)a)->type), ""))
				{	soap_flag_type1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_type1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__LinkInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__LinkInfo, 0, sizeof(ngwt__LinkInfo), 0, soap_copy_ngwt__LinkInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__LinkInfo * SOAP_FMAC6 soap_new_ngwt__LinkInfo(struct soap *soap, int n)
{	return soap_instantiate_ngwt__LinkInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__LinkInfo(struct soap *soap, ngwt__LinkInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__LinkInfo * SOAP_FMAC6 soap_instantiate_ngwt__LinkInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__LinkInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__LinkInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__LinkInfo;
		if (size)
			*size = sizeof(ngwt__LinkInfo);
		((ngwt__LinkInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__LinkInfo[n];
		if (size)
			*size = n * sizeof(ngwt__LinkInfo);
		for (int i = 0; i < n; i++)
			((ngwt__LinkInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__LinkInfo*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__LinkInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__LinkInfo %p -> %p\n", q, p));
	*(ngwt__LinkInfo*)p = *(ngwt__LinkInfo*)q;
}

void ngwt__LibraryList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Library(soap, &((ngwt__LibraryList*)this)->library);
	/* transient soap skipped */
}

void ngwt__LibraryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Library(soap, &((ngwt__LibraryList*)this)->library);
	/* transient soap skipped */
}

int ngwt__LibraryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__LibraryList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__LibraryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__LibraryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__LibraryList(struct soap *soap, const char *tag, int id, const ngwt__LibraryList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__LibraryList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Library(soap, "ngwt:library", -1, &(((ngwt__LibraryList*)a)->library), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__LibraryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__LibraryList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__LibraryList * SOAP_FMAC4 soap_get_ngwt__LibraryList(struct soap *soap, ngwt__LibraryList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__LibraryList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__LibraryList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__LibraryList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__LibraryList * SOAP_FMAC4 soap_in_ngwt__LibraryList(struct soap *soap, const char *tag, ngwt__LibraryList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__LibraryList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__LibraryList, sizeof(ngwt__LibraryList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__LibraryList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__LibraryList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Library(soap, "ngwt:library", &(((ngwt__LibraryList*)a)->library), "ngwt:Library"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__LibraryList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__LibraryList, 0, sizeof(ngwt__LibraryList), 0, soap_copy_ngwt__LibraryList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__LibraryList * SOAP_FMAC6 soap_new_ngwt__LibraryList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__LibraryList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__LibraryList(struct soap *soap, ngwt__LibraryList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__LibraryList * SOAP_FMAC6 soap_instantiate_ngwt__LibraryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__LibraryList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__LibraryList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__LibraryList;
		if (size)
			*size = sizeof(ngwt__LibraryList);
		((ngwt__LibraryList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__LibraryList[n];
		if (size)
			*size = n * sizeof(ngwt__LibraryList);
		for (int i = 0; i < n; i++)
			((ngwt__LibraryList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__LibraryList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__LibraryList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__LibraryList %p -> %p\n", q, p));
	*(ngwt__LibraryList*)p = *(ngwt__LibraryList*)q;
}

void ngwt__Library::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Library*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Library*)this)->description);
	soap_embedded(soap, &((ngwt__Library*)this)->domain, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Library*)this)->domain);
	soap_embedded(soap, &((ngwt__Library*)this)->postOffice, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Library*)this)->postOffice);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Library::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Library*)this)->description = NULL;
	((ngwt__Library*)this)->domain = NULL;
	((ngwt__Library*)this)->postOffice = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Library::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Library);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Library::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Library(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Library(struct soap *soap, const char *tag, int id, const ngwt__Library *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Library), "ngwt:Library");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__Library*)a)->description), "");
	soap_out_PointerTostd__string(soap, "ngwt:domain", -1, &(((ngwt__Library*)a)->domain), "");
	soap_out_PointerTostd__string(soap, "ngwt:postOffice", -1, &(((ngwt__Library*)a)->postOffice), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Library::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Library(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Library * SOAP_FMAC4 soap_get_ngwt__Library(struct soap *soap, ngwt__Library *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Library(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Library::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Library(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Library * SOAP_FMAC4 soap_in_ngwt__Library(struct soap *soap, const char *tag, ngwt__Library *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Library *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Library, sizeof(ngwt__Library), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Library)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Library *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id2 = 1, soap_flag_name2 = 1, soap_flag_version2 = 1, soap_flag_modified2 = 1, soap_flag_changes2 = 1, soap_flag_description1 = 1, soap_flag_domain1 = 1, soap_flag_postOffice1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id2 = 0;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name2 = 0;
					continue;
				}
			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version2 = 0;
					continue;
				}
			if (soap_flag_modified2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified2 = 0;
					continue;
				}
			if (soap_flag_changes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__Library*)a)->description), ""))
				{	soap_flag_description1 = 0;
					continue;
				}
			if (soap_flag_domain1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:domain", &(((ngwt__Library*)a)->domain), ""))
				{	soap_flag_domain1 = 0;
					continue;
				}
			if (soap_flag_postOffice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:postOffice", &(((ngwt__Library*)a)->postOffice), ""))
				{	soap_flag_postOffice1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Library *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Library, 0, sizeof(ngwt__Library), 0, soap_copy_ngwt__Library);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Library * SOAP_FMAC6 soap_new_ngwt__Library(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Library(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Library(struct soap *soap, ngwt__Library *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Library * SOAP_FMAC6 soap_instantiate_ngwt__Library(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Library(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Library, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Library;
		if (size)
			*size = sizeof(ngwt__Library);
		((ngwt__Library*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Library[n];
		if (size)
			*size = n * sizeof(ngwt__Library);
		for (int i = 0; i < n; i++)
			((ngwt__Library*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Library*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Library(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Library %p -> %p\n", q, p));
	*(ngwt__Library*)p = *(ngwt__Library*)q;
}

void ngwt__JunkHandlingList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__JunkEntry(soap, &((ngwt__JunkHandlingList*)this)->entry);
	/* transient soap skipped */
}

void ngwt__JunkHandlingList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__JunkEntry(soap, &((ngwt__JunkHandlingList*)this)->entry);
	/* transient soap skipped */
}

int ngwt__JunkHandlingList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__JunkHandlingList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__JunkHandlingList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__JunkHandlingList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__JunkHandlingList(struct soap *soap, const char *tag, int id, const ngwt__JunkHandlingList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__JunkHandlingList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__JunkEntry(soap, "ngwt:entry", -1, &(((ngwt__JunkHandlingList*)a)->entry), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__JunkHandlingList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__JunkHandlingList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__JunkHandlingList * SOAP_FMAC4 soap_get_ngwt__JunkHandlingList(struct soap *soap, ngwt__JunkHandlingList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__JunkHandlingList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__JunkHandlingList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__JunkHandlingList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__JunkHandlingList * SOAP_FMAC4 soap_in_ngwt__JunkHandlingList(struct soap *soap, const char *tag, ngwt__JunkHandlingList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__JunkHandlingList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__JunkHandlingList, sizeof(ngwt__JunkHandlingList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__JunkHandlingList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__JunkHandlingList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__JunkEntry(soap, "ngwt:entry", &(((ngwt__JunkHandlingList*)a)->entry), "ngwt:JunkEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__JunkHandlingList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__JunkHandlingList, 0, sizeof(ngwt__JunkHandlingList), 0, soap_copy_ngwt__JunkHandlingList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__JunkHandlingList * SOAP_FMAC6 soap_new_ngwt__JunkHandlingList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__JunkHandlingList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__JunkHandlingList(struct soap *soap, ngwt__JunkHandlingList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__JunkHandlingList * SOAP_FMAC6 soap_instantiate_ngwt__JunkHandlingList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__JunkHandlingList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__JunkHandlingList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__JunkHandlingList;
		if (size)
			*size = sizeof(ngwt__JunkHandlingList);
		((ngwt__JunkHandlingList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__JunkHandlingList[n];
		if (size)
			*size = n * sizeof(ngwt__JunkHandlingList);
		for (int i = 0; i < n; i++)
			((ngwt__JunkHandlingList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__JunkHandlingList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__JunkHandlingList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__JunkHandlingList %p -> %p\n", q, p));
	*(ngwt__JunkHandlingList*)p = *(ngwt__JunkHandlingList*)q;
}

void ngwt__JunkEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__JunkEntry*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__JunkEntry*)this)->id);
	soap_embedded(soap, &((ngwt__JunkEntry*)this)->match, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__JunkEntry*)this)->match);
	soap_embedded(soap, &((ngwt__JunkEntry*)this)->matchType, SOAP_TYPE_ngwt__JunkMatchType);
	soap_embedded(soap, &((ngwt__JunkEntry*)this)->listType, SOAP_TYPE_PointerTongwt__JunkHandlingListType);
	soap_serialize_PointerTongwt__JunkHandlingListType(soap, &((ngwt__JunkEntry*)this)->listType);
	soap_embedded(soap, &((ngwt__JunkEntry*)this)->useCount, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__JunkEntry*)this)->useCount);
	soap_embedded(soap, &((ngwt__JunkEntry*)this)->lastUsed, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__JunkEntry*)this)->lastUsed);
	soap_embedded(soap, &((ngwt__JunkEntry*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__JunkEntry*)this)->version);
	soap_embedded(soap, &((ngwt__JunkEntry*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__JunkEntry*)this)->modified);
	/* transient soap skipped */
}

void ngwt__JunkEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__JunkEntry*)this)->id = NULL;
	soap_default_std__string(soap, &((ngwt__JunkEntry*)this)->match);
	soap_default_ngwt__JunkMatchType(soap, &((ngwt__JunkEntry*)this)->matchType);
	((ngwt__JunkEntry*)this)->listType = NULL;
	((ngwt__JunkEntry*)this)->useCount = NULL;
	soap_default_string(soap, &((ngwt__JunkEntry*)this)->lastUsed);
	((ngwt__JunkEntry*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__JunkEntry*)this)->modified);
	/* transient soap skipped */
}

int ngwt__JunkEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__JunkEntry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__JunkEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__JunkEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__JunkEntry(struct soap *soap, const char *tag, int id, const ngwt__JunkEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__JunkEntry), type);
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__JunkEntry*)a)->id), "");
	soap_out_std__string(soap, "ngwt:match", -1, &(((ngwt__JunkEntry*)a)->match), "");
	soap_out_ngwt__JunkMatchType(soap, "ngwt:matchType", -1, &(((ngwt__JunkEntry*)a)->matchType), "");
	soap_out_PointerTongwt__JunkHandlingListType(soap, "ngwt:listType", -1, &(((ngwt__JunkEntry*)a)->listType), "");
	soap_out_PointerToint(soap, "ngwt:useCount", -1, &(((ngwt__JunkEntry*)a)->useCount), "");
	soap_out_string(soap, "ngwt:lastUsed", -1, &(((ngwt__JunkEntry*)a)->lastUsed), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__JunkEntry*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__JunkEntry*)a)->modified), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__JunkEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__JunkEntry(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__JunkEntry * SOAP_FMAC4 soap_get_ngwt__JunkEntry(struct soap *soap, ngwt__JunkEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__JunkEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__JunkEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__JunkEntry(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__JunkEntry * SOAP_FMAC4 soap_in_ngwt__JunkEntry(struct soap *soap, const char *tag, ngwt__JunkEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__JunkEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__JunkEntry, sizeof(ngwt__JunkEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__JunkEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__JunkEntry *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_match1 = 1, soap_flag_matchType1 = 1, soap_flag_listType1 = 1, soap_flag_useCount1 = 1, soap_flag_lastUsed1 = 1, soap_flag_version1 = 1, soap_flag_modified1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__JunkEntry*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_match1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:match", &(((ngwt__JunkEntry*)a)->match), ""))
				{	soap_flag_match1 = 0;
					continue;
				}
			if (soap_flag_matchType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__JunkMatchType(soap, "ngwt:matchType", &(((ngwt__JunkEntry*)a)->matchType), ""))
				{	soap_flag_matchType1 = 0;
					continue;
				}
			if (soap_flag_listType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__JunkHandlingListType(soap, "ngwt:listType", &(((ngwt__JunkEntry*)a)->listType), ""))
				{	soap_flag_listType1 = 0;
					continue;
				}
			if (soap_flag_useCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:useCount", &(((ngwt__JunkEntry*)a)->useCount), ""))
				{	soap_flag_useCount1 = 0;
					continue;
				}
			if (soap_flag_lastUsed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:lastUsed", &(((ngwt__JunkEntry*)a)->lastUsed), ""))
				{	soap_flag_lastUsed1 = 0;
					continue;
				}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__JunkEntry*)a)->version), ""))
				{	soap_flag_version1 = 0;
					continue;
				}
			if (soap_flag_modified1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__JunkEntry*)a)->modified), ""))
				{	soap_flag_modified1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_match1 || soap_flag_matchType1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__JunkEntry *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__JunkEntry, 0, sizeof(ngwt__JunkEntry), 0, soap_copy_ngwt__JunkEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__JunkEntry * SOAP_FMAC6 soap_new_ngwt__JunkEntry(struct soap *soap, int n)
{	return soap_instantiate_ngwt__JunkEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__JunkEntry(struct soap *soap, ngwt__JunkEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__JunkEntry * SOAP_FMAC6 soap_instantiate_ngwt__JunkEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__JunkEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__JunkEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__JunkEntry;
		if (size)
			*size = sizeof(ngwt__JunkEntry);
		((ngwt__JunkEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__JunkEntry[n];
		if (size)
			*size = n * sizeof(ngwt__JunkEntry);
		for (int i = 0; i < n; i++)
			((ngwt__JunkEntry*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__JunkEntry*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__JunkEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__JunkEntry %p -> %p\n", q, p));
	*(ngwt__JunkEntry*)p = *(ngwt__JunkEntry*)q;
}

void ngwt__ItemStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ItemStatus*)this)->accepted, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__ItemStatus*)this)->accepted);
	soap_embedded(soap, &((ngwt__ItemStatus*)this)->completed, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__ItemStatus*)this)->completed);
	soap_embedded(soap, &((ngwt__ItemStatus*)this)->delegated, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__ItemStatus*)this)->delegated);
	soap_embedded(soap, &((ngwt__ItemStatus*)this)->deleted, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__ItemStatus*)this)->deleted);
	soap_embedded(soap, &((ngwt__ItemStatus*)this)->forwarded, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__ItemStatus*)this)->forwarded);
	soap_embedded(soap, &((ngwt__ItemStatus*)this)->private_, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__ItemStatus*)this)->private_);
	soap_embedded(soap, &((ngwt__ItemStatus*)this)->opened, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__ItemStatus*)this)->opened);
	soap_embedded(soap, &((ngwt__ItemStatus*)this)->read, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__ItemStatus*)this)->read);
	soap_embedded(soap, &((ngwt__ItemStatus*)this)->replied, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__ItemStatus*)this)->replied);
	/* transient soap skipped */
}

void ngwt__ItemStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__ItemStatus*)this)->accepted = NULL;
	((ngwt__ItemStatus*)this)->completed = NULL;
	((ngwt__ItemStatus*)this)->delegated = NULL;
	((ngwt__ItemStatus*)this)->deleted = NULL;
	((ngwt__ItemStatus*)this)->forwarded = NULL;
	((ngwt__ItemStatus*)this)->private_ = NULL;
	((ngwt__ItemStatus*)this)->opened = NULL;
	((ngwt__ItemStatus*)this)->read = NULL;
	((ngwt__ItemStatus*)this)->replied = NULL;
	/* transient soap skipped */
}

int ngwt__ItemStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ItemStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ItemStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ItemStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ItemStatus(struct soap *soap, const char *tag, int id, const ngwt__ItemStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ItemStatus), type);
	soap_out_PointerTobool(soap, "ngwt:accepted", -1, &(((ngwt__ItemStatus*)a)->accepted), "");
	soap_out_PointerTobool(soap, "ngwt:completed", -1, &(((ngwt__ItemStatus*)a)->completed), "");
	soap_out_PointerTobool(soap, "ngwt:delegated", -1, &(((ngwt__ItemStatus*)a)->delegated), "");
	soap_out_PointerTobool(soap, "ngwt:deleted", -1, &(((ngwt__ItemStatus*)a)->deleted), "");
	soap_out_PointerTobool(soap, "ngwt:forwarded", -1, &(((ngwt__ItemStatus*)a)->forwarded), "");
	soap_out_PointerTobool(soap, "ngwt:private", -1, &(((ngwt__ItemStatus*)a)->private_), "");
	soap_out_PointerTobool(soap, "ngwt:opened", -1, &(((ngwt__ItemStatus*)a)->opened), "");
	soap_out_PointerTobool(soap, "ngwt:read", -1, &(((ngwt__ItemStatus*)a)->read), "");
	soap_out_PointerTobool(soap, "ngwt:replied", -1, &(((ngwt__ItemStatus*)a)->replied), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ItemStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ItemStatus(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ItemStatus * SOAP_FMAC4 soap_get_ngwt__ItemStatus(struct soap *soap, ngwt__ItemStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ItemStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ItemStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ItemStatus(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ItemStatus * SOAP_FMAC4 soap_in_ngwt__ItemStatus(struct soap *soap, const char *tag, ngwt__ItemStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ItemStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ItemStatus, sizeof(ngwt__ItemStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ItemStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ItemStatus *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_accepted1 = 1, soap_flag_completed1 = 1, soap_flag_delegated1 = 1, soap_flag_deleted1 = 1, soap_flag_forwarded1 = 1, soap_flag_private_1 = 1, soap_flag_opened1 = 1, soap_flag_read1 = 1, soap_flag_replied1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accepted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:accepted", &(((ngwt__ItemStatus*)a)->accepted), ""))
				{	soap_flag_accepted1 = 0;
					continue;
				}
			if (soap_flag_completed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:completed", &(((ngwt__ItemStatus*)a)->completed), ""))
				{	soap_flag_completed1 = 0;
					continue;
				}
			if (soap_flag_delegated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:delegated", &(((ngwt__ItemStatus*)a)->delegated), ""))
				{	soap_flag_delegated1 = 0;
					continue;
				}
			if (soap_flag_deleted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:deleted", &(((ngwt__ItemStatus*)a)->deleted), ""))
				{	soap_flag_deleted1 = 0;
					continue;
				}
			if (soap_flag_forwarded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:forwarded", &(((ngwt__ItemStatus*)a)->forwarded), ""))
				{	soap_flag_forwarded1 = 0;
					continue;
				}
			if (soap_flag_private_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:private", &(((ngwt__ItemStatus*)a)->private_), ""))
				{	soap_flag_private_1 = 0;
					continue;
				}
			if (soap_flag_opened1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:opened", &(((ngwt__ItemStatus*)a)->opened), ""))
				{	soap_flag_opened1 = 0;
					continue;
				}
			if (soap_flag_read1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:read", &(((ngwt__ItemStatus*)a)->read), ""))
				{	soap_flag_read1 = 0;
					continue;
				}
			if (soap_flag_replied1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:replied", &(((ngwt__ItemStatus*)a)->replied), ""))
				{	soap_flag_replied1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ItemStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemStatus, 0, sizeof(ngwt__ItemStatus), 0, soap_copy_ngwt__ItemStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ItemStatus * SOAP_FMAC6 soap_new_ngwt__ItemStatus(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ItemStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ItemStatus(struct soap *soap, ngwt__ItemStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ItemStatus * SOAP_FMAC6 soap_instantiate_ngwt__ItemStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ItemStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ItemStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ItemStatus;
		if (size)
			*size = sizeof(ngwt__ItemStatus);
		((ngwt__ItemStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ItemStatus[n];
		if (size)
			*size = n * sizeof(ngwt__ItemStatus);
		for (int i = 0; i < n; i++)
			((ngwt__ItemStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ItemStatus*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ItemStatus(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ItemStatus %p -> %p\n", q, p));
	*(ngwt__ItemStatus*)p = *(ngwt__ItemStatus*)q;
}

void ngwt__Items::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Item(soap, &((ngwt__Items*)this)->item);
	/* transient soap skipped */
}

void ngwt__Items::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Item(soap, &((ngwt__Items*)this)->item);
	/* transient soap skipped */
}

int ngwt__Items::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Items);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Items::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Items(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Items(struct soap *soap, const char *tag, int id, const ngwt__Items *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Items), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Item(soap, "ngwt:item", -1, &(((ngwt__Items*)a)->item), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Items::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Items(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Items * SOAP_FMAC4 soap_get_ngwt__Items(struct soap *soap, ngwt__Items *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Items(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Items::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Items(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Items * SOAP_FMAC4 soap_in_ngwt__Items(struct soap *soap, const char *tag, ngwt__Items *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Items *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Items, sizeof(ngwt__Items), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Items)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Items *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Item(soap, "ngwt:item", &(((ngwt__Items*)a)->item), "ngwt:Item"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Items *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Items, 0, sizeof(ngwt__Items), 0, soap_copy_ngwt__Items);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Items * SOAP_FMAC6 soap_new_ngwt__Items(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Items(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Items(struct soap *soap, ngwt__Items *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Items * SOAP_FMAC6 soap_instantiate_ngwt__Items(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Items(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Items, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Items;
		if (size)
			*size = sizeof(ngwt__Items);
		((ngwt__Items*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Items[n];
		if (size)
			*size = n * sizeof(ngwt__Items);
		for (int i = 0; i < n; i++)
			((ngwt__Items*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Items*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Items(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Items %p -> %p\n", q, p));
	*(ngwt__Items*)p = *(ngwt__Items*)q;
}

void ngwt__ItemRefList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfngwt__uid(soap, &((ngwt__ItemRefList*)this)->item);
	/* transient soap skipped */
}

void ngwt__ItemRefList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfngwt__uid(soap, &((ngwt__ItemRefList*)this)->item);
	/* transient soap skipped */
}

int ngwt__ItemRefList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ItemRefList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ItemRefList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ItemRefList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ItemRefList(struct soap *soap, const char *tag, int id, const ngwt__ItemRefList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ItemRefList), type);
	soap_out_std__vectorTemplateOfngwt__uid(soap, "ngwt:item", -1, &(((ngwt__ItemRefList*)a)->item), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ItemRefList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ItemRefList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ItemRefList * SOAP_FMAC4 soap_get_ngwt__ItemRefList(struct soap *soap, ngwt__ItemRefList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ItemRefList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ItemRefList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ItemRefList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ItemRefList * SOAP_FMAC4 soap_in_ngwt__ItemRefList(struct soap *soap, const char *tag, ngwt__ItemRefList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ItemRefList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ItemRefList, sizeof(ngwt__ItemRefList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ItemRefList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ItemRefList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__uid(soap, "ngwt:item", &(((ngwt__ItemRefList*)a)->item), "ngwt:uid"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ItemRefList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemRefList, 0, sizeof(ngwt__ItemRefList), 0, soap_copy_ngwt__ItemRefList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ItemRefList * SOAP_FMAC6 soap_new_ngwt__ItemRefList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ItemRefList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ItemRefList(struct soap *soap, ngwt__ItemRefList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ItemRefList * SOAP_FMAC6 soap_instantiate_ngwt__ItemRefList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ItemRefList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ItemRefList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ItemRefList;
		if (size)
			*size = sizeof(ngwt__ItemRefList);
		((ngwt__ItemRefList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ItemRefList[n];
		if (size)
			*size = n * sizeof(ngwt__ItemRefList);
		for (int i = 0; i < n; i++)
			((ngwt__ItemRefList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ItemRefList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ItemRefList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ItemRefList %p -> %p\n", q, p));
	*(ngwt__ItemRefList*)p = *(ngwt__ItemRefList*)q;
}

void ngwt__ItemRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ItemRef*)this)->__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__ItemRef*)this)->__item);
	/* transient soap skipped */
}

void ngwt__ItemRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwt__ItemRef*)this)->__item);
	((ngwt__ItemRef*)this)->uid = NULL;
	/* transient soap skipped */
}

int ngwt__ItemRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ItemRef);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ItemRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ItemRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ItemRef(struct soap *soap, const char *tag, int id, const ngwt__ItemRef *a, const char *type)
{
	if (((ngwt__ItemRef *)a)->uid)
		soap_set_attr(soap, "uid", ((ngwt__ItemRef *)a)->uid->c_str());
	soap_out_std__string(soap, tag, id, &(((ngwt__ItemRef*)a)->__item), "");
	return SOAP_OK;
}

void *ngwt__ItemRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ItemRef(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ItemRef * SOAP_FMAC4 soap_get_ngwt__ItemRef(struct soap *soap, ngwt__ItemRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ItemRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ItemRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ItemRef(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ItemRef * SOAP_FMAC4 soap_in_ngwt__ItemRef(struct soap *soap, const char *tag, ngwt__ItemRef *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ngwt__ItemRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ItemRef, sizeof(ngwt__ItemRef), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ItemRef)
			return (ngwt__ItemRef *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "uid", 0);
		if (t)
		{	if (!(((ngwt__ItemRef *)a)->uid = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__ItemRef *)a)->uid = soap_new_std__string(soap, -1);
			((ngwt__ItemRef *)a)->uid->assign(s);
		}
		}
	}
	if (!soap_in_std__string(soap, tag, &(((ngwt__ItemRef*)a)->__item), "ngwt:ItemRef"))
		return NULL;
	return a;
}

SOAP_FMAC5 ngwt__ItemRef * SOAP_FMAC6 soap_new_ngwt__ItemRef(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ItemRef(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ItemRef(struct soap *soap, ngwt__ItemRef *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ItemRef * SOAP_FMAC6 soap_instantiate_ngwt__ItemRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ItemRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ItemRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ItemRef;
		if (size)
			*size = sizeof(ngwt__ItemRef);
		((ngwt__ItemRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ItemRef[n];
		if (size)
			*size = n * sizeof(ngwt__ItemRef);
		for (int i = 0; i < n; i++)
			((ngwt__ItemRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ItemRef*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ItemRef(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ItemRef %p -> %p\n", q, p));
	*(ngwt__ItemRef*)p = *(ngwt__ItemRef*)q;
}

void ngwt__ItemOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ItemOptions*)this)->priority, SOAP_TYPE_ngwt__ItemOptionsPriority);
	soap_embedded(soap, &((ngwt__ItemOptions*)this)->expires, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ItemOptions*)this)->expires);
	soap_embedded(soap, &((ngwt__ItemOptions*)this)->delayDeliveryUntil, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ItemOptions*)this)->delayDeliveryUntil);
	soap_embedded(soap, &((ngwt__ItemOptions*)this)->concealSubject, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__ItemOptions*)this)->concealSubject);
	soap_embedded(soap, &((ngwt__ItemOptions*)this)->hidden, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__ItemOptions*)this)->hidden);
	/* transient soap skipped */
}

void ngwt__ItemOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__ItemOptions*)this)->priority = (enum ngwt__ItemOptionsPriority)1;
	soap_default_string(soap, &((ngwt__ItemOptions*)this)->expires);
	soap_default_string(soap, &((ngwt__ItemOptions*)this)->delayDeliveryUntil);
	((ngwt__ItemOptions*)this)->concealSubject = NULL;
	((ngwt__ItemOptions*)this)->hidden = NULL;
	/* transient soap skipped */
}

int ngwt__ItemOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ItemOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ItemOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ItemOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ItemOptions(struct soap *soap, const char *tag, int id, const ngwt__ItemOptions *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ItemOptions), type);
	soap_out_ngwt__ItemOptionsPriority(soap, "ngwt:priority", -1, &(((ngwt__ItemOptions*)a)->priority), "");
	soap_out_string(soap, "ngwt:expires", -1, &(((ngwt__ItemOptions*)a)->expires), "");
	soap_out_string(soap, "ngwt:delayDeliveryUntil", -1, &(((ngwt__ItemOptions*)a)->delayDeliveryUntil), "");
	soap_out_PointerTobool(soap, "ngwt:concealSubject", -1, &(((ngwt__ItemOptions*)a)->concealSubject), "");
	soap_out_PointerTobool(soap, "ngwt:hidden", -1, &(((ngwt__ItemOptions*)a)->hidden), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ItemOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ItemOptions(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ItemOptions * SOAP_FMAC4 soap_get_ngwt__ItemOptions(struct soap *soap, ngwt__ItemOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ItemOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ItemOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ItemOptions(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ItemOptions * SOAP_FMAC4 soap_in_ngwt__ItemOptions(struct soap *soap, const char *tag, ngwt__ItemOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ItemOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ItemOptions, sizeof(ngwt__ItemOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ItemOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ItemOptions *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_priority1 = 1, soap_flag_expires1 = 1, soap_flag_delayDeliveryUntil1 = 1, soap_flag_concealSubject1 = 1, soap_flag_hidden1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__ItemOptionsPriority(soap, "ngwt:priority", &(((ngwt__ItemOptions*)a)->priority), ""))
				{	soap_flag_priority1 = 0;
					continue;
				}
			if (soap_flag_expires1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:expires", &(((ngwt__ItemOptions*)a)->expires), ""))
				{	soap_flag_expires1 = 0;
					continue;
				}
			if (soap_flag_delayDeliveryUntil1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delayDeliveryUntil", &(((ngwt__ItemOptions*)a)->delayDeliveryUntil), ""))
				{	soap_flag_delayDeliveryUntil1 = 0;
					continue;
				}
			if (soap_flag_concealSubject1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:concealSubject", &(((ngwt__ItemOptions*)a)->concealSubject), ""))
				{	soap_flag_concealSubject1 = 0;
					continue;
				}
			if (soap_flag_hidden1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:hidden", &(((ngwt__ItemOptions*)a)->hidden), ""))
				{	soap_flag_hidden1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ItemOptions *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemOptions, 0, sizeof(ngwt__ItemOptions), 0, soap_copy_ngwt__ItemOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ItemOptions * SOAP_FMAC6 soap_new_ngwt__ItemOptions(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ItemOptions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ItemOptions(struct soap *soap, ngwt__ItemOptions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ItemOptions * SOAP_FMAC6 soap_instantiate_ngwt__ItemOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ItemOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ItemOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ItemOptions;
		if (size)
			*size = sizeof(ngwt__ItemOptions);
		((ngwt__ItemOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ItemOptions[n];
		if (size)
			*size = n * sizeof(ngwt__ItemOptions);
		for (int i = 0; i < n; i++)
			((ngwt__ItemOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ItemOptions*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ItemOptions(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ItemOptions %p -> %p\n", q, p));
	*(ngwt__ItemOptions*)p = *(ngwt__ItemOptions*)q;
}

void ngwt__ItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Item(soap, &((ngwt__ItemList*)this)->item);
	/* transient soap skipped */
}

void ngwt__ItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Item(soap, &((ngwt__ItemList*)this)->item);
	((ngwt__ItemList*)this)->offset = NULL;
	((ngwt__ItemList*)this)->count = NULL;
	/* transient soap skipped */
}

int ngwt__ItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ItemList(struct soap *soap, const char *tag, int id, const ngwt__ItemList *a, const char *type)
{
	if (((ngwt__ItemList *)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ngwt__ItemList *)a)->offset));
	if (((ngwt__ItemList *)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ngwt__ItemList *)a)->count));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ItemList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Item(soap, "ngwt:item", -1, &(((ngwt__ItemList*)a)->item), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ItemList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ItemList * SOAP_FMAC4 soap_get_ngwt__ItemList(struct soap *soap, ngwt__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ItemList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ItemList * SOAP_FMAC4 soap_in_ngwt__ItemList(struct soap *soap, const char *tag, ngwt__ItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ItemList, sizeof(ngwt__ItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if (t)
		{	if (!(((ngwt__ItemList *)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((ngwt__ItemList *)a)->offset))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if (t)
		{	if (!(((ngwt__ItemList *)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((ngwt__ItemList *)a)->count))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Item(soap, "ngwt:item", &(((ngwt__ItemList*)a)->item), "ngwt:Item"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ItemList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemList, 0, sizeof(ngwt__ItemList), 0, soap_copy_ngwt__ItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ItemList * SOAP_FMAC6 soap_new_ngwt__ItemList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ItemList(struct soap *soap, ngwt__ItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ItemList * SOAP_FMAC6 soap_instantiate_ngwt__ItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ItemList;
		if (size)
			*size = sizeof(ngwt__ItemList);
		((ngwt__ItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ItemList[n];
		if (size)
			*size = n * sizeof(ngwt__ItemList);
		for (int i = 0; i < n; i++)
			((ngwt__ItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ItemList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ItemList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ItemList %p -> %p\n", q, p));
	*(ngwt__ItemList*)p = *(ngwt__ItemList*)q;
}

void ngwt__ItemChanges::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ItemChanges*)this)->add, SOAP_TYPE_PointerTongwt__Item);
	soap_serialize_PointerTongwt__Item(soap, &((ngwt__ItemChanges*)this)->add);
	soap_embedded(soap, &((ngwt__ItemChanges*)this)->_delete, SOAP_TYPE_PointerTongwt__Item);
	soap_serialize_PointerTongwt__Item(soap, &((ngwt__ItemChanges*)this)->_delete);
	soap_embedded(soap, &((ngwt__ItemChanges*)this)->update, SOAP_TYPE_PointerTongwt__Item);
	soap_serialize_PointerTongwt__Item(soap, &((ngwt__ItemChanges*)this)->update);
	/* transient soap skipped */
}

void ngwt__ItemChanges::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__ItemChanges*)this)->add = NULL;
	((ngwt__ItemChanges*)this)->_delete = NULL;
	((ngwt__ItemChanges*)this)->update = NULL;
	/* transient soap skipped */
}

int ngwt__ItemChanges::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ItemChanges);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ItemChanges::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ItemChanges(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ItemChanges(struct soap *soap, const char *tag, int id, const ngwt__ItemChanges *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ItemChanges), type);
	soap_out_PointerTongwt__Item(soap, "ngwt:add", -1, &(((ngwt__ItemChanges*)a)->add), "");
	soap_out_PointerTongwt__Item(soap, "ngwt:delete", -1, &(((ngwt__ItemChanges*)a)->_delete), "");
	soap_out_PointerTongwt__Item(soap, "ngwt:update", -1, &(((ngwt__ItemChanges*)a)->update), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ItemChanges::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ItemChanges(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ItemChanges * SOAP_FMAC4 soap_get_ngwt__ItemChanges(struct soap *soap, ngwt__ItemChanges *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ItemChanges(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ItemChanges::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ItemChanges(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ItemChanges * SOAP_FMAC4 soap_in_ngwt__ItemChanges(struct soap *soap, const char *tag, ngwt__ItemChanges *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ItemChanges *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ItemChanges, sizeof(ngwt__ItemChanges), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ItemChanges)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ItemChanges *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_add1 = 1, soap_flag_delete1 = 1, soap_flag_update1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_add1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Item(soap, "ngwt:add", &(((ngwt__ItemChanges*)a)->add), "ngwt:Item"))
				{	soap_flag_add1 = 0;
					continue;
				}
			if (soap_flag_delete1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Item(soap, "ngwt:delete", &(((ngwt__ItemChanges*)a)->_delete), "ngwt:Item"))
				{	soap_flag_delete1 = 0;
					continue;
				}
			if (soap_flag_update1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Item(soap, "ngwt:update", &(((ngwt__ItemChanges*)a)->update), "ngwt:Item"))
				{	soap_flag_update1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ItemChanges *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemChanges, 0, sizeof(ngwt__ItemChanges), 0, soap_copy_ngwt__ItemChanges);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ItemChanges * SOAP_FMAC6 soap_new_ngwt__ItemChanges(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ItemChanges(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ItemChanges(struct soap *soap, ngwt__ItemChanges *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ItemChanges * SOAP_FMAC6 soap_instantiate_ngwt__ItemChanges(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ItemChanges(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ItemChanges, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ItemChanges;
		if (size)
			*size = sizeof(ngwt__ItemChanges);
		((ngwt__ItemChanges*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ItemChanges[n];
		if (size)
			*size = n * sizeof(ngwt__ItemChanges);
		for (int i = 0; i < n; i++)
			((ngwt__ItemChanges*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ItemChanges*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ItemChanges(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ItemChanges %p -> %p\n", q, p));
	*(ngwt__ItemChanges*)p = *(ngwt__ItemChanges*)q;
}

void ngwt__Item::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Item::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Item::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Item);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Item::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Item(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Item(struct soap *soap, const char *tag, int id, const ngwt__Item *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Item), type);
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Item::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Item(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Item * SOAP_FMAC4 soap_get_ngwt__Item(struct soap *soap, ngwt__Item *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Item(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Item::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Item(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Item * SOAP_FMAC4 soap_in_ngwt__Item(struct soap *soap, const char *tag, ngwt__Item *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Item *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Item, sizeof(ngwt__Item), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Item)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Item *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_name1 = 1, soap_flag_version1 = 1, soap_flag_modified1 = 1, soap_flag_changes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version1 = 0;
					continue;
				}
			if (soap_flag_modified1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified1 = 0;
					continue;
				}
			if (soap_flag_changes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Item *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Item, 0, sizeof(ngwt__Item), 0, soap_copy_ngwt__Item);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Item * SOAP_FMAC6 soap_new_ngwt__Item(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Item(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Item(struct soap *soap, ngwt__Item *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Item * SOAP_FMAC6 soap_instantiate_ngwt__Item(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Item(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Item, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:AddressBook"))
	{	cp->type = SOAP_TYPE_ngwt__AddressBook;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__AddressBook;
			if (size)
				*size = sizeof(ngwt__AddressBook);
			((ngwt__AddressBook*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__AddressBook[n];
			if (size)
				*size = n * sizeof(ngwt__AddressBook);
			for (int i = 0; i < n; i++)
				((ngwt__AddressBook*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__AddressBook*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Category"))
	{	cp->type = SOAP_TYPE_ngwt__Category;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Category;
			if (size)
				*size = sizeof(ngwt__Category);
			((ngwt__Category*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Category[n];
			if (size)
				*size = n * sizeof(ngwt__Category);
			for (int i = 0; i < n; i++)
				((ngwt__Category*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Category*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:ContainerItem"))
	{	cp->type = SOAP_TYPE_ngwt__ContainerItem;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__ContainerItem;
			if (size)
				*size = sizeof(ngwt__ContainerItem);
			((ngwt__ContainerItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__ContainerItem[n];
			if (size)
				*size = n * sizeof(ngwt__ContainerItem);
			for (int i = 0; i < n; i++)
				((ngwt__ContainerItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__ContainerItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Folder"))
	{	cp->type = SOAP_TYPE_ngwt__Folder;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Folder;
			if (size)
				*size = sizeof(ngwt__Folder);
			((ngwt__Folder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Folder[n];
			if (size)
				*size = n * sizeof(ngwt__Folder);
			for (int i = 0; i < n; i++)
				((ngwt__Folder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Folder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Library"))
	{	cp->type = SOAP_TYPE_ngwt__Library;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Library;
			if (size)
				*size = sizeof(ngwt__Library);
			((ngwt__Library*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Library[n];
			if (size)
				*size = n * sizeof(ngwt__Library);
			for (int i = 0; i < n; i++)
				((ngwt__Library*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Library*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:AddressBookItem"))
	{	cp->type = SOAP_TYPE_ngwt__AddressBookItem;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__AddressBookItem;
			if (size)
				*size = sizeof(ngwt__AddressBookItem);
			((ngwt__AddressBookItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__AddressBookItem[n];
			if (size)
				*size = n * sizeof(ngwt__AddressBookItem);
			for (int i = 0; i < n; i++)
				((ngwt__AddressBookItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__AddressBookItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:BoxEntry"))
	{	cp->type = SOAP_TYPE_ngwt__BoxEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__BoxEntry;
			if (size)
				*size = sizeof(ngwt__BoxEntry);
			((ngwt__BoxEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__BoxEntry[n];
			if (size)
				*size = n * sizeof(ngwt__BoxEntry);
			for (int i = 0; i < n; i++)
				((ngwt__BoxEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__BoxEntry*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Document"))
	{	cp->type = SOAP_TYPE_ngwt__Document;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Document;
			if (size)
				*size = sizeof(ngwt__Document);
			((ngwt__Document*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Document[n];
			if (size)
				*size = n * sizeof(ngwt__Document);
			for (int i = 0; i < n; i++)
				((ngwt__Document*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Document*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:QueryFolder"))
	{	cp->type = SOAP_TYPE_ngwt__QueryFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__QueryFolder;
			if (size)
				*size = sizeof(ngwt__QueryFolder);
			((ngwt__QueryFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__QueryFolder[n];
			if (size)
				*size = n * sizeof(ngwt__QueryFolder);
			for (int i = 0; i < n; i++)
				((ngwt__QueryFolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__QueryFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Rule"))
	{	cp->type = SOAP_TYPE_ngwt__Rule;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Rule;
			if (size)
				*size = sizeof(ngwt__Rule);
			((ngwt__Rule*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Rule[n];
			if (size)
				*size = n * sizeof(ngwt__Rule);
			for (int i = 0; i < n; i++)
				((ngwt__Rule*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Rule*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:SharedFolder"))
	{	cp->type = SOAP_TYPE_ngwt__SharedFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__SharedFolder;
			if (size)
				*size = sizeof(ngwt__SharedFolder);
			((ngwt__SharedFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__SharedFolder[n];
			if (size)
				*size = n * sizeof(ngwt__SharedFolder);
			for (int i = 0; i < n; i++)
				((ngwt__SharedFolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__SharedFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:SystemFolder"))
	{	cp->type = SOAP_TYPE_ngwt__SystemFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__SystemFolder;
			if (size)
				*size = sizeof(ngwt__SystemFolder);
			((ngwt__SystemFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__SystemFolder[n];
			if (size)
				*size = n * sizeof(ngwt__SystemFolder);
			for (int i = 0; i < n; i++)
				((ngwt__SystemFolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__SystemFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Version"))
	{	cp->type = SOAP_TYPE_ngwt__Version;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Version;
			if (size)
				*size = sizeof(ngwt__Version);
			((ngwt__Version*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Version[n];
			if (size)
				*size = n * sizeof(ngwt__Version);
			for (int i = 0; i < n; i++)
				((ngwt__Version*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Version*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:VersionEvent"))
	{	cp->type = SOAP_TYPE_ngwt__VersionEvent;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__VersionEvent;
			if (size)
				*size = sizeof(ngwt__VersionEvent);
			((ngwt__VersionEvent*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__VersionEvent[n];
			if (size)
				*size = n * sizeof(ngwt__VersionEvent);
			for (int i = 0; i < n; i++)
				((ngwt__VersionEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__VersionEvent*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Contact"))
	{	cp->type = SOAP_TYPE_ngwt__Contact;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Contact;
			if (size)
				*size = sizeof(ngwt__Contact);
			((ngwt__Contact*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Contact[n];
			if (size)
				*size = n * sizeof(ngwt__Contact);
			for (int i = 0; i < n; i++)
				((ngwt__Contact*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Contact*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:ContactFolder"))
	{	cp->type = SOAP_TYPE_ngwt__ContactFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__ContactFolder;
			if (size)
				*size = sizeof(ngwt__ContactFolder);
			((ngwt__ContactFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__ContactFolder[n];
			if (size)
				*size = n * sizeof(ngwt__ContactFolder);
			for (int i = 0; i < n; i++)
				((ngwt__ContactFolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__ContactFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Group"))
	{	cp->type = SOAP_TYPE_ngwt__Group;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Group;
			if (size)
				*size = sizeof(ngwt__Group);
			((ngwt__Group*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Group[n];
			if (size)
				*size = n * sizeof(ngwt__Group);
			for (int i = 0; i < n; i++)
				((ngwt__Group*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Group*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Mail"))
	{	cp->type = SOAP_TYPE_ngwt__Mail;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Mail;
			if (size)
				*size = sizeof(ngwt__Mail);
			((ngwt__Mail*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Mail[n];
			if (size)
				*size = n * sizeof(ngwt__Mail);
			for (int i = 0; i < n; i++)
				((ngwt__Mail*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Mail*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Organization"))
	{	cp->type = SOAP_TYPE_ngwt__Organization;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Organization;
			if (size)
				*size = sizeof(ngwt__Organization);
			((ngwt__Organization*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Organization[n];
			if (size)
				*size = n * sizeof(ngwt__Organization);
			for (int i = 0; i < n; i++)
				((ngwt__Organization*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Organization*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Resource"))
	{	cp->type = SOAP_TYPE_ngwt__Resource;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Resource;
			if (size)
				*size = sizeof(ngwt__Resource);
			((ngwt__Resource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Resource[n];
			if (size)
				*size = n * sizeof(ngwt__Resource);
			for (int i = 0; i < n; i++)
				((ngwt__Resource*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Resource*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:CalendarItem"))
	{	cp->type = SOAP_TYPE_ngwt__CalendarItem;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__CalendarItem;
			if (size)
				*size = sizeof(ngwt__CalendarItem);
			((ngwt__CalendarItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__CalendarItem[n];
			if (size)
				*size = n * sizeof(ngwt__CalendarItem);
			for (int i = 0; i < n; i++)
				((ngwt__CalendarItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__CalendarItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:DocumentRef"))
	{	cp->type = SOAP_TYPE_ngwt__DocumentRef;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__DocumentRef;
			if (size)
				*size = sizeof(ngwt__DocumentRef);
			((ngwt__DocumentRef*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__DocumentRef[n];
			if (size)
				*size = n * sizeof(ngwt__DocumentRef);
			for (int i = 0; i < n; i++)
				((ngwt__DocumentRef*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__DocumentRef*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:PhoneMessage"))
	{	cp->type = SOAP_TYPE_ngwt__PhoneMessage;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__PhoneMessage;
			if (size)
				*size = sizeof(ngwt__PhoneMessage);
			((ngwt__PhoneMessage*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__PhoneMessage[n];
			if (size)
				*size = n * sizeof(ngwt__PhoneMessage);
			for (int i = 0; i < n; i++)
				((ngwt__PhoneMessage*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__PhoneMessage*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:SharedNotification"))
	{	cp->type = SOAP_TYPE_ngwt__SharedNotification;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__SharedNotification;
			if (size)
				*size = sizeof(ngwt__SharedNotification);
			((ngwt__SharedNotification*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__SharedNotification[n];
			if (size)
				*size = n * sizeof(ngwt__SharedNotification);
			for (int i = 0; i < n; i++)
				((ngwt__SharedNotification*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__SharedNotification*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Appointment"))
	{	cp->type = SOAP_TYPE_ngwt__Appointment;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Appointment;
			if (size)
				*size = sizeof(ngwt__Appointment);
			((ngwt__Appointment*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Appointment[n];
			if (size)
				*size = n * sizeof(ngwt__Appointment);
			for (int i = 0; i < n; i++)
				((ngwt__Appointment*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Appointment*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Note"))
	{	cp->type = SOAP_TYPE_ngwt__Note;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Note;
			if (size)
				*size = sizeof(ngwt__Note);
			((ngwt__Note*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Note[n];
			if (size)
				*size = n * sizeof(ngwt__Note);
			for (int i = 0; i < n; i++)
				((ngwt__Note*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Note*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Task"))
	{	cp->type = SOAP_TYPE_ngwt__Task;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Task;
			if (size)
				*size = sizeof(ngwt__Task);
			((ngwt__Task*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Task[n];
			if (size)
				*size = n * sizeof(ngwt__Task);
			for (int i = 0; i < n; i++)
				((ngwt__Task*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Task*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Item;
		if (size)
			*size = sizeof(ngwt__Item);
		((ngwt__Item*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Item[n];
		if (size)
			*size = n * sizeof(ngwt__Item);
		for (int i = 0; i < n; i++)
			((ngwt__Item*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Item*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Item(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Item %p -> %p\n", q, p));
	*(ngwt__Item*)p = *(ngwt__Item*)q;
}

void ngwt__ImAddressList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__ImAddress(soap, &((ngwt__ImAddressList*)this)->im);
	/* transient soap skipped */
}

void ngwt__ImAddressList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__ImAddress(soap, &((ngwt__ImAddressList*)this)->im);
	/* transient soap skipped */
}

int ngwt__ImAddressList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ImAddressList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ImAddressList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ImAddressList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ImAddressList(struct soap *soap, const char *tag, int id, const ngwt__ImAddressList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ImAddressList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__ImAddress(soap, "ngwt:im", -1, &(((ngwt__ImAddressList*)a)->im), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ImAddressList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ImAddressList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ImAddressList * SOAP_FMAC4 soap_get_ngwt__ImAddressList(struct soap *soap, ngwt__ImAddressList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ImAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ImAddressList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ImAddressList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ImAddressList * SOAP_FMAC4 soap_in_ngwt__ImAddressList(struct soap *soap, const char *tag, ngwt__ImAddressList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ImAddressList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ImAddressList, sizeof(ngwt__ImAddressList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ImAddressList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ImAddressList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ImAddress(soap, "ngwt:im", &(((ngwt__ImAddressList*)a)->im), "ngwt:ImAddress"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ImAddressList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ImAddressList, 0, sizeof(ngwt__ImAddressList), 0, soap_copy_ngwt__ImAddressList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ImAddressList * SOAP_FMAC6 soap_new_ngwt__ImAddressList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ImAddressList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ImAddressList(struct soap *soap, ngwt__ImAddressList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ImAddressList * SOAP_FMAC6 soap_instantiate_ngwt__ImAddressList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ImAddressList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ImAddressList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ImAddressList;
		if (size)
			*size = sizeof(ngwt__ImAddressList);
		((ngwt__ImAddressList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ImAddressList[n];
		if (size)
			*size = n * sizeof(ngwt__ImAddressList);
		for (int i = 0; i < n; i++)
			((ngwt__ImAddressList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ImAddressList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ImAddressList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ImAddressList %p -> %p\n", q, p));
	*(ngwt__ImAddressList*)p = *(ngwt__ImAddressList*)q;
}

void ngwt__ImAddress::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ImAddress*)this)->service, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__ImAddress*)this)->service);
	soap_embedded(soap, &((ngwt__ImAddress*)this)->address, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__ImAddress*)this)->address);
	soap_embedded(soap, &((ngwt__ImAddress*)this)->type, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__ImAddress*)this)->type);
	/* transient soap skipped */
}

void ngwt__ImAddress::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__ImAddress*)this)->service = NULL;
	((ngwt__ImAddress*)this)->address = NULL;
	((ngwt__ImAddress*)this)->type = NULL;
	/* transient soap skipped */
}

int ngwt__ImAddress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ImAddress);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ImAddress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ImAddress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ImAddress(struct soap *soap, const char *tag, int id, const ngwt__ImAddress *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ImAddress), type);
	soap_out_PointerTostd__string(soap, "ngwt:service", -1, &(((ngwt__ImAddress*)a)->service), "");
	soap_out_PointerTostd__string(soap, "ngwt:address", -1, &(((ngwt__ImAddress*)a)->address), "");
	soap_out_PointerTostd__string(soap, "ngwt:type", -1, &(((ngwt__ImAddress*)a)->type), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ImAddress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ImAddress(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ImAddress * SOAP_FMAC4 soap_get_ngwt__ImAddress(struct soap *soap, ngwt__ImAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ImAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ImAddress::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ImAddress(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ImAddress * SOAP_FMAC4 soap_in_ngwt__ImAddress(struct soap *soap, const char *tag, ngwt__ImAddress *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ImAddress *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ImAddress, sizeof(ngwt__ImAddress), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ImAddress)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ImAddress *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_service1 = 1, soap_flag_address1 = 1, soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_service1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:service", &(((ngwt__ImAddress*)a)->service), ""))
				{	soap_flag_service1 = 0;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:address", &(((ngwt__ImAddress*)a)->address), ""))
				{	soap_flag_address1 = 0;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:type", &(((ngwt__ImAddress*)a)->type), ""))
				{	soap_flag_type1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ImAddress *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ImAddress, 0, sizeof(ngwt__ImAddress), 0, soap_copy_ngwt__ImAddress);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ImAddress * SOAP_FMAC6 soap_new_ngwt__ImAddress(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ImAddress(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ImAddress(struct soap *soap, ngwt__ImAddress *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ImAddress * SOAP_FMAC6 soap_instantiate_ngwt__ImAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ImAddress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ImAddress, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ImAddress;
		if (size)
			*size = sizeof(ngwt__ImAddress);
		((ngwt__ImAddress*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ImAddress[n];
		if (size)
			*size = n * sizeof(ngwt__ImAddress);
		for (int i = 0; i < n; i++)
			((ngwt__ImAddress*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ImAddress*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ImAddress(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ImAddress %p -> %p\n", q, p));
	*(ngwt__ImAddress*)p = *(ngwt__ImAddress*)q;
}

void ngwt__Host::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Host*)this)->ipAddress, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Host*)this)->ipAddress);
	soap_embedded(soap, &((ngwt__Host*)this)->port, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Host*)this)->port);
	/* transient soap skipped */
}

void ngwt__Host::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Host*)this)->ipAddress = NULL;
	((ngwt__Host*)this)->port = NULL;
	/* transient soap skipped */
}

int ngwt__Host::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Host);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Host::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Host(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Host(struct soap *soap, const char *tag, int id, const ngwt__Host *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Host), type);
	soap_out_PointerTostd__string(soap, "ngwt:ipAddress", -1, &(((ngwt__Host*)a)->ipAddress), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:port", -1, &(((ngwt__Host*)a)->port), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Host::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Host(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Host * SOAP_FMAC4 soap_get_ngwt__Host(struct soap *soap, ngwt__Host *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Host(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Host::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Host(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Host * SOAP_FMAC4 soap_in_ngwt__Host(struct soap *soap, const char *tag, ngwt__Host *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Host *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Host, sizeof(ngwt__Host), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Host)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Host *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ipAddress1 = 1, soap_flag_port1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ipAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:ipAddress", &(((ngwt__Host*)a)->ipAddress), ""))
				{	soap_flag_ipAddress1 = 0;
					continue;
				}
			if (soap_flag_port1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:port", &(((ngwt__Host*)a)->port), ""))
				{	soap_flag_port1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Host *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Host, 0, sizeof(ngwt__Host), 0, soap_copy_ngwt__Host);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Host * SOAP_FMAC6 soap_new_ngwt__Host(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Host(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Host(struct soap *soap, ngwt__Host *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Host * SOAP_FMAC6 soap_instantiate_ngwt__Host(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Host(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Host, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Host;
		if (size)
			*size = sizeof(ngwt__Host);
		((ngwt__Host*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Host[n];
		if (size)
			*size = n * sizeof(ngwt__Host);
		for (int i = 0; i < n; i++)
			((ngwt__Host*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Host*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Host(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Host %p -> %p\n", q, p));
	*(ngwt__Host*)p = *(ngwt__Host*)q;
}

void ngwt__GroupMemberList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__GroupMember(soap, &((ngwt__GroupMemberList*)this)->member);
	/* transient soap skipped */
}

void ngwt__GroupMemberList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__GroupMember(soap, &((ngwt__GroupMemberList*)this)->member);
	/* transient soap skipped */
}

int ngwt__GroupMemberList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__GroupMemberList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__GroupMemberList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__GroupMemberList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__GroupMemberList(struct soap *soap, const char *tag, int id, const ngwt__GroupMemberList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__GroupMemberList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__GroupMember(soap, "ngwt:member", -1, &(((ngwt__GroupMemberList*)a)->member), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__GroupMemberList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__GroupMemberList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__GroupMemberList * SOAP_FMAC4 soap_get_ngwt__GroupMemberList(struct soap *soap, ngwt__GroupMemberList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__GroupMemberList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__GroupMemberList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__GroupMemberList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__GroupMemberList * SOAP_FMAC4 soap_in_ngwt__GroupMemberList(struct soap *soap, const char *tag, ngwt__GroupMemberList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__GroupMemberList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__GroupMemberList, sizeof(ngwt__GroupMemberList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__GroupMemberList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__GroupMemberList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__GroupMember(soap, "ngwt:member", &(((ngwt__GroupMemberList*)a)->member), "ngwt:GroupMember"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__GroupMemberList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__GroupMemberList, 0, sizeof(ngwt__GroupMemberList), 0, soap_copy_ngwt__GroupMemberList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__GroupMemberList * SOAP_FMAC6 soap_new_ngwt__GroupMemberList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__GroupMemberList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__GroupMemberList(struct soap *soap, ngwt__GroupMemberList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__GroupMemberList * SOAP_FMAC6 soap_instantiate_ngwt__GroupMemberList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__GroupMemberList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__GroupMemberList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__GroupMemberList;
		if (size)
			*size = sizeof(ngwt__GroupMemberList);
		((ngwt__GroupMemberList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__GroupMemberList[n];
		if (size)
			*size = n * sizeof(ngwt__GroupMemberList);
		for (int i = 0; i < n; i++)
			((ngwt__GroupMemberList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__GroupMemberList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__GroupMemberList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__GroupMemberList %p -> %p\n", q, p));
	*(ngwt__GroupMemberList*)p = *(ngwt__GroupMemberList*)q;
}

void ngwt__GroupMember::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__GroupMember*)this)->id, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((ngwt__GroupMember*)this)->id);
	soap_embedded(soap, &((ngwt__GroupMember*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__GroupMember*)this)->name);
	soap_embedded(soap, &((ngwt__GroupMember*)this)->email, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__GroupMember*)this)->email);
	soap_embedded(soap, &((ngwt__GroupMember*)this)->distType, SOAP_TYPE_ngwt__DistributionType);
	soap_embedded(soap, &((ngwt__GroupMember*)this)->itemType, SOAP_TYPE_ngwt__ContactType);
	soap_embedded(soap, &((ngwt__GroupMember*)this)->members, SOAP_TYPE_PointerTongwt__GroupMemberList);
	soap_serialize_PointerTongwt__GroupMemberList(soap, &((ngwt__GroupMember*)this)->members);
	/* transient soap skipped */
}

void ngwt__GroupMember::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((ngwt__GroupMember*)this)->id);
	((ngwt__GroupMember*)this)->name = NULL;
	soap_default_std__string(soap, &((ngwt__GroupMember*)this)->email);
	((ngwt__GroupMember*)this)->distType = (enum ngwt__DistributionType)0;
	((ngwt__GroupMember*)this)->itemType = (enum ngwt__ContactType)0;
	((ngwt__GroupMember*)this)->members = NULL;
	/* transient soap skipped */
}

int ngwt__GroupMember::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__GroupMember);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__GroupMember::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__GroupMember(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__GroupMember(struct soap *soap, const char *tag, int id, const ngwt__GroupMember *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__GroupMember), type);
	soap_out_ngwt__uid(soap, "ngwt:id", -1, &(((ngwt__GroupMember*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__GroupMember*)a)->name), "");
	soap_out_std__string(soap, "ngwt:email", -1, &(((ngwt__GroupMember*)a)->email), "");
	soap_out_ngwt__DistributionType(soap, "ngwt:distType", -1, &(((ngwt__GroupMember*)a)->distType), "");
	soap_out_ngwt__ContactType(soap, "ngwt:itemType", -1, &(((ngwt__GroupMember*)a)->itemType), "");
	soap_out_PointerTongwt__GroupMemberList(soap, "ngwt:members", -1, &(((ngwt__GroupMember*)a)->members), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__GroupMember::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__GroupMember(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__GroupMember * SOAP_FMAC4 soap_get_ngwt__GroupMember(struct soap *soap, ngwt__GroupMember *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__GroupMember(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__GroupMember::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__GroupMember(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__GroupMember * SOAP_FMAC4 soap_in_ngwt__GroupMember(struct soap *soap, const char *tag, ngwt__GroupMember *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__GroupMember *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__GroupMember, sizeof(ngwt__GroupMember), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__GroupMember)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__GroupMember *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_name1 = 1, soap_flag_email1 = 1, soap_flag_distType1 = 1, soap_flag_itemType1 = 1, soap_flag_members1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwt:id", &(((ngwt__GroupMember*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__GroupMember*)a)->name), ""))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:email", &(((ngwt__GroupMember*)a)->email), ""))
				{	soap_flag_email1 = 0;
					continue;
				}
			if (soap_flag_distType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__DistributionType(soap, "ngwt:distType", &(((ngwt__GroupMember*)a)->distType), ""))
				{	soap_flag_distType1 = 0;
					continue;
				}
			if (soap_flag_itemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__ContactType(soap, "ngwt:itemType", &(((ngwt__GroupMember*)a)->itemType), ""))
				{	soap_flag_itemType1 = 0;
					continue;
				}
			if (soap_flag_members1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__GroupMemberList(soap, "ngwt:members", &(((ngwt__GroupMember*)a)->members), "ngwt:GroupMemberList"))
				{	soap_flag_members1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 || soap_flag_email1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__GroupMember *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__GroupMember, 0, sizeof(ngwt__GroupMember), 0, soap_copy_ngwt__GroupMember);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__GroupMember * SOAP_FMAC6 soap_new_ngwt__GroupMember(struct soap *soap, int n)
{	return soap_instantiate_ngwt__GroupMember(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__GroupMember(struct soap *soap, ngwt__GroupMember *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__GroupMember * SOAP_FMAC6 soap_instantiate_ngwt__GroupMember(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__GroupMember(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__GroupMember, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__GroupMember;
		if (size)
			*size = sizeof(ngwt__GroupMember);
		((ngwt__GroupMember*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__GroupMember[n];
		if (size)
			*size = n * sizeof(ngwt__GroupMember);
		for (int i = 0; i < n; i++)
			((ngwt__GroupMember*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__GroupMember*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__GroupMember(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__GroupMember %p -> %p\n", q, p));
	*(ngwt__GroupMember*)p = *(ngwt__GroupMember*)q;
}

void ngwt__Group::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Group*)this)->members, SOAP_TYPE_PointerTongwt__GroupMemberList);
	soap_serialize_PointerTongwt__GroupMemberList(soap, &((ngwt__Group*)this)->members);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__AddressBookItem*)this)->uuid);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->comment);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->sync, SOAP_TYPE_PointerTongwt__DeltaSyncType);
	soap_serialize_PointerTongwt__DeltaSyncType(soap, &((ngwt__AddressBookItem*)this)->sync);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->domain, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->domain);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->postOffice, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->postOffice);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->distinguishedName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->distinguishedName);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->userid, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->userid);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Group::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Group*)this)->members = NULL;
	((ngwt__AddressBookItem*)this)->uuid = NULL;
	((ngwt__AddressBookItem*)this)->comment = NULL;
	((ngwt__AddressBookItem*)this)->sync = NULL;
	((ngwt__AddressBookItem*)this)->domain = NULL;
	((ngwt__AddressBookItem*)this)->postOffice = NULL;
	((ngwt__AddressBookItem*)this)->distinguishedName = NULL;
	((ngwt__AddressBookItem*)this)->userid = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Group::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Group);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Group::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Group(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Group(struct soap *soap, const char *tag, int id, const ngwt__Group *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Group), "ngwt:Group");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__AddressBookItem*)a)->uuid), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__AddressBookItem*)a)->comment), "");
	soap_out_PointerTongwt__DeltaSyncType(soap, "ngwt:sync", -1, &(((ngwt__AddressBookItem*)a)->sync), "");
	soap_out_PointerTostd__string(soap, "ngwt:domain", -1, &(((ngwt__AddressBookItem*)a)->domain), "");
	soap_out_PointerTostd__string(soap, "ngwt:postOffice", -1, &(((ngwt__AddressBookItem*)a)->postOffice), "");
	soap_out_PointerTostd__string(soap, "ngwt:distinguishedName", -1, &(((ngwt__AddressBookItem*)a)->distinguishedName), "");
	soap_out_PointerTostd__string(soap, "ngwt:userid", -1, &(((ngwt__AddressBookItem*)a)->userid), "");
	soap_out_PointerTongwt__GroupMemberList(soap, "ngwt:members", -1, &(((ngwt__Group*)a)->members), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Group::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Group(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Group * SOAP_FMAC4 soap_get_ngwt__Group(struct soap *soap, ngwt__Group *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Group(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Group::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Group(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Group * SOAP_FMAC4 soap_in_ngwt__Group(struct soap *soap, const char *tag, ngwt__Group *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Group *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Group, sizeof(ngwt__Group), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Group)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Group *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_categories3 = 1, soap_flag_created3 = 1, soap_flag_customs3 = 1, soap_flag_uuid2 = 1, soap_flag_comment2 = 1, soap_flag_sync2 = 1, soap_flag_domain2 = 1, soap_flag_postOffice2 = 1, soap_flag_distinguishedName2 = 1, soap_flag_userid2 = 1, soap_flag_members1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}
			if (soap_flag_name4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name4 = 0;
					continue;
				}
			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}
			if (soap_flag_modified4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}
			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories3 = 0;
					continue;
				}
			if (soap_flag_created3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created3 = 0;
					continue;
				}
			if (soap_flag_customs3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs3 = 0;
					continue;
				}
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__AddressBookItem*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}
			if (soap_flag_comment2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__AddressBookItem*)a)->comment), ""))
				{	soap_flag_comment2 = 0;
					continue;
				}
			if (soap_flag_sync2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DeltaSyncType(soap, "ngwt:sync", &(((ngwt__AddressBookItem*)a)->sync), ""))
				{	soap_flag_sync2 = 0;
					continue;
				}
			if (soap_flag_domain2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:domain", &(((ngwt__AddressBookItem*)a)->domain), ""))
				{	soap_flag_domain2 = 0;
					continue;
				}
			if (soap_flag_postOffice2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:postOffice", &(((ngwt__AddressBookItem*)a)->postOffice), ""))
				{	soap_flag_postOffice2 = 0;
					continue;
				}
			if (soap_flag_distinguishedName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:distinguishedName", &(((ngwt__AddressBookItem*)a)->distinguishedName), ""))
				{	soap_flag_distinguishedName2 = 0;
					continue;
				}
			if (soap_flag_userid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:userid", &(((ngwt__AddressBookItem*)a)->userid), ""))
				{	soap_flag_userid2 = 0;
					continue;
				}
			if (soap_flag_members1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__GroupMemberList(soap, "ngwt:members", &(((ngwt__Group*)a)->members), "ngwt:GroupMemberList"))
				{	soap_flag_members1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Group *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Group, 0, sizeof(ngwt__Group), 0, soap_copy_ngwt__Group);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Group * SOAP_FMAC6 soap_new_ngwt__Group(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Group(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Group(struct soap *soap, ngwt__Group *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Group * SOAP_FMAC6 soap_instantiate_ngwt__Group(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Group(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Group, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Group;
		if (size)
			*size = sizeof(ngwt__Group);
		((ngwt__Group*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Group[n];
		if (size)
			*size = n * sizeof(ngwt__Group);
		for (int i = 0; i < n; i++)
			((ngwt__Group*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Group*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Group(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Group %p -> %p\n", q, p));
	*(ngwt__Group*)p = *(ngwt__Group*)q;
}

void ngwt__FullName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__FullName*)this)->displayName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__FullName*)this)->displayName);
	soap_embedded(soap, &((ngwt__FullName*)this)->namePrefix, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__FullName*)this)->namePrefix);
	soap_embedded(soap, &((ngwt__FullName*)this)->firstName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__FullName*)this)->firstName);
	soap_embedded(soap, &((ngwt__FullName*)this)->middleName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__FullName*)this)->middleName);
	soap_embedded(soap, &((ngwt__FullName*)this)->lastName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__FullName*)this)->lastName);
	soap_embedded(soap, &((ngwt__FullName*)this)->nameSuffix, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__FullName*)this)->nameSuffix);
	/* transient soap skipped */
}

void ngwt__FullName::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__FullName*)this)->displayName = NULL;
	((ngwt__FullName*)this)->namePrefix = NULL;
	((ngwt__FullName*)this)->firstName = NULL;
	((ngwt__FullName*)this)->middleName = NULL;
	((ngwt__FullName*)this)->lastName = NULL;
	((ngwt__FullName*)this)->nameSuffix = NULL;
	/* transient soap skipped */
}

int ngwt__FullName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FullName);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FullName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FullName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FullName(struct soap *soap, const char *tag, int id, const ngwt__FullName *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FullName), type);
	soap_out_PointerTostd__string(soap, "ngwt:displayName", -1, &(((ngwt__FullName*)a)->displayName), "");
	soap_out_PointerTostd__string(soap, "ngwt:namePrefix", -1, &(((ngwt__FullName*)a)->namePrefix), "");
	soap_out_PointerTostd__string(soap, "ngwt:firstName", -1, &(((ngwt__FullName*)a)->firstName), "");
	soap_out_PointerTostd__string(soap, "ngwt:middleName", -1, &(((ngwt__FullName*)a)->middleName), "");
	soap_out_PointerTostd__string(soap, "ngwt:lastName", -1, &(((ngwt__FullName*)a)->lastName), "");
	soap_out_PointerTostd__string(soap, "ngwt:nameSuffix", -1, &(((ngwt__FullName*)a)->nameSuffix), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FullName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FullName(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FullName * SOAP_FMAC4 soap_get_ngwt__FullName(struct soap *soap, ngwt__FullName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FullName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FullName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FullName(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FullName * SOAP_FMAC4 soap_in_ngwt__FullName(struct soap *soap, const char *tag, ngwt__FullName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FullName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FullName, sizeof(ngwt__FullName), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FullName)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FullName *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_displayName1 = 1, soap_flag_namePrefix1 = 1, soap_flag_firstName1 = 1, soap_flag_middleName1 = 1, soap_flag_lastName1 = 1, soap_flag_nameSuffix1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_displayName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:displayName", &(((ngwt__FullName*)a)->displayName), ""))
				{	soap_flag_displayName1 = 0;
					continue;
				}
			if (soap_flag_namePrefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:namePrefix", &(((ngwt__FullName*)a)->namePrefix), ""))
				{	soap_flag_namePrefix1 = 0;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:firstName", &(((ngwt__FullName*)a)->firstName), ""))
				{	soap_flag_firstName1 = 0;
					continue;
				}
			if (soap_flag_middleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:middleName", &(((ngwt__FullName*)a)->middleName), ""))
				{	soap_flag_middleName1 = 0;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:lastName", &(((ngwt__FullName*)a)->lastName), ""))
				{	soap_flag_lastName1 = 0;
					continue;
				}
			if (soap_flag_nameSuffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:nameSuffix", &(((ngwt__FullName*)a)->nameSuffix), ""))
				{	soap_flag_nameSuffix1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FullName *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FullName, 0, sizeof(ngwt__FullName), 0, soap_copy_ngwt__FullName);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FullName * SOAP_FMAC6 soap_new_ngwt__FullName(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FullName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FullName(struct soap *soap, ngwt__FullName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FullName * SOAP_FMAC6 soap_instantiate_ngwt__FullName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FullName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FullName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FullName;
		if (size)
			*size = sizeof(ngwt__FullName);
		((ngwt__FullName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FullName[n];
		if (size)
			*size = n * sizeof(ngwt__FullName);
		for (int i = 0; i < n; i++)
			((ngwt__FullName*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FullName*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FullName(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FullName %p -> %p\n", q, p));
	*(ngwt__FullName*)p = *(ngwt__FullName*)q;
}

void ngwt__From::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__From*)this)->replyTo, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__From*)this)->replyTo);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->displayName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->email, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ngwt__From::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__From*)this)->replyTo = NULL;
	((ngwt__NameAndEmail*)this)->displayName = NULL;
	((ngwt__NameAndEmail*)this)->email = NULL;
	((ngwt__NameAndEmail*)this)->uuid = NULL;
	/* transient soap skipped */
}

int ngwt__From::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__From);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__From::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__From(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__From(struct soap *soap, const char *tag, int id, const ngwt__From *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__From), "ngwt:From");
	soap_out_PointerTostd__string(soap, "ngwt:displayName", -1, &(((ngwt__NameAndEmail*)a)->displayName), "");
	soap_out_PointerTostd__string(soap, "ngwt:email", -1, &(((ngwt__NameAndEmail*)a)->email), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__NameAndEmail*)a)->uuid), "");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ngwt:replyTo", -1, &(((ngwt__From*)a)->replyTo), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__From::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__From(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__From * SOAP_FMAC4 soap_get_ngwt__From(struct soap *soap, ngwt__From *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__From(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__From::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__From(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__From * SOAP_FMAC4 soap_in_ngwt__From(struct soap *soap, const char *tag, ngwt__From *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__From *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__From, sizeof(ngwt__From), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__From)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__From *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_displayName2 = 1, soap_flag_email2 = 1, soap_flag_uuid2 = 1, soap_flag_replyTo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_displayName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:displayName", &(((ngwt__NameAndEmail*)a)->displayName), ""))
				{	soap_flag_displayName2 = 0;
					continue;
				}
			if (soap_flag_email2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:email", &(((ngwt__NameAndEmail*)a)->email), ""))
				{	soap_flag_email2 = 0;
					continue;
				}
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__NameAndEmail*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_replyTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:replyTo", &(((ngwt__From*)a)->replyTo), ""))
				{	soap_flag_replyTo1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__From *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__From, 0, sizeof(ngwt__From), 0, soap_copy_ngwt__From);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__From * SOAP_FMAC6 soap_new_ngwt__From(struct soap *soap, int n)
{	return soap_instantiate_ngwt__From(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__From(struct soap *soap, ngwt__From *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__From * SOAP_FMAC6 soap_instantiate_ngwt__From(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__From(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__From, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__From;
		if (size)
			*size = sizeof(ngwt__From);
		((ngwt__From*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__From[n];
		if (size)
			*size = n * sizeof(ngwt__From);
		for (int i = 0; i < n; i++)
			((ngwt__From*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__From*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__From(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__From %p -> %p\n", q, p));
	*(ngwt__From*)p = *(ngwt__From*)q;
}

void ngwt__FreeBusyStats::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__FreeBusyStats*)this)->responded, SOAP_TYPE_int);
	soap_embedded(soap, &((ngwt__FreeBusyStats*)this)->outstanding, SOAP_TYPE_int);
	soap_embedded(soap, &((ngwt__FreeBusyStats*)this)->total, SOAP_TYPE_int);
	/* transient soap skipped */
}

void ngwt__FreeBusyStats::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ngwt__FreeBusyStats*)this)->responded);
	soap_default_int(soap, &((ngwt__FreeBusyStats*)this)->outstanding);
	soap_default_int(soap, &((ngwt__FreeBusyStats*)this)->total);
	/* transient soap skipped */
}

int ngwt__FreeBusyStats::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FreeBusyStats);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FreeBusyStats::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FreeBusyStats(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FreeBusyStats(struct soap *soap, const char *tag, int id, const ngwt__FreeBusyStats *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FreeBusyStats), type);
	soap_out_int(soap, "ngwt:responded", -1, &(((ngwt__FreeBusyStats*)a)->responded), "");
	soap_out_int(soap, "ngwt:outstanding", -1, &(((ngwt__FreeBusyStats*)a)->outstanding), "");
	soap_out_int(soap, "ngwt:total", -1, &(((ngwt__FreeBusyStats*)a)->total), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FreeBusyStats::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FreeBusyStats(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FreeBusyStats * SOAP_FMAC4 soap_get_ngwt__FreeBusyStats(struct soap *soap, ngwt__FreeBusyStats *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FreeBusyStats(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FreeBusyStats::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FreeBusyStats(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FreeBusyStats * SOAP_FMAC4 soap_in_ngwt__FreeBusyStats(struct soap *soap, const char *tag, ngwt__FreeBusyStats *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FreeBusyStats *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FreeBusyStats, sizeof(ngwt__FreeBusyStats), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FreeBusyStats)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FreeBusyStats *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_responded1 = 1, soap_flag_outstanding1 = 1, soap_flag_total1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:responded", &(((ngwt__FreeBusyStats*)a)->responded), ""))
				{	soap_flag_responded1 = 0;
					continue;
				}
			if (soap_flag_outstanding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:outstanding", &(((ngwt__FreeBusyStats*)a)->outstanding), ""))
				{	soap_flag_outstanding1 = 0;
					continue;
				}
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:total", &(((ngwt__FreeBusyStats*)a)->total), ""))
				{	soap_flag_total1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responded1 || soap_flag_outstanding1 || soap_flag_total1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyStats *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyStats, 0, sizeof(ngwt__FreeBusyStats), 0, soap_copy_ngwt__FreeBusyStats);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FreeBusyStats * SOAP_FMAC6 soap_new_ngwt__FreeBusyStats(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FreeBusyStats(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FreeBusyStats(struct soap *soap, ngwt__FreeBusyStats *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FreeBusyStats * SOAP_FMAC6 soap_instantiate_ngwt__FreeBusyStats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FreeBusyStats(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FreeBusyStats, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FreeBusyStats;
		if (size)
			*size = sizeof(ngwt__FreeBusyStats);
		((ngwt__FreeBusyStats*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FreeBusyStats[n];
		if (size)
			*size = n * sizeof(ngwt__FreeBusyStats);
		for (int i = 0; i < n; i++)
			((ngwt__FreeBusyStats*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FreeBusyStats*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FreeBusyStats(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FreeBusyStats %p -> %p\n", q, p));
	*(ngwt__FreeBusyStats*)p = *(ngwt__FreeBusyStats*)q;
}

void ngwt__FreeBusyInfoList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(soap, &((ngwt__FreeBusyInfoList*)this)->user);
	/* transient soap skipped */
}

void ngwt__FreeBusyInfoList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(soap, &((ngwt__FreeBusyInfoList*)this)->user);
	/* transient soap skipped */
}

int ngwt__FreeBusyInfoList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FreeBusyInfoList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FreeBusyInfoList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FreeBusyInfoList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FreeBusyInfoList(struct soap *soap, const char *tag, int id, const ngwt__FreeBusyInfoList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FreeBusyInfoList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(soap, "ngwt:user", -1, &(((ngwt__FreeBusyInfoList*)a)->user), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FreeBusyInfoList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FreeBusyInfoList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FreeBusyInfoList * SOAP_FMAC4 soap_get_ngwt__FreeBusyInfoList(struct soap *soap, ngwt__FreeBusyInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FreeBusyInfoList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FreeBusyInfoList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FreeBusyInfoList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FreeBusyInfoList * SOAP_FMAC4 soap_in_ngwt__FreeBusyInfoList(struct soap *soap, const char *tag, ngwt__FreeBusyInfoList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FreeBusyInfoList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FreeBusyInfoList, sizeof(ngwt__FreeBusyInfoList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FreeBusyInfoList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FreeBusyInfoList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(soap, "ngwt:user", &(((ngwt__FreeBusyInfoList*)a)->user), "ngwt:FreeBusyInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyInfoList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyInfoList, 0, sizeof(ngwt__FreeBusyInfoList), 0, soap_copy_ngwt__FreeBusyInfoList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FreeBusyInfoList * SOAP_FMAC6 soap_new_ngwt__FreeBusyInfoList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FreeBusyInfoList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FreeBusyInfoList(struct soap *soap, ngwt__FreeBusyInfoList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FreeBusyInfoList * SOAP_FMAC6 soap_instantiate_ngwt__FreeBusyInfoList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FreeBusyInfoList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FreeBusyInfoList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FreeBusyInfoList;
		if (size)
			*size = sizeof(ngwt__FreeBusyInfoList);
		((ngwt__FreeBusyInfoList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FreeBusyInfoList[n];
		if (size)
			*size = n * sizeof(ngwt__FreeBusyInfoList);
		for (int i = 0; i < n; i++)
			((ngwt__FreeBusyInfoList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FreeBusyInfoList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FreeBusyInfoList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FreeBusyInfoList %p -> %p\n", q, p));
	*(ngwt__FreeBusyInfoList*)p = *(ngwt__FreeBusyInfoList*)q;
}

void ngwt__FreeBusyUserList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__NameAndEmail(soap, &((ngwt__FreeBusyUserList*)this)->user);
	/* transient soap skipped */
}

void ngwt__FreeBusyUserList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__NameAndEmail(soap, &((ngwt__FreeBusyUserList*)this)->user);
	/* transient soap skipped */
}

int ngwt__FreeBusyUserList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FreeBusyUserList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FreeBusyUserList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FreeBusyUserList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FreeBusyUserList(struct soap *soap, const char *tag, int id, const ngwt__FreeBusyUserList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FreeBusyUserList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__NameAndEmail(soap, "ngwt:user", -1, &(((ngwt__FreeBusyUserList*)a)->user), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FreeBusyUserList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FreeBusyUserList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FreeBusyUserList * SOAP_FMAC4 soap_get_ngwt__FreeBusyUserList(struct soap *soap, ngwt__FreeBusyUserList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FreeBusyUserList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FreeBusyUserList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FreeBusyUserList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FreeBusyUserList * SOAP_FMAC4 soap_in_ngwt__FreeBusyUserList(struct soap *soap, const char *tag, ngwt__FreeBusyUserList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FreeBusyUserList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FreeBusyUserList, sizeof(ngwt__FreeBusyUserList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FreeBusyUserList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FreeBusyUserList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__NameAndEmail(soap, "ngwt:user", &(((ngwt__FreeBusyUserList*)a)->user), "ngwt:NameAndEmail"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyUserList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyUserList, 0, sizeof(ngwt__FreeBusyUserList), 0, soap_copy_ngwt__FreeBusyUserList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FreeBusyUserList * SOAP_FMAC6 soap_new_ngwt__FreeBusyUserList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FreeBusyUserList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FreeBusyUserList(struct soap *soap, ngwt__FreeBusyUserList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FreeBusyUserList * SOAP_FMAC6 soap_instantiate_ngwt__FreeBusyUserList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FreeBusyUserList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FreeBusyUserList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FreeBusyUserList;
		if (size)
			*size = sizeof(ngwt__FreeBusyUserList);
		((ngwt__FreeBusyUserList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FreeBusyUserList[n];
		if (size)
			*size = n * sizeof(ngwt__FreeBusyUserList);
		for (int i = 0; i < n; i++)
			((ngwt__FreeBusyUserList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FreeBusyUserList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FreeBusyUserList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FreeBusyUserList %p -> %p\n", q, p));
	*(ngwt__FreeBusyUserList*)p = *(ngwt__FreeBusyUserList*)q;
}

void ngwt__FreeBusyInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__FreeBusyInfo*)this)->blocks, SOAP_TYPE_PointerTongwt__FreeBusyBlockList);
	soap_serialize_PointerTongwt__FreeBusyBlockList(soap, &((ngwt__FreeBusyInfo*)this)->blocks);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->displayName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->email, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ngwt__FreeBusyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__FreeBusyInfo*)this)->blocks = NULL;
	((ngwt__NameAndEmail*)this)->displayName = NULL;
	((ngwt__NameAndEmail*)this)->email = NULL;
	((ngwt__NameAndEmail*)this)->uuid = NULL;
	/* transient soap skipped */
}

int ngwt__FreeBusyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FreeBusyInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FreeBusyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FreeBusyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FreeBusyInfo(struct soap *soap, const char *tag, int id, const ngwt__FreeBusyInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FreeBusyInfo), "ngwt:FreeBusyInfo");
	soap_out_PointerTostd__string(soap, "ngwt:displayName", -1, &(((ngwt__NameAndEmail*)a)->displayName), "");
	soap_out_PointerTostd__string(soap, "ngwt:email", -1, &(((ngwt__NameAndEmail*)a)->email), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__NameAndEmail*)a)->uuid), "");
	/* transient soap skipped */
	soap_out_PointerTongwt__FreeBusyBlockList(soap, "ngwt:blocks", -1, &(((ngwt__FreeBusyInfo*)a)->blocks), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FreeBusyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FreeBusyInfo(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FreeBusyInfo * SOAP_FMAC4 soap_get_ngwt__FreeBusyInfo(struct soap *soap, ngwt__FreeBusyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FreeBusyInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FreeBusyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FreeBusyInfo(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FreeBusyInfo * SOAP_FMAC4 soap_in_ngwt__FreeBusyInfo(struct soap *soap, const char *tag, ngwt__FreeBusyInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FreeBusyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FreeBusyInfo, sizeof(ngwt__FreeBusyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FreeBusyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FreeBusyInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_displayName2 = 1, soap_flag_email2 = 1, soap_flag_uuid2 = 1, soap_flag_blocks1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_displayName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:displayName", &(((ngwt__NameAndEmail*)a)->displayName), ""))
				{	soap_flag_displayName2 = 0;
					continue;
				}
			if (soap_flag_email2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:email", &(((ngwt__NameAndEmail*)a)->email), ""))
				{	soap_flag_email2 = 0;
					continue;
				}
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__NameAndEmail*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_blocks1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FreeBusyBlockList(soap, "ngwt:blocks", &(((ngwt__FreeBusyInfo*)a)->blocks), "ngwt:FreeBusyBlockList"))
				{	soap_flag_blocks1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blocks1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyInfo, 0, sizeof(ngwt__FreeBusyInfo), 0, soap_copy_ngwt__FreeBusyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FreeBusyInfo * SOAP_FMAC6 soap_new_ngwt__FreeBusyInfo(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FreeBusyInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FreeBusyInfo(struct soap *soap, ngwt__FreeBusyInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FreeBusyInfo * SOAP_FMAC6 soap_instantiate_ngwt__FreeBusyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FreeBusyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FreeBusyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FreeBusyInfo;
		if (size)
			*size = sizeof(ngwt__FreeBusyInfo);
		((ngwt__FreeBusyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FreeBusyInfo[n];
		if (size)
			*size = n * sizeof(ngwt__FreeBusyInfo);
		for (int i = 0; i < n; i++)
			((ngwt__FreeBusyInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FreeBusyInfo*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FreeBusyInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FreeBusyInfo %p -> %p\n", q, p));
	*(ngwt__FreeBusyInfo*)p = *(ngwt__FreeBusyInfo*)q;
}

void ngwt__FreeBusyBlock::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__FreeBusyBlock*)this)->startDate, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__FreeBusyBlock*)this)->startDate);
	soap_embedded(soap, &((ngwt__FreeBusyBlock*)this)->endDate, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__FreeBusyBlock*)this)->endDate);
	soap_embedded(soap, &((ngwt__FreeBusyBlock*)this)->acceptLevel, SOAP_TYPE_PointerTongwt__AcceptLevel);
	soap_serialize_PointerTongwt__AcceptLevel(soap, &((ngwt__FreeBusyBlock*)this)->acceptLevel);
	soap_embedded(soap, &((ngwt__FreeBusyBlock*)this)->subject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__FreeBusyBlock*)this)->subject);
	/* transient soap skipped */
}

void ngwt__FreeBusyBlock::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ngwt__FreeBusyBlock*)this)->startDate);
	soap_default_string(soap, &((ngwt__FreeBusyBlock*)this)->endDate);
	((ngwt__FreeBusyBlock*)this)->acceptLevel = NULL;
	((ngwt__FreeBusyBlock*)this)->subject = NULL;
	/* transient soap skipped */
}

int ngwt__FreeBusyBlock::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FreeBusyBlock);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FreeBusyBlock::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FreeBusyBlock(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FreeBusyBlock(struct soap *soap, const char *tag, int id, const ngwt__FreeBusyBlock *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FreeBusyBlock), type);
	soap_out_string(soap, "ngwt:startDate", -1, &(((ngwt__FreeBusyBlock*)a)->startDate), "");
	soap_out_string(soap, "ngwt:endDate", -1, &(((ngwt__FreeBusyBlock*)a)->endDate), "");
	soap_out_PointerTongwt__AcceptLevel(soap, "ngwt:acceptLevel", -1, &(((ngwt__FreeBusyBlock*)a)->acceptLevel), "");
	soap_out_PointerTostd__string(soap, "ngwt:subject", -1, &(((ngwt__FreeBusyBlock*)a)->subject), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FreeBusyBlock::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FreeBusyBlock(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FreeBusyBlock * SOAP_FMAC4 soap_get_ngwt__FreeBusyBlock(struct soap *soap, ngwt__FreeBusyBlock *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FreeBusyBlock(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FreeBusyBlock::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FreeBusyBlock(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FreeBusyBlock * SOAP_FMAC4 soap_in_ngwt__FreeBusyBlock(struct soap *soap, const char *tag, ngwt__FreeBusyBlock *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FreeBusyBlock *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FreeBusyBlock, sizeof(ngwt__FreeBusyBlock), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FreeBusyBlock)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FreeBusyBlock *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_startDate1 = 1, soap_flag_endDate1 = 1, soap_flag_acceptLevel1 = 1, soap_flag_subject1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:startDate", &(((ngwt__FreeBusyBlock*)a)->startDate), ""))
				{	soap_flag_startDate1 = 0;
					continue;
				}
			if (soap_flag_endDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:endDate", &(((ngwt__FreeBusyBlock*)a)->endDate), ""))
				{	soap_flag_endDate1 = 0;
					continue;
				}
			if (soap_flag_acceptLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AcceptLevel(soap, "ngwt:acceptLevel", &(((ngwt__FreeBusyBlock*)a)->acceptLevel), ""))
				{	soap_flag_acceptLevel1 = 0;
					continue;
				}
			if (soap_flag_subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subject", &(((ngwt__FreeBusyBlock*)a)->subject), ""))
				{	soap_flag_subject1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startDate1 || soap_flag_endDate1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyBlock *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyBlock, 0, sizeof(ngwt__FreeBusyBlock), 0, soap_copy_ngwt__FreeBusyBlock);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FreeBusyBlock * SOAP_FMAC6 soap_new_ngwt__FreeBusyBlock(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FreeBusyBlock(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FreeBusyBlock(struct soap *soap, ngwt__FreeBusyBlock *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FreeBusyBlock * SOAP_FMAC6 soap_instantiate_ngwt__FreeBusyBlock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FreeBusyBlock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FreeBusyBlock, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FreeBusyBlock;
		if (size)
			*size = sizeof(ngwt__FreeBusyBlock);
		((ngwt__FreeBusyBlock*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FreeBusyBlock[n];
		if (size)
			*size = n * sizeof(ngwt__FreeBusyBlock);
		for (int i = 0; i < n; i++)
			((ngwt__FreeBusyBlock*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FreeBusyBlock*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FreeBusyBlock(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FreeBusyBlock %p -> %p\n", q, p));
	*(ngwt__FreeBusyBlock*)p = *(ngwt__FreeBusyBlock*)q;
}

void ngwt__FreeBusyBlockList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(soap, &((ngwt__FreeBusyBlockList*)this)->block);
	/* transient soap skipped */
}

void ngwt__FreeBusyBlockList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(soap, &((ngwt__FreeBusyBlockList*)this)->block);
	/* transient soap skipped */
}

int ngwt__FreeBusyBlockList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FreeBusyBlockList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FreeBusyBlockList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FreeBusyBlockList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FreeBusyBlockList(struct soap *soap, const char *tag, int id, const ngwt__FreeBusyBlockList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FreeBusyBlockList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(soap, "ngwt:block", -1, &(((ngwt__FreeBusyBlockList*)a)->block), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FreeBusyBlockList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FreeBusyBlockList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FreeBusyBlockList * SOAP_FMAC4 soap_get_ngwt__FreeBusyBlockList(struct soap *soap, ngwt__FreeBusyBlockList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FreeBusyBlockList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FreeBusyBlockList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FreeBusyBlockList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FreeBusyBlockList * SOAP_FMAC4 soap_in_ngwt__FreeBusyBlockList(struct soap *soap, const char *tag, ngwt__FreeBusyBlockList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FreeBusyBlockList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FreeBusyBlockList, sizeof(ngwt__FreeBusyBlockList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FreeBusyBlockList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FreeBusyBlockList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(soap, "ngwt:block", &(((ngwt__FreeBusyBlockList*)a)->block), "ngwt:FreeBusyBlock"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyBlockList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyBlockList, 0, sizeof(ngwt__FreeBusyBlockList), 0, soap_copy_ngwt__FreeBusyBlockList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FreeBusyBlockList * SOAP_FMAC6 soap_new_ngwt__FreeBusyBlockList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FreeBusyBlockList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FreeBusyBlockList(struct soap *soap, ngwt__FreeBusyBlockList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FreeBusyBlockList * SOAP_FMAC6 soap_instantiate_ngwt__FreeBusyBlockList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FreeBusyBlockList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FreeBusyBlockList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FreeBusyBlockList;
		if (size)
			*size = sizeof(ngwt__FreeBusyBlockList);
		((ngwt__FreeBusyBlockList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FreeBusyBlockList[n];
		if (size)
			*size = n * sizeof(ngwt__FreeBusyBlockList);
		for (int i = 0; i < n; i++)
			((ngwt__FreeBusyBlockList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FreeBusyBlockList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FreeBusyBlockList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FreeBusyBlockList %p -> %p\n", q, p));
	*(ngwt__FreeBusyBlockList*)p = *(ngwt__FreeBusyBlockList*)q;
}

void ngwt__FolderList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Folder(soap, &((ngwt__FolderList*)this)->folder);
	/* transient soap skipped */
}

void ngwt__FolderList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Folder(soap, &((ngwt__FolderList*)this)->folder);
	/* transient soap skipped */
}

int ngwt__FolderList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FolderList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FolderList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FolderList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FolderList(struct soap *soap, const char *tag, int id, const ngwt__FolderList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FolderList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Folder(soap, "ngwt:folder", -1, &(((ngwt__FolderList*)a)->folder), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FolderList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FolderList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FolderList * SOAP_FMAC4 soap_get_ngwt__FolderList(struct soap *soap, ngwt__FolderList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FolderList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FolderList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FolderList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FolderList * SOAP_FMAC4 soap_in_ngwt__FolderList(struct soap *soap, const char *tag, ngwt__FolderList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FolderList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FolderList, sizeof(ngwt__FolderList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FolderList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FolderList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Folder(soap, "ngwt:folder", &(((ngwt__FolderList*)a)->folder), "ngwt:Folder"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FolderList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FolderList, 0, sizeof(ngwt__FolderList), 0, soap_copy_ngwt__FolderList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FolderList * SOAP_FMAC6 soap_new_ngwt__FolderList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FolderList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FolderList(struct soap *soap, ngwt__FolderList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FolderList * SOAP_FMAC6 soap_instantiate_ngwt__FolderList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FolderList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FolderList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FolderList;
		if (size)
			*size = sizeof(ngwt__FolderList);
		((ngwt__FolderList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FolderList[n];
		if (size)
			*size = n * sizeof(ngwt__FolderList);
		for (int i = 0; i < n; i++)
			((ngwt__FolderList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FolderList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FolderList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FolderList %p -> %p\n", q, p));
	*(ngwt__FolderList*)p = *(ngwt__FolderList*)q;
}

void ngwt__FolderACLEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__FolderACLEntry*)this)->status, SOAP_TYPE_PointerTongwt__FolderACLStatus);
	soap_serialize_PointerTongwt__FolderACLStatus(soap, &((ngwt__FolderACLEntry*)this)->status);
	soap_embedded(soap, &((ngwt__AccessControlListEntry*)this)->rights, SOAP_TYPE_PointerTongwt__Rights);
	soap_serialize_PointerTongwt__Rights(soap, &((ngwt__AccessControlListEntry*)this)->rights);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->displayName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->email, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ngwt__FolderACLEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__FolderACLEntry*)this)->status = NULL;
	((ngwt__AccessControlListEntry*)this)->rights = NULL;
	((ngwt__NameAndEmail*)this)->displayName = NULL;
	((ngwt__NameAndEmail*)this)->email = NULL;
	((ngwt__NameAndEmail*)this)->uuid = NULL;
	/* transient soap skipped */
}

int ngwt__FolderACLEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FolderACLEntry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FolderACLEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FolderACLEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FolderACLEntry(struct soap *soap, const char *tag, int id, const ngwt__FolderACLEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FolderACLEntry), "ngwt:FolderACLEntry");
	soap_out_PointerTostd__string(soap, "ngwt:displayName", -1, &(((ngwt__NameAndEmail*)a)->displayName), "");
	soap_out_PointerTostd__string(soap, "ngwt:email", -1, &(((ngwt__NameAndEmail*)a)->email), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__NameAndEmail*)a)->uuid), "");
	/* transient soap skipped */
	soap_out_PointerTongwt__Rights(soap, "ngwt:rights", -1, &(((ngwt__AccessControlListEntry*)a)->rights), "");
	soap_out_PointerTongwt__FolderACLStatus(soap, "ngwt:status", -1, &(((ngwt__FolderACLEntry*)a)->status), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FolderACLEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FolderACLEntry(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FolderACLEntry * SOAP_FMAC4 soap_get_ngwt__FolderACLEntry(struct soap *soap, ngwt__FolderACLEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FolderACLEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FolderACLEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FolderACLEntry(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FolderACLEntry * SOAP_FMAC4 soap_in_ngwt__FolderACLEntry(struct soap *soap, const char *tag, ngwt__FolderACLEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FolderACLEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FolderACLEntry, sizeof(ngwt__FolderACLEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FolderACLEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FolderACLEntry *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_displayName3 = 1, soap_flag_email3 = 1, soap_flag_uuid3 = 1, soap_flag_rights2 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_displayName3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:displayName", &(((ngwt__NameAndEmail*)a)->displayName), ""))
				{	soap_flag_displayName3 = 0;
					continue;
				}
			if (soap_flag_email3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:email", &(((ngwt__NameAndEmail*)a)->email), ""))
				{	soap_flag_email3 = 0;
					continue;
				}
			if (soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__NameAndEmail*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid3 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_rights2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Rights(soap, "ngwt:rights", &(((ngwt__AccessControlListEntry*)a)->rights), "ngwt:Rights"))
				{	soap_flag_rights2 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FolderACLStatus(soap, "ngwt:status", &(((ngwt__FolderACLEntry*)a)->status), ""))
				{	soap_flag_status1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_rights2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FolderACLEntry *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FolderACLEntry, 0, sizeof(ngwt__FolderACLEntry), 0, soap_copy_ngwt__FolderACLEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FolderACLEntry * SOAP_FMAC6 soap_new_ngwt__FolderACLEntry(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FolderACLEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FolderACLEntry(struct soap *soap, ngwt__FolderACLEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FolderACLEntry * SOAP_FMAC6 soap_instantiate_ngwt__FolderACLEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FolderACLEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FolderACLEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FolderACLEntry;
		if (size)
			*size = sizeof(ngwt__FolderACLEntry);
		((ngwt__FolderACLEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FolderACLEntry[n];
		if (size)
			*size = n * sizeof(ngwt__FolderACLEntry);
		for (int i = 0; i < n; i++)
			((ngwt__FolderACLEntry*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FolderACLEntry*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FolderACLEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FolderACLEntry %p -> %p\n", q, p));
	*(ngwt__FolderACLEntry*)p = *(ngwt__FolderACLEntry*)q;
}

void ngwt__FolderACL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__FolderACLEntry(soap, &((ngwt__FolderACL*)this)->entry);
	/* transient soap skipped */
}

void ngwt__FolderACL::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__FolderACLEntry(soap, &((ngwt__FolderACL*)this)->entry);
	/* transient soap skipped */
}

int ngwt__FolderACL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FolderACL);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FolderACL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FolderACL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FolderACL(struct soap *soap, const char *tag, int id, const ngwt__FolderACL *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FolderACL), type);
	soap_out_std__vectorTemplateOfPointerTongwt__FolderACLEntry(soap, "ngwt:entry", -1, &(((ngwt__FolderACL*)a)->entry), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FolderACL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FolderACL(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FolderACL * SOAP_FMAC4 soap_get_ngwt__FolderACL(struct soap *soap, ngwt__FolderACL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FolderACL(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FolderACL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FolderACL(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FolderACL * SOAP_FMAC4 soap_in_ngwt__FolderACL(struct soap *soap, const char *tag, ngwt__FolderACL *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FolderACL *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FolderACL, sizeof(ngwt__FolderACL), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FolderACL)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FolderACL *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__FolderACLEntry(soap, "ngwt:entry", &(((ngwt__FolderACL*)a)->entry), "ngwt:FolderACLEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FolderACL *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FolderACL, 0, sizeof(ngwt__FolderACL), 0, soap_copy_ngwt__FolderACL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FolderACL * SOAP_FMAC6 soap_new_ngwt__FolderACL(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FolderACL(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FolderACL(struct soap *soap, ngwt__FolderACL *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FolderACL * SOAP_FMAC6 soap_instantiate_ngwt__FolderACL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FolderACL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FolderACL, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FolderACL;
		if (size)
			*size = sizeof(ngwt__FolderACL);
		((ngwt__FolderACL*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FolderACL[n];
		if (size)
			*size = n * sizeof(ngwt__FolderACL);
		for (int i = 0; i < n; i++)
			((ngwt__FolderACL*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FolderACL*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FolderACL(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FolderACL %p -> %p\n", q, p));
	*(ngwt__FolderACL*)p = *(ngwt__FolderACL*)q;
}

void ngwt__Folder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Folder*)this)->parent, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((ngwt__Folder*)this)->parent);
	soap_embedded(soap, &((ngwt__Folder*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Folder*)this)->description);
	soap_embedded(soap, &((ngwt__Folder*)this)->count, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__Folder*)this)->count);
	soap_embedded(soap, &((ngwt__Folder*)this)->hasUnread, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Folder*)this)->hasUnread);
	soap_embedded(soap, &((ngwt__Folder*)this)->unreadCount, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__Folder*)this)->unreadCount);
	soap_embedded(soap, &((ngwt__Folder*)this)->sequence, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Folder*)this)->sequence);
	soap_embedded(soap, &((ngwt__Folder*)this)->settings, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Folder*)this)->settings);
	soap_embedded(soap, &((ngwt__Folder*)this)->calendarAttribute, SOAP_TYPE_PointerTongwt__CalendarFolderAttribute);
	soap_serialize_PointerTongwt__CalendarFolderAttribute(soap, &((ngwt__Folder*)this)->calendarAttribute);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Folder::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((ngwt__Folder*)this)->parent);
	((ngwt__Folder*)this)->description = NULL;
	((ngwt__Folder*)this)->count = NULL;
	((ngwt__Folder*)this)->hasUnread = NULL;
	((ngwt__Folder*)this)->unreadCount = NULL;
	((ngwt__Folder*)this)->sequence = NULL;
	((ngwt__Folder*)this)->settings = NULL;
	((ngwt__Folder*)this)->calendarAttribute = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Folder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Folder);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Folder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Folder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Folder(struct soap *soap, const char *tag, int id, const ngwt__Folder *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Folder), "ngwt:Folder");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_ngwt__uid(soap, "ngwt:parent", -1, &(((ngwt__Folder*)a)->parent), "");
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__Folder*)a)->description), "");
	soap_out_PointerToint(soap, "ngwt:count", -1, &(((ngwt__Folder*)a)->count), "");
	soap_out_PointerTobool(soap, "ngwt:hasUnread", -1, &(((ngwt__Folder*)a)->hasUnread), "");
	soap_out_PointerToint(soap, "ngwt:unreadCount", -1, &(((ngwt__Folder*)a)->unreadCount), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:sequence", -1, &(((ngwt__Folder*)a)->sequence), "");
	soap_out_PointerTongwt__uid(soap, "ngwt:settings", -1, &(((ngwt__Folder*)a)->settings), "");
	soap_out_PointerTongwt__CalendarFolderAttribute(soap, "ngwt:calendarAttribute", -1, &(((ngwt__Folder*)a)->calendarAttribute), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Folder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Folder(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Folder * SOAP_FMAC4 soap_get_ngwt__Folder(struct soap *soap, ngwt__Folder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Folder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Folder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Folder(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Folder * SOAP_FMAC4 soap_in_ngwt__Folder(struct soap *soap, const char *tag, ngwt__Folder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Folder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Folder, sizeof(ngwt__Folder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Folder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Folder *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id2 = 1, soap_flag_name2 = 1, soap_flag_version2 = 1, soap_flag_modified2 = 1, soap_flag_changes2 = 1, soap_flag_parent1 = 1, soap_flag_description1 = 1, soap_flag_count1 = 1, soap_flag_hasUnread1 = 1, soap_flag_unreadCount1 = 1, soap_flag_sequence1 = 1, soap_flag_settings1 = 1, soap_flag_calendarAttribute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id2 = 0;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name2 = 0;
					continue;
				}
			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version2 = 0;
					continue;
				}
			if (soap_flag_modified2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified2 = 0;
					continue;
				}
			if (soap_flag_changes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_parent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwt:parent", &(((ngwt__Folder*)a)->parent), "ngwt:uid"))
				{	soap_flag_parent1 = 0;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__Folder*)a)->description), ""))
				{	soap_flag_description1 = 0;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:count", &(((ngwt__Folder*)a)->count), ""))
				{	soap_flag_count1 = 0;
					continue;
				}
			if (soap_flag_hasUnread1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:hasUnread", &(((ngwt__Folder*)a)->hasUnread), ""))
				{	soap_flag_hasUnread1 = 0;
					continue;
				}
			if (soap_flag_unreadCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:unreadCount", &(((ngwt__Folder*)a)->unreadCount), ""))
				{	soap_flag_unreadCount1 = 0;
					continue;
				}
			if (soap_flag_sequence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:sequence", &(((ngwt__Folder*)a)->sequence), ""))
				{	soap_flag_sequence1 = 0;
					continue;
				}
			if (soap_flag_settings1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:settings", &(((ngwt__Folder*)a)->settings), "ngwt:uid"))
				{	soap_flag_settings1 = 0;
					continue;
				}
			if (soap_flag_calendarAttribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CalendarFolderAttribute(soap, "ngwt:calendarAttribute", &(((ngwt__Folder*)a)->calendarAttribute), "ngwt:CalendarFolderAttribute"))
				{	soap_flag_calendarAttribute1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Folder *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Folder, 0, sizeof(ngwt__Folder), 0, soap_copy_ngwt__Folder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Folder * SOAP_FMAC6 soap_new_ngwt__Folder(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Folder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Folder(struct soap *soap, ngwt__Folder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Folder * SOAP_FMAC6 soap_instantiate_ngwt__Folder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Folder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Folder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:QueryFolder"))
	{	cp->type = SOAP_TYPE_ngwt__QueryFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__QueryFolder;
			if (size)
				*size = sizeof(ngwt__QueryFolder);
			((ngwt__QueryFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__QueryFolder[n];
			if (size)
				*size = n * sizeof(ngwt__QueryFolder);
			for (int i = 0; i < n; i++)
				((ngwt__QueryFolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__QueryFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:SharedFolder"))
	{	cp->type = SOAP_TYPE_ngwt__SharedFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__SharedFolder;
			if (size)
				*size = sizeof(ngwt__SharedFolder);
			((ngwt__SharedFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__SharedFolder[n];
			if (size)
				*size = n * sizeof(ngwt__SharedFolder);
			for (int i = 0; i < n; i++)
				((ngwt__SharedFolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__SharedFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:SystemFolder"))
	{	cp->type = SOAP_TYPE_ngwt__SystemFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__SystemFolder;
			if (size)
				*size = sizeof(ngwt__SystemFolder);
			((ngwt__SystemFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__SystemFolder[n];
			if (size)
				*size = n * sizeof(ngwt__SystemFolder);
			for (int i = 0; i < n; i++)
				((ngwt__SystemFolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__SystemFolder*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:ContactFolder"))
	{	cp->type = SOAP_TYPE_ngwt__ContactFolder;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__ContactFolder;
			if (size)
				*size = sizeof(ngwt__ContactFolder);
			((ngwt__ContactFolder*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__ContactFolder[n];
			if (size)
				*size = n * sizeof(ngwt__ContactFolder);
			for (int i = 0; i < n; i++)
				((ngwt__ContactFolder*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__ContactFolder*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Folder;
		if (size)
			*size = sizeof(ngwt__Folder);
		((ngwt__Folder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Folder[n];
		if (size)
			*size = n * sizeof(ngwt__Folder);
		for (int i = 0; i < n; i++)
			((ngwt__Folder*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Folder*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Folder(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Folder %p -> %p\n", q, p));
	*(ngwt__Folder*)p = *(ngwt__Folder*)q;
}

void ngwt__FilterGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__FilterElement(soap, &((ngwt__FilterGroup*)this)->element);
	soap_embedded(soap, &((ngwt__FilterElement*)this)->op, SOAP_TYPE_ngwt__FilterOp);
	/* transient soap skipped */
}

void ngwt__FilterGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__FilterElement(soap, &((ngwt__FilterGroup*)this)->element);
	soap_default_ngwt__FilterOp(soap, &((ngwt__FilterElement*)this)->op);
	/* transient soap skipped */
}

int ngwt__FilterGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FilterGroup);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FilterGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FilterGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FilterGroup(struct soap *soap, const char *tag, int id, const ngwt__FilterGroup *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FilterGroup), "ngwt:FilterGroup");
	soap_out_ngwt__FilterOp(soap, "ngwt:op", -1, &(((ngwt__FilterElement*)a)->op), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__FilterElement(soap, "ngwt:element", -1, &(((ngwt__FilterGroup*)a)->element), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FilterGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FilterGroup(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FilterGroup * SOAP_FMAC4 soap_get_ngwt__FilterGroup(struct soap *soap, ngwt__FilterGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FilterGroup(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FilterGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FilterGroup(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FilterGroup * SOAP_FMAC4 soap_in_ngwt__FilterGroup(struct soap *soap, const char *tag, ngwt__FilterGroup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FilterGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FilterGroup, sizeof(ngwt__FilterGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FilterGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FilterGroup *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_op2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_op2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__FilterOp(soap, "ngwt:op", &(((ngwt__FilterElement*)a)->op), ""))
				{	soap_flag_op2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__FilterElement(soap, "ngwt:element", &(((ngwt__FilterGroup*)a)->element), "ngwt:FilterElement"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_op2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FilterGroup *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FilterGroup, 0, sizeof(ngwt__FilterGroup), 0, soap_copy_ngwt__FilterGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FilterGroup * SOAP_FMAC6 soap_new_ngwt__FilterGroup(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FilterGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FilterGroup(struct soap *soap, ngwt__FilterGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FilterGroup * SOAP_FMAC6 soap_instantiate_ngwt__FilterGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FilterGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FilterGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FilterGroup;
		if (size)
			*size = sizeof(ngwt__FilterGroup);
		((ngwt__FilterGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FilterGroup[n];
		if (size)
			*size = n * sizeof(ngwt__FilterGroup);
		for (int i = 0; i < n; i++)
			((ngwt__FilterGroup*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FilterGroup*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FilterGroup(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FilterGroup %p -> %p\n", q, p));
	*(ngwt__FilterGroup*)p = *(ngwt__FilterGroup*)q;
}

void ngwt__FilterEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__FilterEntry*)this)->field, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__FilterEntry*)this)->field);
	soap_embedded(soap, &((ngwt__FilterEntry*)this)->custom, SOAP_TYPE_PointerTongwt__Custom);
	soap_serialize_PointerTongwt__Custom(soap, &((ngwt__FilterEntry*)this)->custom);
	soap_embedded(soap, &((ngwt__FilterEntry*)this)->value, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__FilterEntry*)this)->value);
	soap_embedded(soap, &((ngwt__FilterEntry*)this)->date, SOAP_TYPE_PointerTongwt__FilterDate);
	soap_serialize_PointerTongwt__FilterDate(soap, &((ngwt__FilterEntry*)this)->date);
	soap_embedded(soap, &((ngwt__FilterElement*)this)->op, SOAP_TYPE_ngwt__FilterOp);
	/* transient soap skipped */
}

void ngwt__FilterEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__FilterEntry*)this)->field = NULL;
	((ngwt__FilterEntry*)this)->custom = NULL;
	((ngwt__FilterEntry*)this)->value = NULL;
	((ngwt__FilterEntry*)this)->date = NULL;
	soap_default_ngwt__FilterOp(soap, &((ngwt__FilterElement*)this)->op);
	/* transient soap skipped */
}

int ngwt__FilterEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FilterEntry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FilterEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FilterEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FilterEntry(struct soap *soap, const char *tag, int id, const ngwt__FilterEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FilterEntry), "ngwt:FilterEntry");
	soap_out_ngwt__FilterOp(soap, "ngwt:op", -1, &(((ngwt__FilterElement*)a)->op), "");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ngwt:field", -1, &(((ngwt__FilterEntry*)a)->field), "");
	soap_out_PointerTongwt__Custom(soap, "ngwt:custom", -1, &(((ngwt__FilterEntry*)a)->custom), "");
	soap_out_PointerTostd__string(soap, "ngwt:value", -1, &(((ngwt__FilterEntry*)a)->value), "");
	soap_out_PointerTongwt__FilterDate(soap, "ngwt:date", -1, &(((ngwt__FilterEntry*)a)->date), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FilterEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FilterEntry(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FilterEntry * SOAP_FMAC4 soap_get_ngwt__FilterEntry(struct soap *soap, ngwt__FilterEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FilterEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FilterEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FilterEntry(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FilterEntry * SOAP_FMAC4 soap_in_ngwt__FilterEntry(struct soap *soap, const char *tag, ngwt__FilterEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FilterEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FilterEntry, sizeof(ngwt__FilterEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FilterEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FilterEntry *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_op2 = 1, soap_flag_field1 = 1, soap_flag_custom1 = 1, soap_flag_value1 = 1, soap_flag_date1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_op2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__FilterOp(soap, "ngwt:op", &(((ngwt__FilterElement*)a)->op), ""))
				{	soap_flag_op2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_field1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:field", &(((ngwt__FilterEntry*)a)->field), ""))
				{	soap_flag_field1 = 0;
					continue;
				}
			if (soap_flag_custom1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Custom(soap, "ngwt:custom", &(((ngwt__FilterEntry*)a)->custom), "ngwt:Custom"))
				{	soap_flag_custom1 = 0;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:value", &(((ngwt__FilterEntry*)a)->value), ""))
				{	soap_flag_value1 = 0;
					continue;
				}
			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FilterDate(soap, "ngwt:date", &(((ngwt__FilterEntry*)a)->date), ""))
				{	soap_flag_date1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_op2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FilterEntry *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FilterEntry, 0, sizeof(ngwt__FilterEntry), 0, soap_copy_ngwt__FilterEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FilterEntry * SOAP_FMAC6 soap_new_ngwt__FilterEntry(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FilterEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FilterEntry(struct soap *soap, ngwt__FilterEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FilterEntry * SOAP_FMAC6 soap_instantiate_ngwt__FilterEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FilterEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FilterEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FilterEntry;
		if (size)
			*size = sizeof(ngwt__FilterEntry);
		((ngwt__FilterEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FilterEntry[n];
		if (size)
			*size = n * sizeof(ngwt__FilterEntry);
		for (int i = 0; i < n; i++)
			((ngwt__FilterEntry*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FilterEntry*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FilterEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FilterEntry %p -> %p\n", q, p));
	*(ngwt__FilterEntry*)p = *(ngwt__FilterEntry*)q;
}

void ngwt__FilterElement::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__FilterElement*)this)->op, SOAP_TYPE_ngwt__FilterOp);
	/* transient soap skipped */
}

void ngwt__FilterElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__FilterOp(soap, &((ngwt__FilterElement*)this)->op);
	/* transient soap skipped */
}

int ngwt__FilterElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__FilterElement);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__FilterElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__FilterElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__FilterElement(struct soap *soap, const char *tag, int id, const ngwt__FilterElement *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__FilterElement), type);
	soap_out_ngwt__FilterOp(soap, "ngwt:op", -1, &(((ngwt__FilterElement*)a)->op), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__FilterElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__FilterElement(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__FilterElement * SOAP_FMAC4 soap_get_ngwt__FilterElement(struct soap *soap, ngwt__FilterElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__FilterElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__FilterElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__FilterElement(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__FilterElement * SOAP_FMAC4 soap_in_ngwt__FilterElement(struct soap *soap, const char *tag, ngwt__FilterElement *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__FilterElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__FilterElement, sizeof(ngwt__FilterElement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__FilterElement)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__FilterElement *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_op1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_op1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ngwt__FilterOp(soap, "ngwt:op", &(((ngwt__FilterElement*)a)->op), ""))
				{	soap_flag_op1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_op1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__FilterElement *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FilterElement, 0, sizeof(ngwt__FilterElement), 0, soap_copy_ngwt__FilterElement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__FilterElement * SOAP_FMAC6 soap_new_ngwt__FilterElement(struct soap *soap, int n)
{	return soap_instantiate_ngwt__FilterElement(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__FilterElement(struct soap *soap, ngwt__FilterElement *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__FilterElement * SOAP_FMAC6 soap_instantiate_ngwt__FilterElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__FilterElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__FilterElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:FilterEntry"))
	{	cp->type = SOAP_TYPE_ngwt__FilterEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__FilterEntry;
			if (size)
				*size = sizeof(ngwt__FilterEntry);
			((ngwt__FilterEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__FilterEntry[n];
			if (size)
				*size = n * sizeof(ngwt__FilterEntry);
			for (int i = 0; i < n; i++)
				((ngwt__FilterEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__FilterEntry*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:FilterGroup"))
	{	cp->type = SOAP_TYPE_ngwt__FilterGroup;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__FilterGroup;
			if (size)
				*size = sizeof(ngwt__FilterGroup);
			((ngwt__FilterGroup*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__FilterGroup[n];
			if (size)
				*size = n * sizeof(ngwt__FilterGroup);
			for (int i = 0; i < n; i++)
				((ngwt__FilterGroup*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__FilterGroup*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__FilterElement;
		if (size)
			*size = sizeof(ngwt__FilterElement);
		((ngwt__FilterElement*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__FilterElement[n];
		if (size)
			*size = n * sizeof(ngwt__FilterElement);
		for (int i = 0; i < n; i++)
			((ngwt__FilterElement*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__FilterElement*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__FilterElement(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__FilterElement %p -> %p\n", q, p));
	*(ngwt__FilterElement*)p = *(ngwt__FilterElement*)q;
}

void ngwt__Filter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Filter*)this)->element, SOAP_TYPE_PointerTongwt__FilterElement);
	soap_serialize_PointerTongwt__FilterElement(soap, &((ngwt__Filter*)this)->element);
	/* transient soap skipped */
}

void ngwt__Filter::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Filter*)this)->element = NULL;
	/* transient soap skipped */
}

int ngwt__Filter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Filter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Filter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Filter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Filter(struct soap *soap, const char *tag, int id, const ngwt__Filter *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Filter), type);
	soap_out_PointerTongwt__FilterElement(soap, "ngwt:element", -1, &(((ngwt__Filter*)a)->element), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Filter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Filter(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Filter * SOAP_FMAC4 soap_get_ngwt__Filter(struct soap *soap, ngwt__Filter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Filter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Filter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Filter(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Filter * SOAP_FMAC4 soap_in_ngwt__Filter(struct soap *soap, const char *tag, ngwt__Filter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Filter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Filter, sizeof(ngwt__Filter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Filter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Filter *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_element1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_element1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FilterElement(soap, "ngwt:element", &(((ngwt__Filter*)a)->element), "ngwt:FilterElement"))
				{	soap_flag_element1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Filter *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Filter, 0, sizeof(ngwt__Filter), 0, soap_copy_ngwt__Filter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Filter * SOAP_FMAC6 soap_new_ngwt__Filter(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Filter(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Filter(struct soap *soap, ngwt__Filter *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Filter * SOAP_FMAC6 soap_instantiate_ngwt__Filter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Filter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Filter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Filter;
		if (size)
			*size = sizeof(ngwt__Filter);
		((ngwt__Filter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Filter[n];
		if (size)
			*size = n * sizeof(ngwt__Filter);
		for (int i = 0; i < n; i++)
			((ngwt__Filter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Filter*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Filter(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Filter %p -> %p\n", q, p));
	*(ngwt__Filter*)p = *(ngwt__Filter*)q;
}

void ngwt__EmailAddressList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ngwt__EmailAddressList*)this)->email);
	/* transient soap skipped */
}

void ngwt__EmailAddressList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &((ngwt__EmailAddressList*)this)->email);
	((ngwt__EmailAddressList*)this)->primary = NULL;
	/* transient soap skipped */
}

int ngwt__EmailAddressList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__EmailAddressList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__EmailAddressList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__EmailAddressList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__EmailAddressList(struct soap *soap, const char *tag, int id, const ngwt__EmailAddressList *a, const char *type)
{
	if (((ngwt__EmailAddressList *)a)->primary)
		soap_set_attr(soap, "primary", ((ngwt__EmailAddressList *)a)->primary->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__EmailAddressList), type);
	soap_out_std__vectorTemplateOfstd__string(soap, "ngwt:email", -1, &(((ngwt__EmailAddressList*)a)->email), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__EmailAddressList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__EmailAddressList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__EmailAddressList * SOAP_FMAC4 soap_get_ngwt__EmailAddressList(struct soap *soap, ngwt__EmailAddressList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__EmailAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__EmailAddressList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__EmailAddressList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__EmailAddressList * SOAP_FMAC4 soap_in_ngwt__EmailAddressList(struct soap *soap, const char *tag, ngwt__EmailAddressList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__EmailAddressList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__EmailAddressList, sizeof(ngwt__EmailAddressList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__EmailAddressList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__EmailAddressList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "primary", 0);
		if (t)
		{	if (!(((ngwt__EmailAddressList *)a)->primary = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__EmailAddressList *)a)->primary = soap_new_std__string(soap, -1);
			((ngwt__EmailAddressList *)a)->primary->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ngwt:email", &(((ngwt__EmailAddressList*)a)->email), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__EmailAddressList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__EmailAddressList, 0, sizeof(ngwt__EmailAddressList), 0, soap_copy_ngwt__EmailAddressList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__EmailAddressList * SOAP_FMAC6 soap_new_ngwt__EmailAddressList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__EmailAddressList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__EmailAddressList(struct soap *soap, ngwt__EmailAddressList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__EmailAddressList * SOAP_FMAC6 soap_instantiate_ngwt__EmailAddressList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__EmailAddressList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__EmailAddressList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__EmailAddressList;
		if (size)
			*size = sizeof(ngwt__EmailAddressList);
		((ngwt__EmailAddressList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__EmailAddressList[n];
		if (size)
			*size = n * sizeof(ngwt__EmailAddressList);
		for (int i = 0; i < n; i++)
			((ngwt__EmailAddressList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__EmailAddressList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__EmailAddressList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__EmailAddressList %p -> %p\n", q, p));
	*(ngwt__EmailAddressList*)p = *(ngwt__EmailAddressList*)q;
}

void ngwt__DocumentTypeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__DocumentType(soap, &((ngwt__DocumentTypeList*)this)->item);
	/* transient soap skipped */
}

void ngwt__DocumentTypeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__DocumentType(soap, &((ngwt__DocumentTypeList*)this)->item);
	/* transient soap skipped */
}

int ngwt__DocumentTypeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__DocumentTypeList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__DocumentTypeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__DocumentTypeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DocumentTypeList(struct soap *soap, const char *tag, int id, const ngwt__DocumentTypeList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__DocumentTypeList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__DocumentType(soap, "ngwt:item", -1, &(((ngwt__DocumentTypeList*)a)->item), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__DocumentTypeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__DocumentTypeList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__DocumentTypeList * SOAP_FMAC4 soap_get_ngwt__DocumentTypeList(struct soap *soap, ngwt__DocumentTypeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DocumentTypeList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__DocumentTypeList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__DocumentTypeList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__DocumentTypeList * SOAP_FMAC4 soap_in_ngwt__DocumentTypeList(struct soap *soap, const char *tag, ngwt__DocumentTypeList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__DocumentTypeList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DocumentTypeList, sizeof(ngwt__DocumentTypeList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__DocumentTypeList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__DocumentTypeList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__DocumentType(soap, "ngwt:item", &(((ngwt__DocumentTypeList*)a)->item), "ngwt:DocumentType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__DocumentTypeList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DocumentTypeList, 0, sizeof(ngwt__DocumentTypeList), 0, soap_copy_ngwt__DocumentTypeList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__DocumentTypeList * SOAP_FMAC6 soap_new_ngwt__DocumentTypeList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__DocumentTypeList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__DocumentTypeList(struct soap *soap, ngwt__DocumentTypeList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__DocumentTypeList * SOAP_FMAC6 soap_instantiate_ngwt__DocumentTypeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__DocumentTypeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__DocumentTypeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__DocumentTypeList;
		if (size)
			*size = sizeof(ngwt__DocumentTypeList);
		((ngwt__DocumentTypeList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__DocumentTypeList[n];
		if (size)
			*size = n * sizeof(ngwt__DocumentTypeList);
		for (int i = 0; i < n; i++)
			((ngwt__DocumentTypeList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__DocumentTypeList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__DocumentTypeList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__DocumentTypeList %p -> %p\n", q, p));
	*(ngwt__DocumentTypeList*)p = *(ngwt__DocumentTypeList*)q;
}

void ngwt__DocumentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__DocumentType*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__DocumentType*)this)->name);
	soap_embedded(soap, &((ngwt__DocumentType*)this)->life, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__DocumentType*)this)->life);
	soap_embedded(soap, &((ngwt__DocumentType*)this)->maximumVersions, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__DocumentType*)this)->maximumVersions);
	soap_embedded(soap, &((ngwt__DocumentType*)this)->ageAction, SOAP_TYPE_PointerTongwt__AgeAction);
	soap_serialize_PointerTongwt__AgeAction(soap, &((ngwt__DocumentType*)this)->ageAction);
	/* transient soap skipped */
}

void ngwt__DocumentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwt__DocumentType*)this)->name);
	((ngwt__DocumentType*)this)->life = NULL;
	((ngwt__DocumentType*)this)->maximumVersions = NULL;
	((ngwt__DocumentType*)this)->ageAction = NULL;
	/* transient soap skipped */
}

int ngwt__DocumentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__DocumentType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__DocumentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__DocumentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DocumentType(struct soap *soap, const char *tag, int id, const ngwt__DocumentType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__DocumentType), type);
	soap_out_std__string(soap, "ngwt:name", -1, &(((ngwt__DocumentType*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:life", -1, &(((ngwt__DocumentType*)a)->life), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:maximumVersions", -1, &(((ngwt__DocumentType*)a)->maximumVersions), "");
	soap_out_PointerTongwt__AgeAction(soap, "ngwt:ageAction", -1, &(((ngwt__DocumentType*)a)->ageAction), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__DocumentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__DocumentType(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__DocumentType * SOAP_FMAC4 soap_get_ngwt__DocumentType(struct soap *soap, ngwt__DocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DocumentType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__DocumentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__DocumentType(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__DocumentType * SOAP_FMAC4 soap_in_ngwt__DocumentType(struct soap *soap, const char *tag, ngwt__DocumentType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__DocumentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DocumentType, sizeof(ngwt__DocumentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__DocumentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__DocumentType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1, soap_flag_life1 = 1, soap_flag_maximumVersions1 = 1, soap_flag_ageAction1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:name", &(((ngwt__DocumentType*)a)->name), ""))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_life1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:life", &(((ngwt__DocumentType*)a)->life), ""))
				{	soap_flag_life1 = 0;
					continue;
				}
			if (soap_flag_maximumVersions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:maximumVersions", &(((ngwt__DocumentType*)a)->maximumVersions), ""))
				{	soap_flag_maximumVersions1 = 0;
					continue;
				}
			if (soap_flag_ageAction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AgeAction(soap, "ngwt:ageAction", &(((ngwt__DocumentType*)a)->ageAction), ""))
				{	soap_flag_ageAction1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__DocumentType *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DocumentType, 0, sizeof(ngwt__DocumentType), 0, soap_copy_ngwt__DocumentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__DocumentType * SOAP_FMAC6 soap_new_ngwt__DocumentType(struct soap *soap, int n)
{	return soap_instantiate_ngwt__DocumentType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__DocumentType(struct soap *soap, ngwt__DocumentType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__DocumentType * SOAP_FMAC6 soap_instantiate_ngwt__DocumentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__DocumentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__DocumentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__DocumentType;
		if (size)
			*size = sizeof(ngwt__DocumentType);
		((ngwt__DocumentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__DocumentType[n];
		if (size)
			*size = n * sizeof(ngwt__DocumentType);
		for (int i = 0; i < n; i++)
			((ngwt__DocumentType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__DocumentType*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__DocumentType(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__DocumentType %p -> %p\n", q, p));
	*(ngwt__DocumentType*)p = *(ngwt__DocumentType*)q;
}

void ngwt__DocumentRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__DocumentRef*)this)->library, SOAP_TYPE_PointerTongwt__NameAndEmail);
	soap_serialize_PointerTongwt__NameAndEmail(soap, &((ngwt__DocumentRef*)this)->library);
	soap_embedded(soap, &((ngwt__DocumentRef*)this)->documentNumber, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__DocumentRef*)this)->documentNumber);
	soap_embedded(soap, &((ngwt__DocumentRef*)this)->filename, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__DocumentRef*)this)->filename);
	soap_embedded(soap, &((ngwt__DocumentRef*)this)->documentTypeName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__DocumentRef*)this)->documentTypeName);
	soap_embedded(soap, &((ngwt__DocumentRef*)this)->author, SOAP_TYPE_PointerTongwt__NameAndEmail);
	soap_serialize_PointerTongwt__NameAndEmail(soap, &((ngwt__DocumentRef*)this)->author);
	soap_embedded(soap, &((ngwt__DocumentRef*)this)->creator, SOAP_TYPE_PointerTongwt__NameAndEmail);
	soap_serialize_PointerTongwt__NameAndEmail(soap, &((ngwt__DocumentRef*)this)->creator);
	soap_embedded(soap, &((ngwt__DocumentRef*)this)->officialVersion, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__DocumentRef*)this)->officialVersion);
	soap_embedded(soap, &((ngwt__DocumentRef*)this)->currentVersion, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__DocumentRef*)this)->currentVersion);
	soap_embedded(soap, &((ngwt__DocumentRef*)this)->versionNumber, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__DocumentRef*)this)->versionNumber);
	soap_embedded(soap, &((ngwt__DocumentRef*)this)->fileSize, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__DocumentRef*)this)->fileSize);
	soap_embedded(soap, &((ngwt__DocumentRef*)this)->acl, SOAP_TYPE_PointerTongwt__AccessControlList);
	soap_serialize_PointerTongwt__AccessControlList(soap, &((ngwt__DocumentRef*)this)->acl);
	soap_embedded(soap, &((ngwt__Mail*)this)->subject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subject);
	soap_embedded(soap, &((ngwt__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ngwt__Mail*)this)->subjectPrefix, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subjectPrefix);
	soap_embedded(soap, &((ngwt__Mail*)this)->distribution, SOAP_TYPE_PointerTongwt__Distribution);
	soap_serialize_PointerTongwt__Distribution(soap, &((ngwt__Mail*)this)->distribution);
	soap_embedded(soap, &((ngwt__Mail*)this)->message, SOAP_TYPE_PointerTongwt__MessageBody);
	soap_serialize_PointerTongwt__MessageBody(soap, &((ngwt__Mail*)this)->message);
	soap_embedded(soap, &((ngwt__Mail*)this)->attachments, SOAP_TYPE_PointerTongwt__AttachmentInfo);
	soap_serialize_PointerTongwt__AttachmentInfo(soap, &((ngwt__Mail*)this)->attachments);
	soap_embedded(soap, &((ngwt__Mail*)this)->options, SOAP_TYPE_PointerTongwt__ItemOptions);
	soap_serialize_PointerTongwt__ItemOptions(soap, &((ngwt__Mail*)this)->options);
	soap_embedded(soap, &((ngwt__Mail*)this)->link, SOAP_TYPE_PointerTongwt__LinkInfo);
	soap_serialize_PointerTongwt__LinkInfo(soap, &((ngwt__Mail*)this)->link);
	soap_embedded(soap, &((ngwt__Mail*)this)->hasAttachment, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwt__Mail*)this)->size, SOAP_TYPE_int);
	soap_embedded(soap, &((ngwt__Mail*)this)->subType, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subType);
	soap_embedded(soap, &((ngwt__Mail*)this)->nntpOrImap, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Mail*)this)->nntpOrImap);
	soap_embedded(soap, &((ngwt__Mail*)this)->smimeType, SOAP_TYPE_PointerTongwt__SMimeOperation);
	soap_serialize_PointerTongwt__SMimeOperation(soap, &((ngwt__Mail*)this)->smimeType);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->status, SOAP_TYPE_PointerTongwt__ItemStatus);
	soap_serialize_PointerTongwt__ItemStatus(soap, &((ngwt__BoxEntry*)this)->status);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->msgId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->msgId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->messageId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->messageId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->source, SOAP_TYPE_PointerTongwt__ItemSource);
	soap_serialize_PointerTongwt__ItemSource(soap, &((ngwt__BoxEntry*)this)->source);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->class_, SOAP_TYPE_PointerTongwt__ItemClass);
	soap_serialize_PointerTongwt__ItemClass(soap, &((ngwt__BoxEntry*)this)->class_);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->security, SOAP_TYPE_PointerTongwt__ItemSecurity);
	soap_serialize_PointerTongwt__ItemSecurity(soap, &((ngwt__BoxEntry*)this)->security);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->comment);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__DocumentRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__DocumentRef*)this)->library = NULL;
	((ngwt__DocumentRef*)this)->documentNumber = NULL;
	((ngwt__DocumentRef*)this)->filename = NULL;
	((ngwt__DocumentRef*)this)->documentTypeName = NULL;
	((ngwt__DocumentRef*)this)->author = NULL;
	((ngwt__DocumentRef*)this)->creator = NULL;
	((ngwt__DocumentRef*)this)->officialVersion = NULL;
	((ngwt__DocumentRef*)this)->currentVersion = NULL;
	((ngwt__DocumentRef*)this)->versionNumber = NULL;
	((ngwt__DocumentRef*)this)->versionDescription = NULL;
	((ngwt__DocumentRef*)this)->fileSize = NULL;
	((ngwt__DocumentRef*)this)->acl = NULL;
	((ngwt__Mail*)this)->subject = NULL;
	((ngwt__Mail*)this)->originalSubject = NULL;
	((ngwt__Mail*)this)->subjectPrefix = NULL;
	((ngwt__Mail*)this)->distribution = NULL;
	((ngwt__Mail*)this)->message = NULL;
	((ngwt__Mail*)this)->attachments = NULL;
	((ngwt__Mail*)this)->options = NULL;
	((ngwt__Mail*)this)->link = NULL;
	((ngwt__Mail*)this)->hasAttachment = (bool)0;
	((ngwt__Mail*)this)->size = 0;
	((ngwt__Mail*)this)->subType = NULL;
	((ngwt__Mail*)this)->nntpOrImap = NULL;
	((ngwt__Mail*)this)->smimeType = NULL;
	((ngwt__BoxEntry*)this)->status = NULL;
	((ngwt__BoxEntry*)this)->thread = NULL;
	((ngwt__BoxEntry*)this)->msgId = NULL;
	((ngwt__BoxEntry*)this)->messageId = NULL;
	((ngwt__BoxEntry*)this)->source = NULL;
	((ngwt__BoxEntry*)this)->returnSentItemsId = NULL;
	soap_default_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	((ngwt__BoxEntry*)this)->class_ = NULL;
	((ngwt__BoxEntry*)this)->security = NULL;
	((ngwt__BoxEntry*)this)->comment = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__DocumentRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__DocumentRef);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__DocumentRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__DocumentRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DocumentRef(struct soap *soap, const char *tag, int id, const ngwt__DocumentRef *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__DocumentRef), "ngwt:DocumentRef");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__ItemStatus(soap, "ngwt:status", -1, &(((ngwt__BoxEntry*)a)->status), "");
	soap_out_PointerTostd__string(soap, "ngwt:thread", -1, &(((ngwt__BoxEntry*)a)->thread), "");
	soap_out_PointerTostd__string(soap, "ngwt:msgId", -1, &(((ngwt__BoxEntry*)a)->msgId), "");
	soap_out_PointerTostd__string(soap, "ngwt:messageId", -1, &(((ngwt__BoxEntry*)a)->messageId), "");
	soap_out_PointerTongwt__ItemSource(soap, "ngwt:source", -1, &(((ngwt__BoxEntry*)a)->source), "");
	soap_out_PointerTobool(soap, "ngwt:returnSentItemsId", -1, &(((ngwt__BoxEntry*)a)->returnSentItemsId), "");
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__BoxEntry*)a)->delivered), "");
	soap_out_PointerTongwt__ItemClass(soap, "ngwt:class", -1, &(((ngwt__BoxEntry*)a)->class_), "");
	soap_out_PointerTongwt__ItemSecurity(soap, "ngwt:security", -1, &(((ngwt__BoxEntry*)a)->security), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__BoxEntry*)a)->comment), "");
	soap_out_PointerTostd__string(soap, "ngwt:subject", -1, &(((ngwt__Mail*)a)->subject), "");
	soap_out_PointerTostd__string(soap, "ngwt:originalSubject", -1, &(((ngwt__Mail*)a)->originalSubject), "");
	soap_out_PointerTostd__string(soap, "ngwt:subjectPrefix", -1, &(((ngwt__Mail*)a)->subjectPrefix), "");
	soap_out_PointerTongwt__Distribution(soap, "ngwt:distribution", -1, &(((ngwt__Mail*)a)->distribution), "");
	soap_out_PointerTongwt__MessageBody(soap, "ngwt:message", -1, &(((ngwt__Mail*)a)->message), "");
	soap_out_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", -1, &(((ngwt__Mail*)a)->attachments), "");
	soap_out_PointerTongwt__ItemOptions(soap, "ngwt:options", -1, &(((ngwt__Mail*)a)->options), "");
	soap_out_PointerTongwt__LinkInfo(soap, "ngwt:link", -1, &(((ngwt__Mail*)a)->link), "");
	soap_out_bool(soap, "ngwt:hasAttachment", -1, &(((ngwt__Mail*)a)->hasAttachment), "");
	soap_out_int(soap, "ngwt:size", -1, &(((ngwt__Mail*)a)->size), "");
	soap_out_PointerTostd__string(soap, "ngwt:subType", -1, &(((ngwt__Mail*)a)->subType), "");
	soap_out_PointerTobool(soap, "ngwt:nntpOrImap", -1, &(((ngwt__Mail*)a)->nntpOrImap), "");
	soap_out_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", -1, &(((ngwt__Mail*)a)->smimeType), "");
	soap_out_PointerTongwt__NameAndEmail(soap, "ngwt:library", -1, &(((ngwt__DocumentRef*)a)->library), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:documentNumber", -1, &(((ngwt__DocumentRef*)a)->documentNumber), "");
	soap_out_PointerTostd__string(soap, "ngwt:filename", -1, &(((ngwt__DocumentRef*)a)->filename), "");
	soap_out_PointerTostd__string(soap, "ngwt:documentTypeName", -1, &(((ngwt__DocumentRef*)a)->documentTypeName), "");
	soap_out_PointerTongwt__NameAndEmail(soap, "ngwt:author", -1, &(((ngwt__DocumentRef*)a)->author), "");
	soap_out_PointerTongwt__NameAndEmail(soap, "ngwt:creator", -1, &(((ngwt__DocumentRef*)a)->creator), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:officialVersion", -1, &(((ngwt__DocumentRef*)a)->officialVersion), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:currentVersion", -1, &(((ngwt__DocumentRef*)a)->currentVersion), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:versionNumber", -1, &(((ngwt__DocumentRef*)a)->versionNumber), "");
	soap_outliteral(soap, "ngwt:versionDescription", &(((ngwt__DocumentRef*)a)->versionDescription));
	soap_out_PointerTounsignedLong(soap, "ngwt:fileSize", -1, &(((ngwt__DocumentRef*)a)->fileSize), "");
	soap_out_PointerTongwt__AccessControlList(soap, "ngwt:acl", -1, &(((ngwt__DocumentRef*)a)->acl), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__DocumentRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__DocumentRef(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__DocumentRef * SOAP_FMAC4 soap_get_ngwt__DocumentRef(struct soap *soap, ngwt__DocumentRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DocumentRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__DocumentRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__DocumentRef(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__DocumentRef * SOAP_FMAC4 soap_in_ngwt__DocumentRef(struct soap *soap, const char *tag, ngwt__DocumentRef *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__DocumentRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DocumentRef, sizeof(ngwt__DocumentRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__DocumentRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__DocumentRef *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id5 = 1, soap_flag_name5 = 1, soap_flag_version5 = 1, soap_flag_modified5 = 1, soap_flag_changes5 = 1, soap_flag_categories4 = 1, soap_flag_created4 = 1, soap_flag_customs4 = 1, soap_flag_status3 = 1, soap_flag_thread3 = 1, soap_flag_msgId3 = 1, soap_flag_messageId3 = 1, soap_flag_source3 = 1, soap_flag_returnSentItemsId3 = 1, soap_flag_delivered3 = 1, soap_flag_class_3 = 1, soap_flag_security3 = 1, soap_flag_comment3 = 1, soap_flag_subject2 = 1, soap_flag_originalSubject2 = 1, soap_flag_subjectPrefix2 = 1, soap_flag_distribution2 = 1, soap_flag_message2 = 1, soap_flag_attachments2 = 1, soap_flag_options2 = 1, soap_flag_link2 = 1, soap_flag_hasAttachment2 = 1, soap_flag_size2 = 1, soap_flag_subType2 = 1, soap_flag_nntpOrImap2 = 1, soap_flag_smimeType2 = 1, soap_flag_library1 = 1, soap_flag_documentNumber1 = 1, soap_flag_filename1 = 1, soap_flag_documentTypeName1 = 1, soap_flag_author1 = 1, soap_flag_creator1 = 1, soap_flag_officialVersion1 = 1, soap_flag_currentVersion1 = 1, soap_flag_versionNumber1 = 1, soap_flag_versionDescription1 = 1, soap_flag_fileSize1 = 1, soap_flag_acl1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id5 = 0;
					continue;
				}
			if (soap_flag_name5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name5 = 0;
					continue;
				}
			if (soap_flag_version5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version5 = 0;
					continue;
				}
			if (soap_flag_modified5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified5 = 0;
					continue;
				}
			if (soap_flag_changes5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes5 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories4 = 0;
					continue;
				}
			if (soap_flag_created4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created4 = 0;
					continue;
				}
			if (soap_flag_customs4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs4 = 0;
					continue;
				}
			if (soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemStatus(soap, "ngwt:status", &(((ngwt__BoxEntry*)a)->status), "ngwt:ItemStatus"))
				{	soap_flag_status3 = 0;
					continue;
				}
			if (soap_flag_thread3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:thread", &(((ngwt__BoxEntry*)a)->thread), ""))
				{	soap_flag_thread3 = 0;
					continue;
				}
			if (soap_flag_msgId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:msgId", &(((ngwt__BoxEntry*)a)->msgId), ""))
				{	soap_flag_msgId3 = 0;
					continue;
				}
			if (soap_flag_messageId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:messageId", &(((ngwt__BoxEntry*)a)->messageId), ""))
				{	soap_flag_messageId3 = 0;
					continue;
				}
			if (soap_flag_source3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSource(soap, "ngwt:source", &(((ngwt__BoxEntry*)a)->source), ""))
				{	soap_flag_source3 = 0;
					continue;
				}
			if (soap_flag_returnSentItemsId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:returnSentItemsId", &(((ngwt__BoxEntry*)a)->returnSentItemsId), ""))
				{	soap_flag_returnSentItemsId3 = 0;
					continue;
				}
			if (soap_flag_delivered3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered3 = 0;
					continue;
				}
			if (soap_flag_class_3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemClass(soap, "ngwt:class", &(((ngwt__BoxEntry*)a)->class_), ""))
				{	soap_flag_class_3 = 0;
					continue;
				}
			if (soap_flag_security3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSecurity(soap, "ngwt:security", &(((ngwt__BoxEntry*)a)->security), ""))
				{	soap_flag_security3 = 0;
					continue;
				}
			if (soap_flag_comment3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__BoxEntry*)a)->comment), ""))
				{	soap_flag_comment3 = 0;
					continue;
				}
			if (soap_flag_subject2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subject", &(((ngwt__Mail*)a)->subject), ""))
				{	soap_flag_subject2 = 0;
					continue;
				}
			if (soap_flag_originalSubject2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:originalSubject", &(((ngwt__Mail*)a)->originalSubject), ""))
				{	soap_flag_originalSubject2 = 0;
					continue;
				}
			if (soap_flag_subjectPrefix2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subjectPrefix", &(((ngwt__Mail*)a)->subjectPrefix), ""))
				{	soap_flag_subjectPrefix2 = 0;
					continue;
				}
			if (soap_flag_distribution2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Distribution(soap, "ngwt:distribution", &(((ngwt__Mail*)a)->distribution), "ngwt:Distribution"))
				{	soap_flag_distribution2 = 0;
					continue;
				}
			if (soap_flag_message2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessageBody(soap, "ngwt:message", &(((ngwt__Mail*)a)->message), "ngwt:MessageBody"))
				{	soap_flag_message2 = 0;
					continue;
				}
			if (soap_flag_attachments2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", &(((ngwt__Mail*)a)->attachments), "ngwt:AttachmentInfo"))
				{	soap_flag_attachments2 = 0;
					continue;
				}
			if (soap_flag_options2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemOptions(soap, "ngwt:options", &(((ngwt__Mail*)a)->options), "ngwt:ItemOptions"))
				{	soap_flag_options2 = 0;
					continue;
				}
			if (soap_flag_link2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__LinkInfo(soap, "ngwt:link", &(((ngwt__Mail*)a)->link), "ngwt:LinkInfo"))
				{	soap_flag_link2 = 0;
					continue;
				}
			if (soap_flag_hasAttachment2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:hasAttachment", &(((ngwt__Mail*)a)->hasAttachment), ""))
				{	soap_flag_hasAttachment2 = 0;
					continue;
				}
			if (soap_flag_size2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:size", &(((ngwt__Mail*)a)->size), ""))
				{	soap_flag_size2 = 0;
					continue;
				}
			if (soap_flag_subType2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subType", &(((ngwt__Mail*)a)->subType), ""))
				{	soap_flag_subType2 = 0;
					continue;
				}
			if (soap_flag_nntpOrImap2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:nntpOrImap", &(((ngwt__Mail*)a)->nntpOrImap), ""))
				{	soap_flag_nntpOrImap2 = 0;
					continue;
				}
			if (soap_flag_smimeType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", &(((ngwt__Mail*)a)->smimeType), "ngwt:SMimeOperation"))
				{	soap_flag_smimeType2 = 0;
					continue;
				}
			if (soap_flag_library1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__NameAndEmail(soap, "ngwt:library", &(((ngwt__DocumentRef*)a)->library), "ngwt:NameAndEmail"))
				{	soap_flag_library1 = 0;
					continue;
				}
			if (soap_flag_documentNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:documentNumber", &(((ngwt__DocumentRef*)a)->documentNumber), ""))
				{	soap_flag_documentNumber1 = 0;
					continue;
				}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:filename", &(((ngwt__DocumentRef*)a)->filename), ""))
				{	soap_flag_filename1 = 0;
					continue;
				}
			if (soap_flag_documentTypeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:documentTypeName", &(((ngwt__DocumentRef*)a)->documentTypeName), ""))
				{	soap_flag_documentTypeName1 = 0;
					continue;
				}
			if (soap_flag_author1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__NameAndEmail(soap, "ngwt:author", &(((ngwt__DocumentRef*)a)->author), "ngwt:NameAndEmail"))
				{	soap_flag_author1 = 0;
					continue;
				}
			if (soap_flag_creator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__NameAndEmail(soap, "ngwt:creator", &(((ngwt__DocumentRef*)a)->creator), "ngwt:NameAndEmail"))
				{	soap_flag_creator1 = 0;
					continue;
				}
			if (soap_flag_officialVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:officialVersion", &(((ngwt__DocumentRef*)a)->officialVersion), ""))
				{	soap_flag_officialVersion1 = 0;
					continue;
				}
			if (soap_flag_currentVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:currentVersion", &(((ngwt__DocumentRef*)a)->currentVersion), ""))
				{	soap_flag_currentVersion1 = 0;
					continue;
				}
			if (soap_flag_versionNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:versionNumber", &(((ngwt__DocumentRef*)a)->versionNumber), ""))
				{	soap_flag_versionNumber1 = 0;
					continue;
				}
			if (soap_flag_versionDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ngwt:versionDescription", &(((ngwt__DocumentRef*)a)->versionDescription)))
				{	soap_flag_versionDescription1 = 0;
					continue;
				}
			if (soap_flag_fileSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:fileSize", &(((ngwt__DocumentRef*)a)->fileSize), ""))
				{	soap_flag_fileSize1 = 0;
					continue;
				}
			if (soap_flag_acl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessControlList(soap, "ngwt:acl", &(((ngwt__DocumentRef*)a)->acl), "ngwt:AccessControlList"))
				{	soap_flag_acl1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_delivered3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__DocumentRef *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DocumentRef, 0, sizeof(ngwt__DocumentRef), 0, soap_copy_ngwt__DocumentRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__DocumentRef * SOAP_FMAC6 soap_new_ngwt__DocumentRef(struct soap *soap, int n)
{	return soap_instantiate_ngwt__DocumentRef(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__DocumentRef(struct soap *soap, ngwt__DocumentRef *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__DocumentRef * SOAP_FMAC6 soap_instantiate_ngwt__DocumentRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__DocumentRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__DocumentRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__DocumentRef;
		if (size)
			*size = sizeof(ngwt__DocumentRef);
		((ngwt__DocumentRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__DocumentRef[n];
		if (size)
			*size = n * sizeof(ngwt__DocumentRef);
		for (int i = 0; i < n; i++)
			((ngwt__DocumentRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__DocumentRef*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__DocumentRef(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__DocumentRef %p -> %p\n", q, p));
	*(ngwt__DocumentRef*)p = *(ngwt__DocumentRef*)q;
}

void ngwt__Document::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Document*)this)->subject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Document*)this)->subject);
	soap_embedded(soap, &((ngwt__Document*)this)->library, SOAP_TYPE_PointerTongwt__NameAndEmail);
	soap_serialize_PointerTongwt__NameAndEmail(soap, &((ngwt__Document*)this)->library);
	soap_embedded(soap, &((ngwt__Document*)this)->documentNumber, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Document*)this)->documentNumber);
	soap_embedded(soap, &((ngwt__Document*)this)->documentTypeName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Document*)this)->documentTypeName);
	soap_embedded(soap, &((ngwt__Document*)this)->author, SOAP_TYPE_PointerTongwt__NameAndEmail);
	soap_serialize_PointerTongwt__NameAndEmail(soap, &((ngwt__Document*)this)->author);
	soap_embedded(soap, &((ngwt__Document*)this)->creator, SOAP_TYPE_PointerTongwt__NameAndEmail);
	soap_serialize_PointerTongwt__NameAndEmail(soap, &((ngwt__Document*)this)->creator);
	soap_embedded(soap, &((ngwt__Document*)this)->officialVersion, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Document*)this)->officialVersion);
	soap_embedded(soap, &((ngwt__Document*)this)->currentVersion, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Document*)this)->currentVersion);
	soap_embedded(soap, &((ngwt__Document*)this)->current, SOAP_TYPE_PointerTongwt__AccessControlList);
	soap_serialize_PointerTongwt__AccessControlList(soap, &((ngwt__Document*)this)->current);
	soap_embedded(soap, &((ngwt__Document*)this)->official, SOAP_TYPE_PointerTongwt__AccessControlList);
	soap_serialize_PointerTongwt__AccessControlList(soap, &((ngwt__Document*)this)->official);
	soap_embedded(soap, &((ngwt__Document*)this)->other, SOAP_TYPE_PointerTongwt__AccessControlList);
	soap_serialize_PointerTongwt__AccessControlList(soap, &((ngwt__Document*)this)->other);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Document::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Document*)this)->subject = NULL;
	((ngwt__Document*)this)->library = NULL;
	((ngwt__Document*)this)->documentNumber = NULL;
	((ngwt__Document*)this)->documentTypeName = NULL;
	((ngwt__Document*)this)->author = NULL;
	((ngwt__Document*)this)->creator = NULL;
	((ngwt__Document*)this)->officialVersion = NULL;
	((ngwt__Document*)this)->currentVersion = NULL;
	((ngwt__Document*)this)->current = NULL;
	((ngwt__Document*)this)->official = NULL;
	((ngwt__Document*)this)->other = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Document::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Document);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Document::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Document(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Document(struct soap *soap, const char *tag, int id, const ngwt__Document *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Document), "ngwt:Document");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTostd__string(soap, "ngwt:subject", -1, &(((ngwt__Document*)a)->subject), "");
	soap_out_PointerTongwt__NameAndEmail(soap, "ngwt:library", -1, &(((ngwt__Document*)a)->library), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:documentNumber", -1, &(((ngwt__Document*)a)->documentNumber), "");
	soap_out_PointerTostd__string(soap, "ngwt:documentTypeName", -1, &(((ngwt__Document*)a)->documentTypeName), "");
	soap_out_PointerTongwt__NameAndEmail(soap, "ngwt:author", -1, &(((ngwt__Document*)a)->author), "");
	soap_out_PointerTongwt__NameAndEmail(soap, "ngwt:creator", -1, &(((ngwt__Document*)a)->creator), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:officialVersion", -1, &(((ngwt__Document*)a)->officialVersion), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:currentVersion", -1, &(((ngwt__Document*)a)->currentVersion), "");
	soap_out_PointerTongwt__AccessControlList(soap, "ngwt:current", -1, &(((ngwt__Document*)a)->current), "");
	soap_out_PointerTongwt__AccessControlList(soap, "ngwt:official", -1, &(((ngwt__Document*)a)->official), "");
	soap_out_PointerTongwt__AccessControlList(soap, "ngwt:other", -1, &(((ngwt__Document*)a)->other), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Document::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Document(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Document * SOAP_FMAC4 soap_get_ngwt__Document(struct soap *soap, ngwt__Document *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Document(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Document::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Document(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Document * SOAP_FMAC4 soap_in_ngwt__Document(struct soap *soap, const char *tag, ngwt__Document *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Document *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Document, sizeof(ngwt__Document), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Document)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Document *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_categories2 = 1, soap_flag_created2 = 1, soap_flag_customs2 = 1, soap_flag_subject1 = 1, soap_flag_library1 = 1, soap_flag_documentNumber1 = 1, soap_flag_documentTypeName1 = 1, soap_flag_author1 = 1, soap_flag_creator1 = 1, soap_flag_officialVersion1 = 1, soap_flag_currentVersion1 = 1, soap_flag_current1 = 1, soap_flag_official1 = 1, soap_flag_other1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}
			if (soap_flag_name3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name3 = 0;
					continue;
				}
			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}
			if (soap_flag_modified3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}
			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories2 = 0;
					continue;
				}
			if (soap_flag_created2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created2 = 0;
					continue;
				}
			if (soap_flag_customs2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs2 = 0;
					continue;
				}
			if (soap_flag_subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subject", &(((ngwt__Document*)a)->subject), ""))
				{	soap_flag_subject1 = 0;
					continue;
				}
			if (soap_flag_library1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__NameAndEmail(soap, "ngwt:library", &(((ngwt__Document*)a)->library), "ngwt:NameAndEmail"))
				{	soap_flag_library1 = 0;
					continue;
				}
			if (soap_flag_documentNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:documentNumber", &(((ngwt__Document*)a)->documentNumber), ""))
				{	soap_flag_documentNumber1 = 0;
					continue;
				}
			if (soap_flag_documentTypeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:documentTypeName", &(((ngwt__Document*)a)->documentTypeName), ""))
				{	soap_flag_documentTypeName1 = 0;
					continue;
				}
			if (soap_flag_author1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__NameAndEmail(soap, "ngwt:author", &(((ngwt__Document*)a)->author), "ngwt:NameAndEmail"))
				{	soap_flag_author1 = 0;
					continue;
				}
			if (soap_flag_creator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__NameAndEmail(soap, "ngwt:creator", &(((ngwt__Document*)a)->creator), "ngwt:NameAndEmail"))
				{	soap_flag_creator1 = 0;
					continue;
				}
			if (soap_flag_officialVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:officialVersion", &(((ngwt__Document*)a)->officialVersion), ""))
				{	soap_flag_officialVersion1 = 0;
					continue;
				}
			if (soap_flag_currentVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:currentVersion", &(((ngwt__Document*)a)->currentVersion), ""))
				{	soap_flag_currentVersion1 = 0;
					continue;
				}
			if (soap_flag_current1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessControlList(soap, "ngwt:current", &(((ngwt__Document*)a)->current), "ngwt:AccessControlList"))
				{	soap_flag_current1 = 0;
					continue;
				}
			if (soap_flag_official1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessControlList(soap, "ngwt:official", &(((ngwt__Document*)a)->official), "ngwt:AccessControlList"))
				{	soap_flag_official1 = 0;
					continue;
				}
			if (soap_flag_other1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessControlList(soap, "ngwt:other", &(((ngwt__Document*)a)->other), "ngwt:AccessControlList"))
				{	soap_flag_other1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Document *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Document, 0, sizeof(ngwt__Document), 0, soap_copy_ngwt__Document);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Document * SOAP_FMAC6 soap_new_ngwt__Document(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Document(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Document(struct soap *soap, ngwt__Document *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Document * SOAP_FMAC6 soap_instantiate_ngwt__Document(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Document(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Document, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Document;
		if (size)
			*size = sizeof(ngwt__Document);
		((ngwt__Document*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Document[n];
		if (size)
			*size = n * sizeof(ngwt__Document);
		for (int i = 0; i < n; i++)
			((ngwt__Document*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Document*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Document(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Document %p -> %p\n", q, p));
	*(ngwt__Document*)p = *(ngwt__Document*)q;
}

void ngwt__Distribution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Distribution*)this)->from, SOAP_TYPE_PointerTongwt__From);
	soap_serialize_PointerTongwt__From(soap, &((ngwt__Distribution*)this)->from);
	soap_embedded(soap, &((ngwt__Distribution*)this)->to, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Distribution*)this)->to);
	soap_embedded(soap, &((ngwt__Distribution*)this)->cc, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Distribution*)this)->cc);
	soap_embedded(soap, &((ngwt__Distribution*)this)->bc, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Distribution*)this)->bc);
	soap_embedded(soap, &((ngwt__Distribution*)this)->recipients, SOAP_TYPE_PointerTongwt__RecipientList);
	soap_serialize_PointerTongwt__RecipientList(soap, &((ngwt__Distribution*)this)->recipients);
	soap_embedded(soap, &((ngwt__Distribution*)this)->sendoptions, SOAP_TYPE_PointerTongwt__SendOptions);
	soap_serialize_PointerTongwt__SendOptions(soap, &((ngwt__Distribution*)this)->sendoptions);
	/* transient soap skipped */
}

void ngwt__Distribution::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Distribution*)this)->from = NULL;
	((ngwt__Distribution*)this)->to = NULL;
	((ngwt__Distribution*)this)->cc = NULL;
	((ngwt__Distribution*)this)->bc = NULL;
	((ngwt__Distribution*)this)->recipients = NULL;
	((ngwt__Distribution*)this)->sendoptions = NULL;
	/* transient soap skipped */
}

int ngwt__Distribution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Distribution);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Distribution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Distribution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Distribution(struct soap *soap, const char *tag, int id, const ngwt__Distribution *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Distribution), type);
	soap_out_PointerTongwt__From(soap, "ngwt:from", -1, &(((ngwt__Distribution*)a)->from), "");
	soap_out_PointerTostd__string(soap, "ngwt:to", -1, &(((ngwt__Distribution*)a)->to), "");
	soap_out_PointerTostd__string(soap, "ngwt:cc", -1, &(((ngwt__Distribution*)a)->cc), "");
	soap_out_PointerTostd__string(soap, "ngwt:bc", -1, &(((ngwt__Distribution*)a)->bc), "");
	soap_out_PointerTongwt__RecipientList(soap, "ngwt:recipients", -1, &(((ngwt__Distribution*)a)->recipients), "");
	soap_out_PointerTongwt__SendOptions(soap, "ngwt:sendoptions", -1, &(((ngwt__Distribution*)a)->sendoptions), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Distribution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Distribution(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Distribution * SOAP_FMAC4 soap_get_ngwt__Distribution(struct soap *soap, ngwt__Distribution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Distribution(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Distribution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Distribution(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Distribution * SOAP_FMAC4 soap_in_ngwt__Distribution(struct soap *soap, const char *tag, ngwt__Distribution *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Distribution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Distribution, sizeof(ngwt__Distribution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Distribution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Distribution *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_from1 = 1, soap_flag_to1 = 1, soap_flag_cc1 = 1, soap_flag_bc1 = 1, soap_flag_recipients1 = 1, soap_flag_sendoptions1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__From(soap, "ngwt:from", &(((ngwt__Distribution*)a)->from), "ngwt:From"))
				{	soap_flag_from1 = 0;
					continue;
				}
			if (soap_flag_to1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:to", &(((ngwt__Distribution*)a)->to), ""))
				{	soap_flag_to1 = 0;
					continue;
				}
			if (soap_flag_cc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:cc", &(((ngwt__Distribution*)a)->cc), ""))
				{	soap_flag_cc1 = 0;
					continue;
				}
			if (soap_flag_bc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:bc", &(((ngwt__Distribution*)a)->bc), ""))
				{	soap_flag_bc1 = 0;
					continue;
				}
			if (soap_flag_recipients1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecipientList(soap, "ngwt:recipients", &(((ngwt__Distribution*)a)->recipients), "ngwt:RecipientList"))
				{	soap_flag_recipients1 = 0;
					continue;
				}
			if (soap_flag_sendoptions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SendOptions(soap, "ngwt:sendoptions", &(((ngwt__Distribution*)a)->sendoptions), "ngwt:SendOptions"))
				{	soap_flag_sendoptions1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Distribution *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Distribution, 0, sizeof(ngwt__Distribution), 0, soap_copy_ngwt__Distribution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Distribution * SOAP_FMAC6 soap_new_ngwt__Distribution(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Distribution(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Distribution(struct soap *soap, ngwt__Distribution *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Distribution * SOAP_FMAC6 soap_instantiate_ngwt__Distribution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Distribution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Distribution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Distribution;
		if (size)
			*size = sizeof(ngwt__Distribution);
		((ngwt__Distribution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Distribution[n];
		if (size)
			*size = n * sizeof(ngwt__Distribution);
		for (int i = 0; i < n; i++)
			((ngwt__Distribution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Distribution*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Distribution(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Distribution %p -> %p\n", q, p));
	*(ngwt__Distribution*)p = *(ngwt__Distribution*)q;
}

void ngwt__DeltaInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__DeltaInfo*)this)->count, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__DeltaInfo*)this)->count);
	soap_embedded(soap, &((ngwt__DeltaInfo*)this)->firstSequence, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__DeltaInfo*)this)->firstSequence);
	soap_embedded(soap, &((ngwt__DeltaInfo*)this)->lastSequence, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__DeltaInfo*)this)->lastSequence);
	soap_embedded(soap, &((ngwt__DeltaInfo*)this)->lastTimePORebuild, SOAP_TYPE_unsignedLong);
	/* transient soap skipped */
}

void ngwt__DeltaInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__DeltaInfo*)this)->count = NULL;
	((ngwt__DeltaInfo*)this)->firstSequence = NULL;
	((ngwt__DeltaInfo*)this)->lastSequence = NULL;
	soap_default_unsignedLong(soap, &((ngwt__DeltaInfo*)this)->lastTimePORebuild);
	/* transient soap skipped */
}

int ngwt__DeltaInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__DeltaInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__DeltaInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__DeltaInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DeltaInfo(struct soap *soap, const char *tag, int id, const ngwt__DeltaInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__DeltaInfo), type);
	soap_out_PointerToint(soap, "ngwt:count", -1, &(((ngwt__DeltaInfo*)a)->count), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:firstSequence", -1, &(((ngwt__DeltaInfo*)a)->firstSequence), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:lastSequence", -1, &(((ngwt__DeltaInfo*)a)->lastSequence), "");
	soap_out_unsignedLong(soap, "ngwt:lastTimePORebuild", -1, &(((ngwt__DeltaInfo*)a)->lastTimePORebuild), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__DeltaInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__DeltaInfo(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__DeltaInfo * SOAP_FMAC4 soap_get_ngwt__DeltaInfo(struct soap *soap, ngwt__DeltaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DeltaInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__DeltaInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__DeltaInfo(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__DeltaInfo * SOAP_FMAC4 soap_in_ngwt__DeltaInfo(struct soap *soap, const char *tag, ngwt__DeltaInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__DeltaInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DeltaInfo, sizeof(ngwt__DeltaInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__DeltaInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__DeltaInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_count1 = 1, soap_flag_firstSequence1 = 1, soap_flag_lastSequence1 = 1, soap_flag_lastTimePORebuild1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:count", &(((ngwt__DeltaInfo*)a)->count), ""))
				{	soap_flag_count1 = 0;
					continue;
				}
			if (soap_flag_firstSequence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:firstSequence", &(((ngwt__DeltaInfo*)a)->firstSequence), ""))
				{	soap_flag_firstSequence1 = 0;
					continue;
				}
			if (soap_flag_lastSequence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:lastSequence", &(((ngwt__DeltaInfo*)a)->lastSequence), ""))
				{	soap_flag_lastSequence1 = 0;
					continue;
				}
			if (soap_flag_lastTimePORebuild1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "ngwt:lastTimePORebuild", &(((ngwt__DeltaInfo*)a)->lastTimePORebuild), ""))
				{	soap_flag_lastTimePORebuild1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lastTimePORebuild1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__DeltaInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DeltaInfo, 0, sizeof(ngwt__DeltaInfo), 0, soap_copy_ngwt__DeltaInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__DeltaInfo * SOAP_FMAC6 soap_new_ngwt__DeltaInfo(struct soap *soap, int n)
{	return soap_instantiate_ngwt__DeltaInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__DeltaInfo(struct soap *soap, ngwt__DeltaInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__DeltaInfo * SOAP_FMAC6 soap_instantiate_ngwt__DeltaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__DeltaInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__DeltaInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__DeltaInfo;
		if (size)
			*size = sizeof(ngwt__DeltaInfo);
		((ngwt__DeltaInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__DeltaInfo[n];
		if (size)
			*size = n * sizeof(ngwt__DeltaInfo);
		for (int i = 0; i < n; i++)
			((ngwt__DeltaInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__DeltaInfo*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__DeltaInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__DeltaInfo %p -> %p\n", q, p));
	*(ngwt__DeltaInfo*)p = *(ngwt__DeltaInfo*)q;
}

void ngwt__DelegateeStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->delivered);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->undeliverable, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->undeliverable);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->transferred, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->transferred);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->transferDelayed, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->transferDelayed);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->transferFailed, SOAP_TYPE_PointerTongwt__TransferFailedStatus);
	soap_serialize_PointerTongwt__TransferFailedStatus(soap, &((ngwt__RecipientStatus*)this)->transferFailed);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->downloaded, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->downloaded);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->downloadedByThirdParty, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->downloadedByThirdParty);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->retractRequested, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->retractRequested);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->retracted, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->retracted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->opened, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->opened);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->deleted, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->deleted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->undeleted, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->undeleted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->purged, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->purged);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->accepted, SOAP_TYPE_PointerTongwt__CommentStatus);
	soap_serialize_PointerTongwt__CommentStatus(soap, &((ngwt__RecipientStatus*)this)->accepted);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->declined, SOAP_TYPE_PointerTongwt__CommentStatus);
	soap_serialize_PointerTongwt__CommentStatus(soap, &((ngwt__RecipientStatus*)this)->declined);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->replied, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->replied);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->forwarded, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->forwarded);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->shared, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->shared);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->started, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->started);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->completed, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->completed);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->incomplete, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__RecipientStatus*)this)->incomplete);
	soap_embedded(soap, &((ngwt__RecipientStatus*)this)->delegated, SOAP_TYPE_PointerTongwt__DelegatedStatus);
	soap_serialize_PointerTongwt__DelegatedStatus(soap, &((ngwt__RecipientStatus*)this)->delegated);
	soap_serialize_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, &((ngwt__RecipientStatus*)this)->delegateeStatus);
	/* transient soap skipped */
}

void ngwt__DelegateeStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__DelegateeStatus*)this)->userid = NULL;
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->delivered);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->undeliverable);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->transferred);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->transferDelayed);
	((ngwt__RecipientStatus*)this)->transferFailed = NULL;
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->downloaded);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->downloadedByThirdParty);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->retractRequested);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->retracted);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->opened);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->deleted);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->undeleted);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->purged);
	((ngwt__RecipientStatus*)this)->accepted = NULL;
	((ngwt__RecipientStatus*)this)->declined = NULL;
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->replied);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->forwarded);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->shared);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->started);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->completed);
	soap_default_string(soap, &((ngwt__RecipientStatus*)this)->incomplete);
	((ngwt__RecipientStatus*)this)->delegated = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, &((ngwt__RecipientStatus*)this)->delegateeStatus);
	/* transient soap skipped */
}

int ngwt__DelegateeStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__DelegateeStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__DelegateeStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__DelegateeStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DelegateeStatus(struct soap *soap, const char *tag, int id, const ngwt__DelegateeStatus *a, const char *type)
{
	if (((ngwt__DelegateeStatus *)a)->userid)
		soap_set_attr(soap, "userid", ((ngwt__DelegateeStatus *)a)->userid->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__DelegateeStatus), "ngwt:DelegateeStatus");
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__RecipientStatus*)a)->delivered), "");
	soap_out_string(soap, "ngwt:undeliverable", -1, &(((ngwt__RecipientStatus*)a)->undeliverable), "");
	soap_out_string(soap, "ngwt:transferred", -1, &(((ngwt__RecipientStatus*)a)->transferred), "");
	soap_out_string(soap, "ngwt:transferDelayed", -1, &(((ngwt__RecipientStatus*)a)->transferDelayed), "");
	soap_out_PointerTongwt__TransferFailedStatus(soap, "ngwt:transferFailed", -1, &(((ngwt__RecipientStatus*)a)->transferFailed), "");
	soap_out_string(soap, "ngwt:downloaded", -1, &(((ngwt__RecipientStatus*)a)->downloaded), "");
	soap_out_string(soap, "ngwt:downloadedByThirdParty", -1, &(((ngwt__RecipientStatus*)a)->downloadedByThirdParty), "");
	soap_out_string(soap, "ngwt:retractRequested", -1, &(((ngwt__RecipientStatus*)a)->retractRequested), "");
	soap_out_string(soap, "ngwt:retracted", -1, &(((ngwt__RecipientStatus*)a)->retracted), "");
	soap_out_string(soap, "ngwt:opened", -1, &(((ngwt__RecipientStatus*)a)->opened), "");
	soap_out_string(soap, "ngwt:deleted", -1, &(((ngwt__RecipientStatus*)a)->deleted), "");
	soap_out_string(soap, "ngwt:undeleted", -1, &(((ngwt__RecipientStatus*)a)->undeleted), "");
	soap_out_string(soap, "ngwt:purged", -1, &(((ngwt__RecipientStatus*)a)->purged), "");
	soap_out_PointerTongwt__CommentStatus(soap, "ngwt:accepted", -1, &(((ngwt__RecipientStatus*)a)->accepted), "");
	soap_out_PointerTongwt__CommentStatus(soap, "ngwt:declined", -1, &(((ngwt__RecipientStatus*)a)->declined), "");
	soap_out_string(soap, "ngwt:replied", -1, &(((ngwt__RecipientStatus*)a)->replied), "");
	soap_out_string(soap, "ngwt:forwarded", -1, &(((ngwt__RecipientStatus*)a)->forwarded), "");
	soap_out_string(soap, "ngwt:shared", -1, &(((ngwt__RecipientStatus*)a)->shared), "");
	soap_out_string(soap, "ngwt:started", -1, &(((ngwt__RecipientStatus*)a)->started), "");
	soap_out_string(soap, "ngwt:completed", -1, &(((ngwt__RecipientStatus*)a)->completed), "");
	soap_out_string(soap, "ngwt:incomplete", -1, &(((ngwt__RecipientStatus*)a)->incomplete), "");
	soap_out_PointerTongwt__DelegatedStatus(soap, "ngwt:delegated", -1, &(((ngwt__RecipientStatus*)a)->delegated), "");
	soap_out_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, "ngwt:delegateeStatus", -1, &(((ngwt__RecipientStatus*)a)->delegateeStatus), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__DelegateeStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__DelegateeStatus(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__DelegateeStatus * SOAP_FMAC4 soap_get_ngwt__DelegateeStatus(struct soap *soap, ngwt__DelegateeStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DelegateeStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__DelegateeStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__DelegateeStatus(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__DelegateeStatus * SOAP_FMAC4 soap_in_ngwt__DelegateeStatus(struct soap *soap, const char *tag, ngwt__DelegateeStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__DelegateeStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DelegateeStatus, sizeof(ngwt__DelegateeStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__DelegateeStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__DelegateeStatus *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "userid", 0);
		if (t)
		{	if (!(((ngwt__DelegateeStatus *)a)->userid = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__DelegateeStatus *)a)->userid = soap_new_std__string(soap, -1);
			((ngwt__DelegateeStatus *)a)->userid->assign(s);
		}
		}
	}
	short soap_flag_delivered2 = 1, soap_flag_undeliverable2 = 1, soap_flag_transferred2 = 1, soap_flag_transferDelayed2 = 1, soap_flag_transferFailed2 = 1, soap_flag_downloaded2 = 1, soap_flag_downloadedByThirdParty2 = 1, soap_flag_retractRequested2 = 1, soap_flag_retracted2 = 1, soap_flag_opened2 = 1, soap_flag_deleted2 = 1, soap_flag_undeleted2 = 1, soap_flag_purged2 = 1, soap_flag_accepted2 = 1, soap_flag_declined2 = 1, soap_flag_replied2 = 1, soap_flag_forwarded2 = 1, soap_flag_shared2 = 1, soap_flag_started2 = 1, soap_flag_completed2 = 1, soap_flag_incomplete2 = 1, soap_flag_delegated2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_delivered2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__RecipientStatus*)a)->delivered), ""))
				{	soap_flag_delivered2 = 0;
					continue;
				}
			if (soap_flag_undeliverable2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:undeliverable", &(((ngwt__RecipientStatus*)a)->undeliverable), ""))
				{	soap_flag_undeliverable2 = 0;
					continue;
				}
			if (soap_flag_transferred2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:transferred", &(((ngwt__RecipientStatus*)a)->transferred), ""))
				{	soap_flag_transferred2 = 0;
					continue;
				}
			if (soap_flag_transferDelayed2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:transferDelayed", &(((ngwt__RecipientStatus*)a)->transferDelayed), ""))
				{	soap_flag_transferDelayed2 = 0;
					continue;
				}
			if (soap_flag_transferFailed2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__TransferFailedStatus(soap, "ngwt:transferFailed", &(((ngwt__RecipientStatus*)a)->transferFailed), "ngwt:TransferFailedStatus"))
				{	soap_flag_transferFailed2 = 0;
					continue;
				}
			if (soap_flag_downloaded2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:downloaded", &(((ngwt__RecipientStatus*)a)->downloaded), ""))
				{	soap_flag_downloaded2 = 0;
					continue;
				}
			if (soap_flag_downloadedByThirdParty2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:downloadedByThirdParty", &(((ngwt__RecipientStatus*)a)->downloadedByThirdParty), ""))
				{	soap_flag_downloadedByThirdParty2 = 0;
					continue;
				}
			if (soap_flag_retractRequested2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:retractRequested", &(((ngwt__RecipientStatus*)a)->retractRequested), ""))
				{	soap_flag_retractRequested2 = 0;
					continue;
				}
			if (soap_flag_retracted2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:retracted", &(((ngwt__RecipientStatus*)a)->retracted), ""))
				{	soap_flag_retracted2 = 0;
					continue;
				}
			if (soap_flag_opened2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:opened", &(((ngwt__RecipientStatus*)a)->opened), ""))
				{	soap_flag_opened2 = 0;
					continue;
				}
			if (soap_flag_deleted2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:deleted", &(((ngwt__RecipientStatus*)a)->deleted), ""))
				{	soap_flag_deleted2 = 0;
					continue;
				}
			if (soap_flag_undeleted2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:undeleted", &(((ngwt__RecipientStatus*)a)->undeleted), ""))
				{	soap_flag_undeleted2 = 0;
					continue;
				}
			if (soap_flag_purged2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:purged", &(((ngwt__RecipientStatus*)a)->purged), ""))
				{	soap_flag_purged2 = 0;
					continue;
				}
			if (soap_flag_accepted2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CommentStatus(soap, "ngwt:accepted", &(((ngwt__RecipientStatus*)a)->accepted), "ngwt:CommentStatus"))
				{	soap_flag_accepted2 = 0;
					continue;
				}
			if (soap_flag_declined2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CommentStatus(soap, "ngwt:declined", &(((ngwt__RecipientStatus*)a)->declined), "ngwt:CommentStatus"))
				{	soap_flag_declined2 = 0;
					continue;
				}
			if (soap_flag_replied2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:replied", &(((ngwt__RecipientStatus*)a)->replied), ""))
				{	soap_flag_replied2 = 0;
					continue;
				}
			if (soap_flag_forwarded2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:forwarded", &(((ngwt__RecipientStatus*)a)->forwarded), ""))
				{	soap_flag_forwarded2 = 0;
					continue;
				}
			if (soap_flag_shared2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:shared", &(((ngwt__RecipientStatus*)a)->shared), ""))
				{	soap_flag_shared2 = 0;
					continue;
				}
			if (soap_flag_started2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:started", &(((ngwt__RecipientStatus*)a)->started), ""))
				{	soap_flag_started2 = 0;
					continue;
				}
			if (soap_flag_completed2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:completed", &(((ngwt__RecipientStatus*)a)->completed), ""))
				{	soap_flag_completed2 = 0;
					continue;
				}
			if (soap_flag_incomplete2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:incomplete", &(((ngwt__RecipientStatus*)a)->incomplete), ""))
				{	soap_flag_incomplete2 = 0;
					continue;
				}
			if (soap_flag_delegated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DelegatedStatus(soap, "ngwt:delegated", &(((ngwt__RecipientStatus*)a)->delegated), "ngwt:DelegatedStatus"))
				{	soap_flag_delegated2 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, "ngwt:delegateeStatus", &(((ngwt__RecipientStatus*)a)->delegateeStatus), "ngwt:DelegateeStatus"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__DelegateeStatus *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DelegateeStatus, 0, sizeof(ngwt__DelegateeStatus), 0, soap_copy_ngwt__DelegateeStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__DelegateeStatus * SOAP_FMAC6 soap_new_ngwt__DelegateeStatus(struct soap *soap, int n)
{	return soap_instantiate_ngwt__DelegateeStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__DelegateeStatus(struct soap *soap, ngwt__DelegateeStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__DelegateeStatus * SOAP_FMAC6 soap_instantiate_ngwt__DelegateeStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__DelegateeStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__DelegateeStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__DelegateeStatus;
		if (size)
			*size = sizeof(ngwt__DelegateeStatus);
		((ngwt__DelegateeStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__DelegateeStatus[n];
		if (size)
			*size = n * sizeof(ngwt__DelegateeStatus);
		for (int i = 0; i < n; i++)
			((ngwt__DelegateeStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__DelegateeStatus*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__DelegateeStatus(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__DelegateeStatus %p -> %p\n", q, p));
	*(ngwt__DelegateeStatus*)p = *(ngwt__DelegateeStatus*)q;
}

void ngwt__DelegatedStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__DelegatedStatus*)this)->__item, SOAP_TYPE_PointerTongwt__CommentStatus);
	soap_serialize_PointerTongwt__CommentStatus(soap, &((ngwt__DelegatedStatus*)this)->__item);
	/* transient soap skipped */
}

void ngwt__DelegatedStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__DelegatedStatus*)this)->__item = NULL;
	((ngwt__DelegatedStatus*)this)->userid = NULL;
	/* transient soap skipped */
}

int ngwt__DelegatedStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__DelegatedStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__DelegatedStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__DelegatedStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DelegatedStatus(struct soap *soap, const char *tag, int id, const ngwt__DelegatedStatus *a, const char *type)
{
	if (((ngwt__DelegatedStatus *)a)->userid)
		soap_set_attr(soap, "userid", ((ngwt__DelegatedStatus *)a)->userid->c_str());
	soap_out_PointerTongwt__CommentStatus(soap, tag, id, &(((ngwt__DelegatedStatus*)a)->__item), "");
	return SOAP_OK;
}

void *ngwt__DelegatedStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__DelegatedStatus(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__DelegatedStatus * SOAP_FMAC4 soap_get_ngwt__DelegatedStatus(struct soap *soap, ngwt__DelegatedStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DelegatedStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__DelegatedStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__DelegatedStatus(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__DelegatedStatus * SOAP_FMAC4 soap_in_ngwt__DelegatedStatus(struct soap *soap, const char *tag, ngwt__DelegatedStatus *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ngwt__DelegatedStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DelegatedStatus, sizeof(ngwt__DelegatedStatus), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__DelegatedStatus)
			return (ngwt__DelegatedStatus *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "userid", 0);
		if (t)
		{	if (!(((ngwt__DelegatedStatus *)a)->userid = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__DelegatedStatus *)a)->userid = soap_new_std__string(soap, -1);
			((ngwt__DelegatedStatus *)a)->userid->assign(s);
		}
		}
	}
	if (!soap_in_PointerTongwt__CommentStatus(soap, tag, &(((ngwt__DelegatedStatus*)a)->__item), "ngwt:DelegatedStatus"))
		return NULL;
	return a;
}

SOAP_FMAC5 ngwt__DelegatedStatus * SOAP_FMAC6 soap_new_ngwt__DelegatedStatus(struct soap *soap, int n)
{	return soap_instantiate_ngwt__DelegatedStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__DelegatedStatus(struct soap *soap, ngwt__DelegatedStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__DelegatedStatus * SOAP_FMAC6 soap_instantiate_ngwt__DelegatedStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__DelegatedStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__DelegatedStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__DelegatedStatus;
		if (size)
			*size = sizeof(ngwt__DelegatedStatus);
		((ngwt__DelegatedStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__DelegatedStatus[n];
		if (size)
			*size = n * sizeof(ngwt__DelegatedStatus);
		for (int i = 0; i < n; i++)
			((ngwt__DelegatedStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__DelegatedStatus*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__DelegatedStatus(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__DelegatedStatus %p -> %p\n", q, p));
	*(ngwt__DelegatedStatus*)p = *(ngwt__DelegatedStatus*)q;
}

void ngwt__DayOfYearWeekList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(soap, &((ngwt__DayOfYearWeekList*)this)->day);
	/* transient soap skipped */
}

void ngwt__DayOfYearWeekList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(soap, &((ngwt__DayOfYearWeekList*)this)->day);
	/* transient soap skipped */
}

int ngwt__DayOfYearWeekList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__DayOfYearWeekList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__DayOfYearWeekList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__DayOfYearWeekList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DayOfYearWeekList(struct soap *soap, const char *tag, int id, const ngwt__DayOfYearWeekList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__DayOfYearWeekList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(soap, "ngwt:day", -1, &(((ngwt__DayOfYearWeekList*)a)->day), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__DayOfYearWeekList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__DayOfYearWeekList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__DayOfYearWeekList * SOAP_FMAC4 soap_get_ngwt__DayOfYearWeekList(struct soap *soap, ngwt__DayOfYearWeekList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DayOfYearWeekList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__DayOfYearWeekList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__DayOfYearWeekList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__DayOfYearWeekList * SOAP_FMAC4 soap_in_ngwt__DayOfYearWeekList(struct soap *soap, const char *tag, ngwt__DayOfYearWeekList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__DayOfYearWeekList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DayOfYearWeekList, sizeof(ngwt__DayOfYearWeekList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__DayOfYearWeekList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__DayOfYearWeekList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(soap, "ngwt:day", &(((ngwt__DayOfYearWeekList*)a)->day), "ngwt:DayOfYearWeek"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__DayOfYearWeekList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DayOfYearWeekList, 0, sizeof(ngwt__DayOfYearWeekList), 0, soap_copy_ngwt__DayOfYearWeekList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__DayOfYearWeekList * SOAP_FMAC6 soap_new_ngwt__DayOfYearWeekList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__DayOfYearWeekList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__DayOfYearWeekList(struct soap *soap, ngwt__DayOfYearWeekList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__DayOfYearWeekList * SOAP_FMAC6 soap_instantiate_ngwt__DayOfYearWeekList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__DayOfYearWeekList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__DayOfYearWeekList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__DayOfYearWeekList;
		if (size)
			*size = sizeof(ngwt__DayOfYearWeekList);
		((ngwt__DayOfYearWeekList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__DayOfYearWeekList[n];
		if (size)
			*size = n * sizeof(ngwt__DayOfYearWeekList);
		for (int i = 0; i < n; i++)
			((ngwt__DayOfYearWeekList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__DayOfYearWeekList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__DayOfYearWeekList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__DayOfYearWeekList %p -> %p\n", q, p));
	*(ngwt__DayOfYearWeekList*)p = *(ngwt__DayOfYearWeekList*)q;
}

void ngwt__DayOfYearWeek::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__DayOfYearWeek*)this)->__item, SOAP_TYPE_ngwt__WeekDay);
	/* transient soap skipped */
}

void ngwt__DayOfYearWeek::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__WeekDay(soap, &((ngwt__DayOfYearWeek*)this)->__item);
	((ngwt__DayOfYearWeek*)this)->occurrence = NULL;
	/* transient soap skipped */
}

int ngwt__DayOfYearWeek::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__DayOfYearWeek);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__DayOfYearWeek::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__DayOfYearWeek(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DayOfYearWeek(struct soap *soap, const char *tag, int id, const ngwt__DayOfYearWeek *a, const char *type)
{
	if (((ngwt__DayOfYearWeek *)a)->occurrence)
		soap_set_attr(soap, "occurrence", soap_short2s(soap, *((ngwt__DayOfYearWeek *)a)->occurrence));
	soap_out_ngwt__WeekDay(soap, tag, id, &(((ngwt__DayOfYearWeek*)a)->__item), "");
	return SOAP_OK;
}

void *ngwt__DayOfYearWeek::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__DayOfYearWeek(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__DayOfYearWeek * SOAP_FMAC4 soap_get_ngwt__DayOfYearWeek(struct soap *soap, ngwt__DayOfYearWeek *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DayOfYearWeek(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__DayOfYearWeek::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__DayOfYearWeek(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__DayOfYearWeek * SOAP_FMAC4 soap_in_ngwt__DayOfYearWeek(struct soap *soap, const char *tag, ngwt__DayOfYearWeek *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ngwt__DayOfYearWeek *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DayOfYearWeek, sizeof(ngwt__DayOfYearWeek), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__DayOfYearWeek)
			return (ngwt__DayOfYearWeek *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "occurrence", 0);
		if (t)
		{	if (!(((ngwt__DayOfYearWeek *)a)->occurrence = (short *)soap_malloc(soap, sizeof(short))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2short(soap, t, ((ngwt__DayOfYearWeek *)a)->occurrence))
		return NULL;
		}
	}
	if (!soap_in_ngwt__WeekDay(soap, tag, &(((ngwt__DayOfYearWeek*)a)->__item), "ngwt:DayOfYearWeek"))
		return NULL;
	return a;
}

SOAP_FMAC5 ngwt__DayOfYearWeek * SOAP_FMAC6 soap_new_ngwt__DayOfYearWeek(struct soap *soap, int n)
{	return soap_instantiate_ngwt__DayOfYearWeek(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__DayOfYearWeek(struct soap *soap, ngwt__DayOfYearWeek *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__DayOfYearWeek * SOAP_FMAC6 soap_instantiate_ngwt__DayOfYearWeek(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__DayOfYearWeek(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__DayOfYearWeek, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__DayOfYearWeek;
		if (size)
			*size = sizeof(ngwt__DayOfYearWeek);
		((ngwt__DayOfYearWeek*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__DayOfYearWeek[n];
		if (size)
			*size = n * sizeof(ngwt__DayOfYearWeek);
		for (int i = 0; i < n; i++)
			((ngwt__DayOfYearWeek*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__DayOfYearWeek*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__DayOfYearWeek(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__DayOfYearWeek %p -> %p\n", q, p));
	*(ngwt__DayOfYearWeek*)p = *(ngwt__DayOfYearWeek*)q;
}

void ngwt__DayOfYearList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfngwt__DayOfYear(soap, &((ngwt__DayOfYearList*)this)->day);
	/* transient soap skipped */
}

void ngwt__DayOfYearList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfngwt__DayOfYear(soap, &((ngwt__DayOfYearList*)this)->day);
	/* transient soap skipped */
}

int ngwt__DayOfYearList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__DayOfYearList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__DayOfYearList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__DayOfYearList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DayOfYearList(struct soap *soap, const char *tag, int id, const ngwt__DayOfYearList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__DayOfYearList), type);
	soap_out_std__vectorTemplateOfngwt__DayOfYear(soap, "ngwt:day", -1, &(((ngwt__DayOfYearList*)a)->day), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__DayOfYearList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__DayOfYearList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__DayOfYearList * SOAP_FMAC4 soap_get_ngwt__DayOfYearList(struct soap *soap, ngwt__DayOfYearList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DayOfYearList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__DayOfYearList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__DayOfYearList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__DayOfYearList * SOAP_FMAC4 soap_in_ngwt__DayOfYearList(struct soap *soap, const char *tag, ngwt__DayOfYearList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__DayOfYearList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DayOfYearList, sizeof(ngwt__DayOfYearList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__DayOfYearList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__DayOfYearList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__DayOfYear(soap, "ngwt:day", &(((ngwt__DayOfYearList*)a)->day), "ngwt:DayOfYear"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__DayOfYearList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DayOfYearList, 0, sizeof(ngwt__DayOfYearList), 0, soap_copy_ngwt__DayOfYearList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__DayOfYearList * SOAP_FMAC6 soap_new_ngwt__DayOfYearList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__DayOfYearList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__DayOfYearList(struct soap *soap, ngwt__DayOfYearList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__DayOfYearList * SOAP_FMAC6 soap_instantiate_ngwt__DayOfYearList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__DayOfYearList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__DayOfYearList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__DayOfYearList;
		if (size)
			*size = sizeof(ngwt__DayOfYearList);
		((ngwt__DayOfYearList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__DayOfYearList[n];
		if (size)
			*size = n * sizeof(ngwt__DayOfYearList);
		for (int i = 0; i < n; i++)
			((ngwt__DayOfYearList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__DayOfYearList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__DayOfYearList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__DayOfYearList %p -> %p\n", q, p));
	*(ngwt__DayOfYearList*)p = *(ngwt__DayOfYearList*)q;
}

void ngwt__DayOfWeek::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__DayOfWeek*)this)->__item, SOAP_TYPE_ngwt__WeekDay);
	/* transient soap skipped */
}

void ngwt__DayOfWeek::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__WeekDay(soap, &((ngwt__DayOfWeek*)this)->__item);
	((ngwt__DayOfWeek*)this)->occurrence = NULL;
	/* transient soap skipped */
}

int ngwt__DayOfWeek::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__DayOfWeek);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__DayOfWeek::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__DayOfWeek(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DayOfWeek(struct soap *soap, const char *tag, int id, const ngwt__DayOfWeek *a, const char *type)
{
	if (((ngwt__DayOfWeek *)a)->occurrence)
		soap_set_attr(soap, "occurrence", soap_ngwt__OccurrenceType2s(soap, *((ngwt__DayOfWeek *)a)->occurrence));
	soap_out_ngwt__WeekDay(soap, tag, id, &(((ngwt__DayOfWeek*)a)->__item), "");
	return SOAP_OK;
}

void *ngwt__DayOfWeek::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__DayOfWeek(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__DayOfWeek * SOAP_FMAC4 soap_get_ngwt__DayOfWeek(struct soap *soap, ngwt__DayOfWeek *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DayOfWeek(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__DayOfWeek::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__DayOfWeek(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__DayOfWeek * SOAP_FMAC4 soap_in_ngwt__DayOfWeek(struct soap *soap, const char *tag, ngwt__DayOfWeek *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ngwt__DayOfWeek *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DayOfWeek, sizeof(ngwt__DayOfWeek), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__DayOfWeek)
			return (ngwt__DayOfWeek *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "occurrence", 0);
		if (t)
		{	if (!(((ngwt__DayOfWeek *)a)->occurrence = (enum ngwt__OccurrenceType *)soap_malloc(soap, sizeof(enum ngwt__OccurrenceType))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2ngwt__OccurrenceType(soap, t, ((ngwt__DayOfWeek *)a)->occurrence))
		return NULL;
		}
	}
	if (!soap_in_ngwt__WeekDay(soap, tag, &(((ngwt__DayOfWeek*)a)->__item), "ngwt:DayOfWeek"))
		return NULL;
	return a;
}

SOAP_FMAC5 ngwt__DayOfWeek * SOAP_FMAC6 soap_new_ngwt__DayOfWeek(struct soap *soap, int n)
{	return soap_instantiate_ngwt__DayOfWeek(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__DayOfWeek(struct soap *soap, ngwt__DayOfWeek *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__DayOfWeek * SOAP_FMAC6 soap_instantiate_ngwt__DayOfWeek(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__DayOfWeek(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__DayOfWeek, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__DayOfWeek;
		if (size)
			*size = sizeof(ngwt__DayOfWeek);
		((ngwt__DayOfWeek*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__DayOfWeek[n];
		if (size)
			*size = n * sizeof(ngwt__DayOfWeek);
		for (int i = 0; i < n; i++)
			((ngwt__DayOfWeek*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__DayOfWeek*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__DayOfWeek(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__DayOfWeek %p -> %p\n", q, p));
	*(ngwt__DayOfWeek*)p = *(ngwt__DayOfWeek*)q;
}

void ngwt__DayOfMonthList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfngwt__DayOfMonth(soap, &((ngwt__DayOfMonthList*)this)->day);
	/* transient soap skipped */
}

void ngwt__DayOfMonthList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfngwt__DayOfMonth(soap, &((ngwt__DayOfMonthList*)this)->day);
	/* transient soap skipped */
}

int ngwt__DayOfMonthList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__DayOfMonthList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__DayOfMonthList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__DayOfMonthList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__DayOfMonthList(struct soap *soap, const char *tag, int id, const ngwt__DayOfMonthList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__DayOfMonthList), type);
	soap_out_std__vectorTemplateOfngwt__DayOfMonth(soap, "ngwt:day", -1, &(((ngwt__DayOfMonthList*)a)->day), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__DayOfMonthList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__DayOfMonthList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__DayOfMonthList * SOAP_FMAC4 soap_get_ngwt__DayOfMonthList(struct soap *soap, ngwt__DayOfMonthList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__DayOfMonthList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__DayOfMonthList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__DayOfMonthList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__DayOfMonthList * SOAP_FMAC4 soap_in_ngwt__DayOfMonthList(struct soap *soap, const char *tag, ngwt__DayOfMonthList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__DayOfMonthList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__DayOfMonthList, sizeof(ngwt__DayOfMonthList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__DayOfMonthList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__DayOfMonthList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__DayOfMonth(soap, "ngwt:day", &(((ngwt__DayOfMonthList*)a)->day), "ngwt:DayOfMonth"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__DayOfMonthList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DayOfMonthList, 0, sizeof(ngwt__DayOfMonthList), 0, soap_copy_ngwt__DayOfMonthList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__DayOfMonthList * SOAP_FMAC6 soap_new_ngwt__DayOfMonthList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__DayOfMonthList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__DayOfMonthList(struct soap *soap, ngwt__DayOfMonthList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__DayOfMonthList * SOAP_FMAC6 soap_instantiate_ngwt__DayOfMonthList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__DayOfMonthList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__DayOfMonthList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__DayOfMonthList;
		if (size)
			*size = sizeof(ngwt__DayOfMonthList);
		((ngwt__DayOfMonthList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__DayOfMonthList[n];
		if (size)
			*size = n * sizeof(ngwt__DayOfMonthList);
		for (int i = 0; i < n; i++)
			((ngwt__DayOfMonthList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__DayOfMonthList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__DayOfMonthList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__DayOfMonthList %p -> %p\n", q, p));
	*(ngwt__DayOfMonthList*)p = *(ngwt__DayOfMonthList*)q;
}

void ngwt__CustomList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Custom(soap, &((ngwt__CustomList*)this)->custom);
	/* transient soap skipped */
}

void ngwt__CustomList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Custom(soap, &((ngwt__CustomList*)this)->custom);
	/* transient soap skipped */
}

int ngwt__CustomList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__CustomList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__CustomList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__CustomList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__CustomList(struct soap *soap, const char *tag, int id, const ngwt__CustomList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__CustomList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Custom(soap, "ngwt:custom", -1, &(((ngwt__CustomList*)a)->custom), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__CustomList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__CustomList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__CustomList * SOAP_FMAC4 soap_get_ngwt__CustomList(struct soap *soap, ngwt__CustomList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__CustomList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__CustomList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__CustomList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__CustomList * SOAP_FMAC4 soap_in_ngwt__CustomList(struct soap *soap, const char *tag, ngwt__CustomList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__CustomList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__CustomList, sizeof(ngwt__CustomList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__CustomList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__CustomList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Custom(soap, "ngwt:custom", &(((ngwt__CustomList*)a)->custom), "ngwt:Custom"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__CustomList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CustomList, 0, sizeof(ngwt__CustomList), 0, soap_copy_ngwt__CustomList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__CustomList * SOAP_FMAC6 soap_new_ngwt__CustomList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__CustomList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__CustomList(struct soap *soap, ngwt__CustomList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__CustomList * SOAP_FMAC6 soap_instantiate_ngwt__CustomList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__CustomList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__CustomList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__CustomList;
		if (size)
			*size = sizeof(ngwt__CustomList);
		((ngwt__CustomList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__CustomList[n];
		if (size)
			*size = n * sizeof(ngwt__CustomList);
		for (int i = 0; i < n; i++)
			((ngwt__CustomList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__CustomList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__CustomList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__CustomList %p -> %p\n", q, p));
	*(ngwt__CustomList*)p = *(ngwt__CustomList*)q;
}

void ngwt__Custom::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Custom*)this)->field, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__Custom*)this)->field);
	soap_embedded(soap, &((ngwt__Custom*)this)->value, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Custom*)this)->value);
	soap_embedded(soap, &((ngwt__Custom*)this)->locked, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Custom*)this)->locked);
	/* transient soap skipped */
}

void ngwt__Custom::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwt__Custom*)this)->field);
	((ngwt__Custom*)this)->value = NULL;
	((ngwt__Custom*)this)->locked = NULL;
	((ngwt__Custom*)this)->type = NULL;
	/* transient soap skipped */
}

int ngwt__Custom::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Custom);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Custom::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Custom(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Custom(struct soap *soap, const char *tag, int id, const ngwt__Custom *a, const char *type)
{
	if (((ngwt__Custom *)a)->type)
		soap_set_attr(soap, "type", soap_ngwt__CustomType2s(soap, *((ngwt__Custom *)a)->type));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Custom), type);
	soap_out_std__string(soap, "ngwt:field", -1, &(((ngwt__Custom*)a)->field), "");
	soap_out_PointerTostd__string(soap, "ngwt:value", -1, &(((ngwt__Custom*)a)->value), "");
	soap_out_PointerTobool(soap, "ngwt:locked", -1, &(((ngwt__Custom*)a)->locked), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Custom::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Custom(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Custom * SOAP_FMAC4 soap_get_ngwt__Custom(struct soap *soap, ngwt__Custom *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Custom(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Custom::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Custom(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Custom * SOAP_FMAC4 soap_in_ngwt__Custom(struct soap *soap, const char *tag, ngwt__Custom *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Custom *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Custom, sizeof(ngwt__Custom), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Custom)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Custom *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "type", 0);
		if (t)
		{	if (!(((ngwt__Custom *)a)->type = (enum ngwt__CustomType *)soap_malloc(soap, sizeof(enum ngwt__CustomType))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2ngwt__CustomType(soap, t, ((ngwt__Custom *)a)->type))
		return NULL;
		}
	}
	short soap_flag_field1 = 1, soap_flag_value1 = 1, soap_flag_locked1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_field1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:field", &(((ngwt__Custom*)a)->field), ""))
				{	soap_flag_field1 = 0;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:value", &(((ngwt__Custom*)a)->value), ""))
				{	soap_flag_value1 = 0;
					continue;
				}
			if (soap_flag_locked1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:locked", &(((ngwt__Custom*)a)->locked), ""))
				{	soap_flag_locked1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_field1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Custom *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Custom, 0, sizeof(ngwt__Custom), 0, soap_copy_ngwt__Custom);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Custom * SOAP_FMAC6 soap_new_ngwt__Custom(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Custom(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Custom(struct soap *soap, ngwt__Custom *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Custom * SOAP_FMAC6 soap_instantiate_ngwt__Custom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Custom(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Custom, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Custom;
		if (size)
			*size = sizeof(ngwt__Custom);
		((ngwt__Custom*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Custom[n];
		if (size)
			*size = n * sizeof(ngwt__Custom);
		for (int i = 0; i < n; i++)
			((ngwt__Custom*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Custom*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Custom(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Custom %p -> %p\n", q, p));
	*(ngwt__Custom*)p = *(ngwt__Custom*)q;
}

void ngwt__ContainerRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ContainerRef*)this)->__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ngwt__ContainerRef*)this)->__item);
	/* transient soap skipped */
}

void ngwt__ContainerRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ngwt__ContainerRef*)this)->__item);
	soap_default_string(soap, &((ngwt__ContainerRef*)this)->deleted);
	/* transient soap skipped */
}

int ngwt__ContainerRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ContainerRef);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ContainerRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ContainerRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ContainerRef(struct soap *soap, const char *tag, int id, const ngwt__ContainerRef *a, const char *type)
{
	if (((ngwt__ContainerRef *)a)->deleted)
		soap_set_attr(soap, "deleted", ((ngwt__ContainerRef *)a)->deleted);
	soap_out_std__string(soap, tag, id, &(((ngwt__ContainerRef*)a)->__item), "");
	return SOAP_OK;
}

void *ngwt__ContainerRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ContainerRef(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ContainerRef * SOAP_FMAC4 soap_get_ngwt__ContainerRef(struct soap *soap, ngwt__ContainerRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ContainerRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ContainerRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ContainerRef(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ContainerRef * SOAP_FMAC4 soap_in_ngwt__ContainerRef(struct soap *soap, const char *tag, ngwt__ContainerRef *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ngwt__ContainerRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ContainerRef, sizeof(ngwt__ContainerRef), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ContainerRef)
			return (ngwt__ContainerRef *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "deleted", 0), &((ngwt__ContainerRef *)a)->deleted))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(((ngwt__ContainerRef*)a)->__item), "ngwt:ContainerRef"))
		return NULL;
	return a;
}

SOAP_FMAC5 ngwt__ContainerRef * SOAP_FMAC6 soap_new_ngwt__ContainerRef(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ContainerRef(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ContainerRef(struct soap *soap, ngwt__ContainerRef *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ContainerRef * SOAP_FMAC6 soap_instantiate_ngwt__ContainerRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ContainerRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ContainerRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ContainerRef;
		if (size)
			*size = sizeof(ngwt__ContainerRef);
		((ngwt__ContainerRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ContainerRef[n];
		if (size)
			*size = n * sizeof(ngwt__ContainerRef);
		for (int i = 0; i < n; i++)
			((ngwt__ContainerRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ContainerRef*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ContainerRef(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ContainerRef %p -> %p\n", q, p));
	*(ngwt__ContainerRef*)p = *(ngwt__ContainerRef*)q;
}

void ngwt__ContainerItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__ContainerItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__ContainerItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ContainerItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ContainerItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ContainerItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ContainerItem(struct soap *soap, const char *tag, int id, const ngwt__ContainerItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ContainerItem), "ngwt:ContainerItem");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ContainerItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ContainerItem(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ContainerItem * SOAP_FMAC4 soap_get_ngwt__ContainerItem(struct soap *soap, ngwt__ContainerItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ContainerItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ContainerItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ContainerItem(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ContainerItem * SOAP_FMAC4 soap_in_ngwt__ContainerItem(struct soap *soap, const char *tag, ngwt__ContainerItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ContainerItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ContainerItem, sizeof(ngwt__ContainerItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ContainerItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ContainerItem *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id2 = 1, soap_flag_name2 = 1, soap_flag_version2 = 1, soap_flag_modified2 = 1, soap_flag_changes2 = 1, soap_flag_categories1 = 1, soap_flag_created1 = 1, soap_flag_customs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id2 = 0;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name2 = 0;
					continue;
				}
			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version2 = 0;
					continue;
				}
			if (soap_flag_modified2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified2 = 0;
					continue;
				}
			if (soap_flag_changes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories1 = 0;
					continue;
				}
			if (soap_flag_created1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created1 = 0;
					continue;
				}
			if (soap_flag_customs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ContainerItem *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ContainerItem, 0, sizeof(ngwt__ContainerItem), 0, soap_copy_ngwt__ContainerItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ContainerItem * SOAP_FMAC6 soap_new_ngwt__ContainerItem(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ContainerItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ContainerItem(struct soap *soap, ngwt__ContainerItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ContainerItem * SOAP_FMAC6 soap_instantiate_ngwt__ContainerItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ContainerItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ContainerItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:AddressBookItem"))
	{	cp->type = SOAP_TYPE_ngwt__AddressBookItem;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__AddressBookItem;
			if (size)
				*size = sizeof(ngwt__AddressBookItem);
			((ngwt__AddressBookItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__AddressBookItem[n];
			if (size)
				*size = n * sizeof(ngwt__AddressBookItem);
			for (int i = 0; i < n; i++)
				((ngwt__AddressBookItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__AddressBookItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:BoxEntry"))
	{	cp->type = SOAP_TYPE_ngwt__BoxEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__BoxEntry;
			if (size)
				*size = sizeof(ngwt__BoxEntry);
			((ngwt__BoxEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__BoxEntry[n];
			if (size)
				*size = n * sizeof(ngwt__BoxEntry);
			for (int i = 0; i < n; i++)
				((ngwt__BoxEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__BoxEntry*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Document"))
	{	cp->type = SOAP_TYPE_ngwt__Document;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Document;
			if (size)
				*size = sizeof(ngwt__Document);
			((ngwt__Document*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Document[n];
			if (size)
				*size = n * sizeof(ngwt__Document);
			for (int i = 0; i < n; i++)
				((ngwt__Document*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Document*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Rule"))
	{	cp->type = SOAP_TYPE_ngwt__Rule;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Rule;
			if (size)
				*size = sizeof(ngwt__Rule);
			((ngwt__Rule*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Rule[n];
			if (size)
				*size = n * sizeof(ngwt__Rule);
			for (int i = 0; i < n; i++)
				((ngwt__Rule*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Rule*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Version"))
	{	cp->type = SOAP_TYPE_ngwt__Version;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Version;
			if (size)
				*size = sizeof(ngwt__Version);
			((ngwt__Version*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Version[n];
			if (size)
				*size = n * sizeof(ngwt__Version);
			for (int i = 0; i < n; i++)
				((ngwt__Version*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Version*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:VersionEvent"))
	{	cp->type = SOAP_TYPE_ngwt__VersionEvent;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__VersionEvent;
			if (size)
				*size = sizeof(ngwt__VersionEvent);
			((ngwt__VersionEvent*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__VersionEvent[n];
			if (size)
				*size = n * sizeof(ngwt__VersionEvent);
			for (int i = 0; i < n; i++)
				((ngwt__VersionEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__VersionEvent*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Contact"))
	{	cp->type = SOAP_TYPE_ngwt__Contact;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Contact;
			if (size)
				*size = sizeof(ngwt__Contact);
			((ngwt__Contact*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Contact[n];
			if (size)
				*size = n * sizeof(ngwt__Contact);
			for (int i = 0; i < n; i++)
				((ngwt__Contact*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Contact*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Group"))
	{	cp->type = SOAP_TYPE_ngwt__Group;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Group;
			if (size)
				*size = sizeof(ngwt__Group);
			((ngwt__Group*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Group[n];
			if (size)
				*size = n * sizeof(ngwt__Group);
			for (int i = 0; i < n; i++)
				((ngwt__Group*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Group*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Mail"))
	{	cp->type = SOAP_TYPE_ngwt__Mail;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Mail;
			if (size)
				*size = sizeof(ngwt__Mail);
			((ngwt__Mail*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Mail[n];
			if (size)
				*size = n * sizeof(ngwt__Mail);
			for (int i = 0; i < n; i++)
				((ngwt__Mail*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Mail*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Organization"))
	{	cp->type = SOAP_TYPE_ngwt__Organization;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Organization;
			if (size)
				*size = sizeof(ngwt__Organization);
			((ngwt__Organization*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Organization[n];
			if (size)
				*size = n * sizeof(ngwt__Organization);
			for (int i = 0; i < n; i++)
				((ngwt__Organization*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Organization*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Resource"))
	{	cp->type = SOAP_TYPE_ngwt__Resource;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Resource;
			if (size)
				*size = sizeof(ngwt__Resource);
			((ngwt__Resource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Resource[n];
			if (size)
				*size = n * sizeof(ngwt__Resource);
			for (int i = 0; i < n; i++)
				((ngwt__Resource*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Resource*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:CalendarItem"))
	{	cp->type = SOAP_TYPE_ngwt__CalendarItem;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__CalendarItem;
			if (size)
				*size = sizeof(ngwt__CalendarItem);
			((ngwt__CalendarItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__CalendarItem[n];
			if (size)
				*size = n * sizeof(ngwt__CalendarItem);
			for (int i = 0; i < n; i++)
				((ngwt__CalendarItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__CalendarItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:DocumentRef"))
	{	cp->type = SOAP_TYPE_ngwt__DocumentRef;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__DocumentRef;
			if (size)
				*size = sizeof(ngwt__DocumentRef);
			((ngwt__DocumentRef*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__DocumentRef[n];
			if (size)
				*size = n * sizeof(ngwt__DocumentRef);
			for (int i = 0; i < n; i++)
				((ngwt__DocumentRef*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__DocumentRef*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:PhoneMessage"))
	{	cp->type = SOAP_TYPE_ngwt__PhoneMessage;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__PhoneMessage;
			if (size)
				*size = sizeof(ngwt__PhoneMessage);
			((ngwt__PhoneMessage*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__PhoneMessage[n];
			if (size)
				*size = n * sizeof(ngwt__PhoneMessage);
			for (int i = 0; i < n; i++)
				((ngwt__PhoneMessage*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__PhoneMessage*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:SharedNotification"))
	{	cp->type = SOAP_TYPE_ngwt__SharedNotification;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__SharedNotification;
			if (size)
				*size = sizeof(ngwt__SharedNotification);
			((ngwt__SharedNotification*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__SharedNotification[n];
			if (size)
				*size = n * sizeof(ngwt__SharedNotification);
			for (int i = 0; i < n; i++)
				((ngwt__SharedNotification*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__SharedNotification*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Appointment"))
	{	cp->type = SOAP_TYPE_ngwt__Appointment;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Appointment;
			if (size)
				*size = sizeof(ngwt__Appointment);
			((ngwt__Appointment*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Appointment[n];
			if (size)
				*size = n * sizeof(ngwt__Appointment);
			for (int i = 0; i < n; i++)
				((ngwt__Appointment*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Appointment*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Note"))
	{	cp->type = SOAP_TYPE_ngwt__Note;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Note;
			if (size)
				*size = sizeof(ngwt__Note);
			((ngwt__Note*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Note[n];
			if (size)
				*size = n * sizeof(ngwt__Note);
			for (int i = 0; i < n; i++)
				((ngwt__Note*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Note*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Task"))
	{	cp->type = SOAP_TYPE_ngwt__Task;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Task;
			if (size)
				*size = sizeof(ngwt__Task);
			((ngwt__Task*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Task[n];
			if (size)
				*size = n * sizeof(ngwt__Task);
			for (int i = 0; i < n; i++)
				((ngwt__Task*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Task*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ContainerItem;
		if (size)
			*size = sizeof(ngwt__ContainerItem);
		((ngwt__ContainerItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ContainerItem[n];
		if (size)
			*size = n * sizeof(ngwt__ContainerItem);
		for (int i = 0; i < n; i++)
			((ngwt__ContainerItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ContainerItem*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ContainerItem(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ContainerItem %p -> %p\n", q, p));
	*(ngwt__ContainerItem*)p = *(ngwt__ContainerItem*)q;
}

void ngwt__ContactFolder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__ContactFolder*)this)->addressBook, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__ContactFolder*)this)->addressBook);
	soap_embedded(soap, &((ngwt__SystemFolder*)this)->isSystemFolder, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__SystemFolder*)this)->isSystemFolder);
	soap_embedded(soap, &((ngwt__SystemFolder*)this)->folderType, SOAP_TYPE_PointerTongwt__FolderType);
	soap_serialize_PointerTongwt__FolderType(soap, &((ngwt__SystemFolder*)this)->folderType);
	soap_embedded(soap, &((ngwt__SystemFolder*)this)->acl, SOAP_TYPE_PointerTongwt__FolderACL);
	soap_serialize_PointerTongwt__FolderACL(soap, &((ngwt__SystemFolder*)this)->acl);
	soap_embedded(soap, &((ngwt__SystemFolder*)this)->isSharedByMe, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__SystemFolder*)this)->isSharedByMe);
	soap_embedded(soap, &((ngwt__Folder*)this)->parent, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((ngwt__Folder*)this)->parent);
	soap_embedded(soap, &((ngwt__Folder*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Folder*)this)->description);
	soap_embedded(soap, &((ngwt__Folder*)this)->count, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__Folder*)this)->count);
	soap_embedded(soap, &((ngwt__Folder*)this)->hasUnread, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Folder*)this)->hasUnread);
	soap_embedded(soap, &((ngwt__Folder*)this)->unreadCount, SOAP_TYPE_PointerToint);
	soap_serialize_PointerToint(soap, &((ngwt__Folder*)this)->unreadCount);
	soap_embedded(soap, &((ngwt__Folder*)this)->sequence, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Folder*)this)->sequence);
	soap_embedded(soap, &((ngwt__Folder*)this)->settings, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Folder*)this)->settings);
	soap_embedded(soap, &((ngwt__Folder*)this)->calendarAttribute, SOAP_TYPE_PointerTongwt__CalendarFolderAttribute);
	soap_serialize_PointerTongwt__CalendarFolderAttribute(soap, &((ngwt__Folder*)this)->calendarAttribute);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__ContactFolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__ContactFolder*)this)->addressBook = NULL;
	((ngwt__SystemFolder*)this)->isSystemFolder = NULL;
	((ngwt__SystemFolder*)this)->folderType = NULL;
	((ngwt__SystemFolder*)this)->acl = NULL;
	((ngwt__SystemFolder*)this)->isSharedByMe = NULL;
	soap_default_ngwt__uid(soap, &((ngwt__Folder*)this)->parent);
	((ngwt__Folder*)this)->description = NULL;
	((ngwt__Folder*)this)->count = NULL;
	((ngwt__Folder*)this)->hasUnread = NULL;
	((ngwt__Folder*)this)->unreadCount = NULL;
	((ngwt__Folder*)this)->sequence = NULL;
	((ngwt__Folder*)this)->settings = NULL;
	((ngwt__Folder*)this)->calendarAttribute = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__ContactFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__ContactFolder);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__ContactFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__ContactFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__ContactFolder(struct soap *soap, const char *tag, int id, const ngwt__ContactFolder *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__ContactFolder), "ngwt:ContactFolder");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_ngwt__uid(soap, "ngwt:parent", -1, &(((ngwt__Folder*)a)->parent), "");
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__Folder*)a)->description), "");
	soap_out_PointerToint(soap, "ngwt:count", -1, &(((ngwt__Folder*)a)->count), "");
	soap_out_PointerTobool(soap, "ngwt:hasUnread", -1, &(((ngwt__Folder*)a)->hasUnread), "");
	soap_out_PointerToint(soap, "ngwt:unreadCount", -1, &(((ngwt__Folder*)a)->unreadCount), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:sequence", -1, &(((ngwt__Folder*)a)->sequence), "");
	soap_out_PointerTongwt__uid(soap, "ngwt:settings", -1, &(((ngwt__Folder*)a)->settings), "");
	soap_out_PointerTongwt__CalendarFolderAttribute(soap, "ngwt:calendarAttribute", -1, &(((ngwt__Folder*)a)->calendarAttribute), "");
	soap_out_PointerTobool(soap, "ngwt:isSystemFolder", -1, &(((ngwt__SystemFolder*)a)->isSystemFolder), "");
	soap_out_PointerTongwt__FolderType(soap, "ngwt:folderType", -1, &(((ngwt__SystemFolder*)a)->folderType), "");
	soap_out_PointerTongwt__FolderACL(soap, "ngwt:acl", -1, &(((ngwt__SystemFolder*)a)->acl), "");
	soap_out_PointerTobool(soap, "ngwt:isSharedByMe", -1, &(((ngwt__SystemFolder*)a)->isSharedByMe), "");
	soap_out_PointerTongwt__uid(soap, "ngwt:addressBook", -1, &(((ngwt__ContactFolder*)a)->addressBook), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__ContactFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__ContactFolder(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__ContactFolder * SOAP_FMAC4 soap_get_ngwt__ContactFolder(struct soap *soap, ngwt__ContactFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__ContactFolder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__ContactFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__ContactFolder(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__ContactFolder * SOAP_FMAC4 soap_in_ngwt__ContactFolder(struct soap *soap, const char *tag, ngwt__ContactFolder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__ContactFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__ContactFolder, sizeof(ngwt__ContactFolder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__ContactFolder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__ContactFolder *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_parent3 = 1, soap_flag_description3 = 1, soap_flag_count3 = 1, soap_flag_hasUnread3 = 1, soap_flag_unreadCount3 = 1, soap_flag_sequence3 = 1, soap_flag_settings3 = 1, soap_flag_calendarAttribute3 = 1, soap_flag_isSystemFolder2 = 1, soap_flag_folderType2 = 1, soap_flag_acl2 = 1, soap_flag_isSharedByMe2 = 1, soap_flag_addressBook1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}
			if (soap_flag_name4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name4 = 0;
					continue;
				}
			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}
			if (soap_flag_modified4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}
			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_parent3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ngwt__uid(soap, "ngwt:parent", &(((ngwt__Folder*)a)->parent), "ngwt:uid"))
				{	soap_flag_parent3 = 0;
					continue;
				}
			if (soap_flag_description3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__Folder*)a)->description), ""))
				{	soap_flag_description3 = 0;
					continue;
				}
			if (soap_flag_count3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:count", &(((ngwt__Folder*)a)->count), ""))
				{	soap_flag_count3 = 0;
					continue;
				}
			if (soap_flag_hasUnread3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:hasUnread", &(((ngwt__Folder*)a)->hasUnread), ""))
				{	soap_flag_hasUnread3 = 0;
					continue;
				}
			if (soap_flag_unreadCount3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ngwt:unreadCount", &(((ngwt__Folder*)a)->unreadCount), ""))
				{	soap_flag_unreadCount3 = 0;
					continue;
				}
			if (soap_flag_sequence3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:sequence", &(((ngwt__Folder*)a)->sequence), ""))
				{	soap_flag_sequence3 = 0;
					continue;
				}
			if (soap_flag_settings3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:settings", &(((ngwt__Folder*)a)->settings), "ngwt:uid"))
				{	soap_flag_settings3 = 0;
					continue;
				}
			if (soap_flag_calendarAttribute3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CalendarFolderAttribute(soap, "ngwt:calendarAttribute", &(((ngwt__Folder*)a)->calendarAttribute), "ngwt:CalendarFolderAttribute"))
				{	soap_flag_calendarAttribute3 = 0;
					continue;
				}
			if (soap_flag_isSystemFolder2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:isSystemFolder", &(((ngwt__SystemFolder*)a)->isSystemFolder), ""))
				{	soap_flag_isSystemFolder2 = 0;
					continue;
				}
			if (soap_flag_folderType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FolderType(soap, "ngwt:folderType", &(((ngwt__SystemFolder*)a)->folderType), ""))
				{	soap_flag_folderType2 = 0;
					continue;
				}
			if (soap_flag_acl2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FolderACL(soap, "ngwt:acl", &(((ngwt__SystemFolder*)a)->acl), "ngwt:FolderACL"))
				{	soap_flag_acl2 = 0;
					continue;
				}
			if (soap_flag_isSharedByMe2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:isSharedByMe", &(((ngwt__SystemFolder*)a)->isSharedByMe), ""))
				{	soap_flag_isSharedByMe2 = 0;
					continue;
				}
			if (soap_flag_addressBook1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:addressBook", &(((ngwt__ContactFolder*)a)->addressBook), "ngwt:uid"))
				{	soap_flag_addressBook1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__ContactFolder *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ContactFolder, 0, sizeof(ngwt__ContactFolder), 0, soap_copy_ngwt__ContactFolder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__ContactFolder * SOAP_FMAC6 soap_new_ngwt__ContactFolder(struct soap *soap, int n)
{	return soap_instantiate_ngwt__ContactFolder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__ContactFolder(struct soap *soap, ngwt__ContactFolder *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__ContactFolder * SOAP_FMAC6 soap_instantiate_ngwt__ContactFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__ContactFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__ContactFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__ContactFolder;
		if (size)
			*size = sizeof(ngwt__ContactFolder);
		((ngwt__ContactFolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__ContactFolder[n];
		if (size)
			*size = n * sizeof(ngwt__ContactFolder);
		for (int i = 0; i < n; i++)
			((ngwt__ContactFolder*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__ContactFolder*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__ContactFolder(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__ContactFolder %p -> %p\n", q, p));
	*(ngwt__ContactFolder*)p = *(ngwt__ContactFolder*)q;
}

void ngwt__Contact::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Contact*)this)->fullName, SOAP_TYPE_PointerTongwt__FullName);
	soap_serialize_PointerTongwt__FullName(soap, &((ngwt__Contact*)this)->fullName);
	soap_embedded(soap, &((ngwt__Contact*)this)->emailList, SOAP_TYPE_PointerTongwt__EmailAddressList);
	soap_serialize_PointerTongwt__EmailAddressList(soap, &((ngwt__Contact*)this)->emailList);
	soap_embedded(soap, &((ngwt__Contact*)this)->imList, SOAP_TYPE_PointerTongwt__ImAddressList);
	soap_serialize_PointerTongwt__ImAddressList(soap, &((ngwt__Contact*)this)->imList);
	soap_embedded(soap, &((ngwt__Contact*)this)->phoneList, SOAP_TYPE_PointerTongwt__PhoneList);
	soap_serialize_PointerTongwt__PhoneList(soap, &((ngwt__Contact*)this)->phoneList);
	soap_embedded(soap, &((ngwt__Contact*)this)->addressList, SOAP_TYPE_PointerTongwt__PostalAddressList);
	soap_serialize_PointerTongwt__PostalAddressList(soap, &((ngwt__Contact*)this)->addressList);
	soap_embedded(soap, &((ngwt__Contact*)this)->officeInfo, SOAP_TYPE_PointerTongwt__OfficeInfo);
	soap_serialize_PointerTongwt__OfficeInfo(soap, &((ngwt__Contact*)this)->officeInfo);
	soap_embedded(soap, &((ngwt__Contact*)this)->personalInfo, SOAP_TYPE_PointerTongwt__PersonalInfo);
	soap_serialize_PointerTongwt__PersonalInfo(soap, &((ngwt__Contact*)this)->personalInfo);
	soap_embedded(soap, &((ngwt__Contact*)this)->referenceInfo, SOAP_TYPE_PointerTongwt__ReferenceInfo);
	soap_serialize_PointerTongwt__ReferenceInfo(soap, &((ngwt__Contact*)this)->referenceInfo);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__AddressBookItem*)this)->uuid);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->comment);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->sync, SOAP_TYPE_PointerTongwt__DeltaSyncType);
	soap_serialize_PointerTongwt__DeltaSyncType(soap, &((ngwt__AddressBookItem*)this)->sync);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->domain, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->domain);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->postOffice, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->postOffice);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->distinguishedName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->distinguishedName);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->userid, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->userid);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Contact::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Contact*)this)->fullName = NULL;
	((ngwt__Contact*)this)->emailList = NULL;
	((ngwt__Contact*)this)->imList = NULL;
	((ngwt__Contact*)this)->phoneList = NULL;
	((ngwt__Contact*)this)->addressList = NULL;
	((ngwt__Contact*)this)->officeInfo = NULL;
	((ngwt__Contact*)this)->personalInfo = NULL;
	((ngwt__Contact*)this)->referenceInfo = NULL;
	((ngwt__AddressBookItem*)this)->uuid = NULL;
	((ngwt__AddressBookItem*)this)->comment = NULL;
	((ngwt__AddressBookItem*)this)->sync = NULL;
	((ngwt__AddressBookItem*)this)->domain = NULL;
	((ngwt__AddressBookItem*)this)->postOffice = NULL;
	((ngwt__AddressBookItem*)this)->distinguishedName = NULL;
	((ngwt__AddressBookItem*)this)->userid = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Contact::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Contact);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Contact::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Contact(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Contact(struct soap *soap, const char *tag, int id, const ngwt__Contact *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Contact), "ngwt:Contact");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__AddressBookItem*)a)->uuid), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__AddressBookItem*)a)->comment), "");
	soap_out_PointerTongwt__DeltaSyncType(soap, "ngwt:sync", -1, &(((ngwt__AddressBookItem*)a)->sync), "");
	soap_out_PointerTostd__string(soap, "ngwt:domain", -1, &(((ngwt__AddressBookItem*)a)->domain), "");
	soap_out_PointerTostd__string(soap, "ngwt:postOffice", -1, &(((ngwt__AddressBookItem*)a)->postOffice), "");
	soap_out_PointerTostd__string(soap, "ngwt:distinguishedName", -1, &(((ngwt__AddressBookItem*)a)->distinguishedName), "");
	soap_out_PointerTostd__string(soap, "ngwt:userid", -1, &(((ngwt__AddressBookItem*)a)->userid), "");
	soap_out_PointerTongwt__FullName(soap, "ngwt:fullName", -1, &(((ngwt__Contact*)a)->fullName), "");
	soap_out_PointerTongwt__EmailAddressList(soap, "ngwt:emailList", -1, &(((ngwt__Contact*)a)->emailList), "");
	soap_out_PointerTongwt__ImAddressList(soap, "ngwt:imList", -1, &(((ngwt__Contact*)a)->imList), "");
	soap_out_PointerTongwt__PhoneList(soap, "ngwt:phoneList", -1, &(((ngwt__Contact*)a)->phoneList), "");
	soap_out_PointerTongwt__PostalAddressList(soap, "ngwt:addressList", -1, &(((ngwt__Contact*)a)->addressList), "");
	soap_out_PointerTongwt__OfficeInfo(soap, "ngwt:officeInfo", -1, &(((ngwt__Contact*)a)->officeInfo), "");
	soap_out_PointerTongwt__PersonalInfo(soap, "ngwt:personalInfo", -1, &(((ngwt__Contact*)a)->personalInfo), "");
	soap_out_PointerTongwt__ReferenceInfo(soap, "ngwt:referenceInfo", -1, &(((ngwt__Contact*)a)->referenceInfo), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Contact::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Contact(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Contact * SOAP_FMAC4 soap_get_ngwt__Contact(struct soap *soap, ngwt__Contact *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Contact(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Contact::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Contact(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Contact * SOAP_FMAC4 soap_in_ngwt__Contact(struct soap *soap, const char *tag, ngwt__Contact *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Contact *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Contact, sizeof(ngwt__Contact), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Contact)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Contact *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id4 = 1, soap_flag_name4 = 1, soap_flag_version4 = 1, soap_flag_modified4 = 1, soap_flag_changes4 = 1, soap_flag_categories3 = 1, soap_flag_created3 = 1, soap_flag_customs3 = 1, soap_flag_uuid2 = 1, soap_flag_comment2 = 1, soap_flag_sync2 = 1, soap_flag_domain2 = 1, soap_flag_postOffice2 = 1, soap_flag_distinguishedName2 = 1, soap_flag_userid2 = 1, soap_flag_fullName1 = 1, soap_flag_emailList1 = 1, soap_flag_imList1 = 1, soap_flag_phoneList1 = 1, soap_flag_addressList1 = 1, soap_flag_officeInfo1 = 1, soap_flag_personalInfo1 = 1, soap_flag_referenceInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id4 = 0;
					continue;
				}
			if (soap_flag_name4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name4 = 0;
					continue;
				}
			if (soap_flag_version4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version4 = 0;
					continue;
				}
			if (soap_flag_modified4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified4 = 0;
					continue;
				}
			if (soap_flag_changes4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes4 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories3 = 0;
					continue;
				}
			if (soap_flag_created3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created3 = 0;
					continue;
				}
			if (soap_flag_customs3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs3 = 0;
					continue;
				}
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__AddressBookItem*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}
			if (soap_flag_comment2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__AddressBookItem*)a)->comment), ""))
				{	soap_flag_comment2 = 0;
					continue;
				}
			if (soap_flag_sync2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DeltaSyncType(soap, "ngwt:sync", &(((ngwt__AddressBookItem*)a)->sync), ""))
				{	soap_flag_sync2 = 0;
					continue;
				}
			if (soap_flag_domain2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:domain", &(((ngwt__AddressBookItem*)a)->domain), ""))
				{	soap_flag_domain2 = 0;
					continue;
				}
			if (soap_flag_postOffice2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:postOffice", &(((ngwt__AddressBookItem*)a)->postOffice), ""))
				{	soap_flag_postOffice2 = 0;
					continue;
				}
			if (soap_flag_distinguishedName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:distinguishedName", &(((ngwt__AddressBookItem*)a)->distinguishedName), ""))
				{	soap_flag_distinguishedName2 = 0;
					continue;
				}
			if (soap_flag_userid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:userid", &(((ngwt__AddressBookItem*)a)->userid), ""))
				{	soap_flag_userid2 = 0;
					continue;
				}
			if (soap_flag_fullName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__FullName(soap, "ngwt:fullName", &(((ngwt__Contact*)a)->fullName), "ngwt:FullName"))
				{	soap_flag_fullName1 = 0;
					continue;
				}
			if (soap_flag_emailList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__EmailAddressList(soap, "ngwt:emailList", &(((ngwt__Contact*)a)->emailList), "ngwt:EmailAddressList"))
				{	soap_flag_emailList1 = 0;
					continue;
				}
			if (soap_flag_imList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ImAddressList(soap, "ngwt:imList", &(((ngwt__Contact*)a)->imList), "ngwt:ImAddressList"))
				{	soap_flag_imList1 = 0;
					continue;
				}
			if (soap_flag_phoneList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__PhoneList(soap, "ngwt:phoneList", &(((ngwt__Contact*)a)->phoneList), "ngwt:PhoneList"))
				{	soap_flag_phoneList1 = 0;
					continue;
				}
			if (soap_flag_addressList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__PostalAddressList(soap, "ngwt:addressList", &(((ngwt__Contact*)a)->addressList), "ngwt:PostalAddressList"))
				{	soap_flag_addressList1 = 0;
					continue;
				}
			if (soap_flag_officeInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__OfficeInfo(soap, "ngwt:officeInfo", &(((ngwt__Contact*)a)->officeInfo), "ngwt:OfficeInfo"))
				{	soap_flag_officeInfo1 = 0;
					continue;
				}
			if (soap_flag_personalInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__PersonalInfo(soap, "ngwt:personalInfo", &(((ngwt__Contact*)a)->personalInfo), "ngwt:PersonalInfo"))
				{	soap_flag_personalInfo1 = 0;
					continue;
				}
			if (soap_flag_referenceInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ReferenceInfo(soap, "ngwt:referenceInfo", &(((ngwt__Contact*)a)->referenceInfo), "ngwt:ReferenceInfo"))
				{	soap_flag_referenceInfo1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Contact *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Contact, 0, sizeof(ngwt__Contact), 0, soap_copy_ngwt__Contact);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Contact * SOAP_FMAC6 soap_new_ngwt__Contact(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Contact(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Contact(struct soap *soap, ngwt__Contact *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Contact * SOAP_FMAC6 soap_instantiate_ngwt__Contact(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Contact(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Contact, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Contact;
		if (size)
			*size = sizeof(ngwt__Contact);
		((ngwt__Contact*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Contact[n];
		if (size)
			*size = n * sizeof(ngwt__Contact);
		for (int i = 0; i < n; i++)
			((ngwt__Contact*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Contact*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Contact(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Contact %p -> %p\n", q, p));
	*(ngwt__Contact*)p = *(ngwt__Contact*)q;
}

void ngwt__CommentStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__CommentStatus*)this)->__item, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__CommentStatus*)this)->__item);
	/* transient soap skipped */
}

void ngwt__CommentStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ngwt__CommentStatus*)this)->__item);
	((ngwt__CommentStatus*)this)->comment = NULL;
	/* transient soap skipped */
}

int ngwt__CommentStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__CommentStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__CommentStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__CommentStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__CommentStatus(struct soap *soap, const char *tag, int id, const ngwt__CommentStatus *a, const char *type)
{
	if (((ngwt__CommentStatus *)a)->comment)
		soap_set_attr(soap, "comment", ((ngwt__CommentStatus *)a)->comment->c_str());
	soap_out_string(soap, tag, id, &(((ngwt__CommentStatus*)a)->__item), "");
	return SOAP_OK;
}

void *ngwt__CommentStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__CommentStatus(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__CommentStatus * SOAP_FMAC4 soap_get_ngwt__CommentStatus(struct soap *soap, ngwt__CommentStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__CommentStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__CommentStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__CommentStatus(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__CommentStatus * SOAP_FMAC4 soap_in_ngwt__CommentStatus(struct soap *soap, const char *tag, ngwt__CommentStatus *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ngwt__CommentStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__CommentStatus, sizeof(ngwt__CommentStatus), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__CommentStatus)
			return (ngwt__CommentStatus *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "comment", 0);
		if (t)
		{	if (!(((ngwt__CommentStatus *)a)->comment = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__CommentStatus *)a)->comment = soap_new_std__string(soap, -1);
			((ngwt__CommentStatus *)a)->comment->assign(s);
		}
		}
	}
	if (!soap_in_string(soap, tag, &(((ngwt__CommentStatus*)a)->__item), "ngwt:CommentStatus"))
		return NULL;
	return a;
}

SOAP_FMAC5 ngwt__CommentStatus * SOAP_FMAC6 soap_new_ngwt__CommentStatus(struct soap *soap, int n)
{	return soap_instantiate_ngwt__CommentStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__CommentStatus(struct soap *soap, ngwt__CommentStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__CommentStatus * SOAP_FMAC6 soap_instantiate_ngwt__CommentStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__CommentStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__CommentStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__CommentStatus;
		if (size)
			*size = sizeof(ngwt__CommentStatus);
		((ngwt__CommentStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__CommentStatus[n];
		if (size)
			*size = n * sizeof(ngwt__CommentStatus);
		for (int i = 0; i < n; i++)
			((ngwt__CommentStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__CommentStatus*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__CommentStatus(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__CommentStatus %p -> %p\n", q, p));
	*(ngwt__CommentStatus*)p = *(ngwt__CommentStatus*)q;
}

void ngwt__CategoryRefList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfngwt__uid(soap, &((ngwt__CategoryRefList*)this)->category);
	/* transient soap skipped */
}

void ngwt__CategoryRefList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfngwt__uid(soap, &((ngwt__CategoryRefList*)this)->category);
	((ngwt__CategoryRefList*)this)->primary = NULL;
	/* transient soap skipped */
}

int ngwt__CategoryRefList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__CategoryRefList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__CategoryRefList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__CategoryRefList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__CategoryRefList(struct soap *soap, const char *tag, int id, const ngwt__CategoryRefList *a, const char *type)
{
	if (((ngwt__CategoryRefList *)a)->primary)
		soap_set_attr(soap, "primary", ((ngwt__CategoryRefList *)a)->primary->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__CategoryRefList), type);
	soap_out_std__vectorTemplateOfngwt__uid(soap, "ngwt:category", -1, &(((ngwt__CategoryRefList*)a)->category), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__CategoryRefList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__CategoryRefList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__CategoryRefList * SOAP_FMAC4 soap_get_ngwt__CategoryRefList(struct soap *soap, ngwt__CategoryRefList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__CategoryRefList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__CategoryRefList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__CategoryRefList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__CategoryRefList * SOAP_FMAC4 soap_in_ngwt__CategoryRefList(struct soap *soap, const char *tag, ngwt__CategoryRefList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__CategoryRefList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__CategoryRefList, sizeof(ngwt__CategoryRefList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__CategoryRefList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__CategoryRefList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "primary", 0);
		if (t)
		{	if (!(((ngwt__CategoryRefList *)a)->primary = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ngwt__CategoryRefList *)a)->primary = soap_new_std__string(soap, -1);
			((ngwt__CategoryRefList *)a)->primary->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__uid(soap, "ngwt:category", &(((ngwt__CategoryRefList*)a)->category), "ngwt:uid"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__CategoryRefList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CategoryRefList, 0, sizeof(ngwt__CategoryRefList), 0, soap_copy_ngwt__CategoryRefList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__CategoryRefList * SOAP_FMAC6 soap_new_ngwt__CategoryRefList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__CategoryRefList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__CategoryRefList(struct soap *soap, ngwt__CategoryRefList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__CategoryRefList * SOAP_FMAC6 soap_instantiate_ngwt__CategoryRefList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__CategoryRefList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__CategoryRefList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__CategoryRefList;
		if (size)
			*size = sizeof(ngwt__CategoryRefList);
		((ngwt__CategoryRefList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__CategoryRefList[n];
		if (size)
			*size = n * sizeof(ngwt__CategoryRefList);
		for (int i = 0; i < n; i++)
			((ngwt__CategoryRefList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__CategoryRefList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__CategoryRefList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__CategoryRefList %p -> %p\n", q, p));
	*(ngwt__CategoryRefList*)p = *(ngwt__CategoryRefList*)q;
}

void ngwt__CategoryList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__Category(soap, &((ngwt__CategoryList*)this)->category);
	/* transient soap skipped */
}

void ngwt__CategoryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__Category(soap, &((ngwt__CategoryList*)this)->category);
	/* transient soap skipped */
}

int ngwt__CategoryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__CategoryList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__CategoryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__CategoryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__CategoryList(struct soap *soap, const char *tag, int id, const ngwt__CategoryList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__CategoryList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__Category(soap, "ngwt:category", -1, &(((ngwt__CategoryList*)a)->category), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__CategoryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__CategoryList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__CategoryList * SOAP_FMAC4 soap_get_ngwt__CategoryList(struct soap *soap, ngwt__CategoryList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__CategoryList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__CategoryList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__CategoryList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__CategoryList * SOAP_FMAC4 soap_in_ngwt__CategoryList(struct soap *soap, const char *tag, ngwt__CategoryList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__CategoryList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__CategoryList, sizeof(ngwt__CategoryList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__CategoryList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__CategoryList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__Category(soap, "ngwt:category", &(((ngwt__CategoryList*)a)->category), "ngwt:Category"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__CategoryList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CategoryList, 0, sizeof(ngwt__CategoryList), 0, soap_copy_ngwt__CategoryList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__CategoryList * SOAP_FMAC6 soap_new_ngwt__CategoryList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__CategoryList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__CategoryList(struct soap *soap, ngwt__CategoryList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__CategoryList * SOAP_FMAC6 soap_instantiate_ngwt__CategoryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__CategoryList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__CategoryList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__CategoryList;
		if (size)
			*size = sizeof(ngwt__CategoryList);
		((ngwt__CategoryList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__CategoryList[n];
		if (size)
			*size = n * sizeof(ngwt__CategoryList);
		for (int i = 0; i < n; i++)
			((ngwt__CategoryList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__CategoryList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__CategoryList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__CategoryList %p -> %p\n", q, p));
	*(ngwt__CategoryList*)p = *(ngwt__CategoryList*)q;
}

void ngwt__Category::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Category*)this)->type, SOAP_TYPE_PointerTongwt__CategoryType);
	soap_serialize_PointerTongwt__CategoryType(soap, &((ngwt__Category*)this)->type);
	soap_embedded(soap, &((ngwt__Category*)this)->color, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Category*)this)->color);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Category::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__Category*)this)->type = NULL;
	((ngwt__Category*)this)->color = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Category::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Category);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Category::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Category(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Category(struct soap *soap, const char *tag, int id, const ngwt__Category *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Category), "ngwt:Category");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_PointerTongwt__CategoryType(soap, "ngwt:type", -1, &(((ngwt__Category*)a)->type), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:color", -1, &(((ngwt__Category*)a)->color), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Category::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Category(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Category * SOAP_FMAC4 soap_get_ngwt__Category(struct soap *soap, ngwt__Category *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Category(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Category::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Category(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Category * SOAP_FMAC4 soap_in_ngwt__Category(struct soap *soap, const char *tag, ngwt__Category *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Category *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Category, sizeof(ngwt__Category), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Category)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Category *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id2 = 1, soap_flag_name2 = 1, soap_flag_version2 = 1, soap_flag_modified2 = 1, soap_flag_changes2 = 1, soap_flag_type1 = 1, soap_flag_color1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id2 = 0;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name2 = 0;
					continue;
				}
			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version2 = 0;
					continue;
				}
			if (soap_flag_modified2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified2 = 0;
					continue;
				}
			if (soap_flag_changes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryType(soap, "ngwt:type", &(((ngwt__Category*)a)->type), ""))
				{	soap_flag_type1 = 0;
					continue;
				}
			if (soap_flag_color1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:color", &(((ngwt__Category*)a)->color), ""))
				{	soap_flag_color1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Category *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Category, 0, sizeof(ngwt__Category), 0, soap_copy_ngwt__Category);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Category * SOAP_FMAC6 soap_new_ngwt__Category(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Category(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Category(struct soap *soap, ngwt__Category *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Category * SOAP_FMAC6 soap_instantiate_ngwt__Category(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Category(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Category, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Category;
		if (size)
			*size = sizeof(ngwt__Category);
		((ngwt__Category*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Category[n];
		if (size)
			*size = n * sizeof(ngwt__Category);
		for (int i = 0; i < n; i++)
			((ngwt__Category*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Category*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Category(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Category %p -> %p\n", q, p));
	*(ngwt__Category*)p = *(ngwt__Category*)q;
}

void ngwt__CalendarItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->rdate, SOAP_TYPE_PointerTongwt__RecurrenceDateType);
	soap_serialize_PointerTongwt__RecurrenceDateType(soap, &((ngwt__CalendarItem*)this)->rdate);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->rrule, SOAP_TYPE_PointerTongwt__RecurrenceRule);
	soap_serialize_PointerTongwt__RecurrenceRule(soap, &((ngwt__CalendarItem*)this)->rrule);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->exdate, SOAP_TYPE_PointerTongwt__RecurrenceDateType);
	soap_serialize_PointerTongwt__RecurrenceDateType(soap, &((ngwt__CalendarItem*)this)->exdate);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->recurrenceKey, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__CalendarItem*)this)->recurrenceKey);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->iCalId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__CalendarItem*)this)->iCalId);
	soap_embedded(soap, &((ngwt__Mail*)this)->subject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subject);
	soap_embedded(soap, &((ngwt__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ngwt__Mail*)this)->subjectPrefix, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subjectPrefix);
	soap_embedded(soap, &((ngwt__Mail*)this)->distribution, SOAP_TYPE_PointerTongwt__Distribution);
	soap_serialize_PointerTongwt__Distribution(soap, &((ngwt__Mail*)this)->distribution);
	soap_embedded(soap, &((ngwt__Mail*)this)->message, SOAP_TYPE_PointerTongwt__MessageBody);
	soap_serialize_PointerTongwt__MessageBody(soap, &((ngwt__Mail*)this)->message);
	soap_embedded(soap, &((ngwt__Mail*)this)->attachments, SOAP_TYPE_PointerTongwt__AttachmentInfo);
	soap_serialize_PointerTongwt__AttachmentInfo(soap, &((ngwt__Mail*)this)->attachments);
	soap_embedded(soap, &((ngwt__Mail*)this)->options, SOAP_TYPE_PointerTongwt__ItemOptions);
	soap_serialize_PointerTongwt__ItemOptions(soap, &((ngwt__Mail*)this)->options);
	soap_embedded(soap, &((ngwt__Mail*)this)->link, SOAP_TYPE_PointerTongwt__LinkInfo);
	soap_serialize_PointerTongwt__LinkInfo(soap, &((ngwt__Mail*)this)->link);
	soap_embedded(soap, &((ngwt__Mail*)this)->hasAttachment, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwt__Mail*)this)->size, SOAP_TYPE_int);
	soap_embedded(soap, &((ngwt__Mail*)this)->subType, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subType);
	soap_embedded(soap, &((ngwt__Mail*)this)->nntpOrImap, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Mail*)this)->nntpOrImap);
	soap_embedded(soap, &((ngwt__Mail*)this)->smimeType, SOAP_TYPE_PointerTongwt__SMimeOperation);
	soap_serialize_PointerTongwt__SMimeOperation(soap, &((ngwt__Mail*)this)->smimeType);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->status, SOAP_TYPE_PointerTongwt__ItemStatus);
	soap_serialize_PointerTongwt__ItemStatus(soap, &((ngwt__BoxEntry*)this)->status);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->msgId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->msgId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->messageId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->messageId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->source, SOAP_TYPE_PointerTongwt__ItemSource);
	soap_serialize_PointerTongwt__ItemSource(soap, &((ngwt__BoxEntry*)this)->source);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->class_, SOAP_TYPE_PointerTongwt__ItemClass);
	soap_serialize_PointerTongwt__ItemClass(soap, &((ngwt__BoxEntry*)this)->class_);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->security, SOAP_TYPE_PointerTongwt__ItemSecurity);
	soap_serialize_PointerTongwt__ItemSecurity(soap, &((ngwt__BoxEntry*)this)->security);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->comment);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__CalendarItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__CalendarItem*)this)->rdate = NULL;
	((ngwt__CalendarItem*)this)->rrule = NULL;
	((ngwt__CalendarItem*)this)->exdate = NULL;
	((ngwt__CalendarItem*)this)->recurrenceKey = NULL;
	((ngwt__CalendarItem*)this)->iCalId = NULL;
	((ngwt__Mail*)this)->subject = NULL;
	((ngwt__Mail*)this)->originalSubject = NULL;
	((ngwt__Mail*)this)->subjectPrefix = NULL;
	((ngwt__Mail*)this)->distribution = NULL;
	((ngwt__Mail*)this)->message = NULL;
	((ngwt__Mail*)this)->attachments = NULL;
	((ngwt__Mail*)this)->options = NULL;
	((ngwt__Mail*)this)->link = NULL;
	((ngwt__Mail*)this)->hasAttachment = (bool)0;
	((ngwt__Mail*)this)->size = 0;
	((ngwt__Mail*)this)->subType = NULL;
	((ngwt__Mail*)this)->nntpOrImap = NULL;
	((ngwt__Mail*)this)->smimeType = NULL;
	((ngwt__BoxEntry*)this)->status = NULL;
	((ngwt__BoxEntry*)this)->thread = NULL;
	((ngwt__BoxEntry*)this)->msgId = NULL;
	((ngwt__BoxEntry*)this)->messageId = NULL;
	((ngwt__BoxEntry*)this)->source = NULL;
	((ngwt__BoxEntry*)this)->returnSentItemsId = NULL;
	soap_default_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	((ngwt__BoxEntry*)this)->class_ = NULL;
	((ngwt__BoxEntry*)this)->security = NULL;
	((ngwt__BoxEntry*)this)->comment = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__CalendarItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__CalendarItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__CalendarItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__CalendarItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__CalendarItem(struct soap *soap, const char *tag, int id, const ngwt__CalendarItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__CalendarItem), "ngwt:CalendarItem");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__ItemStatus(soap, "ngwt:status", -1, &(((ngwt__BoxEntry*)a)->status), "");
	soap_out_PointerTostd__string(soap, "ngwt:thread", -1, &(((ngwt__BoxEntry*)a)->thread), "");
	soap_out_PointerTostd__string(soap, "ngwt:msgId", -1, &(((ngwt__BoxEntry*)a)->msgId), "");
	soap_out_PointerTostd__string(soap, "ngwt:messageId", -1, &(((ngwt__BoxEntry*)a)->messageId), "");
	soap_out_PointerTongwt__ItemSource(soap, "ngwt:source", -1, &(((ngwt__BoxEntry*)a)->source), "");
	soap_out_PointerTobool(soap, "ngwt:returnSentItemsId", -1, &(((ngwt__BoxEntry*)a)->returnSentItemsId), "");
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__BoxEntry*)a)->delivered), "");
	soap_out_PointerTongwt__ItemClass(soap, "ngwt:class", -1, &(((ngwt__BoxEntry*)a)->class_), "");
	soap_out_PointerTongwt__ItemSecurity(soap, "ngwt:security", -1, &(((ngwt__BoxEntry*)a)->security), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__BoxEntry*)a)->comment), "");
	soap_out_PointerTostd__string(soap, "ngwt:subject", -1, &(((ngwt__Mail*)a)->subject), "");
	soap_out_PointerTostd__string(soap, "ngwt:originalSubject", -1, &(((ngwt__Mail*)a)->originalSubject), "");
	soap_out_PointerTostd__string(soap, "ngwt:subjectPrefix", -1, &(((ngwt__Mail*)a)->subjectPrefix), "");
	soap_out_PointerTongwt__Distribution(soap, "ngwt:distribution", -1, &(((ngwt__Mail*)a)->distribution), "");
	soap_out_PointerTongwt__MessageBody(soap, "ngwt:message", -1, &(((ngwt__Mail*)a)->message), "");
	soap_out_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", -1, &(((ngwt__Mail*)a)->attachments), "");
	soap_out_PointerTongwt__ItemOptions(soap, "ngwt:options", -1, &(((ngwt__Mail*)a)->options), "");
	soap_out_PointerTongwt__LinkInfo(soap, "ngwt:link", -1, &(((ngwt__Mail*)a)->link), "");
	soap_out_bool(soap, "ngwt:hasAttachment", -1, &(((ngwt__Mail*)a)->hasAttachment), "");
	soap_out_int(soap, "ngwt:size", -1, &(((ngwt__Mail*)a)->size), "");
	soap_out_PointerTostd__string(soap, "ngwt:subType", -1, &(((ngwt__Mail*)a)->subType), "");
	soap_out_PointerTobool(soap, "ngwt:nntpOrImap", -1, &(((ngwt__Mail*)a)->nntpOrImap), "");
	soap_out_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", -1, &(((ngwt__Mail*)a)->smimeType), "");
	soap_out_PointerTongwt__RecurrenceDateType(soap, "ngwt:rdate", -1, &(((ngwt__CalendarItem*)a)->rdate), "");
	soap_out_PointerTongwt__RecurrenceRule(soap, "ngwt:rrule", -1, &(((ngwt__CalendarItem*)a)->rrule), "");
	soap_out_PointerTongwt__RecurrenceDateType(soap, "ngwt:exdate", -1, &(((ngwt__CalendarItem*)a)->exdate), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:recurrenceKey", -1, &(((ngwt__CalendarItem*)a)->recurrenceKey), "");
	soap_out_PointerTostd__string(soap, "ngwt:iCalId", -1, &(((ngwt__CalendarItem*)a)->iCalId), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__CalendarItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__CalendarItem(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__CalendarItem * SOAP_FMAC4 soap_get_ngwt__CalendarItem(struct soap *soap, ngwt__CalendarItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__CalendarItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__CalendarItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__CalendarItem(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__CalendarItem * SOAP_FMAC4 soap_in_ngwt__CalendarItem(struct soap *soap, const char *tag, ngwt__CalendarItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__CalendarItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__CalendarItem, sizeof(ngwt__CalendarItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__CalendarItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__CalendarItem *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id5 = 1, soap_flag_name5 = 1, soap_flag_version5 = 1, soap_flag_modified5 = 1, soap_flag_changes5 = 1, soap_flag_categories4 = 1, soap_flag_created4 = 1, soap_flag_customs4 = 1, soap_flag_status3 = 1, soap_flag_thread3 = 1, soap_flag_msgId3 = 1, soap_flag_messageId3 = 1, soap_flag_source3 = 1, soap_flag_returnSentItemsId3 = 1, soap_flag_delivered3 = 1, soap_flag_class_3 = 1, soap_flag_security3 = 1, soap_flag_comment3 = 1, soap_flag_subject2 = 1, soap_flag_originalSubject2 = 1, soap_flag_subjectPrefix2 = 1, soap_flag_distribution2 = 1, soap_flag_message2 = 1, soap_flag_attachments2 = 1, soap_flag_options2 = 1, soap_flag_link2 = 1, soap_flag_hasAttachment2 = 1, soap_flag_size2 = 1, soap_flag_subType2 = 1, soap_flag_nntpOrImap2 = 1, soap_flag_smimeType2 = 1, soap_flag_rdate1 = 1, soap_flag_rrule1 = 1, soap_flag_exdate1 = 1, soap_flag_recurrenceKey1 = 1, soap_flag_iCalId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id5 = 0;
					continue;
				}
			if (soap_flag_name5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name5 = 0;
					continue;
				}
			if (soap_flag_version5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version5 = 0;
					continue;
				}
			if (soap_flag_modified5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified5 = 0;
					continue;
				}
			if (soap_flag_changes5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes5 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories4 = 0;
					continue;
				}
			if (soap_flag_created4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created4 = 0;
					continue;
				}
			if (soap_flag_customs4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs4 = 0;
					continue;
				}
			if (soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemStatus(soap, "ngwt:status", &(((ngwt__BoxEntry*)a)->status), "ngwt:ItemStatus"))
				{	soap_flag_status3 = 0;
					continue;
				}
			if (soap_flag_thread3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:thread", &(((ngwt__BoxEntry*)a)->thread), ""))
				{	soap_flag_thread3 = 0;
					continue;
				}
			if (soap_flag_msgId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:msgId", &(((ngwt__BoxEntry*)a)->msgId), ""))
				{	soap_flag_msgId3 = 0;
					continue;
				}
			if (soap_flag_messageId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:messageId", &(((ngwt__BoxEntry*)a)->messageId), ""))
				{	soap_flag_messageId3 = 0;
					continue;
				}
			if (soap_flag_source3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSource(soap, "ngwt:source", &(((ngwt__BoxEntry*)a)->source), ""))
				{	soap_flag_source3 = 0;
					continue;
				}
			if (soap_flag_returnSentItemsId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:returnSentItemsId", &(((ngwt__BoxEntry*)a)->returnSentItemsId), ""))
				{	soap_flag_returnSentItemsId3 = 0;
					continue;
				}
			if (soap_flag_delivered3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered3 = 0;
					continue;
				}
			if (soap_flag_class_3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemClass(soap, "ngwt:class", &(((ngwt__BoxEntry*)a)->class_), ""))
				{	soap_flag_class_3 = 0;
					continue;
				}
			if (soap_flag_security3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSecurity(soap, "ngwt:security", &(((ngwt__BoxEntry*)a)->security), ""))
				{	soap_flag_security3 = 0;
					continue;
				}
			if (soap_flag_comment3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__BoxEntry*)a)->comment), ""))
				{	soap_flag_comment3 = 0;
					continue;
				}
			if (soap_flag_subject2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subject", &(((ngwt__Mail*)a)->subject), ""))
				{	soap_flag_subject2 = 0;
					continue;
				}
			if (soap_flag_originalSubject2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:originalSubject", &(((ngwt__Mail*)a)->originalSubject), ""))
				{	soap_flag_originalSubject2 = 0;
					continue;
				}
			if (soap_flag_subjectPrefix2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subjectPrefix", &(((ngwt__Mail*)a)->subjectPrefix), ""))
				{	soap_flag_subjectPrefix2 = 0;
					continue;
				}
			if (soap_flag_distribution2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Distribution(soap, "ngwt:distribution", &(((ngwt__Mail*)a)->distribution), "ngwt:Distribution"))
				{	soap_flag_distribution2 = 0;
					continue;
				}
			if (soap_flag_message2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessageBody(soap, "ngwt:message", &(((ngwt__Mail*)a)->message), "ngwt:MessageBody"))
				{	soap_flag_message2 = 0;
					continue;
				}
			if (soap_flag_attachments2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", &(((ngwt__Mail*)a)->attachments), "ngwt:AttachmentInfo"))
				{	soap_flag_attachments2 = 0;
					continue;
				}
			if (soap_flag_options2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemOptions(soap, "ngwt:options", &(((ngwt__Mail*)a)->options), "ngwt:ItemOptions"))
				{	soap_flag_options2 = 0;
					continue;
				}
			if (soap_flag_link2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__LinkInfo(soap, "ngwt:link", &(((ngwt__Mail*)a)->link), "ngwt:LinkInfo"))
				{	soap_flag_link2 = 0;
					continue;
				}
			if (soap_flag_hasAttachment2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:hasAttachment", &(((ngwt__Mail*)a)->hasAttachment), ""))
				{	soap_flag_hasAttachment2 = 0;
					continue;
				}
			if (soap_flag_size2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:size", &(((ngwt__Mail*)a)->size), ""))
				{	soap_flag_size2 = 0;
					continue;
				}
			if (soap_flag_subType2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subType", &(((ngwt__Mail*)a)->subType), ""))
				{	soap_flag_subType2 = 0;
					continue;
				}
			if (soap_flag_nntpOrImap2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:nntpOrImap", &(((ngwt__Mail*)a)->nntpOrImap), ""))
				{	soap_flag_nntpOrImap2 = 0;
					continue;
				}
			if (soap_flag_smimeType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", &(((ngwt__Mail*)a)->smimeType), "ngwt:SMimeOperation"))
				{	soap_flag_smimeType2 = 0;
					continue;
				}
			if (soap_flag_rdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceDateType(soap, "ngwt:rdate", &(((ngwt__CalendarItem*)a)->rdate), "ngwt:RecurrenceDateType"))
				{	soap_flag_rdate1 = 0;
					continue;
				}
			if (soap_flag_rrule1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceRule(soap, "ngwt:rrule", &(((ngwt__CalendarItem*)a)->rrule), "ngwt:RecurrenceRule"))
				{	soap_flag_rrule1 = 0;
					continue;
				}
			if (soap_flag_exdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceDateType(soap, "ngwt:exdate", &(((ngwt__CalendarItem*)a)->exdate), "ngwt:RecurrenceDateType"))
				{	soap_flag_exdate1 = 0;
					continue;
				}
			if (soap_flag_recurrenceKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:recurrenceKey", &(((ngwt__CalendarItem*)a)->recurrenceKey), ""))
				{	soap_flag_recurrenceKey1 = 0;
					continue;
				}
			if (soap_flag_iCalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:iCalId", &(((ngwt__CalendarItem*)a)->iCalId), ""))
				{	soap_flag_iCalId1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_delivered3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__CalendarItem *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CalendarItem, 0, sizeof(ngwt__CalendarItem), 0, soap_copy_ngwt__CalendarItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__CalendarItem * SOAP_FMAC6 soap_new_ngwt__CalendarItem(struct soap *soap, int n)
{	return soap_instantiate_ngwt__CalendarItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__CalendarItem(struct soap *soap, ngwt__CalendarItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__CalendarItem * SOAP_FMAC6 soap_instantiate_ngwt__CalendarItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__CalendarItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__CalendarItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:Appointment"))
	{	cp->type = SOAP_TYPE_ngwt__Appointment;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Appointment;
			if (size)
				*size = sizeof(ngwt__Appointment);
			((ngwt__Appointment*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Appointment[n];
			if (size)
				*size = n * sizeof(ngwt__Appointment);
			for (int i = 0; i < n; i++)
				((ngwt__Appointment*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Appointment*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Note"))
	{	cp->type = SOAP_TYPE_ngwt__Note;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Note;
			if (size)
				*size = sizeof(ngwt__Note);
			((ngwt__Note*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Note[n];
			if (size)
				*size = n * sizeof(ngwt__Note);
			for (int i = 0; i < n; i++)
				((ngwt__Note*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Note*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Task"))
	{	cp->type = SOAP_TYPE_ngwt__Task;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Task;
			if (size)
				*size = sizeof(ngwt__Task);
			((ngwt__Task*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Task[n];
			if (size)
				*size = n * sizeof(ngwt__Task);
			for (int i = 0; i < n; i++)
				((ngwt__Task*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Task*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__CalendarItem;
		if (size)
			*size = sizeof(ngwt__CalendarItem);
		((ngwt__CalendarItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__CalendarItem[n];
		if (size)
			*size = n * sizeof(ngwt__CalendarItem);
		for (int i = 0; i < n; i++)
			((ngwt__CalendarItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__CalendarItem*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__CalendarItem(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__CalendarItem %p -> %p\n", q, p));
	*(ngwt__CalendarItem*)p = *(ngwt__CalendarItem*)q;
}

void ngwt__CalendarFolderAttribute::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfngwt__CalendarFolderFlags(soap, &((ngwt__CalendarFolderAttribute*)this)->flags);
	soap_embedded(soap, &((ngwt__CalendarFolderAttribute*)this)->color, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__CalendarFolderAttribute*)this)->color);
	/* transient soap skipped */
}

void ngwt__CalendarFolderAttribute::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfngwt__CalendarFolderFlags(soap, &((ngwt__CalendarFolderAttribute*)this)->flags);
	((ngwt__CalendarFolderAttribute*)this)->color = NULL;
	/* transient soap skipped */
}

int ngwt__CalendarFolderAttribute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__CalendarFolderAttribute);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__CalendarFolderAttribute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__CalendarFolderAttribute(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__CalendarFolderAttribute(struct soap *soap, const char *tag, int id, const ngwt__CalendarFolderAttribute *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__CalendarFolderAttribute), type);
	soap_out_std__vectorTemplateOfngwt__CalendarFolderFlags(soap, "ngwt:flags", -1, &(((ngwt__CalendarFolderAttribute*)a)->flags), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:color", -1, &(((ngwt__CalendarFolderAttribute*)a)->color), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__CalendarFolderAttribute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__CalendarFolderAttribute(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__CalendarFolderAttribute * SOAP_FMAC4 soap_get_ngwt__CalendarFolderAttribute(struct soap *soap, ngwt__CalendarFolderAttribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__CalendarFolderAttribute(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__CalendarFolderAttribute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__CalendarFolderAttribute(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__CalendarFolderAttribute * SOAP_FMAC4 soap_in_ngwt__CalendarFolderAttribute(struct soap *soap, const char *tag, ngwt__CalendarFolderAttribute *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__CalendarFolderAttribute *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__CalendarFolderAttribute, sizeof(ngwt__CalendarFolderAttribute), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__CalendarFolderAttribute)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__CalendarFolderAttribute *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_color1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfngwt__CalendarFolderFlags(soap, "ngwt:flags", &(((ngwt__CalendarFolderAttribute*)a)->flags), ""))
					continue;
			if (soap_flag_color1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:color", &(((ngwt__CalendarFolderAttribute*)a)->color), ""))
				{	soap_flag_color1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (((ngwt__CalendarFolderAttribute*)a)->flags.size() > 2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__CalendarFolderAttribute *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CalendarFolderAttribute, 0, sizeof(ngwt__CalendarFolderAttribute), 0, soap_copy_ngwt__CalendarFolderAttribute);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__CalendarFolderAttribute * SOAP_FMAC6 soap_new_ngwt__CalendarFolderAttribute(struct soap *soap, int n)
{	return soap_instantiate_ngwt__CalendarFolderAttribute(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__CalendarFolderAttribute(struct soap *soap, ngwt__CalendarFolderAttribute *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__CalendarFolderAttribute * SOAP_FMAC6 soap_instantiate_ngwt__CalendarFolderAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__CalendarFolderAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__CalendarFolderAttribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__CalendarFolderAttribute;
		if (size)
			*size = sizeof(ngwt__CalendarFolderAttribute);
		((ngwt__CalendarFolderAttribute*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__CalendarFolderAttribute[n];
		if (size)
			*size = n * sizeof(ngwt__CalendarFolderAttribute);
		for (int i = 0; i < n; i++)
			((ngwt__CalendarFolderAttribute*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__CalendarFolderAttribute*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__CalendarFolderAttribute(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__CalendarFolderAttribute %p -> %p\n", q, p));
	*(ngwt__CalendarFolderAttribute*)p = *(ngwt__CalendarFolderAttribute*)q;
}

void ngwt__BoxEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->status, SOAP_TYPE_PointerTongwt__ItemStatus);
	soap_serialize_PointerTongwt__ItemStatus(soap, &((ngwt__BoxEntry*)this)->status);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->msgId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->msgId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->messageId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->messageId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->source, SOAP_TYPE_PointerTongwt__ItemSource);
	soap_serialize_PointerTongwt__ItemSource(soap, &((ngwt__BoxEntry*)this)->source);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->class_, SOAP_TYPE_PointerTongwt__ItemClass);
	soap_serialize_PointerTongwt__ItemClass(soap, &((ngwt__BoxEntry*)this)->class_);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->security, SOAP_TYPE_PointerTongwt__ItemSecurity);
	soap_serialize_PointerTongwt__ItemSecurity(soap, &((ngwt__BoxEntry*)this)->security);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->comment);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__BoxEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__BoxEntry*)this)->status = NULL;
	((ngwt__BoxEntry*)this)->thread = NULL;
	((ngwt__BoxEntry*)this)->msgId = NULL;
	((ngwt__BoxEntry*)this)->messageId = NULL;
	((ngwt__BoxEntry*)this)->source = NULL;
	((ngwt__BoxEntry*)this)->returnSentItemsId = NULL;
	soap_default_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	((ngwt__BoxEntry*)this)->class_ = NULL;
	((ngwt__BoxEntry*)this)->security = NULL;
	((ngwt__BoxEntry*)this)->comment = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__BoxEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__BoxEntry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__BoxEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__BoxEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__BoxEntry(struct soap *soap, const char *tag, int id, const ngwt__BoxEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__BoxEntry), "ngwt:BoxEntry");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__ItemStatus(soap, "ngwt:status", -1, &(((ngwt__BoxEntry*)a)->status), "");
	soap_out_PointerTostd__string(soap, "ngwt:thread", -1, &(((ngwt__BoxEntry*)a)->thread), "");
	soap_out_PointerTostd__string(soap, "ngwt:msgId", -1, &(((ngwt__BoxEntry*)a)->msgId), "");
	soap_out_PointerTostd__string(soap, "ngwt:messageId", -1, &(((ngwt__BoxEntry*)a)->messageId), "");
	soap_out_PointerTongwt__ItemSource(soap, "ngwt:source", -1, &(((ngwt__BoxEntry*)a)->source), "");
	soap_out_PointerTobool(soap, "ngwt:returnSentItemsId", -1, &(((ngwt__BoxEntry*)a)->returnSentItemsId), "");
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__BoxEntry*)a)->delivered), "");
	soap_out_PointerTongwt__ItemClass(soap, "ngwt:class", -1, &(((ngwt__BoxEntry*)a)->class_), "");
	soap_out_PointerTongwt__ItemSecurity(soap, "ngwt:security", -1, &(((ngwt__BoxEntry*)a)->security), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__BoxEntry*)a)->comment), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__BoxEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__BoxEntry(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__BoxEntry * SOAP_FMAC4 soap_get_ngwt__BoxEntry(struct soap *soap, ngwt__BoxEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__BoxEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__BoxEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__BoxEntry(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__BoxEntry * SOAP_FMAC4 soap_in_ngwt__BoxEntry(struct soap *soap, const char *tag, ngwt__BoxEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__BoxEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__BoxEntry, sizeof(ngwt__BoxEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__BoxEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__BoxEntry *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_categories2 = 1, soap_flag_created2 = 1, soap_flag_customs2 = 1, soap_flag_status1 = 1, soap_flag_thread1 = 1, soap_flag_msgId1 = 1, soap_flag_messageId1 = 1, soap_flag_source1 = 1, soap_flag_returnSentItemsId1 = 1, soap_flag_delivered1 = 1, soap_flag_class_1 = 1, soap_flag_security1 = 1, soap_flag_comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}
			if (soap_flag_name3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name3 = 0;
					continue;
				}
			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}
			if (soap_flag_modified3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}
			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories2 = 0;
					continue;
				}
			if (soap_flag_created2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created2 = 0;
					continue;
				}
			if (soap_flag_customs2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs2 = 0;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemStatus(soap, "ngwt:status", &(((ngwt__BoxEntry*)a)->status), "ngwt:ItemStatus"))
				{	soap_flag_status1 = 0;
					continue;
				}
			if (soap_flag_thread1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:thread", &(((ngwt__BoxEntry*)a)->thread), ""))
				{	soap_flag_thread1 = 0;
					continue;
				}
			if (soap_flag_msgId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:msgId", &(((ngwt__BoxEntry*)a)->msgId), ""))
				{	soap_flag_msgId1 = 0;
					continue;
				}
			if (soap_flag_messageId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:messageId", &(((ngwt__BoxEntry*)a)->messageId), ""))
				{	soap_flag_messageId1 = 0;
					continue;
				}
			if (soap_flag_source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSource(soap, "ngwt:source", &(((ngwt__BoxEntry*)a)->source), ""))
				{	soap_flag_source1 = 0;
					continue;
				}
			if (soap_flag_returnSentItemsId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:returnSentItemsId", &(((ngwt__BoxEntry*)a)->returnSentItemsId), ""))
				{	soap_flag_returnSentItemsId1 = 0;
					continue;
				}
			if (soap_flag_delivered1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered1 = 0;
					continue;
				}
			if (soap_flag_class_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemClass(soap, "ngwt:class", &(((ngwt__BoxEntry*)a)->class_), ""))
				{	soap_flag_class_1 = 0;
					continue;
				}
			if (soap_flag_security1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSecurity(soap, "ngwt:security", &(((ngwt__BoxEntry*)a)->security), ""))
				{	soap_flag_security1 = 0;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__BoxEntry*)a)->comment), ""))
				{	soap_flag_comment1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_delivered1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__BoxEntry *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__BoxEntry, 0, sizeof(ngwt__BoxEntry), 0, soap_copy_ngwt__BoxEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__BoxEntry * SOAP_FMAC6 soap_new_ngwt__BoxEntry(struct soap *soap, int n)
{	return soap_instantiate_ngwt__BoxEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__BoxEntry(struct soap *soap, ngwt__BoxEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__BoxEntry * SOAP_FMAC6 soap_instantiate_ngwt__BoxEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__BoxEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__BoxEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:Mail"))
	{	cp->type = SOAP_TYPE_ngwt__Mail;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Mail;
			if (size)
				*size = sizeof(ngwt__Mail);
			((ngwt__Mail*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Mail[n];
			if (size)
				*size = n * sizeof(ngwt__Mail);
			for (int i = 0; i < n; i++)
				((ngwt__Mail*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Mail*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:CalendarItem"))
	{	cp->type = SOAP_TYPE_ngwt__CalendarItem;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__CalendarItem;
			if (size)
				*size = sizeof(ngwt__CalendarItem);
			((ngwt__CalendarItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__CalendarItem[n];
			if (size)
				*size = n * sizeof(ngwt__CalendarItem);
			for (int i = 0; i < n; i++)
				((ngwt__CalendarItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__CalendarItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:DocumentRef"))
	{	cp->type = SOAP_TYPE_ngwt__DocumentRef;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__DocumentRef;
			if (size)
				*size = sizeof(ngwt__DocumentRef);
			((ngwt__DocumentRef*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__DocumentRef[n];
			if (size)
				*size = n * sizeof(ngwt__DocumentRef);
			for (int i = 0; i < n; i++)
				((ngwt__DocumentRef*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__DocumentRef*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:PhoneMessage"))
	{	cp->type = SOAP_TYPE_ngwt__PhoneMessage;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__PhoneMessage;
			if (size)
				*size = sizeof(ngwt__PhoneMessage);
			((ngwt__PhoneMessage*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__PhoneMessage[n];
			if (size)
				*size = n * sizeof(ngwt__PhoneMessage);
			for (int i = 0; i < n; i++)
				((ngwt__PhoneMessage*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__PhoneMessage*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:SharedNotification"))
	{	cp->type = SOAP_TYPE_ngwt__SharedNotification;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__SharedNotification;
			if (size)
				*size = sizeof(ngwt__SharedNotification);
			((ngwt__SharedNotification*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__SharedNotification[n];
			if (size)
				*size = n * sizeof(ngwt__SharedNotification);
			for (int i = 0; i < n; i++)
				((ngwt__SharedNotification*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__SharedNotification*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Appointment"))
	{	cp->type = SOAP_TYPE_ngwt__Appointment;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Appointment;
			if (size)
				*size = sizeof(ngwt__Appointment);
			((ngwt__Appointment*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Appointment[n];
			if (size)
				*size = n * sizeof(ngwt__Appointment);
			for (int i = 0; i < n; i++)
				((ngwt__Appointment*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Appointment*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Note"))
	{	cp->type = SOAP_TYPE_ngwt__Note;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Note;
			if (size)
				*size = sizeof(ngwt__Note);
			((ngwt__Note*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Note[n];
			if (size)
				*size = n * sizeof(ngwt__Note);
			for (int i = 0; i < n; i++)
				((ngwt__Note*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Note*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Task"))
	{	cp->type = SOAP_TYPE_ngwt__Task;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Task;
			if (size)
				*size = sizeof(ngwt__Task);
			((ngwt__Task*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Task[n];
			if (size)
				*size = n * sizeof(ngwt__Task);
			for (int i = 0; i < n; i++)
				((ngwt__Task*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Task*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__BoxEntry;
		if (size)
			*size = sizeof(ngwt__BoxEntry);
		((ngwt__BoxEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__BoxEntry[n];
		if (size)
			*size = n * sizeof(ngwt__BoxEntry);
		for (int i = 0; i < n; i++)
			((ngwt__BoxEntry*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__BoxEntry*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__BoxEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__BoxEntry %p -> %p\n", q, p));
	*(ngwt__BoxEntry*)p = *(ngwt__BoxEntry*)q;
}

void ngwt__Authentication::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void ngwt__Authentication::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int ngwt__Authentication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Authentication);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Authentication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Authentication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Authentication(struct soap *soap, const char *tag, int id, const ngwt__Authentication *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Authentication), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Authentication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Authentication(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Authentication * SOAP_FMAC4 soap_get_ngwt__Authentication(struct soap *soap, ngwt__Authentication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Authentication(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Authentication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Authentication(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Authentication * SOAP_FMAC4 soap_in_ngwt__Authentication(struct soap *soap, const char *tag, ngwt__Authentication *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Authentication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Authentication, sizeof(ngwt__Authentication), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Authentication)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Authentication *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Authentication *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Authentication, 0, sizeof(ngwt__Authentication), 0, soap_copy_ngwt__Authentication);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Authentication * SOAP_FMAC6 soap_new_ngwt__Authentication(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Authentication(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Authentication(struct soap *soap, ngwt__Authentication *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Authentication * SOAP_FMAC6 soap_instantiate_ngwt__Authentication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Authentication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Authentication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:PlainText"))
	{	cp->type = SOAP_TYPE_ngwt__PlainText;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__PlainText;
			if (size)
				*size = sizeof(ngwt__PlainText);
			((ngwt__PlainText*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__PlainText[n];
			if (size)
				*size = n * sizeof(ngwt__PlainText);
			for (int i = 0; i < n; i++)
				((ngwt__PlainText*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__PlainText*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Proxy"))
	{	cp->type = SOAP_TYPE_ngwt__Proxy;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Proxy;
			if (size)
				*size = sizeof(ngwt__Proxy);
			((ngwt__Proxy*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Proxy[n];
			if (size)
				*size = n * sizeof(ngwt__Proxy);
			for (int i = 0; i < n; i++)
				((ngwt__Proxy*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Proxy*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:TrustedApplication"))
	{	cp->type = SOAP_TYPE_ngwt__TrustedApplication;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__TrustedApplication;
			if (size)
				*size = sizeof(ngwt__TrustedApplication);
			((ngwt__TrustedApplication*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__TrustedApplication[n];
			if (size)
				*size = n * sizeof(ngwt__TrustedApplication);
			for (int i = 0; i < n; i++)
				((ngwt__TrustedApplication*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__TrustedApplication*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Authentication;
		if (size)
			*size = sizeof(ngwt__Authentication);
		((ngwt__Authentication*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Authentication[n];
		if (size)
			*size = n * sizeof(ngwt__Authentication);
		for (int i = 0; i < n; i++)
			((ngwt__Authentication*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Authentication*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Authentication(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Authentication %p -> %p\n", q, p));
	*(ngwt__Authentication*)p = *(ngwt__Authentication*)q;
}

void ngwt__AttachmentItemInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__AttachmentItemInfo*)this)->id, SOAP_TYPE_PointerTongwt__AttachmentID);
	soap_serialize_PointerTongwt__AttachmentID(soap, &((ngwt__AttachmentItemInfo*)this)->id);
	soap_embedded(soap, &((ngwt__AttachmentItemInfo*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AttachmentItemInfo*)this)->name);
	soap_embedded(soap, &((ngwt__AttachmentItemInfo*)this)->contentId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AttachmentItemInfo*)this)->contentId);
	soap_embedded(soap, &((ngwt__AttachmentItemInfo*)this)->contentType, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AttachmentItemInfo*)this)->contentType);
	soap_embedded(soap, &((ngwt__AttachmentItemInfo*)this)->size, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__AttachmentItemInfo*)this)->size);
	soap_embedded(soap, &((ngwt__AttachmentItemInfo*)this)->date, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__AttachmentItemInfo*)this)->date);
	soap_embedded(soap, &((ngwt__AttachmentItemInfo*)this)->data, SOAP_TYPE_PointerToxsd__base64Binary);
	soap_serialize_PointerToxsd__base64Binary(soap, &((ngwt__AttachmentItemInfo*)this)->data);
	soap_embedded(soap, &((ngwt__AttachmentItemInfo*)this)->hidden, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__AttachmentItemInfo*)this)->hidden);
	/* transient soap skipped */
}

void ngwt__AttachmentItemInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__AttachmentItemInfo*)this)->id = NULL;
	((ngwt__AttachmentItemInfo*)this)->name = NULL;
	((ngwt__AttachmentItemInfo*)this)->contentId = NULL;
	((ngwt__AttachmentItemInfo*)this)->contentType = NULL;
	((ngwt__AttachmentItemInfo*)this)->size = NULL;
	soap_default_string(soap, &((ngwt__AttachmentItemInfo*)this)->date);
	((ngwt__AttachmentItemInfo*)this)->data = NULL;
	((ngwt__AttachmentItemInfo*)this)->hidden = NULL;
	/* transient soap skipped */
}

int ngwt__AttachmentItemInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AttachmentItemInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AttachmentItemInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AttachmentItemInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AttachmentItemInfo(struct soap *soap, const char *tag, int id, const ngwt__AttachmentItemInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AttachmentItemInfo), type);
	soap_out_PointerTongwt__AttachmentID(soap, "ngwt:id", -1, &(((ngwt__AttachmentItemInfo*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__AttachmentItemInfo*)a)->name), "");
	soap_out_PointerTostd__string(soap, "ngwt:contentId", -1, &(((ngwt__AttachmentItemInfo*)a)->contentId), "");
	soap_out_PointerTostd__string(soap, "ngwt:contentType", -1, &(((ngwt__AttachmentItemInfo*)a)->contentType), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:size", -1, &(((ngwt__AttachmentItemInfo*)a)->size), "");
	soap_out_string(soap, "ngwt:date", -1, &(((ngwt__AttachmentItemInfo*)a)->date), "");
	soap_out_PointerToxsd__base64Binary(soap, "ngwt:data", -1, &(((ngwt__AttachmentItemInfo*)a)->data), "");
	soap_out_PointerTobool(soap, "ngwt:hidden", -1, &(((ngwt__AttachmentItemInfo*)a)->hidden), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AttachmentItemInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AttachmentItemInfo(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AttachmentItemInfo * SOAP_FMAC4 soap_get_ngwt__AttachmentItemInfo(struct soap *soap, ngwt__AttachmentItemInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AttachmentItemInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AttachmentItemInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AttachmentItemInfo(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AttachmentItemInfo * SOAP_FMAC4 soap_in_ngwt__AttachmentItemInfo(struct soap *soap, const char *tag, ngwt__AttachmentItemInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AttachmentItemInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AttachmentItemInfo, sizeof(ngwt__AttachmentItemInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AttachmentItemInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AttachmentItemInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_name1 = 1, soap_flag_contentId1 = 1, soap_flag_contentType1 = 1, soap_flag_size1 = 1, soap_flag_date1 = 1, soap_flag_data1 = 1, soap_flag_hidden1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AttachmentID(soap, "ngwt:id", &(((ngwt__AttachmentItemInfo*)a)->id), "ngwt:AttachmentID"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__AttachmentItemInfo*)a)->name), ""))
				{	soap_flag_name1 = 0;
					continue;
				}
			if (soap_flag_contentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:contentId", &(((ngwt__AttachmentItemInfo*)a)->contentId), ""))
				{	soap_flag_contentId1 = 0;
					continue;
				}
			if (soap_flag_contentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:contentType", &(((ngwt__AttachmentItemInfo*)a)->contentType), ""))
				{	soap_flag_contentType1 = 0;
					continue;
				}
			if (soap_flag_size1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:size", &(((ngwt__AttachmentItemInfo*)a)->size), ""))
				{	soap_flag_size1 = 0;
					continue;
				}
			if (soap_flag_date1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:date", &(((ngwt__AttachmentItemInfo*)a)->date), ""))
				{	soap_flag_date1 = 0;
					continue;
				}
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ngwt:data", &(((ngwt__AttachmentItemInfo*)a)->data), "xsd:base64Binary"))
				{	soap_flag_data1 = 0;
					continue;
				}
			if (soap_flag_hidden1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:hidden", &(((ngwt__AttachmentItemInfo*)a)->hidden), ""))
				{	soap_flag_hidden1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AttachmentItemInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AttachmentItemInfo, 0, sizeof(ngwt__AttachmentItemInfo), 0, soap_copy_ngwt__AttachmentItemInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AttachmentItemInfo * SOAP_FMAC6 soap_new_ngwt__AttachmentItemInfo(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AttachmentItemInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AttachmentItemInfo(struct soap *soap, ngwt__AttachmentItemInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AttachmentItemInfo * SOAP_FMAC6 soap_instantiate_ngwt__AttachmentItemInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AttachmentItemInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AttachmentItemInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AttachmentItemInfo;
		if (size)
			*size = sizeof(ngwt__AttachmentItemInfo);
		((ngwt__AttachmentItemInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AttachmentItemInfo[n];
		if (size)
			*size = n * sizeof(ngwt__AttachmentItemInfo);
		for (int i = 0; i < n; i++)
			((ngwt__AttachmentItemInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AttachmentItemInfo*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AttachmentItemInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AttachmentItemInfo %p -> %p\n", q, p));
	*(ngwt__AttachmentItemInfo*)p = *(ngwt__AttachmentItemInfo*)q;
}

void ngwt__AttachmentInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(soap, &((ngwt__AttachmentInfo*)this)->attachment);
	/* transient soap skipped */
}

void ngwt__AttachmentInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(soap, &((ngwt__AttachmentInfo*)this)->attachment);
	/* transient soap skipped */
}

int ngwt__AttachmentInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AttachmentInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AttachmentInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AttachmentInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AttachmentInfo(struct soap *soap, const char *tag, int id, const ngwt__AttachmentInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AttachmentInfo), type);
	soap_out_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(soap, "ngwt:attachment", -1, &(((ngwt__AttachmentInfo*)a)->attachment), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AttachmentInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AttachmentInfo(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AttachmentInfo * SOAP_FMAC4 soap_get_ngwt__AttachmentInfo(struct soap *soap, ngwt__AttachmentInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AttachmentInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AttachmentInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AttachmentInfo(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AttachmentInfo * SOAP_FMAC4 soap_in_ngwt__AttachmentInfo(struct soap *soap, const char *tag, ngwt__AttachmentInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AttachmentInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AttachmentInfo, sizeof(ngwt__AttachmentInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AttachmentInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AttachmentInfo *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(soap, "ngwt:attachment", &(((ngwt__AttachmentInfo*)a)->attachment), "ngwt:AttachmentItemInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AttachmentInfo *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AttachmentInfo, 0, sizeof(ngwt__AttachmentInfo), 0, soap_copy_ngwt__AttachmentInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AttachmentInfo * SOAP_FMAC6 soap_new_ngwt__AttachmentInfo(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AttachmentInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AttachmentInfo(struct soap *soap, ngwt__AttachmentInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AttachmentInfo * SOAP_FMAC6 soap_instantiate_ngwt__AttachmentInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AttachmentInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AttachmentInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AttachmentInfo;
		if (size)
			*size = sizeof(ngwt__AttachmentInfo);
		((ngwt__AttachmentInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AttachmentInfo[n];
		if (size)
			*size = n * sizeof(ngwt__AttachmentInfo);
		for (int i = 0; i < n; i++)
			((ngwt__AttachmentInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AttachmentInfo*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AttachmentInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AttachmentInfo %p -> %p\n", q, p));
	*(ngwt__AttachmentInfo*)p = *(ngwt__AttachmentInfo*)q;
}

void ngwt__AttachmentID::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__AttachmentID*)this)->__item, SOAP_TYPE_ngwt__uid);
	soap_serialize_ngwt__uid(soap, &((ngwt__AttachmentID*)this)->__item);
	/* transient soap skipped */
}

void ngwt__AttachmentID::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ngwt__uid(soap, &((ngwt__AttachmentID*)this)->__item);
	((ngwt__AttachmentID*)this)->itemReference = NULL;
	/* transient soap skipped */
}

int ngwt__AttachmentID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AttachmentID);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AttachmentID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AttachmentID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AttachmentID(struct soap *soap, const char *tag, int id, const ngwt__AttachmentID *a, const char *type)
{
	if (((ngwt__AttachmentID *)a)->itemReference)
		soap_set_attr(soap, "itemReference", soap_bool2s(soap, *((ngwt__AttachmentID *)a)->itemReference));
	soap_out_ngwt__uid(soap, tag, id, &(((ngwt__AttachmentID*)a)->__item), "");
	return SOAP_OK;
}

void *ngwt__AttachmentID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AttachmentID(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AttachmentID * SOAP_FMAC4 soap_get_ngwt__AttachmentID(struct soap *soap, ngwt__AttachmentID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AttachmentID(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AttachmentID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AttachmentID(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AttachmentID * SOAP_FMAC4 soap_in_ngwt__AttachmentID(struct soap *soap, const char *tag, ngwt__AttachmentID *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ngwt__AttachmentID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AttachmentID, sizeof(ngwt__AttachmentID), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AttachmentID)
			return (ngwt__AttachmentID *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "itemReference", 0);
		if (t)
		{	if (!(((ngwt__AttachmentID *)a)->itemReference = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ngwt__AttachmentID *)a)->itemReference))
		return NULL;
		}
	}
	if (!soap_in_ngwt__uid(soap, tag, &(((ngwt__AttachmentID*)a)->__item), "ngwt:AttachmentID"))
		return NULL;
	return a;
}

SOAP_FMAC5 ngwt__AttachmentID * SOAP_FMAC6 soap_new_ngwt__AttachmentID(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AttachmentID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AttachmentID(struct soap *soap, ngwt__AttachmentID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AttachmentID * SOAP_FMAC6 soap_instantiate_ngwt__AttachmentID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AttachmentID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AttachmentID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AttachmentID;
		if (size)
			*size = sizeof(ngwt__AttachmentID);
		((ngwt__AttachmentID*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AttachmentID[n];
		if (size)
			*size = n * sizeof(ngwt__AttachmentID);
		for (int i = 0; i < n; i++)
			((ngwt__AttachmentID*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AttachmentID*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AttachmentID(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AttachmentID %p -> %p\n", q, p));
	*(ngwt__AttachmentID*)p = *(ngwt__AttachmentID*)q;
}

void ngwt__Appointment::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Appointment*)this)->startDate, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Appointment*)this)->startDate);
	soap_embedded(soap, &((ngwt__Appointment*)this)->endDate, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Appointment*)this)->endDate);
	soap_embedded(soap, &((ngwt__Appointment*)this)->startDay, SOAP_TYPE_PointerToxsd__date);
	soap_serialize_PointerToxsd__date(soap, &((ngwt__Appointment*)this)->startDay);
	soap_embedded(soap, &((ngwt__Appointment*)this)->endDay, SOAP_TYPE_PointerToxsd__date);
	soap_serialize_PointerToxsd__date(soap, &((ngwt__Appointment*)this)->endDay);
	soap_embedded(soap, &((ngwt__Appointment*)this)->acceptLevel, SOAP_TYPE_PointerTongwt__AcceptLevel);
	soap_serialize_PointerTongwt__AcceptLevel(soap, &((ngwt__Appointment*)this)->acceptLevel);
	soap_embedded(soap, &((ngwt__Appointment*)this)->alarm, SOAP_TYPE_PointerTongwt__Alarm);
	soap_serialize_PointerTongwt__Alarm(soap, &((ngwt__Appointment*)this)->alarm);
	soap_embedded(soap, &((ngwt__Appointment*)this)->allDayEvent, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Appointment*)this)->allDayEvent);
	soap_embedded(soap, &((ngwt__Appointment*)this)->place, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Appointment*)this)->place);
	soap_embedded(soap, &((ngwt__Appointment*)this)->timezone, SOAP_TYPE_PointerTongwt__Timezone);
	soap_serialize_PointerTongwt__Timezone(soap, &((ngwt__Appointment*)this)->timezone);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->rdate, SOAP_TYPE_PointerTongwt__RecurrenceDateType);
	soap_serialize_PointerTongwt__RecurrenceDateType(soap, &((ngwt__CalendarItem*)this)->rdate);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->rrule, SOAP_TYPE_PointerTongwt__RecurrenceRule);
	soap_serialize_PointerTongwt__RecurrenceRule(soap, &((ngwt__CalendarItem*)this)->rrule);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->exdate, SOAP_TYPE_PointerTongwt__RecurrenceDateType);
	soap_serialize_PointerTongwt__RecurrenceDateType(soap, &((ngwt__CalendarItem*)this)->exdate);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->recurrenceKey, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__CalendarItem*)this)->recurrenceKey);
	soap_embedded(soap, &((ngwt__CalendarItem*)this)->iCalId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__CalendarItem*)this)->iCalId);
	soap_embedded(soap, &((ngwt__Mail*)this)->subject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subject);
	soap_embedded(soap, &((ngwt__Mail*)this)->originalSubject, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->originalSubject);
	soap_embedded(soap, &((ngwt__Mail*)this)->subjectPrefix, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subjectPrefix);
	soap_embedded(soap, &((ngwt__Mail*)this)->distribution, SOAP_TYPE_PointerTongwt__Distribution);
	soap_serialize_PointerTongwt__Distribution(soap, &((ngwt__Mail*)this)->distribution);
	soap_embedded(soap, &((ngwt__Mail*)this)->message, SOAP_TYPE_PointerTongwt__MessageBody);
	soap_serialize_PointerTongwt__MessageBody(soap, &((ngwt__Mail*)this)->message);
	soap_embedded(soap, &((ngwt__Mail*)this)->attachments, SOAP_TYPE_PointerTongwt__AttachmentInfo);
	soap_serialize_PointerTongwt__AttachmentInfo(soap, &((ngwt__Mail*)this)->attachments);
	soap_embedded(soap, &((ngwt__Mail*)this)->options, SOAP_TYPE_PointerTongwt__ItemOptions);
	soap_serialize_PointerTongwt__ItemOptions(soap, &((ngwt__Mail*)this)->options);
	soap_embedded(soap, &((ngwt__Mail*)this)->link, SOAP_TYPE_PointerTongwt__LinkInfo);
	soap_serialize_PointerTongwt__LinkInfo(soap, &((ngwt__Mail*)this)->link);
	soap_embedded(soap, &((ngwt__Mail*)this)->hasAttachment, SOAP_TYPE_bool);
	soap_embedded(soap, &((ngwt__Mail*)this)->size, SOAP_TYPE_int);
	soap_embedded(soap, &((ngwt__Mail*)this)->subType, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Mail*)this)->subType);
	soap_embedded(soap, &((ngwt__Mail*)this)->nntpOrImap, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__Mail*)this)->nntpOrImap);
	soap_embedded(soap, &((ngwt__Mail*)this)->smimeType, SOAP_TYPE_PointerTongwt__SMimeOperation);
	soap_serialize_PointerTongwt__SMimeOperation(soap, &((ngwt__Mail*)this)->smimeType);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->status, SOAP_TYPE_PointerTongwt__ItemStatus);
	soap_serialize_PointerTongwt__ItemStatus(soap, &((ngwt__BoxEntry*)this)->status);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->thread, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->thread);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->msgId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->msgId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->messageId, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->messageId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->source, SOAP_TYPE_PointerTongwt__ItemSource);
	soap_serialize_PointerTongwt__ItemSource(soap, &((ngwt__BoxEntry*)this)->source);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__BoxEntry*)this)->returnSentItemsId);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->delivered, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->class_, SOAP_TYPE_PointerTongwt__ItemClass);
	soap_serialize_PointerTongwt__ItemClass(soap, &((ngwt__BoxEntry*)this)->class_);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->security, SOAP_TYPE_PointerTongwt__ItemSecurity);
	soap_serialize_PointerTongwt__ItemSecurity(soap, &((ngwt__BoxEntry*)this)->security);
	soap_embedded(soap, &((ngwt__BoxEntry*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__BoxEntry*)this)->comment);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__Appointment::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ngwt__Appointment*)this)->startDate);
	soap_default_string(soap, &((ngwt__Appointment*)this)->endDate);
	((ngwt__Appointment*)this)->startDay = NULL;
	((ngwt__Appointment*)this)->endDay = NULL;
	((ngwt__Appointment*)this)->acceptLevel = NULL;
	((ngwt__Appointment*)this)->alarm = NULL;
	((ngwt__Appointment*)this)->allDayEvent = NULL;
	((ngwt__Appointment*)this)->place = NULL;
	((ngwt__Appointment*)this)->timezone = NULL;
	((ngwt__CalendarItem*)this)->rdate = NULL;
	((ngwt__CalendarItem*)this)->rrule = NULL;
	((ngwt__CalendarItem*)this)->exdate = NULL;
	((ngwt__CalendarItem*)this)->recurrenceKey = NULL;
	((ngwt__CalendarItem*)this)->iCalId = NULL;
	((ngwt__Mail*)this)->subject = NULL;
	((ngwt__Mail*)this)->originalSubject = NULL;
	((ngwt__Mail*)this)->subjectPrefix = NULL;
	((ngwt__Mail*)this)->distribution = NULL;
	((ngwt__Mail*)this)->message = NULL;
	((ngwt__Mail*)this)->attachments = NULL;
	((ngwt__Mail*)this)->options = NULL;
	((ngwt__Mail*)this)->link = NULL;
	((ngwt__Mail*)this)->hasAttachment = (bool)0;
	((ngwt__Mail*)this)->size = 0;
	((ngwt__Mail*)this)->subType = NULL;
	((ngwt__Mail*)this)->nntpOrImap = NULL;
	((ngwt__Mail*)this)->smimeType = NULL;
	((ngwt__BoxEntry*)this)->status = NULL;
	((ngwt__BoxEntry*)this)->thread = NULL;
	((ngwt__BoxEntry*)this)->msgId = NULL;
	((ngwt__BoxEntry*)this)->messageId = NULL;
	((ngwt__BoxEntry*)this)->source = NULL;
	((ngwt__BoxEntry*)this)->returnSentItemsId = NULL;
	soap_default_string(soap, &((ngwt__BoxEntry*)this)->delivered);
	((ngwt__BoxEntry*)this)->class_ = NULL;
	((ngwt__BoxEntry*)this)->security = NULL;
	((ngwt__BoxEntry*)this)->comment = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__Appointment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Appointment);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Appointment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Appointment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Appointment(struct soap *soap, const char *tag, int id, const ngwt__Appointment *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__Appointment), "ngwt:Appointment");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__ItemStatus(soap, "ngwt:status", -1, &(((ngwt__BoxEntry*)a)->status), "");
	soap_out_PointerTostd__string(soap, "ngwt:thread", -1, &(((ngwt__BoxEntry*)a)->thread), "");
	soap_out_PointerTostd__string(soap, "ngwt:msgId", -1, &(((ngwt__BoxEntry*)a)->msgId), "");
	soap_out_PointerTostd__string(soap, "ngwt:messageId", -1, &(((ngwt__BoxEntry*)a)->messageId), "");
	soap_out_PointerTongwt__ItemSource(soap, "ngwt:source", -1, &(((ngwt__BoxEntry*)a)->source), "");
	soap_out_PointerTobool(soap, "ngwt:returnSentItemsId", -1, &(((ngwt__BoxEntry*)a)->returnSentItemsId), "");
	soap_out_string(soap, "ngwt:delivered", -1, &(((ngwt__BoxEntry*)a)->delivered), "");
	soap_out_PointerTongwt__ItemClass(soap, "ngwt:class", -1, &(((ngwt__BoxEntry*)a)->class_), "");
	soap_out_PointerTongwt__ItemSecurity(soap, "ngwt:security", -1, &(((ngwt__BoxEntry*)a)->security), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__BoxEntry*)a)->comment), "");
	soap_out_PointerTostd__string(soap, "ngwt:subject", -1, &(((ngwt__Mail*)a)->subject), "");
	soap_out_PointerTostd__string(soap, "ngwt:originalSubject", -1, &(((ngwt__Mail*)a)->originalSubject), "");
	soap_out_PointerTostd__string(soap, "ngwt:subjectPrefix", -1, &(((ngwt__Mail*)a)->subjectPrefix), "");
	soap_out_PointerTongwt__Distribution(soap, "ngwt:distribution", -1, &(((ngwt__Mail*)a)->distribution), "");
	soap_out_PointerTongwt__MessageBody(soap, "ngwt:message", -1, &(((ngwt__Mail*)a)->message), "");
	soap_out_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", -1, &(((ngwt__Mail*)a)->attachments), "");
	soap_out_PointerTongwt__ItemOptions(soap, "ngwt:options", -1, &(((ngwt__Mail*)a)->options), "");
	soap_out_PointerTongwt__LinkInfo(soap, "ngwt:link", -1, &(((ngwt__Mail*)a)->link), "");
	soap_out_bool(soap, "ngwt:hasAttachment", -1, &(((ngwt__Mail*)a)->hasAttachment), "");
	soap_out_int(soap, "ngwt:size", -1, &(((ngwt__Mail*)a)->size), "");
	soap_out_PointerTostd__string(soap, "ngwt:subType", -1, &(((ngwt__Mail*)a)->subType), "");
	soap_out_PointerTobool(soap, "ngwt:nntpOrImap", -1, &(((ngwt__Mail*)a)->nntpOrImap), "");
	soap_out_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", -1, &(((ngwt__Mail*)a)->smimeType), "");
	soap_out_PointerTongwt__RecurrenceDateType(soap, "ngwt:rdate", -1, &(((ngwt__CalendarItem*)a)->rdate), "");
	soap_out_PointerTongwt__RecurrenceRule(soap, "ngwt:rrule", -1, &(((ngwt__CalendarItem*)a)->rrule), "");
	soap_out_PointerTongwt__RecurrenceDateType(soap, "ngwt:exdate", -1, &(((ngwt__CalendarItem*)a)->exdate), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:recurrenceKey", -1, &(((ngwt__CalendarItem*)a)->recurrenceKey), "");
	soap_out_PointerTostd__string(soap, "ngwt:iCalId", -1, &(((ngwt__CalendarItem*)a)->iCalId), "");
	soap_out_string(soap, "ngwt:startDate", -1, &(((ngwt__Appointment*)a)->startDate), "");
	soap_out_string(soap, "ngwt:endDate", -1, &(((ngwt__Appointment*)a)->endDate), "");
	soap_out_PointerToxsd__date(soap, "ngwt:startDay", -1, &(((ngwt__Appointment*)a)->startDay), "");
	soap_out_PointerToxsd__date(soap, "ngwt:endDay", -1, &(((ngwt__Appointment*)a)->endDay), "");
	soap_out_PointerTongwt__AcceptLevel(soap, "ngwt:acceptLevel", -1, &(((ngwt__Appointment*)a)->acceptLevel), "");
	soap_out_PointerTongwt__Alarm(soap, "ngwt:alarm", -1, &(((ngwt__Appointment*)a)->alarm), "");
	soap_out_PointerTobool(soap, "ngwt:allDayEvent", -1, &(((ngwt__Appointment*)a)->allDayEvent), "");
	soap_out_PointerTostd__string(soap, "ngwt:place", -1, &(((ngwt__Appointment*)a)->place), "");
	soap_out_PointerTongwt__Timezone(soap, "ngwt:timezone", -1, &(((ngwt__Appointment*)a)->timezone), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__Appointment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Appointment(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Appointment * SOAP_FMAC4 soap_get_ngwt__Appointment(struct soap *soap, ngwt__Appointment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Appointment(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Appointment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Appointment(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Appointment * SOAP_FMAC4 soap_in_ngwt__Appointment(struct soap *soap, const char *tag, ngwt__Appointment *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__Appointment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Appointment, sizeof(ngwt__Appointment), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Appointment)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__Appointment *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id6 = 1, soap_flag_name6 = 1, soap_flag_version6 = 1, soap_flag_modified6 = 1, soap_flag_changes6 = 1, soap_flag_categories5 = 1, soap_flag_created5 = 1, soap_flag_customs5 = 1, soap_flag_status4 = 1, soap_flag_thread4 = 1, soap_flag_msgId4 = 1, soap_flag_messageId4 = 1, soap_flag_source4 = 1, soap_flag_returnSentItemsId4 = 1, soap_flag_delivered4 = 1, soap_flag_class_4 = 1, soap_flag_security4 = 1, soap_flag_comment4 = 1, soap_flag_subject3 = 1, soap_flag_originalSubject3 = 1, soap_flag_subjectPrefix3 = 1, soap_flag_distribution3 = 1, soap_flag_message3 = 1, soap_flag_attachments3 = 1, soap_flag_options3 = 1, soap_flag_link3 = 1, soap_flag_hasAttachment3 = 1, soap_flag_size3 = 1, soap_flag_subType3 = 1, soap_flag_nntpOrImap3 = 1, soap_flag_smimeType3 = 1, soap_flag_rdate2 = 1, soap_flag_rrule2 = 1, soap_flag_exdate2 = 1, soap_flag_recurrenceKey2 = 1, soap_flag_iCalId2 = 1, soap_flag_startDate1 = 1, soap_flag_endDate1 = 1, soap_flag_startDay1 = 1, soap_flag_endDay1 = 1, soap_flag_acceptLevel1 = 1, soap_flag_alarm1 = 1, soap_flag_allDayEvent1 = 1, soap_flag_place1 = 1, soap_flag_timezone1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id6 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id6 = 0;
					continue;
				}
			if (soap_flag_name6 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name6 = 0;
					continue;
				}
			if (soap_flag_version6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version6 = 0;
					continue;
				}
			if (soap_flag_modified6 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified6 = 0;
					continue;
				}
			if (soap_flag_changes6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes6 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories5 = 0;
					continue;
				}
			if (soap_flag_created5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created5 = 0;
					continue;
				}
			if (soap_flag_customs5 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs5 = 0;
					continue;
				}
			if (soap_flag_status4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemStatus(soap, "ngwt:status", &(((ngwt__BoxEntry*)a)->status), "ngwt:ItemStatus"))
				{	soap_flag_status4 = 0;
					continue;
				}
			if (soap_flag_thread4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:thread", &(((ngwt__BoxEntry*)a)->thread), ""))
				{	soap_flag_thread4 = 0;
					continue;
				}
			if (soap_flag_msgId4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:msgId", &(((ngwt__BoxEntry*)a)->msgId), ""))
				{	soap_flag_msgId4 = 0;
					continue;
				}
			if (soap_flag_messageId4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:messageId", &(((ngwt__BoxEntry*)a)->messageId), ""))
				{	soap_flag_messageId4 = 0;
					continue;
				}
			if (soap_flag_source4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSource(soap, "ngwt:source", &(((ngwt__BoxEntry*)a)->source), ""))
				{	soap_flag_source4 = 0;
					continue;
				}
			if (soap_flag_returnSentItemsId4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:returnSentItemsId", &(((ngwt__BoxEntry*)a)->returnSentItemsId), ""))
				{	soap_flag_returnSentItemsId4 = 0;
					continue;
				}
			if (soap_flag_delivered4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:delivered", &(((ngwt__BoxEntry*)a)->delivered), ""))
				{	soap_flag_delivered4 = 0;
					continue;
				}
			if (soap_flag_class_4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemClass(soap, "ngwt:class", &(((ngwt__BoxEntry*)a)->class_), ""))
				{	soap_flag_class_4 = 0;
					continue;
				}
			if (soap_flag_security4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemSecurity(soap, "ngwt:security", &(((ngwt__BoxEntry*)a)->security), ""))
				{	soap_flag_security4 = 0;
					continue;
				}
			if (soap_flag_comment4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__BoxEntry*)a)->comment), ""))
				{	soap_flag_comment4 = 0;
					continue;
				}
			if (soap_flag_subject3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subject", &(((ngwt__Mail*)a)->subject), ""))
				{	soap_flag_subject3 = 0;
					continue;
				}
			if (soap_flag_originalSubject3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:originalSubject", &(((ngwt__Mail*)a)->originalSubject), ""))
				{	soap_flag_originalSubject3 = 0;
					continue;
				}
			if (soap_flag_subjectPrefix3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subjectPrefix", &(((ngwt__Mail*)a)->subjectPrefix), ""))
				{	soap_flag_subjectPrefix3 = 0;
					continue;
				}
			if (soap_flag_distribution3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Distribution(soap, "ngwt:distribution", &(((ngwt__Mail*)a)->distribution), "ngwt:Distribution"))
				{	soap_flag_distribution3 = 0;
					continue;
				}
			if (soap_flag_message3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__MessageBody(soap, "ngwt:message", &(((ngwt__Mail*)a)->message), "ngwt:MessageBody"))
				{	soap_flag_message3 = 0;
					continue;
				}
			if (soap_flag_attachments3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AttachmentInfo(soap, "ngwt:attachments", &(((ngwt__Mail*)a)->attachments), "ngwt:AttachmentInfo"))
				{	soap_flag_attachments3 = 0;
					continue;
				}
			if (soap_flag_options3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemOptions(soap, "ngwt:options", &(((ngwt__Mail*)a)->options), "ngwt:ItemOptions"))
				{	soap_flag_options3 = 0;
					continue;
				}
			if (soap_flag_link3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__LinkInfo(soap, "ngwt:link", &(((ngwt__Mail*)a)->link), "ngwt:LinkInfo"))
				{	soap_flag_link3 = 0;
					continue;
				}
			if (soap_flag_hasAttachment3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:hasAttachment", &(((ngwt__Mail*)a)->hasAttachment), ""))
				{	soap_flag_hasAttachment3 = 0;
					continue;
				}
			if (soap_flag_size3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ngwt:size", &(((ngwt__Mail*)a)->size), ""))
				{	soap_flag_size3 = 0;
					continue;
				}
			if (soap_flag_subType3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:subType", &(((ngwt__Mail*)a)->subType), ""))
				{	soap_flag_subType3 = 0;
					continue;
				}
			if (soap_flag_nntpOrImap3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:nntpOrImap", &(((ngwt__Mail*)a)->nntpOrImap), ""))
				{	soap_flag_nntpOrImap3 = 0;
					continue;
				}
			if (soap_flag_smimeType3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__SMimeOperation(soap, "ngwt:smimeType", &(((ngwt__Mail*)a)->smimeType), "ngwt:SMimeOperation"))
				{	soap_flag_smimeType3 = 0;
					continue;
				}
			if (soap_flag_rdate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceDateType(soap, "ngwt:rdate", &(((ngwt__CalendarItem*)a)->rdate), "ngwt:RecurrenceDateType"))
				{	soap_flag_rdate2 = 0;
					continue;
				}
			if (soap_flag_rrule2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceRule(soap, "ngwt:rrule", &(((ngwt__CalendarItem*)a)->rrule), "ngwt:RecurrenceRule"))
				{	soap_flag_rrule2 = 0;
					continue;
				}
			if (soap_flag_exdate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__RecurrenceDateType(soap, "ngwt:exdate", &(((ngwt__CalendarItem*)a)->exdate), "ngwt:RecurrenceDateType"))
				{	soap_flag_exdate2 = 0;
					continue;
				}
			if (soap_flag_recurrenceKey2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:recurrenceKey", &(((ngwt__CalendarItem*)a)->recurrenceKey), ""))
				{	soap_flag_recurrenceKey2 = 0;
					continue;
				}
			if (soap_flag_iCalId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:iCalId", &(((ngwt__CalendarItem*)a)->iCalId), ""))
				{	soap_flag_iCalId2 = 0;
					continue;
				}
			if (soap_flag_startDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:startDate", &(((ngwt__Appointment*)a)->startDate), ""))
				{	soap_flag_startDate1 = 0;
					continue;
				}
			if (soap_flag_endDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:endDate", &(((ngwt__Appointment*)a)->endDate), ""))
				{	soap_flag_endDate1 = 0;
					continue;
				}
			if (soap_flag_startDay1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__date(soap, "ngwt:startDay", &(((ngwt__Appointment*)a)->startDay), "xsd:date"))
				{	soap_flag_startDay1 = 0;
					continue;
				}
			if (soap_flag_endDay1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__date(soap, "ngwt:endDay", &(((ngwt__Appointment*)a)->endDay), "xsd:date"))
				{	soap_flag_endDay1 = 0;
					continue;
				}
			if (soap_flag_acceptLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AcceptLevel(soap, "ngwt:acceptLevel", &(((ngwt__Appointment*)a)->acceptLevel), ""))
				{	soap_flag_acceptLevel1 = 0;
					continue;
				}
			if (soap_flag_alarm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Alarm(soap, "ngwt:alarm", &(((ngwt__Appointment*)a)->alarm), "ngwt:Alarm"))
				{	soap_flag_alarm1 = 0;
					continue;
				}
			if (soap_flag_allDayEvent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:allDayEvent", &(((ngwt__Appointment*)a)->allDayEvent), ""))
				{	soap_flag_allDayEvent1 = 0;
					continue;
				}
			if (soap_flag_place1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:place", &(((ngwt__Appointment*)a)->place), ""))
				{	soap_flag_place1 = 0;
					continue;
				}
			if (soap_flag_timezone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Timezone(soap, "ngwt:timezone", &(((ngwt__Appointment*)a)->timezone), "ngwt:Timezone"))
				{	soap_flag_timezone1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_delivered4))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__Appointment *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Appointment, 0, sizeof(ngwt__Appointment), 0, soap_copy_ngwt__Appointment);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__Appointment * SOAP_FMAC6 soap_new_ngwt__Appointment(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Appointment(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Appointment(struct soap *soap, ngwt__Appointment *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Appointment * SOAP_FMAC6 soap_instantiate_ngwt__Appointment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Appointment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Appointment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Appointment;
		if (size)
			*size = sizeof(ngwt__Appointment);
		((ngwt__Appointment*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Appointment[n];
		if (size)
			*size = n * sizeof(ngwt__Appointment);
		for (int i = 0; i < n; i++)
			((ngwt__Appointment*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Appointment*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Appointment(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Appointment %p -> %p\n", q, p));
	*(ngwt__Appointment*)p = *(ngwt__Appointment*)q;
}

void ngwt__Alarm::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__Alarm*)this)->__item, SOAP_TYPE_int);
	/* transient soap skipped */
}

void ngwt__Alarm::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ngwt__Alarm*)this)->__item);
	((ngwt__Alarm*)this)->enabled = NULL;
	/* transient soap skipped */
}

int ngwt__Alarm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__Alarm);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__Alarm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__Alarm(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__Alarm(struct soap *soap, const char *tag, int id, const ngwt__Alarm *a, const char *type)
{
	if (((ngwt__Alarm *)a)->enabled)
		soap_set_attr(soap, "enabled", soap_bool2s(soap, *((ngwt__Alarm *)a)->enabled));
	soap_out_int(soap, tag, id, &(((ngwt__Alarm*)a)->__item), "");
	return SOAP_OK;
}

void *ngwt__Alarm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__Alarm(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__Alarm * SOAP_FMAC4 soap_get_ngwt__Alarm(struct soap *soap, ngwt__Alarm *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__Alarm(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__Alarm::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__Alarm(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__Alarm * SOAP_FMAC4 soap_in_ngwt__Alarm(struct soap *soap, const char *tag, ngwt__Alarm *a, const char *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!(a = (ngwt__Alarm *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__Alarm, sizeof(ngwt__Alarm), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__Alarm)
			return (ngwt__Alarm *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "enabled", 0);
		if (t)
		{	if (!(((ngwt__Alarm *)a)->enabled = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ngwt__Alarm *)a)->enabled))
		return NULL;
		}
	}
	if (!soap_in_int(soap, tag, &(((ngwt__Alarm*)a)->__item), "ngwt:Alarm"))
		return NULL;
	return a;
}

SOAP_FMAC5 ngwt__Alarm * SOAP_FMAC6 soap_new_ngwt__Alarm(struct soap *soap, int n)
{	return soap_instantiate_ngwt__Alarm(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__Alarm(struct soap *soap, ngwt__Alarm *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__Alarm * SOAP_FMAC6 soap_instantiate_ngwt__Alarm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__Alarm(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__Alarm, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__Alarm;
		if (size)
			*size = sizeof(ngwt__Alarm);
		((ngwt__Alarm*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__Alarm[n];
		if (size)
			*size = n * sizeof(ngwt__Alarm);
		for (int i = 0; i < n; i++)
			((ngwt__Alarm*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__Alarm*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__Alarm(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__Alarm %p -> %p\n", q, p));
	*(ngwt__Alarm*)p = *(ngwt__Alarm*)q;
}

void ngwt__AddressBookList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__AddressBook(soap, &((ngwt__AddressBookList*)this)->book);
	/* transient soap skipped */
}

void ngwt__AddressBookList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__AddressBook(soap, &((ngwt__AddressBookList*)this)->book);
	/* transient soap skipped */
}

int ngwt__AddressBookList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AddressBookList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AddressBookList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AddressBookList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AddressBookList(struct soap *soap, const char *tag, int id, const ngwt__AddressBookList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AddressBookList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__AddressBook(soap, "ngwt:book", -1, &(((ngwt__AddressBookList*)a)->book), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AddressBookList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AddressBookList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AddressBookList * SOAP_FMAC4 soap_get_ngwt__AddressBookList(struct soap *soap, ngwt__AddressBookList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AddressBookList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AddressBookList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AddressBookList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AddressBookList * SOAP_FMAC4 soap_in_ngwt__AddressBookList(struct soap *soap, const char *tag, ngwt__AddressBookList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AddressBookList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AddressBookList, sizeof(ngwt__AddressBookList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AddressBookList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AddressBookList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__AddressBook(soap, "ngwt:book", &(((ngwt__AddressBookList*)a)->book), "ngwt:AddressBook"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AddressBookList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AddressBookList, 0, sizeof(ngwt__AddressBookList), 0, soap_copy_ngwt__AddressBookList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AddressBookList * SOAP_FMAC6 soap_new_ngwt__AddressBookList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AddressBookList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AddressBookList(struct soap *soap, ngwt__AddressBookList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AddressBookList * SOAP_FMAC6 soap_instantiate_ngwt__AddressBookList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AddressBookList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AddressBookList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AddressBookList;
		if (size)
			*size = sizeof(ngwt__AddressBookList);
		((ngwt__AddressBookList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AddressBookList[n];
		if (size)
			*size = n * sizeof(ngwt__AddressBookList);
		for (int i = 0; i < n; i++)
			((ngwt__AddressBookList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AddressBookList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AddressBookList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AddressBookList %p -> %p\n", q, p));
	*(ngwt__AddressBookList*)p = *(ngwt__AddressBookList*)q;
}

void ngwt__AddressBookItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__AddressBookItem*)this)->uuid);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->comment, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->comment);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->sync, SOAP_TYPE_PointerTongwt__DeltaSyncType);
	soap_serialize_PointerTongwt__DeltaSyncType(soap, &((ngwt__AddressBookItem*)this)->sync);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->domain, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->domain);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->postOffice, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->postOffice);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->distinguishedName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->distinguishedName);
	soap_embedded(soap, &((ngwt__AddressBookItem*)this)->userid, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBookItem*)this)->userid);
	soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->categories, SOAP_TYPE_PointerTongwt__CategoryRefList);
	soap_serialize_PointerTongwt__CategoryRefList(soap, &((ngwt__ContainerItem*)this)->categories);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->created, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__ContainerItem*)this)->created);
	soap_embedded(soap, &((ngwt__ContainerItem*)this)->customs, SOAP_TYPE_PointerTongwt__CustomList);
	soap_serialize_PointerTongwt__CustomList(soap, &((ngwt__ContainerItem*)this)->customs);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__AddressBookItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__AddressBookItem*)this)->uuid = NULL;
	((ngwt__AddressBookItem*)this)->comment = NULL;
	((ngwt__AddressBookItem*)this)->sync = NULL;
	((ngwt__AddressBookItem*)this)->domain = NULL;
	((ngwt__AddressBookItem*)this)->postOffice = NULL;
	((ngwt__AddressBookItem*)this)->distinguishedName = NULL;
	((ngwt__AddressBookItem*)this)->userid = NULL;
	soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, &((ngwt__ContainerItem*)this)->container);
	((ngwt__ContainerItem*)this)->categories = NULL;
	soap_default_string(soap, &((ngwt__ContainerItem*)this)->created);
	((ngwt__ContainerItem*)this)->customs = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__AddressBookItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AddressBookItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AddressBookItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AddressBookItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AddressBookItem(struct soap *soap, const char *tag, int id, const ngwt__AddressBookItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AddressBookItem), "ngwt:AddressBookItem");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", -1, &(((ngwt__ContainerItem*)a)->container), "");
	soap_out_PointerTongwt__CategoryRefList(soap, "ngwt:categories", -1, &(((ngwt__ContainerItem*)a)->categories), "");
	soap_out_string(soap, "ngwt:created", -1, &(((ngwt__ContainerItem*)a)->created), "");
	soap_out_PointerTongwt__CustomList(soap, "ngwt:customs", -1, &(((ngwt__ContainerItem*)a)->customs), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__AddressBookItem*)a)->uuid), "");
	soap_out_PointerTostd__string(soap, "ngwt:comment", -1, &(((ngwt__AddressBookItem*)a)->comment), "");
	soap_out_PointerTongwt__DeltaSyncType(soap, "ngwt:sync", -1, &(((ngwt__AddressBookItem*)a)->sync), "");
	soap_out_PointerTostd__string(soap, "ngwt:domain", -1, &(((ngwt__AddressBookItem*)a)->domain), "");
	soap_out_PointerTostd__string(soap, "ngwt:postOffice", -1, &(((ngwt__AddressBookItem*)a)->postOffice), "");
	soap_out_PointerTostd__string(soap, "ngwt:distinguishedName", -1, &(((ngwt__AddressBookItem*)a)->distinguishedName), "");
	soap_out_PointerTostd__string(soap, "ngwt:userid", -1, &(((ngwt__AddressBookItem*)a)->userid), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AddressBookItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AddressBookItem(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AddressBookItem * SOAP_FMAC4 soap_get_ngwt__AddressBookItem(struct soap *soap, ngwt__AddressBookItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AddressBookItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AddressBookItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AddressBookItem(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AddressBookItem * SOAP_FMAC4 soap_in_ngwt__AddressBookItem(struct soap *soap, const char *tag, ngwt__AddressBookItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AddressBookItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AddressBookItem, sizeof(ngwt__AddressBookItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AddressBookItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AddressBookItem *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id3 = 1, soap_flag_name3 = 1, soap_flag_version3 = 1, soap_flag_modified3 = 1, soap_flag_changes3 = 1, soap_flag_categories2 = 1, soap_flag_created2 = 1, soap_flag_customs2 = 1, soap_flag_uuid1 = 1, soap_flag_comment1 = 1, soap_flag_sync1 = 1, soap_flag_domain1 = 1, soap_flag_postOffice1 = 1, soap_flag_distinguishedName1 = 1, soap_flag_userid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id3 = 0;
					continue;
				}
			if (soap_flag_name3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name3 = 0;
					continue;
				}
			if (soap_flag_version3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version3 = 0;
					continue;
				}
			if (soap_flag_modified3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified3 = 0;
					continue;
				}
			if (soap_flag_changes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes3 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, "ngwt:container", &(((ngwt__ContainerItem*)a)->container), "ngwt:ContainerRef"))
					continue;
			if (soap_flag_categories2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CategoryRefList(soap, "ngwt:categories", &(((ngwt__ContainerItem*)a)->categories), "ngwt:CategoryRefList"))
				{	soap_flag_categories2 = 0;
					continue;
				}
			if (soap_flag_created2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:created", &(((ngwt__ContainerItem*)a)->created), ""))
				{	soap_flag_created2 = 0;
					continue;
				}
			if (soap_flag_customs2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__CustomList(soap, "ngwt:customs", &(((ngwt__ContainerItem*)a)->customs), "ngwt:CustomList"))
				{	soap_flag_customs2 = 0;
					continue;
				}
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__AddressBookItem*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid1 = 0;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:comment", &(((ngwt__AddressBookItem*)a)->comment), ""))
				{	soap_flag_comment1 = 0;
					continue;
				}
			if (soap_flag_sync1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__DeltaSyncType(soap, "ngwt:sync", &(((ngwt__AddressBookItem*)a)->sync), ""))
				{	soap_flag_sync1 = 0;
					continue;
				}
			if (soap_flag_domain1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:domain", &(((ngwt__AddressBookItem*)a)->domain), ""))
				{	soap_flag_domain1 = 0;
					continue;
				}
			if (soap_flag_postOffice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:postOffice", &(((ngwt__AddressBookItem*)a)->postOffice), ""))
				{	soap_flag_postOffice1 = 0;
					continue;
				}
			if (soap_flag_distinguishedName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:distinguishedName", &(((ngwt__AddressBookItem*)a)->distinguishedName), ""))
				{	soap_flag_distinguishedName1 = 0;
					continue;
				}
			if (soap_flag_userid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:userid", &(((ngwt__AddressBookItem*)a)->userid), ""))
				{	soap_flag_userid1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AddressBookItem *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AddressBookItem, 0, sizeof(ngwt__AddressBookItem), 0, soap_copy_ngwt__AddressBookItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AddressBookItem * SOAP_FMAC6 soap_new_ngwt__AddressBookItem(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AddressBookItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AddressBookItem(struct soap *soap, ngwt__AddressBookItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AddressBookItem * SOAP_FMAC6 soap_instantiate_ngwt__AddressBookItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AddressBookItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AddressBookItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:Contact"))
	{	cp->type = SOAP_TYPE_ngwt__Contact;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Contact;
			if (size)
				*size = sizeof(ngwt__Contact);
			((ngwt__Contact*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Contact[n];
			if (size)
				*size = n * sizeof(ngwt__Contact);
			for (int i = 0; i < n; i++)
				((ngwt__Contact*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Contact*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Group"))
	{	cp->type = SOAP_TYPE_ngwt__Group;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Group;
			if (size)
				*size = sizeof(ngwt__Group);
			((ngwt__Group*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Group[n];
			if (size)
				*size = n * sizeof(ngwt__Group);
			for (int i = 0; i < n; i++)
				((ngwt__Group*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Group*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Organization"))
	{	cp->type = SOAP_TYPE_ngwt__Organization;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Organization;
			if (size)
				*size = sizeof(ngwt__Organization);
			((ngwt__Organization*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Organization[n];
			if (size)
				*size = n * sizeof(ngwt__Organization);
			for (int i = 0; i < n; i++)
				((ngwt__Organization*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Organization*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ngwt:Resource"))
	{	cp->type = SOAP_TYPE_ngwt__Resource;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__Resource;
			if (size)
				*size = sizeof(ngwt__Resource);
			((ngwt__Resource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__Resource[n];
			if (size)
				*size = n * sizeof(ngwt__Resource);
			for (int i = 0; i < n; i++)
				((ngwt__Resource*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__Resource*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AddressBookItem;
		if (size)
			*size = sizeof(ngwt__AddressBookItem);
		((ngwt__AddressBookItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AddressBookItem[n];
		if (size)
			*size = n * sizeof(ngwt__AddressBookItem);
		for (int i = 0; i < n; i++)
			((ngwt__AddressBookItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AddressBookItem*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AddressBookItem(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AddressBookItem %p -> %p\n", q, p));
	*(ngwt__AddressBookItem*)p = *(ngwt__AddressBookItem*)q;
}

void ngwt__AddressBook::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__AddressBook*)this)->description, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__AddressBook*)this)->description);
	soap_embedded(soap, &((ngwt__AddressBook*)this)->isPersonal, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__AddressBook*)this)->isPersonal);
	soap_embedded(soap, &((ngwt__AddressBook*)this)->isFrequentContacts, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__AddressBook*)this)->isFrequentContacts);
	soap_embedded(soap, &((ngwt__Item*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__Item*)this)->id);
	soap_embedded(soap, &((ngwt__Item*)this)->name, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__Item*)this)->name);
	soap_embedded(soap, &((ngwt__Item*)this)->version, SOAP_TYPE_PointerTounsignedLong);
	soap_serialize_PointerTounsignedLong(soap, &((ngwt__Item*)this)->version);
	soap_embedded(soap, &((ngwt__Item*)this)->modified, SOAP_TYPE_string);
	soap_serialize_string(soap, &((ngwt__Item*)this)->modified);
	soap_embedded(soap, &((ngwt__Item*)this)->changes, SOAP_TYPE_PointerTongwt__ItemChanges);
	soap_serialize_PointerTongwt__ItemChanges(soap, &((ngwt__Item*)this)->changes);
	/* transient soap skipped */
}

void ngwt__AddressBook::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__AddressBook*)this)->description = NULL;
	((ngwt__AddressBook*)this)->isPersonal = NULL;
	((ngwt__AddressBook*)this)->isFrequentContacts = NULL;
	((ngwt__Item*)this)->id = NULL;
	((ngwt__Item*)this)->name = NULL;
	((ngwt__Item*)this)->version = NULL;
	soap_default_string(soap, &((ngwt__Item*)this)->modified);
	((ngwt__Item*)this)->changes = NULL;
	/* transient soap skipped */
}

int ngwt__AddressBook::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AddressBook);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AddressBook::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AddressBook(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AddressBook(struct soap *soap, const char *tag, int id, const ngwt__AddressBook *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AddressBook), "ngwt:AddressBook");
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__Item*)a)->id), "");
	soap_out_PointerTostd__string(soap, "ngwt:name", -1, &(((ngwt__Item*)a)->name), "");
	soap_out_PointerTounsignedLong(soap, "ngwt:version", -1, &(((ngwt__Item*)a)->version), "");
	soap_out_string(soap, "ngwt:modified", -1, &(((ngwt__Item*)a)->modified), "");
	soap_out_PointerTongwt__ItemChanges(soap, "ngwt:changes", -1, &(((ngwt__Item*)a)->changes), "");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "ngwt:description", -1, &(((ngwt__AddressBook*)a)->description), "");
	soap_out_PointerTobool(soap, "ngwt:isPersonal", -1, &(((ngwt__AddressBook*)a)->isPersonal), "");
	soap_out_PointerTobool(soap, "ngwt:isFrequentContacts", -1, &(((ngwt__AddressBook*)a)->isFrequentContacts), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AddressBook::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AddressBook(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AddressBook * SOAP_FMAC4 soap_get_ngwt__AddressBook(struct soap *soap, ngwt__AddressBook *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AddressBook(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AddressBook::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AddressBook(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AddressBook * SOAP_FMAC4 soap_in_ngwt__AddressBook(struct soap *soap, const char *tag, ngwt__AddressBook *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AddressBook *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AddressBook, sizeof(ngwt__AddressBook), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AddressBook)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AddressBook *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id2 = 1, soap_flag_name2 = 1, soap_flag_version2 = 1, soap_flag_modified2 = 1, soap_flag_changes2 = 1, soap_flag_description1 = 1, soap_flag_isPersonal1 = 1, soap_flag_isFrequentContacts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__Item*)a)->id), "ngwt:uid"))
				{	soap_flag_id2 = 0;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:name", &(((ngwt__Item*)a)->name), ""))
				{	soap_flag_name2 = 0;
					continue;
				}
			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLong(soap, "ngwt:version", &(((ngwt__Item*)a)->version), ""))
				{	soap_flag_version2 = 0;
					continue;
				}
			if (soap_flag_modified2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ngwt:modified", &(((ngwt__Item*)a)->modified), ""))
				{	soap_flag_modified2 = 0;
					continue;
				}
			if (soap_flag_changes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__ItemChanges(soap, "ngwt:changes", &(((ngwt__Item*)a)->changes), "ngwt:ItemChanges"))
				{	soap_flag_changes2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:description", &(((ngwt__AddressBook*)a)->description), ""))
				{	soap_flag_description1 = 0;
					continue;
				}
			if (soap_flag_isPersonal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:isPersonal", &(((ngwt__AddressBook*)a)->isPersonal), ""))
				{	soap_flag_isPersonal1 = 0;
					continue;
				}
			if (soap_flag_isFrequentContacts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:isFrequentContacts", &(((ngwt__AddressBook*)a)->isFrequentContacts), ""))
				{	soap_flag_isFrequentContacts1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AddressBook *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AddressBook, 0, sizeof(ngwt__AddressBook), 0, soap_copy_ngwt__AddressBook);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AddressBook * SOAP_FMAC6 soap_new_ngwt__AddressBook(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AddressBook(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AddressBook(struct soap *soap, ngwt__AddressBook *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AddressBook * SOAP_FMAC6 soap_instantiate_ngwt__AddressBook(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AddressBook(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AddressBook, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AddressBook;
		if (size)
			*size = sizeof(ngwt__AddressBook);
		((ngwt__AddressBook*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AddressBook[n];
		if (size)
			*size = n * sizeof(ngwt__AddressBook);
		for (int i = 0; i < n; i++)
			((ngwt__AddressBook*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AddressBook*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AddressBook(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AddressBook %p -> %p\n", q, p));
	*(ngwt__AddressBook*)p = *(ngwt__AddressBook*)q;
}

void ngwt__AccessRightList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__AccessRightEntry(soap, &((ngwt__AccessRightList*)this)->entry);
	/* transient soap skipped */
}

void ngwt__AccessRightList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__AccessRightEntry(soap, &((ngwt__AccessRightList*)this)->entry);
	/* transient soap skipped */
}

int ngwt__AccessRightList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AccessRightList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AccessRightList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AccessRightList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AccessRightList(struct soap *soap, const char *tag, int id, const ngwt__AccessRightList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AccessRightList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__AccessRightEntry(soap, "ngwt:entry", -1, &(((ngwt__AccessRightList*)a)->entry), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AccessRightList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AccessRightList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AccessRightList * SOAP_FMAC4 soap_get_ngwt__AccessRightList(struct soap *soap, ngwt__AccessRightList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AccessRightList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AccessRightList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AccessRightList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AccessRightList * SOAP_FMAC4 soap_in_ngwt__AccessRightList(struct soap *soap, const char *tag, ngwt__AccessRightList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AccessRightList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AccessRightList, sizeof(ngwt__AccessRightList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AccessRightList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AccessRightList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__AccessRightEntry(soap, "ngwt:entry", &(((ngwt__AccessRightList*)a)->entry), "ngwt:AccessRightEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AccessRightList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessRightList, 0, sizeof(ngwt__AccessRightList), 0, soap_copy_ngwt__AccessRightList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AccessRightList * SOAP_FMAC6 soap_new_ngwt__AccessRightList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AccessRightList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AccessRightList(struct soap *soap, ngwt__AccessRightList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AccessRightList * SOAP_FMAC6 soap_instantiate_ngwt__AccessRightList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AccessRightList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AccessRightList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AccessRightList;
		if (size)
			*size = sizeof(ngwt__AccessRightList);
		((ngwt__AccessRightList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AccessRightList[n];
		if (size)
			*size = n * sizeof(ngwt__AccessRightList);
		for (int i = 0; i < n; i++)
			((ngwt__AccessRightList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AccessRightList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AccessRightList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AccessRightList %p -> %p\n", q, p));
	*(ngwt__AccessRightList*)p = *(ngwt__AccessRightList*)q;
}

void ngwt__AccessRightEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__AccessRightEntry*)this)->id, SOAP_TYPE_PointerTongwt__uid);
	soap_serialize_PointerTongwt__uid(soap, &((ngwt__AccessRightEntry*)this)->id);
	soap_embedded(soap, &((ngwt__AccessRightEntry*)this)->appointment, SOAP_TYPE_PointerTongwt__AccessRight);
	soap_serialize_PointerTongwt__AccessRight(soap, &((ngwt__AccessRightEntry*)this)->appointment);
	soap_embedded(soap, &((ngwt__AccessRightEntry*)this)->mail, SOAP_TYPE_PointerTongwt__AccessRight);
	soap_serialize_PointerTongwt__AccessRight(soap, &((ngwt__AccessRightEntry*)this)->mail);
	soap_embedded(soap, &((ngwt__AccessRightEntry*)this)->misc, SOAP_TYPE_PointerTongwt__AccessMiscRight);
	soap_serialize_PointerTongwt__AccessMiscRight(soap, &((ngwt__AccessRightEntry*)this)->misc);
	soap_embedded(soap, &((ngwt__AccessRightEntry*)this)->note, SOAP_TYPE_PointerTongwt__AccessRight);
	soap_serialize_PointerTongwt__AccessRight(soap, &((ngwt__AccessRightEntry*)this)->note);
	soap_embedded(soap, &((ngwt__AccessRightEntry*)this)->task, SOAP_TYPE_PointerTongwt__AccessRight);
	soap_serialize_PointerTongwt__AccessRight(soap, &((ngwt__AccessRightEntry*)this)->task);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->displayName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->email, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ngwt__AccessRightEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__AccessRightEntry*)this)->id = NULL;
	((ngwt__AccessRightEntry*)this)->appointment = NULL;
	((ngwt__AccessRightEntry*)this)->mail = NULL;
	((ngwt__AccessRightEntry*)this)->misc = NULL;
	((ngwt__AccessRightEntry*)this)->note = NULL;
	((ngwt__AccessRightEntry*)this)->task = NULL;
	((ngwt__NameAndEmail*)this)->displayName = NULL;
	((ngwt__NameAndEmail*)this)->email = NULL;
	((ngwt__NameAndEmail*)this)->uuid = NULL;
	/* transient soap skipped */
}

int ngwt__AccessRightEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AccessRightEntry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AccessRightEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AccessRightEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AccessRightEntry(struct soap *soap, const char *tag, int id, const ngwt__AccessRightEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AccessRightEntry), "ngwt:AccessRightEntry");
	soap_out_PointerTostd__string(soap, "ngwt:displayName", -1, &(((ngwt__NameAndEmail*)a)->displayName), "");
	soap_out_PointerTostd__string(soap, "ngwt:email", -1, &(((ngwt__NameAndEmail*)a)->email), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__NameAndEmail*)a)->uuid), "");
	/* transient soap skipped */
	soap_out_PointerTongwt__uid(soap, "ngwt:id", -1, &(((ngwt__AccessRightEntry*)a)->id), "");
	soap_out_PointerTongwt__AccessRight(soap, "ngwt:appointment", -1, &(((ngwt__AccessRightEntry*)a)->appointment), "");
	soap_out_PointerTongwt__AccessRight(soap, "ngwt:mail", -1, &(((ngwt__AccessRightEntry*)a)->mail), "");
	soap_out_PointerTongwt__AccessMiscRight(soap, "ngwt:misc", -1, &(((ngwt__AccessRightEntry*)a)->misc), "");
	soap_out_PointerTongwt__AccessRight(soap, "ngwt:note", -1, &(((ngwt__AccessRightEntry*)a)->note), "");
	soap_out_PointerTongwt__AccessRight(soap, "ngwt:task", -1, &(((ngwt__AccessRightEntry*)a)->task), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AccessRightEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AccessRightEntry(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AccessRightEntry * SOAP_FMAC4 soap_get_ngwt__AccessRightEntry(struct soap *soap, ngwt__AccessRightEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AccessRightEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AccessRightEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AccessRightEntry(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AccessRightEntry * SOAP_FMAC4 soap_in_ngwt__AccessRightEntry(struct soap *soap, const char *tag, ngwt__AccessRightEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AccessRightEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AccessRightEntry, sizeof(ngwt__AccessRightEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AccessRightEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AccessRightEntry *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_displayName2 = 1, soap_flag_email2 = 1, soap_flag_uuid2 = 1, soap_flag_id1 = 1, soap_flag_appointment1 = 1, soap_flag_mail1 = 1, soap_flag_misc1 = 1, soap_flag_note1 = 1, soap_flag_task1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_displayName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:displayName", &(((ngwt__NameAndEmail*)a)->displayName), ""))
				{	soap_flag_displayName2 = 0;
					continue;
				}
			if (soap_flag_email2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:email", &(((ngwt__NameAndEmail*)a)->email), ""))
				{	soap_flag_email2 = 0;
					continue;
				}
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__NameAndEmail*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__uid(soap, "ngwt:id", &(((ngwt__AccessRightEntry*)a)->id), "ngwt:uid"))
				{	soap_flag_id1 = 0;
					continue;
				}
			if (soap_flag_appointment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessRight(soap, "ngwt:appointment", &(((ngwt__AccessRightEntry*)a)->appointment), "ngwt:AccessRight"))
				{	soap_flag_appointment1 = 0;
					continue;
				}
			if (soap_flag_mail1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessRight(soap, "ngwt:mail", &(((ngwt__AccessRightEntry*)a)->mail), "ngwt:AccessRight"))
				{	soap_flag_mail1 = 0;
					continue;
				}
			if (soap_flag_misc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessMiscRight(soap, "ngwt:misc", &(((ngwt__AccessRightEntry*)a)->misc), "ngwt:AccessMiscRight"))
				{	soap_flag_misc1 = 0;
					continue;
				}
			if (soap_flag_note1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessRight(soap, "ngwt:note", &(((ngwt__AccessRightEntry*)a)->note), "ngwt:AccessRight"))
				{	soap_flag_note1 = 0;
					continue;
				}
			if (soap_flag_task1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessRight(soap, "ngwt:task", &(((ngwt__AccessRightEntry*)a)->task), "ngwt:AccessRight"))
				{	soap_flag_task1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AccessRightEntry *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessRightEntry, 0, sizeof(ngwt__AccessRightEntry), 0, soap_copy_ngwt__AccessRightEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AccessRightEntry * SOAP_FMAC6 soap_new_ngwt__AccessRightEntry(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AccessRightEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AccessRightEntry(struct soap *soap, ngwt__AccessRightEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AccessRightEntry * SOAP_FMAC6 soap_instantiate_ngwt__AccessRightEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AccessRightEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AccessRightEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AccessRightEntry;
		if (size)
			*size = sizeof(ngwt__AccessRightEntry);
		((ngwt__AccessRightEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AccessRightEntry[n];
		if (size)
			*size = n * sizeof(ngwt__AccessRightEntry);
		for (int i = 0; i < n; i++)
			((ngwt__AccessRightEntry*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AccessRightEntry*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AccessRightEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AccessRightEntry %p -> %p\n", q, p));
	*(ngwt__AccessRightEntry*)p = *(ngwt__AccessRightEntry*)q;
}

void ngwt__AccessRightChanges::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__AccessRightChanges*)this)->add, SOAP_TYPE_PointerTongwt__AccessRightEntry);
	soap_serialize_PointerTongwt__AccessRightEntry(soap, &((ngwt__AccessRightChanges*)this)->add);
	soap_embedded(soap, &((ngwt__AccessRightChanges*)this)->_delete, SOAP_TYPE_PointerTongwt__AccessRightEntry);
	soap_serialize_PointerTongwt__AccessRightEntry(soap, &((ngwt__AccessRightChanges*)this)->_delete);
	soap_embedded(soap, &((ngwt__AccessRightChanges*)this)->update, SOAP_TYPE_PointerTongwt__AccessRightEntry);
	soap_serialize_PointerTongwt__AccessRightEntry(soap, &((ngwt__AccessRightChanges*)this)->update);
	/* transient soap skipped */
}

void ngwt__AccessRightChanges::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__AccessRightChanges*)this)->add = NULL;
	((ngwt__AccessRightChanges*)this)->_delete = NULL;
	((ngwt__AccessRightChanges*)this)->update = NULL;
	/* transient soap skipped */
}

int ngwt__AccessRightChanges::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AccessRightChanges);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AccessRightChanges::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AccessRightChanges(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AccessRightChanges(struct soap *soap, const char *tag, int id, const ngwt__AccessRightChanges *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AccessRightChanges), type);
	soap_out_PointerTongwt__AccessRightEntry(soap, "ngwt:add", -1, &(((ngwt__AccessRightChanges*)a)->add), "");
	soap_out_PointerTongwt__AccessRightEntry(soap, "ngwt:delete", -1, &(((ngwt__AccessRightChanges*)a)->_delete), "");
	soap_out_PointerTongwt__AccessRightEntry(soap, "ngwt:update", -1, &(((ngwt__AccessRightChanges*)a)->update), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AccessRightChanges::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AccessRightChanges(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AccessRightChanges * SOAP_FMAC4 soap_get_ngwt__AccessRightChanges(struct soap *soap, ngwt__AccessRightChanges *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AccessRightChanges(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AccessRightChanges::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AccessRightChanges(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AccessRightChanges * SOAP_FMAC4 soap_in_ngwt__AccessRightChanges(struct soap *soap, const char *tag, ngwt__AccessRightChanges *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AccessRightChanges *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AccessRightChanges, sizeof(ngwt__AccessRightChanges), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AccessRightChanges)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AccessRightChanges *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_add1 = 1, soap_flag_delete1 = 1, soap_flag_update1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_add1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessRightEntry(soap, "ngwt:add", &(((ngwt__AccessRightChanges*)a)->add), "ngwt:AccessRightEntry"))
				{	soap_flag_add1 = 0;
					continue;
				}
			if (soap_flag_delete1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessRightEntry(soap, "ngwt:delete", &(((ngwt__AccessRightChanges*)a)->_delete), "ngwt:AccessRightEntry"))
				{	soap_flag_delete1 = 0;
					continue;
				}
			if (soap_flag_update1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__AccessRightEntry(soap, "ngwt:update", &(((ngwt__AccessRightChanges*)a)->update), "ngwt:AccessRightEntry"))
				{	soap_flag_update1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AccessRightChanges *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessRightChanges, 0, sizeof(ngwt__AccessRightChanges), 0, soap_copy_ngwt__AccessRightChanges);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AccessRightChanges * SOAP_FMAC6 soap_new_ngwt__AccessRightChanges(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AccessRightChanges(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AccessRightChanges(struct soap *soap, ngwt__AccessRightChanges *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AccessRightChanges * SOAP_FMAC6 soap_instantiate_ngwt__AccessRightChanges(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AccessRightChanges(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AccessRightChanges, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AccessRightChanges;
		if (size)
			*size = sizeof(ngwt__AccessRightChanges);
		((ngwt__AccessRightChanges*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AccessRightChanges[n];
		if (size)
			*size = n * sizeof(ngwt__AccessRightChanges);
		for (int i = 0; i < n; i++)
			((ngwt__AccessRightChanges*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AccessRightChanges*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AccessRightChanges(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AccessRightChanges %p -> %p\n", q, p));
	*(ngwt__AccessRightChanges*)p = *(ngwt__AccessRightChanges*)q;
}

void ngwt__AccessRight::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__AccessRight*)this)->read, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__AccessRight*)this)->read);
	soap_embedded(soap, &((ngwt__AccessRight*)this)->write, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__AccessRight*)this)->write);
	/* transient soap skipped */
}

void ngwt__AccessRight::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__AccessRight*)this)->read = NULL;
	((ngwt__AccessRight*)this)->write = NULL;
	/* transient soap skipped */
}

int ngwt__AccessRight::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AccessRight);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AccessRight::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AccessRight(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AccessRight(struct soap *soap, const char *tag, int id, const ngwt__AccessRight *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AccessRight), type);
	soap_out_PointerTobool(soap, "ngwt:read", -1, &(((ngwt__AccessRight*)a)->read), "");
	soap_out_PointerTobool(soap, "ngwt:write", -1, &(((ngwt__AccessRight*)a)->write), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AccessRight::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AccessRight(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AccessRight * SOAP_FMAC4 soap_get_ngwt__AccessRight(struct soap *soap, ngwt__AccessRight *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AccessRight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AccessRight::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AccessRight(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AccessRight * SOAP_FMAC4 soap_in_ngwt__AccessRight(struct soap *soap, const char *tag, ngwt__AccessRight *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AccessRight *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AccessRight, sizeof(ngwt__AccessRight), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AccessRight)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AccessRight *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_read1 = 1, soap_flag_write1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_read1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:read", &(((ngwt__AccessRight*)a)->read), ""))
				{	soap_flag_read1 = 0;
					continue;
				}
			if (soap_flag_write1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:write", &(((ngwt__AccessRight*)a)->write), ""))
				{	soap_flag_write1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AccessRight *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessRight, 0, sizeof(ngwt__AccessRight), 0, soap_copy_ngwt__AccessRight);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AccessRight * SOAP_FMAC6 soap_new_ngwt__AccessRight(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AccessRight(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AccessRight(struct soap *soap, ngwt__AccessRight *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AccessRight * SOAP_FMAC6 soap_instantiate_ngwt__AccessRight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AccessRight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AccessRight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AccessRight;
		if (size)
			*size = sizeof(ngwt__AccessRight);
		((ngwt__AccessRight*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AccessRight[n];
		if (size)
			*size = n * sizeof(ngwt__AccessRight);
		for (int i = 0; i < n; i++)
			((ngwt__AccessRight*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AccessRight*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AccessRight(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AccessRight %p -> %p\n", q, p));
	*(ngwt__AccessRight*)p = *(ngwt__AccessRight*)q;
}

void ngwt__AccessMiscRight::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__AccessMiscRight*)this)->alarms, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__AccessMiscRight*)this)->alarms);
	soap_embedded(soap, &((ngwt__AccessMiscRight*)this)->notify, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__AccessMiscRight*)this)->notify);
	soap_embedded(soap, &((ngwt__AccessMiscRight*)this)->readHidden, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__AccessMiscRight*)this)->readHidden);
	soap_embedded(soap, &((ngwt__AccessMiscRight*)this)->setup, SOAP_TYPE_PointerTobool);
	soap_serialize_PointerTobool(soap, &((ngwt__AccessMiscRight*)this)->setup);
	/* transient soap skipped */
}

void ngwt__AccessMiscRight::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__AccessMiscRight*)this)->alarms = NULL;
	((ngwt__AccessMiscRight*)this)->notify = NULL;
	((ngwt__AccessMiscRight*)this)->readHidden = NULL;
	((ngwt__AccessMiscRight*)this)->setup = NULL;
	/* transient soap skipped */
}

int ngwt__AccessMiscRight::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AccessMiscRight);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AccessMiscRight::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AccessMiscRight(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AccessMiscRight(struct soap *soap, const char *tag, int id, const ngwt__AccessMiscRight *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AccessMiscRight), type);
	soap_out_PointerTobool(soap, "ngwt:alarms", -1, &(((ngwt__AccessMiscRight*)a)->alarms), "");
	soap_out_PointerTobool(soap, "ngwt:notify", -1, &(((ngwt__AccessMiscRight*)a)->notify), "");
	soap_out_PointerTobool(soap, "ngwt:readHidden", -1, &(((ngwt__AccessMiscRight*)a)->readHidden), "");
	soap_out_PointerTobool(soap, "ngwt:setup", -1, &(((ngwt__AccessMiscRight*)a)->setup), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AccessMiscRight::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AccessMiscRight(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AccessMiscRight * SOAP_FMAC4 soap_get_ngwt__AccessMiscRight(struct soap *soap, ngwt__AccessMiscRight *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AccessMiscRight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AccessMiscRight::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AccessMiscRight(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AccessMiscRight * SOAP_FMAC4 soap_in_ngwt__AccessMiscRight(struct soap *soap, const char *tag, ngwt__AccessMiscRight *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AccessMiscRight *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AccessMiscRight, sizeof(ngwt__AccessMiscRight), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AccessMiscRight)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AccessMiscRight *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarms1 = 1, soap_flag_notify1 = 1, soap_flag_readHidden1 = 1, soap_flag_setup1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarms1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:alarms", &(((ngwt__AccessMiscRight*)a)->alarms), ""))
				{	soap_flag_alarms1 = 0;
					continue;
				}
			if (soap_flag_notify1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:notify", &(((ngwt__AccessMiscRight*)a)->notify), ""))
				{	soap_flag_notify1 = 0;
					continue;
				}
			if (soap_flag_readHidden1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:readHidden", &(((ngwt__AccessMiscRight*)a)->readHidden), ""))
				{	soap_flag_readHidden1 = 0;
					continue;
				}
			if (soap_flag_setup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ngwt:setup", &(((ngwt__AccessMiscRight*)a)->setup), ""))
				{	soap_flag_setup1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AccessMiscRight *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessMiscRight, 0, sizeof(ngwt__AccessMiscRight), 0, soap_copy_ngwt__AccessMiscRight);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AccessMiscRight * SOAP_FMAC6 soap_new_ngwt__AccessMiscRight(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AccessMiscRight(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AccessMiscRight(struct soap *soap, ngwt__AccessMiscRight *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AccessMiscRight * SOAP_FMAC6 soap_instantiate_ngwt__AccessMiscRight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AccessMiscRight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AccessMiscRight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AccessMiscRight;
		if (size)
			*size = sizeof(ngwt__AccessMiscRight);
		((ngwt__AccessMiscRight*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AccessMiscRight[n];
		if (size)
			*size = n * sizeof(ngwt__AccessMiscRight);
		for (int i = 0; i < n; i++)
			((ngwt__AccessMiscRight*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AccessMiscRight*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AccessMiscRight(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AccessMiscRight %p -> %p\n", q, p));
	*(ngwt__AccessMiscRight*)p = *(ngwt__AccessMiscRight*)q;
}

void ngwt__AccessControlList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(soap, &((ngwt__AccessControlList*)this)->entry);
	/* transient soap skipped */
}

void ngwt__AccessControlList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(soap, &((ngwt__AccessControlList*)this)->entry);
	/* transient soap skipped */
}

int ngwt__AccessControlList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AccessControlList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AccessControlList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AccessControlList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AccessControlList(struct soap *soap, const char *tag, int id, const ngwt__AccessControlList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AccessControlList), type);
	soap_out_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(soap, "ngwt:entry", -1, &(((ngwt__AccessControlList*)a)->entry), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AccessControlList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AccessControlList(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AccessControlList * SOAP_FMAC4 soap_get_ngwt__AccessControlList(struct soap *soap, ngwt__AccessControlList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AccessControlList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AccessControlList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AccessControlList(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AccessControlList * SOAP_FMAC4 soap_in_ngwt__AccessControlList(struct soap *soap, const char *tag, ngwt__AccessControlList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AccessControlList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AccessControlList, sizeof(ngwt__AccessControlList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AccessControlList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AccessControlList *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(soap, "ngwt:entry", &(((ngwt__AccessControlList*)a)->entry), "ngwt:AccessControlListEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AccessControlList *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessControlList, 0, sizeof(ngwt__AccessControlList), 0, soap_copy_ngwt__AccessControlList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AccessControlList * SOAP_FMAC6 soap_new_ngwt__AccessControlList(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AccessControlList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AccessControlList(struct soap *soap, ngwt__AccessControlList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AccessControlList * SOAP_FMAC6 soap_instantiate_ngwt__AccessControlList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AccessControlList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AccessControlList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AccessControlList;
		if (size)
			*size = sizeof(ngwt__AccessControlList);
		((ngwt__AccessControlList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AccessControlList[n];
		if (size)
			*size = n * sizeof(ngwt__AccessControlList);
		for (int i = 0; i < n; i++)
			((ngwt__AccessControlList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AccessControlList*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AccessControlList(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AccessControlList %p -> %p\n", q, p));
	*(ngwt__AccessControlList*)p = *(ngwt__AccessControlList*)q;
}

void ngwt__AccessControlListEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ngwt__AccessControlListEntry*)this)->rights, SOAP_TYPE_PointerTongwt__Rights);
	soap_serialize_PointerTongwt__Rights(soap, &((ngwt__AccessControlListEntry*)this)->rights);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->displayName, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->displayName);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->email, SOAP_TYPE_PointerTostd__string);
	soap_serialize_PointerTostd__string(soap, &((ngwt__NameAndEmail*)this)->email);
	soap_embedded(soap, &((ngwt__NameAndEmail*)this)->uuid, SOAP_TYPE_PointerTongwt__UUID);
	soap_serialize_PointerTongwt__UUID(soap, &((ngwt__NameAndEmail*)this)->uuid);
	/* transient soap skipped */
}

void ngwt__AccessControlListEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ngwt__AccessControlListEntry*)this)->rights = NULL;
	((ngwt__NameAndEmail*)this)->displayName = NULL;
	((ngwt__NameAndEmail*)this)->email = NULL;
	((ngwt__NameAndEmail*)this)->uuid = NULL;
	/* transient soap skipped */
}

int ngwt__AccessControlListEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ngwt__AccessControlListEntry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ngwt__AccessControlListEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ngwt__AccessControlListEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ngwt__AccessControlListEntry(struct soap *soap, const char *tag, int id, const ngwt__AccessControlListEntry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ngwt__AccessControlListEntry), "ngwt:AccessControlListEntry");
	soap_out_PointerTostd__string(soap, "ngwt:displayName", -1, &(((ngwt__NameAndEmail*)a)->displayName), "");
	soap_out_PointerTostd__string(soap, "ngwt:email", -1, &(((ngwt__NameAndEmail*)a)->email), "");
	soap_out_PointerTongwt__UUID(soap, "ngwt:uuid", -1, &(((ngwt__NameAndEmail*)a)->uuid), "");
	/* transient soap skipped */
	soap_out_PointerTongwt__Rights(soap, "ngwt:rights", -1, &(((ngwt__AccessControlListEntry*)a)->rights), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ngwt__AccessControlListEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ngwt__AccessControlListEntry(soap, this, tag, type);
}

SOAP_FMAC3 ngwt__AccessControlListEntry * SOAP_FMAC4 soap_get_ngwt__AccessControlListEntry(struct soap *soap, ngwt__AccessControlListEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ngwt__AccessControlListEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ngwt__AccessControlListEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ngwt__AccessControlListEntry(soap, tag, this, type);
}

SOAP_FMAC3 ngwt__AccessControlListEntry * SOAP_FMAC4 soap_in_ngwt__AccessControlListEntry(struct soap *soap, const char *tag, ngwt__AccessControlListEntry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ngwt__AccessControlListEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ngwt__AccessControlListEntry, sizeof(ngwt__AccessControlListEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ngwt__AccessControlListEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ngwt__AccessControlListEntry *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_displayName2 = 1, soap_flag_email2 = 1, soap_flag_uuid2 = 1, soap_flag_rights1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_displayName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:displayName", &(((ngwt__NameAndEmail*)a)->displayName), ""))
				{	soap_flag_displayName2 = 0;
					continue;
				}
			if (soap_flag_email2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ngwt:email", &(((ngwt__NameAndEmail*)a)->email), ""))
				{	soap_flag_email2 = 0;
					continue;
				}
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTongwt__UUID(soap, "ngwt:uuid", &(((ngwt__NameAndEmail*)a)->uuid), "ngwt:UUID"))
				{	soap_flag_uuid2 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_rights1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTongwt__Rights(soap, "ngwt:rights", &(((ngwt__AccessControlListEntry*)a)->rights), "ngwt:Rights"))
				{	soap_flag_rights1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_rights1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ngwt__AccessControlListEntry *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessControlListEntry, 0, sizeof(ngwt__AccessControlListEntry), 0, soap_copy_ngwt__AccessControlListEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ngwt__AccessControlListEntry * SOAP_FMAC6 soap_new_ngwt__AccessControlListEntry(struct soap *soap, int n)
{	return soap_instantiate_ngwt__AccessControlListEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ngwt__AccessControlListEntry(struct soap *soap, ngwt__AccessControlListEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 ngwt__AccessControlListEntry * SOAP_FMAC6 soap_instantiate_ngwt__AccessControlListEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ngwt__AccessControlListEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ngwt__AccessControlListEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ngwt:FolderACLEntry"))
	{	cp->type = SOAP_TYPE_ngwt__FolderACLEntry;
		if (n < 0)
		{	cp->ptr = (void*)new ngwt__FolderACLEntry;
			if (size)
				*size = sizeof(ngwt__FolderACLEntry);
			((ngwt__FolderACLEntry*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ngwt__FolderACLEntry[n];
			if (size)
				*size = n * sizeof(ngwt__FolderACLEntry);
			for (int i = 0; i < n; i++)
				((ngwt__FolderACLEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ngwt__FolderACLEntry*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ngwt__AccessControlListEntry;
		if (size)
			*size = sizeof(ngwt__AccessControlListEntry);
		((ngwt__AccessControlListEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ngwt__AccessControlListEntry[n];
		if (size)
			*size = n * sizeof(ngwt__AccessControlListEntry);
		for (int i = 0; i < n; i++)
			((ngwt__AccessControlListEntry*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ngwt__AccessControlListEntry*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_ngwt__AccessControlListEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ngwt__AccessControlListEntry %p -> %p\n", q, p));
	*(ngwt__AccessControlListEntry*)p = *(ngwt__AccessControlListEntry*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__language(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__language(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__language(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__language);
	if (soap_out_xsd__language(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__language(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__language), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__language(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__language(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__language(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__language, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__language, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_xsd__language, 0, sizeof(std::string), 0, soap_copy_xsd__language);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__language(struct soap *soap, int n)
{	return soap_instantiate_xsd__language(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__language(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_xsd__language(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__language(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__language, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__language(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__duration(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__duration), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__duration(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_xsd__duration, 0, sizeof(std::string), 0, soap_copy_xsd__duration);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__duration(struct soap *soap, int n)
{	return soap_instantiate_xsd__duration(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__duration(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_xsd__duration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__duration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__duration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__duration(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__decimal(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_xsd__decimal, 0, sizeof(std::string), 0, soap_copy_xsd__decimal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__decimal(struct soap *soap, int n)
{	return soap_instantiate_xsd__decimal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__decimal(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_xsd__decimal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__decimal(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__date(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__date), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__date(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_xsd__date, 0, sizeof(std::string), 0, soap_copy_xsd__date);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__date(struct soap *soap, int n)
{	return soap_instantiate_xsd__date(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__date(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_xsd__date(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__date(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__date, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__date(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{ }
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr)
		soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary);
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	soap_putbase64(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap *soap, int n)
{	return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary;
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary[n];
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->faultcode, SOAP_TYPE__QName);
	soap_serialize__QName(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_TYPE_string);
	soap_serialize_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_TYPE_string);
	soap_serialize_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_embedded(soap, &a->SOAP_ENV__Code, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_embedded(soap, &a->SOAP_ENV__Reason, SOAP_TYPE_string);
	soap_serialize_string(soap, &a->SOAP_ENV__Reason);
	soap_embedded(soap, &a->SOAP_ENV__Node, SOAP_TYPE_string);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_embedded(soap, &a->SOAP_ENV__Role, SOAP_TYPE_string);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_embedded(soap, &a->SOAP_ENV__Detail, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Reason);
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_string(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, ""))
				{	soap_flag_SOAP_ENV__Node = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, ""))
				{	soap_flag_SOAP_ENV__Role = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->SOAP_ENV__Value, SOAP_TYPE__QName);
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_embedded(soap, &a->SOAP_ENV__Subcode, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__removeEventsRequest(struct soap *soap, const struct __ngw__removeEventsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwe__removeEventsRequest, SOAP_TYPE_PointerTo_ngwe__removeEventsRequest);
	soap_serialize_PointerTo_ngwe__removeEventsRequest(soap, &a->ngwe__removeEventsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__removeEventsRequest(struct soap *soap, struct __ngw__removeEventsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwe__removeEventsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__removeEventsRequest(struct soap *soap, const struct __ngw__removeEventsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__removeEventsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__removeEventsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__removeEventsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwe__removeEventsRequest(soap, "ngwe:removeEventsRequest", -1, &a->ngwe__removeEventsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__removeEventsRequest * SOAP_FMAC4 soap_get___ngw__removeEventsRequest(struct soap *soap, struct __ngw__removeEventsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__removeEventsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__removeEventsRequest * SOAP_FMAC4 soap_in___ngw__removeEventsRequest(struct soap *soap, const char *tag, struct __ngw__removeEventsRequest *a, const char *type)
{
	short soap_flag_ngwe__removeEventsRequest = 1;
	a = (struct __ngw__removeEventsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__removeEventsRequest, sizeof(struct __ngw__removeEventsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__removeEventsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwe__removeEventsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwe__removeEventsRequest(soap, "ngwe:removeEventsRequest", &a->ngwe__removeEventsRequest, ""))
				{	soap_flag_ngwe__removeEventsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__removeEventConfigurationRequest(struct soap *soap, const struct __ngw__removeEventConfigurationRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwe__removeEventConfigurationRequest, SOAP_TYPE_PointerTo_ngwe__removeEventConfigurationRequest);
	soap_serialize_PointerTo_ngwe__removeEventConfigurationRequest(soap, &a->ngwe__removeEventConfigurationRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__removeEventConfigurationRequest(struct soap *soap, struct __ngw__removeEventConfigurationRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwe__removeEventConfigurationRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__removeEventConfigurationRequest(struct soap *soap, const struct __ngw__removeEventConfigurationRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__removeEventConfigurationRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__removeEventConfigurationRequest(struct soap *soap, const char *tag, int id, const struct __ngw__removeEventConfigurationRequest *a, const char *type)
{
	soap_out_PointerTo_ngwe__removeEventConfigurationRequest(soap, "ngwe:removeEventConfigurationRequest", -1, &a->ngwe__removeEventConfigurationRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__removeEventConfigurationRequest * SOAP_FMAC4 soap_get___ngw__removeEventConfigurationRequest(struct soap *soap, struct __ngw__removeEventConfigurationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__removeEventConfigurationRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__removeEventConfigurationRequest * SOAP_FMAC4 soap_in___ngw__removeEventConfigurationRequest(struct soap *soap, const char *tag, struct __ngw__removeEventConfigurationRequest *a, const char *type)
{
	short soap_flag_ngwe__removeEventConfigurationRequest = 1;
	a = (struct __ngw__removeEventConfigurationRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__removeEventConfigurationRequest, sizeof(struct __ngw__removeEventConfigurationRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__removeEventConfigurationRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwe__removeEventConfigurationRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwe__removeEventConfigurationRequest(soap, "ngwe:removeEventConfigurationRequest", &a->ngwe__removeEventConfigurationRequest, ""))
				{	soap_flag_ngwe__removeEventConfigurationRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getEventsRequest(struct soap *soap, const struct __ngw__getEventsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwe__getEventsRequest, SOAP_TYPE_PointerTo_ngwe__getEventsRequest);
	soap_serialize_PointerTo_ngwe__getEventsRequest(soap, &a->ngwe__getEventsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getEventsRequest(struct soap *soap, struct __ngw__getEventsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwe__getEventsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getEventsRequest(struct soap *soap, const struct __ngw__getEventsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getEventsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getEventsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getEventsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwe__getEventsRequest(soap, "ngwe:getEventsRequest", -1, &a->ngwe__getEventsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getEventsRequest * SOAP_FMAC4 soap_get___ngw__getEventsRequest(struct soap *soap, struct __ngw__getEventsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getEventsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getEventsRequest * SOAP_FMAC4 soap_in___ngw__getEventsRequest(struct soap *soap, const char *tag, struct __ngw__getEventsRequest *a, const char *type)
{
	short soap_flag_ngwe__getEventsRequest = 1;
	a = (struct __ngw__getEventsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getEventsRequest, sizeof(struct __ngw__getEventsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getEventsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwe__getEventsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwe__getEventsRequest(soap, "ngwe:getEventsRequest", &a->ngwe__getEventsRequest, ""))
				{	soap_flag_ngwe__getEventsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getEventConfigurationRequest(struct soap *soap, const struct __ngw__getEventConfigurationRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwe__getEventConfigurationRequest, SOAP_TYPE_PointerTo_ngwe__getEventConfigurationRequest);
	soap_serialize_PointerTo_ngwe__getEventConfigurationRequest(soap, &a->ngwe__getEventConfigurationRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getEventConfigurationRequest(struct soap *soap, struct __ngw__getEventConfigurationRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwe__getEventConfigurationRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getEventConfigurationRequest(struct soap *soap, const struct __ngw__getEventConfigurationRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getEventConfigurationRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getEventConfigurationRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getEventConfigurationRequest *a, const char *type)
{
	soap_out_PointerTo_ngwe__getEventConfigurationRequest(soap, "ngwe:getEventConfigurationRequest", -1, &a->ngwe__getEventConfigurationRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getEventConfigurationRequest * SOAP_FMAC4 soap_get___ngw__getEventConfigurationRequest(struct soap *soap, struct __ngw__getEventConfigurationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getEventConfigurationRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getEventConfigurationRequest * SOAP_FMAC4 soap_in___ngw__getEventConfigurationRequest(struct soap *soap, const char *tag, struct __ngw__getEventConfigurationRequest *a, const char *type)
{
	short soap_flag_ngwe__getEventConfigurationRequest = 1;
	a = (struct __ngw__getEventConfigurationRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getEventConfigurationRequest, sizeof(struct __ngw__getEventConfigurationRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getEventConfigurationRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwe__getEventConfigurationRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwe__getEventConfigurationRequest(soap, "ngwe:getEventConfigurationRequest", &a->ngwe__getEventConfigurationRequest, ""))
				{	soap_flag_ngwe__getEventConfigurationRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__configureEventsRequest(struct soap *soap, const struct __ngw__configureEventsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwe__configureEventsRequest, SOAP_TYPE_PointerTo_ngwe__configureEventsRequest);
	soap_serialize_PointerTo_ngwe__configureEventsRequest(soap, &a->ngwe__configureEventsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__configureEventsRequest(struct soap *soap, struct __ngw__configureEventsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwe__configureEventsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__configureEventsRequest(struct soap *soap, const struct __ngw__configureEventsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__configureEventsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__configureEventsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__configureEventsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwe__configureEventsRequest(soap, "ngwe:configureEventsRequest", -1, &a->ngwe__configureEventsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__configureEventsRequest * SOAP_FMAC4 soap_get___ngw__configureEventsRequest(struct soap *soap, struct __ngw__configureEventsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__configureEventsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__configureEventsRequest * SOAP_FMAC4 soap_in___ngw__configureEventsRequest(struct soap *soap, const char *tag, struct __ngw__configureEventsRequest *a, const char *type)
{
	short soap_flag_ngwe__configureEventsRequest = 1;
	a = (struct __ngw__configureEventsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__configureEventsRequest, sizeof(struct __ngw__configureEventsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__configureEventsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwe__configureEventsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwe__configureEventsRequest(soap, "ngwe:configureEventsRequest", &a->ngwe__configureEventsRequest, ""))
				{	soap_flag_ngwe__configureEventsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__cleanEventConfigurationRequest(struct soap *soap, const struct __ngw__cleanEventConfigurationRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwe__cleanEventConfigurationRequest, SOAP_TYPE_PointerTo_ngwe__cleanEventConfigurationRequest);
	soap_serialize_PointerTo_ngwe__cleanEventConfigurationRequest(soap, &a->ngwe__cleanEventConfigurationRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__cleanEventConfigurationRequest(struct soap *soap, struct __ngw__cleanEventConfigurationRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwe__cleanEventConfigurationRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__cleanEventConfigurationRequest(struct soap *soap, const struct __ngw__cleanEventConfigurationRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__cleanEventConfigurationRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__cleanEventConfigurationRequest(struct soap *soap, const char *tag, int id, const struct __ngw__cleanEventConfigurationRequest *a, const char *type)
{
	soap_out_PointerTo_ngwe__cleanEventConfigurationRequest(soap, "ngwe:cleanEventConfigurationRequest", -1, &a->ngwe__cleanEventConfigurationRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__cleanEventConfigurationRequest * SOAP_FMAC4 soap_get___ngw__cleanEventConfigurationRequest(struct soap *soap, struct __ngw__cleanEventConfigurationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__cleanEventConfigurationRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__cleanEventConfigurationRequest * SOAP_FMAC4 soap_in___ngw__cleanEventConfigurationRequest(struct soap *soap, const char *tag, struct __ngw__cleanEventConfigurationRequest *a, const char *type)
{
	short soap_flag_ngwe__cleanEventConfigurationRequest = 1;
	a = (struct __ngw__cleanEventConfigurationRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__cleanEventConfigurationRequest, sizeof(struct __ngw__cleanEventConfigurationRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__cleanEventConfigurationRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwe__cleanEventConfigurationRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwe__cleanEventConfigurationRequest(soap, "ngwe:cleanEventConfigurationRequest", &a->ngwe__cleanEventConfigurationRequest, ""))
				{	soap_flag_ngwe__cleanEventConfigurationRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__updateVersionStatusRequest(struct soap *soap, const struct __ngw__updateVersionStatusRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__updateVersionStatusRequest, SOAP_TYPE_PointerTo_ngwm__updateVersionStatusRequest);
	soap_serialize_PointerTo_ngwm__updateVersionStatusRequest(soap, &a->ngwm__updateVersionStatusRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__updateVersionStatusRequest(struct soap *soap, struct __ngw__updateVersionStatusRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__updateVersionStatusRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__updateVersionStatusRequest(struct soap *soap, const struct __ngw__updateVersionStatusRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__updateVersionStatusRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__updateVersionStatusRequest(struct soap *soap, const char *tag, int id, const struct __ngw__updateVersionStatusRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__updateVersionStatusRequest(soap, "ngwm:updateVersionStatusRequest", -1, &a->ngwm__updateVersionStatusRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__updateVersionStatusRequest * SOAP_FMAC4 soap_get___ngw__updateVersionStatusRequest(struct soap *soap, struct __ngw__updateVersionStatusRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__updateVersionStatusRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__updateVersionStatusRequest * SOAP_FMAC4 soap_in___ngw__updateVersionStatusRequest(struct soap *soap, const char *tag, struct __ngw__updateVersionStatusRequest *a, const char *type)
{
	short soap_flag_ngwm__updateVersionStatusRequest = 1;
	a = (struct __ngw__updateVersionStatusRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__updateVersionStatusRequest, sizeof(struct __ngw__updateVersionStatusRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__updateVersionStatusRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__updateVersionStatusRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__updateVersionStatusRequest(soap, "ngwm:updateVersionStatusRequest", &a->ngwm__updateVersionStatusRequest, ""))
				{	soap_flag_ngwm__updateVersionStatusRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__uncompleteRequest(struct soap *soap, const struct __ngw__uncompleteRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__uncompleteRequest, SOAP_TYPE_PointerTo_ngwm__uncompleteRequest);
	soap_serialize_PointerTo_ngwm__uncompleteRequest(soap, &a->ngwm__uncompleteRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__uncompleteRequest(struct soap *soap, struct __ngw__uncompleteRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__uncompleteRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__uncompleteRequest(struct soap *soap, const struct __ngw__uncompleteRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__uncompleteRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__uncompleteRequest(struct soap *soap, const char *tag, int id, const struct __ngw__uncompleteRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__uncompleteRequest(soap, "ngwm:uncompleteRequest", -1, &a->ngwm__uncompleteRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__uncompleteRequest * SOAP_FMAC4 soap_get___ngw__uncompleteRequest(struct soap *soap, struct __ngw__uncompleteRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__uncompleteRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__uncompleteRequest * SOAP_FMAC4 soap_in___ngw__uncompleteRequest(struct soap *soap, const char *tag, struct __ngw__uncompleteRequest *a, const char *type)
{
	short soap_flag_ngwm__uncompleteRequest = 1;
	a = (struct __ngw__uncompleteRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__uncompleteRequest, sizeof(struct __ngw__uncompleteRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__uncompleteRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__uncompleteRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__uncompleteRequest(soap, "ngwm:uncompleteRequest", &a->ngwm__uncompleteRequest, ""))
				{	soap_flag_ngwm__uncompleteRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__unacceptRequest(struct soap *soap, const struct __ngw__unacceptRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__unacceptRequest, SOAP_TYPE_PointerTo_ngwm__unacceptRequest);
	soap_serialize_PointerTo_ngwm__unacceptRequest(soap, &a->ngwm__unacceptRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__unacceptRequest(struct soap *soap, struct __ngw__unacceptRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__unacceptRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__unacceptRequest(struct soap *soap, const struct __ngw__unacceptRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__unacceptRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__unacceptRequest(struct soap *soap, const char *tag, int id, const struct __ngw__unacceptRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__unacceptRequest(soap, "ngwm:unacceptRequest", -1, &a->ngwm__unacceptRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__unacceptRequest * SOAP_FMAC4 soap_get___ngw__unacceptRequest(struct soap *soap, struct __ngw__unacceptRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__unacceptRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__unacceptRequest * SOAP_FMAC4 soap_in___ngw__unacceptRequest(struct soap *soap, const char *tag, struct __ngw__unacceptRequest *a, const char *type)
{
	short soap_flag_ngwm__unacceptRequest = 1;
	a = (struct __ngw__unacceptRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__unacceptRequest, sizeof(struct __ngw__unacceptRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__unacceptRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__unacceptRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__unacceptRequest(soap, "ngwm:unacceptRequest", &a->ngwm__unacceptRequest, ""))
				{	soap_flag_ngwm__unacceptRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__startFreeBusySessionRequest(struct soap *soap, const struct __ngw__startFreeBusySessionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__startFreeBusySessionRequest, SOAP_TYPE_PointerTo_ngwm__startFreeBusySessionRequest);
	soap_serialize_PointerTo_ngwm__startFreeBusySessionRequest(soap, &a->ngwm__startFreeBusySessionRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__startFreeBusySessionRequest(struct soap *soap, struct __ngw__startFreeBusySessionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__startFreeBusySessionRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__startFreeBusySessionRequest(struct soap *soap, const struct __ngw__startFreeBusySessionRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__startFreeBusySessionRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__startFreeBusySessionRequest(struct soap *soap, const char *tag, int id, const struct __ngw__startFreeBusySessionRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__startFreeBusySessionRequest(soap, "ngwm:startFreeBusySessionRequest", -1, &a->ngwm__startFreeBusySessionRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__startFreeBusySessionRequest * SOAP_FMAC4 soap_get___ngw__startFreeBusySessionRequest(struct soap *soap, struct __ngw__startFreeBusySessionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__startFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__startFreeBusySessionRequest * SOAP_FMAC4 soap_in___ngw__startFreeBusySessionRequest(struct soap *soap, const char *tag, struct __ngw__startFreeBusySessionRequest *a, const char *type)
{
	short soap_flag_ngwm__startFreeBusySessionRequest = 1;
	a = (struct __ngw__startFreeBusySessionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__startFreeBusySessionRequest, sizeof(struct __ngw__startFreeBusySessionRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__startFreeBusySessionRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__startFreeBusySessionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__startFreeBusySessionRequest(soap, "ngwm:startFreeBusySessionRequest", &a->ngwm__startFreeBusySessionRequest, ""))
				{	soap_flag_ngwm__startFreeBusySessionRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__setTimestampRequest(struct soap *soap, const struct __ngw__setTimestampRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__setTimestampRequest, SOAP_TYPE_PointerTo_ngwm__setTimestampRequest);
	soap_serialize_PointerTo_ngwm__setTimestampRequest(soap, &a->ngwm__setTimestampRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__setTimestampRequest(struct soap *soap, struct __ngw__setTimestampRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__setTimestampRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__setTimestampRequest(struct soap *soap, const struct __ngw__setTimestampRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__setTimestampRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__setTimestampRequest(struct soap *soap, const char *tag, int id, const struct __ngw__setTimestampRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__setTimestampRequest(soap, "ngwm:setTimestampRequest", -1, &a->ngwm__setTimestampRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__setTimestampRequest * SOAP_FMAC4 soap_get___ngw__setTimestampRequest(struct soap *soap, struct __ngw__setTimestampRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__setTimestampRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__setTimestampRequest * SOAP_FMAC4 soap_in___ngw__setTimestampRequest(struct soap *soap, const char *tag, struct __ngw__setTimestampRequest *a, const char *type)
{
	short soap_flag_ngwm__setTimestampRequest = 1;
	a = (struct __ngw__setTimestampRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__setTimestampRequest, sizeof(struct __ngw__setTimestampRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__setTimestampRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__setTimestampRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__setTimestampRequest(soap, "ngwm:setTimestampRequest", &a->ngwm__setTimestampRequest, ""))
				{	soap_flag_ngwm__setTimestampRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__sendItemRequest(struct soap *soap, const struct __ngw__sendItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__sendItemRequest, SOAP_TYPE_PointerTo_ngwm__sendItemRequest);
	soap_serialize_PointerTo_ngwm__sendItemRequest(soap, &a->ngwm__sendItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__sendItemRequest(struct soap *soap, struct __ngw__sendItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__sendItemRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__sendItemRequest(struct soap *soap, const struct __ngw__sendItemRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__sendItemRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__sendItemRequest(struct soap *soap, const char *tag, int id, const struct __ngw__sendItemRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__sendItemRequest(soap, "ngwm:sendItemRequest", -1, &a->ngwm__sendItemRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__sendItemRequest * SOAP_FMAC4 soap_get___ngw__sendItemRequest(struct soap *soap, struct __ngw__sendItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__sendItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__sendItemRequest * SOAP_FMAC4 soap_in___ngw__sendItemRequest(struct soap *soap, const char *tag, struct __ngw__sendItemRequest *a, const char *type)
{
	short soap_flag_ngwm__sendItemRequest = 1;
	a = (struct __ngw__sendItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__sendItemRequest, sizeof(struct __ngw__sendItemRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__sendItemRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__sendItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__sendItemRequest(soap, "ngwm:sendItemRequest", &a->ngwm__sendItemRequest, ""))
				{	soap_flag_ngwm__sendItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__retractRequest(struct soap *soap, const struct __ngw__retractRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__retractRequest, SOAP_TYPE_PointerTo_ngwm__retractRequest);
	soap_serialize_PointerTo_ngwm__retractRequest(soap, &a->ngwm__retractRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__retractRequest(struct soap *soap, struct __ngw__retractRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__retractRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__retractRequest(struct soap *soap, const struct __ngw__retractRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__retractRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__retractRequest(struct soap *soap, const char *tag, int id, const struct __ngw__retractRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__retractRequest(soap, "ngwm:retractRequest", -1, &a->ngwm__retractRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__retractRequest * SOAP_FMAC4 soap_get___ngw__retractRequest(struct soap *soap, struct __ngw__retractRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__retractRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__retractRequest * SOAP_FMAC4 soap_in___ngw__retractRequest(struct soap *soap, const char *tag, struct __ngw__retractRequest *a, const char *type)
{
	short soap_flag_ngwm__retractRequest = 1;
	a = (struct __ngw__retractRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__retractRequest, sizeof(struct __ngw__retractRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__retractRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__retractRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__retractRequest(soap, "ngwm:retractRequest", &a->ngwm__retractRequest, ""))
				{	soap_flag_ngwm__retractRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__replyRequest(struct soap *soap, const struct __ngw__replyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__replyRequest, SOAP_TYPE_PointerTo_ngwm__replyRequest);
	soap_serialize_PointerTo_ngwm__replyRequest(soap, &a->ngwm__replyRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__replyRequest(struct soap *soap, struct __ngw__replyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__replyRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__replyRequest(struct soap *soap, const struct __ngw__replyRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__replyRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__replyRequest(struct soap *soap, const char *tag, int id, const struct __ngw__replyRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__replyRequest(soap, "ngwm:replyRequest", -1, &a->ngwm__replyRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__replyRequest * SOAP_FMAC4 soap_get___ngw__replyRequest(struct soap *soap, struct __ngw__replyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__replyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__replyRequest * SOAP_FMAC4 soap_in___ngw__replyRequest(struct soap *soap, const char *tag, struct __ngw__replyRequest *a, const char *type)
{
	short soap_flag_ngwm__replyRequest = 1;
	a = (struct __ngw__replyRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__replyRequest, sizeof(struct __ngw__replyRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__replyRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__replyRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__replyRequest(soap, "ngwm:replyRequest", &a->ngwm__replyRequest, ""))
				{	soap_flag_ngwm__replyRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__removeSignatureRequest(struct soap *soap, const struct __ngw__removeSignatureRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__removeSignatureRequest, SOAP_TYPE_PointerTo_ngwm__removeSignatureRequest);
	soap_serialize_PointerTo_ngwm__removeSignatureRequest(soap, &a->ngwm__removeSignatureRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__removeSignatureRequest(struct soap *soap, struct __ngw__removeSignatureRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__removeSignatureRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__removeSignatureRequest(struct soap *soap, const struct __ngw__removeSignatureRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__removeSignatureRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__removeSignatureRequest(struct soap *soap, const char *tag, int id, const struct __ngw__removeSignatureRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__removeSignatureRequest(soap, "ngwm:removeSignatureRequest", -1, &a->ngwm__removeSignatureRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__removeSignatureRequest * SOAP_FMAC4 soap_get___ngw__removeSignatureRequest(struct soap *soap, struct __ngw__removeSignatureRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__removeSignatureRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__removeSignatureRequest * SOAP_FMAC4 soap_in___ngw__removeSignatureRequest(struct soap *soap, const char *tag, struct __ngw__removeSignatureRequest *a, const char *type)
{
	short soap_flag_ngwm__removeSignatureRequest = 1;
	a = (struct __ngw__removeSignatureRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__removeSignatureRequest, sizeof(struct __ngw__removeSignatureRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__removeSignatureRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__removeSignatureRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__removeSignatureRequest(soap, "ngwm:removeSignatureRequest", &a->ngwm__removeSignatureRequest, ""))
				{	soap_flag_ngwm__removeSignatureRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__removeProxyUserRequest(struct soap *soap, const struct __ngw__removeProxyUserRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__removeProxyUserRequest, SOAP_TYPE_PointerTo_ngwm__removeProxyUserRequest);
	soap_serialize_PointerTo_ngwm__removeProxyUserRequest(soap, &a->ngwm__removeProxyUserRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__removeProxyUserRequest(struct soap *soap, struct __ngw__removeProxyUserRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__removeProxyUserRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__removeProxyUserRequest(struct soap *soap, const struct __ngw__removeProxyUserRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__removeProxyUserRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__removeProxyUserRequest(struct soap *soap, const char *tag, int id, const struct __ngw__removeProxyUserRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__removeProxyUserRequest(soap, "ngwm:removeProxyUserRequest", -1, &a->ngwm__removeProxyUserRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__removeProxyUserRequest * SOAP_FMAC4 soap_get___ngw__removeProxyUserRequest(struct soap *soap, struct __ngw__removeProxyUserRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__removeProxyUserRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__removeProxyUserRequest * SOAP_FMAC4 soap_in___ngw__removeProxyUserRequest(struct soap *soap, const char *tag, struct __ngw__removeProxyUserRequest *a, const char *type)
{
	short soap_flag_ngwm__removeProxyUserRequest = 1;
	a = (struct __ngw__removeProxyUserRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__removeProxyUserRequest, sizeof(struct __ngw__removeProxyUserRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__removeProxyUserRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__removeProxyUserRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__removeProxyUserRequest(soap, "ngwm:removeProxyUserRequest", &a->ngwm__removeProxyUserRequest, ""))
				{	soap_flag_ngwm__removeProxyUserRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__removeProxyAccessRequest(struct soap *soap, const struct __ngw__removeProxyAccessRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__removeProxyAccessRequest, SOAP_TYPE_PointerTo_ngwm__removeProxyAccessRequest);
	soap_serialize_PointerTo_ngwm__removeProxyAccessRequest(soap, &a->ngwm__removeProxyAccessRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__removeProxyAccessRequest(struct soap *soap, struct __ngw__removeProxyAccessRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__removeProxyAccessRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__removeProxyAccessRequest(struct soap *soap, const struct __ngw__removeProxyAccessRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__removeProxyAccessRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__removeProxyAccessRequest(struct soap *soap, const char *tag, int id, const struct __ngw__removeProxyAccessRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__removeProxyAccessRequest(soap, "ngwm:removeProxyAccessRequest", -1, &a->ngwm__removeProxyAccessRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__removeProxyAccessRequest * SOAP_FMAC4 soap_get___ngw__removeProxyAccessRequest(struct soap *soap, struct __ngw__removeProxyAccessRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__removeProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__removeProxyAccessRequest * SOAP_FMAC4 soap_in___ngw__removeProxyAccessRequest(struct soap *soap, const char *tag, struct __ngw__removeProxyAccessRequest *a, const char *type)
{
	short soap_flag_ngwm__removeProxyAccessRequest = 1;
	a = (struct __ngw__removeProxyAccessRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__removeProxyAccessRequest, sizeof(struct __ngw__removeProxyAccessRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__removeProxyAccessRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__removeProxyAccessRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__removeProxyAccessRequest(soap, "ngwm:removeProxyAccessRequest", &a->ngwm__removeProxyAccessRequest, ""))
				{	soap_flag_ngwm__removeProxyAccessRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__removeMembersRequest(struct soap *soap, const struct __ngw__removeMembersRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__removeMembersRequest, SOAP_TYPE_PointerTo_ngwm__removeMembersRequest);
	soap_serialize_PointerTo_ngwm__removeMembersRequest(soap, &a->ngwm__removeMembersRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__removeMembersRequest(struct soap *soap, struct __ngw__removeMembersRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__removeMembersRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__removeMembersRequest(struct soap *soap, const struct __ngw__removeMembersRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__removeMembersRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__removeMembersRequest(struct soap *soap, const char *tag, int id, const struct __ngw__removeMembersRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__removeMembersRequest(soap, "ngwm:removeMembersRequest", -1, &a->ngwm__removeMembersRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__removeMembersRequest * SOAP_FMAC4 soap_get___ngw__removeMembersRequest(struct soap *soap, struct __ngw__removeMembersRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__removeMembersRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__removeMembersRequest * SOAP_FMAC4 soap_in___ngw__removeMembersRequest(struct soap *soap, const char *tag, struct __ngw__removeMembersRequest *a, const char *type)
{
	short soap_flag_ngwm__removeMembersRequest = 1;
	a = (struct __ngw__removeMembersRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__removeMembersRequest, sizeof(struct __ngw__removeMembersRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__removeMembersRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__removeMembersRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__removeMembersRequest(soap, "ngwm:removeMembersRequest", &a->ngwm__removeMembersRequest, ""))
				{	soap_flag_ngwm__removeMembersRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__removeJunkEntryRequest(struct soap *soap, const struct __ngw__removeJunkEntryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__removeJunkEntryRequest, SOAP_TYPE_PointerTo_ngwm__removeJunkEntryRequest);
	soap_serialize_PointerTo_ngwm__removeJunkEntryRequest(soap, &a->ngwm__removeJunkEntryRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__removeJunkEntryRequest(struct soap *soap, struct __ngw__removeJunkEntryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__removeJunkEntryRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__removeJunkEntryRequest(struct soap *soap, const struct __ngw__removeJunkEntryRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__removeJunkEntryRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__removeJunkEntryRequest(struct soap *soap, const char *tag, int id, const struct __ngw__removeJunkEntryRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__removeJunkEntryRequest(soap, "ngwm:removeJunkEntryRequest", -1, &a->ngwm__removeJunkEntryRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__removeJunkEntryRequest * SOAP_FMAC4 soap_get___ngw__removeJunkEntryRequest(struct soap *soap, struct __ngw__removeJunkEntryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__removeJunkEntryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__removeJunkEntryRequest * SOAP_FMAC4 soap_in___ngw__removeJunkEntryRequest(struct soap *soap, const char *tag, struct __ngw__removeJunkEntryRequest *a, const char *type)
{
	short soap_flag_ngwm__removeJunkEntryRequest = 1;
	a = (struct __ngw__removeJunkEntryRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__removeJunkEntryRequest, sizeof(struct __ngw__removeJunkEntryRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__removeJunkEntryRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__removeJunkEntryRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__removeJunkEntryRequest(soap, "ngwm:removeJunkEntryRequest", &a->ngwm__removeJunkEntryRequest, ""))
				{	soap_flag_ngwm__removeJunkEntryRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__removeItemsRequest(struct soap *soap, const struct __ngw__removeItemsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__removeItemsRequest, SOAP_TYPE_PointerTo_ngwm__removeItemsRequest);
	soap_serialize_PointerTo_ngwm__removeItemsRequest(soap, &a->ngwm__removeItemsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__removeItemsRequest(struct soap *soap, struct __ngw__removeItemsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__removeItemsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__removeItemsRequest(struct soap *soap, const struct __ngw__removeItemsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__removeItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__removeItemsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__removeItemsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__removeItemsRequest(soap, "ngwm:removeItemsRequest", -1, &a->ngwm__removeItemsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__removeItemsRequest * SOAP_FMAC4 soap_get___ngw__removeItemsRequest(struct soap *soap, struct __ngw__removeItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__removeItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__removeItemsRequest * SOAP_FMAC4 soap_in___ngw__removeItemsRequest(struct soap *soap, const char *tag, struct __ngw__removeItemsRequest *a, const char *type)
{
	short soap_flag_ngwm__removeItemsRequest = 1;
	a = (struct __ngw__removeItemsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__removeItemsRequest, sizeof(struct __ngw__removeItemsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__removeItemsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__removeItemsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__removeItemsRequest(soap, "ngwm:removeItemsRequest", &a->ngwm__removeItemsRequest, ""))
				{	soap_flag_ngwm__removeItemsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__removeItemRequest(struct soap *soap, const struct __ngw__removeItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__removeItemRequest, SOAP_TYPE_PointerTo_ngwm__removeItemRequest);
	soap_serialize_PointerTo_ngwm__removeItemRequest(soap, &a->ngwm__removeItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__removeItemRequest(struct soap *soap, struct __ngw__removeItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__removeItemRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__removeItemRequest(struct soap *soap, const struct __ngw__removeItemRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__removeItemRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__removeItemRequest(struct soap *soap, const char *tag, int id, const struct __ngw__removeItemRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__removeItemRequest(soap, "ngwm:removeItemRequest", -1, &a->ngwm__removeItemRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__removeItemRequest * SOAP_FMAC4 soap_get___ngw__removeItemRequest(struct soap *soap, struct __ngw__removeItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__removeItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__removeItemRequest * SOAP_FMAC4 soap_in___ngw__removeItemRequest(struct soap *soap, const char *tag, struct __ngw__removeItemRequest *a, const char *type)
{
	short soap_flag_ngwm__removeItemRequest = 1;
	a = (struct __ngw__removeItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__removeItemRequest, sizeof(struct __ngw__removeItemRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__removeItemRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__removeItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__removeItemRequest(soap, "ngwm:removeItemRequest", &a->ngwm__removeItemRequest, ""))
				{	soap_flag_ngwm__removeItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__removeCustomDefinitionRequest(struct soap *soap, const struct __ngw__removeCustomDefinitionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__removeCustomDefinitionRequest, SOAP_TYPE_PointerTo_ngwm__removeCustomDefinitionRequest);
	soap_serialize_PointerTo_ngwm__removeCustomDefinitionRequest(soap, &a->ngwm__removeCustomDefinitionRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__removeCustomDefinitionRequest(struct soap *soap, struct __ngw__removeCustomDefinitionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__removeCustomDefinitionRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__removeCustomDefinitionRequest(struct soap *soap, const struct __ngw__removeCustomDefinitionRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__removeCustomDefinitionRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__removeCustomDefinitionRequest(struct soap *soap, const char *tag, int id, const struct __ngw__removeCustomDefinitionRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__removeCustomDefinitionRequest(soap, "ngwm:removeCustomDefinitionRequest", -1, &a->ngwm__removeCustomDefinitionRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__removeCustomDefinitionRequest * SOAP_FMAC4 soap_get___ngw__removeCustomDefinitionRequest(struct soap *soap, struct __ngw__removeCustomDefinitionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__removeCustomDefinitionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__removeCustomDefinitionRequest * SOAP_FMAC4 soap_in___ngw__removeCustomDefinitionRequest(struct soap *soap, const char *tag, struct __ngw__removeCustomDefinitionRequest *a, const char *type)
{
	short soap_flag_ngwm__removeCustomDefinitionRequest = 1;
	a = (struct __ngw__removeCustomDefinitionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__removeCustomDefinitionRequest, sizeof(struct __ngw__removeCustomDefinitionRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__removeCustomDefinitionRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__removeCustomDefinitionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__removeCustomDefinitionRequest(soap, "ngwm:removeCustomDefinitionRequest", &a->ngwm__removeCustomDefinitionRequest, ""))
				{	soap_flag_ngwm__removeCustomDefinitionRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__readCursorRequest(struct soap *soap, const struct __ngw__readCursorRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__readCursorRequest, SOAP_TYPE_PointerTo_ngwm__readCursorRequest);
	soap_serialize_PointerTo_ngwm__readCursorRequest(soap, &a->ngwm__readCursorRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__readCursorRequest(struct soap *soap, struct __ngw__readCursorRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__readCursorRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__readCursorRequest(struct soap *soap, const struct __ngw__readCursorRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__readCursorRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__readCursorRequest(struct soap *soap, const char *tag, int id, const struct __ngw__readCursorRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__readCursorRequest(soap, "ngwm:readCursorRequest", -1, &a->ngwm__readCursorRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__readCursorRequest * SOAP_FMAC4 soap_get___ngw__readCursorRequest(struct soap *soap, struct __ngw__readCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__readCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__readCursorRequest * SOAP_FMAC4 soap_in___ngw__readCursorRequest(struct soap *soap, const char *tag, struct __ngw__readCursorRequest *a, const char *type)
{
	short soap_flag_ngwm__readCursorRequest = 1;
	a = (struct __ngw__readCursorRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__readCursorRequest, sizeof(struct __ngw__readCursorRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__readCursorRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__readCursorRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__readCursorRequest(soap, "ngwm:readCursorRequest", &a->ngwm__readCursorRequest, ""))
				{	soap_flag_ngwm__readCursorRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__purgeRequest(struct soap *soap, const struct __ngw__purgeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__purgeRequest, SOAP_TYPE_PointerTo_ngwm__purgeRequest);
	soap_serialize_PointerTo_ngwm__purgeRequest(soap, &a->ngwm__purgeRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__purgeRequest(struct soap *soap, struct __ngw__purgeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__purgeRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__purgeRequest(struct soap *soap, const struct __ngw__purgeRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__purgeRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__purgeRequest(struct soap *soap, const char *tag, int id, const struct __ngw__purgeRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__purgeRequest(soap, "ngwm:purgeRequest", -1, &a->ngwm__purgeRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__purgeRequest * SOAP_FMAC4 soap_get___ngw__purgeRequest(struct soap *soap, struct __ngw__purgeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__purgeRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__purgeRequest * SOAP_FMAC4 soap_in___ngw__purgeRequest(struct soap *soap, const char *tag, struct __ngw__purgeRequest *a, const char *type)
{
	short soap_flag_ngwm__purgeRequest = 1;
	a = (struct __ngw__purgeRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__purgeRequest, sizeof(struct __ngw__purgeRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__purgeRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__purgeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__purgeRequest(soap, "ngwm:purgeRequest", &a->ngwm__purgeRequest, ""))
				{	soap_flag_ngwm__purgeRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__purgeDeletedItemsRequest(struct soap *soap, const struct __ngw__purgeDeletedItemsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__purgeDeletedItemsRequest, SOAP_TYPE_PointerTo_ngwm__purgeDeletedItemsRequest);
	soap_serialize_PointerTo_ngwm__purgeDeletedItemsRequest(soap, &a->ngwm__purgeDeletedItemsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__purgeDeletedItemsRequest(struct soap *soap, struct __ngw__purgeDeletedItemsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__purgeDeletedItemsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__purgeDeletedItemsRequest(struct soap *soap, const struct __ngw__purgeDeletedItemsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__purgeDeletedItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__purgeDeletedItemsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__purgeDeletedItemsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__purgeDeletedItemsRequest(soap, "ngwm:purgeDeletedItemsRequest", -1, &a->ngwm__purgeDeletedItemsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__purgeDeletedItemsRequest * SOAP_FMAC4 soap_get___ngw__purgeDeletedItemsRequest(struct soap *soap, struct __ngw__purgeDeletedItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__purgeDeletedItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__purgeDeletedItemsRequest * SOAP_FMAC4 soap_in___ngw__purgeDeletedItemsRequest(struct soap *soap, const char *tag, struct __ngw__purgeDeletedItemsRequest *a, const char *type)
{
	short soap_flag_ngwm__purgeDeletedItemsRequest = 1;
	a = (struct __ngw__purgeDeletedItemsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__purgeDeletedItemsRequest, sizeof(struct __ngw__purgeDeletedItemsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__purgeDeletedItemsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__purgeDeletedItemsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__purgeDeletedItemsRequest(soap, "ngwm:purgeDeletedItemsRequest", &a->ngwm__purgeDeletedItemsRequest, ""))
				{	soap_flag_ngwm__purgeDeletedItemsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__positionCursorRequest(struct soap *soap, const struct __ngw__positionCursorRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__positionCursorRequest, SOAP_TYPE_PointerTo_ngwm__positionCursorRequest);
	soap_serialize_PointerTo_ngwm__positionCursorRequest(soap, &a->ngwm__positionCursorRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__positionCursorRequest(struct soap *soap, struct __ngw__positionCursorRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__positionCursorRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__positionCursorRequest(struct soap *soap, const struct __ngw__positionCursorRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__positionCursorRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__positionCursorRequest(struct soap *soap, const char *tag, int id, const struct __ngw__positionCursorRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__positionCursorRequest(soap, "ngwm:positionCursorRequest", -1, &a->ngwm__positionCursorRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__positionCursorRequest * SOAP_FMAC4 soap_get___ngw__positionCursorRequest(struct soap *soap, struct __ngw__positionCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__positionCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__positionCursorRequest * SOAP_FMAC4 soap_in___ngw__positionCursorRequest(struct soap *soap, const char *tag, struct __ngw__positionCursorRequest *a, const char *type)
{
	short soap_flag_ngwm__positionCursorRequest = 1;
	a = (struct __ngw__positionCursorRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__positionCursorRequest, sizeof(struct __ngw__positionCursorRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__positionCursorRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__positionCursorRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__positionCursorRequest(soap, "ngwm:positionCursorRequest", &a->ngwm__positionCursorRequest, ""))
				{	soap_flag_ngwm__positionCursorRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__moveItemRequest(struct soap *soap, const struct __ngw__moveItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__moveItemRequest, SOAP_TYPE_PointerTo_ngwm__moveItemRequest);
	soap_serialize_PointerTo_ngwm__moveItemRequest(soap, &a->ngwm__moveItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__moveItemRequest(struct soap *soap, struct __ngw__moveItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__moveItemRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__moveItemRequest(struct soap *soap, const struct __ngw__moveItemRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__moveItemRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__moveItemRequest(struct soap *soap, const char *tag, int id, const struct __ngw__moveItemRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__moveItemRequest(soap, "ngwm:moveItemRequest", -1, &a->ngwm__moveItemRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__moveItemRequest * SOAP_FMAC4 soap_get___ngw__moveItemRequest(struct soap *soap, struct __ngw__moveItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__moveItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__moveItemRequest * SOAP_FMAC4 soap_in___ngw__moveItemRequest(struct soap *soap, const char *tag, struct __ngw__moveItemRequest *a, const char *type)
{
	short soap_flag_ngwm__moveItemRequest = 1;
	a = (struct __ngw__moveItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__moveItemRequest, sizeof(struct __ngw__moveItemRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__moveItemRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__moveItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__moveItemRequest(soap, "ngwm:moveItemRequest", &a->ngwm__moveItemRequest, ""))
				{	soap_flag_ngwm__moveItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__modifySignaturesRequest(struct soap *soap, const struct __ngw__modifySignaturesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__modifySignaturesRequest, SOAP_TYPE_PointerTo_ngwm__modifySignaturesRequest);
	soap_serialize_PointerTo_ngwm__modifySignaturesRequest(soap, &a->ngwm__modifySignaturesRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__modifySignaturesRequest(struct soap *soap, struct __ngw__modifySignaturesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__modifySignaturesRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__modifySignaturesRequest(struct soap *soap, const struct __ngw__modifySignaturesRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__modifySignaturesRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__modifySignaturesRequest(struct soap *soap, const char *tag, int id, const struct __ngw__modifySignaturesRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__modifySignaturesRequest(soap, "ngwm:modifySignaturesRequest", -1, &a->ngwm__modifySignaturesRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__modifySignaturesRequest * SOAP_FMAC4 soap_get___ngw__modifySignaturesRequest(struct soap *soap, struct __ngw__modifySignaturesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__modifySignaturesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__modifySignaturesRequest * SOAP_FMAC4 soap_in___ngw__modifySignaturesRequest(struct soap *soap, const char *tag, struct __ngw__modifySignaturesRequest *a, const char *type)
{
	short soap_flag_ngwm__modifySignaturesRequest = 1;
	a = (struct __ngw__modifySignaturesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__modifySignaturesRequest, sizeof(struct __ngw__modifySignaturesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__modifySignaturesRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__modifySignaturesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__modifySignaturesRequest(soap, "ngwm:modifySignaturesRequest", &a->ngwm__modifySignaturesRequest, ""))
				{	soap_flag_ngwm__modifySignaturesRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__modifySettingsRequest(struct soap *soap, const struct __ngw__modifySettingsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__modifySettingsRequest, SOAP_TYPE_PointerTo_ngwm__modifySettingsRequest);
	soap_serialize_PointerTo_ngwm__modifySettingsRequest(soap, &a->ngwm__modifySettingsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__modifySettingsRequest(struct soap *soap, struct __ngw__modifySettingsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__modifySettingsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__modifySettingsRequest(struct soap *soap, const struct __ngw__modifySettingsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__modifySettingsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__modifySettingsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__modifySettingsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__modifySettingsRequest(soap, "ngwm:modifySettingsRequest", -1, &a->ngwm__modifySettingsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__modifySettingsRequest * SOAP_FMAC4 soap_get___ngw__modifySettingsRequest(struct soap *soap, struct __ngw__modifySettingsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__modifySettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__modifySettingsRequest * SOAP_FMAC4 soap_in___ngw__modifySettingsRequest(struct soap *soap, const char *tag, struct __ngw__modifySettingsRequest *a, const char *type)
{
	short soap_flag_ngwm__modifySettingsRequest = 1;
	a = (struct __ngw__modifySettingsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__modifySettingsRequest, sizeof(struct __ngw__modifySettingsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__modifySettingsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__modifySettingsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__modifySettingsRequest(soap, "ngwm:modifySettingsRequest", &a->ngwm__modifySettingsRequest, ""))
				{	soap_flag_ngwm__modifySettingsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__modifyProxyAccessRequest(struct soap *soap, const struct __ngw__modifyProxyAccessRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__modifyProxyAccessRequest, SOAP_TYPE_PointerTo_ngwm__modifyProxyAccessRequest);
	soap_serialize_PointerTo_ngwm__modifyProxyAccessRequest(soap, &a->ngwm__modifyProxyAccessRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__modifyProxyAccessRequest(struct soap *soap, struct __ngw__modifyProxyAccessRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__modifyProxyAccessRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__modifyProxyAccessRequest(struct soap *soap, const struct __ngw__modifyProxyAccessRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__modifyProxyAccessRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__modifyProxyAccessRequest(struct soap *soap, const char *tag, int id, const struct __ngw__modifyProxyAccessRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__modifyProxyAccessRequest(soap, "ngwm:modifyProxyAccessRequest", -1, &a->ngwm__modifyProxyAccessRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__modifyProxyAccessRequest * SOAP_FMAC4 soap_get___ngw__modifyProxyAccessRequest(struct soap *soap, struct __ngw__modifyProxyAccessRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__modifyProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__modifyProxyAccessRequest * SOAP_FMAC4 soap_in___ngw__modifyProxyAccessRequest(struct soap *soap, const char *tag, struct __ngw__modifyProxyAccessRequest *a, const char *type)
{
	short soap_flag_ngwm__modifyProxyAccessRequest = 1;
	a = (struct __ngw__modifyProxyAccessRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__modifyProxyAccessRequest, sizeof(struct __ngw__modifyProxyAccessRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__modifyProxyAccessRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__modifyProxyAccessRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__modifyProxyAccessRequest(soap, "ngwm:modifyProxyAccessRequest", &a->ngwm__modifyProxyAccessRequest, ""))
				{	soap_flag_ngwm__modifyProxyAccessRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__modifyPasswordRequest(struct soap *soap, const struct __ngw__modifyPasswordRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__modifyPasswordRequest, SOAP_TYPE_PointerTo_ngwm__modifyPasswordRequest);
	soap_serialize_PointerTo_ngwm__modifyPasswordRequest(soap, &a->ngwm__modifyPasswordRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__modifyPasswordRequest(struct soap *soap, struct __ngw__modifyPasswordRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__modifyPasswordRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__modifyPasswordRequest(struct soap *soap, const struct __ngw__modifyPasswordRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__modifyPasswordRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__modifyPasswordRequest(struct soap *soap, const char *tag, int id, const struct __ngw__modifyPasswordRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__modifyPasswordRequest(soap, "ngwm:modifyPasswordRequest", -1, &a->ngwm__modifyPasswordRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__modifyPasswordRequest * SOAP_FMAC4 soap_get___ngw__modifyPasswordRequest(struct soap *soap, struct __ngw__modifyPasswordRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__modifyPasswordRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__modifyPasswordRequest * SOAP_FMAC4 soap_in___ngw__modifyPasswordRequest(struct soap *soap, const char *tag, struct __ngw__modifyPasswordRequest *a, const char *type)
{
	short soap_flag_ngwm__modifyPasswordRequest = 1;
	a = (struct __ngw__modifyPasswordRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__modifyPasswordRequest, sizeof(struct __ngw__modifyPasswordRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__modifyPasswordRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__modifyPasswordRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__modifyPasswordRequest(soap, "ngwm:modifyPasswordRequest", &a->ngwm__modifyPasswordRequest, ""))
				{	soap_flag_ngwm__modifyPasswordRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__modifyJunkMailSettingsRequest(struct soap *soap, const struct __ngw__modifyJunkMailSettingsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__modifyJunkMailSettingsRequest, SOAP_TYPE_PointerTo_ngwm__modifyJunkMailSettingsRequest);
	soap_serialize_PointerTo_ngwm__modifyJunkMailSettingsRequest(soap, &a->ngwm__modifyJunkMailSettingsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__modifyJunkMailSettingsRequest(struct soap *soap, struct __ngw__modifyJunkMailSettingsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__modifyJunkMailSettingsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__modifyJunkMailSettingsRequest(struct soap *soap, const struct __ngw__modifyJunkMailSettingsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__modifyJunkMailSettingsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__modifyJunkMailSettingsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__modifyJunkMailSettingsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__modifyJunkMailSettingsRequest(soap, "ngwm:modifyJunkMailSettingsRequest", -1, &a->ngwm__modifyJunkMailSettingsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__modifyJunkMailSettingsRequest * SOAP_FMAC4 soap_get___ngw__modifyJunkMailSettingsRequest(struct soap *soap, struct __ngw__modifyJunkMailSettingsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__modifyJunkMailSettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__modifyJunkMailSettingsRequest * SOAP_FMAC4 soap_in___ngw__modifyJunkMailSettingsRequest(struct soap *soap, const char *tag, struct __ngw__modifyJunkMailSettingsRequest *a, const char *type)
{
	short soap_flag_ngwm__modifyJunkMailSettingsRequest = 1;
	a = (struct __ngw__modifyJunkMailSettingsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__modifyJunkMailSettingsRequest, sizeof(struct __ngw__modifyJunkMailSettingsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__modifyJunkMailSettingsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__modifyJunkMailSettingsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__modifyJunkMailSettingsRequest(soap, "ngwm:modifyJunkMailSettingsRequest", &a->ngwm__modifyJunkMailSettingsRequest, ""))
				{	soap_flag_ngwm__modifyJunkMailSettingsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__modifyJunkEntryRequest(struct soap *soap, const struct __ngw__modifyJunkEntryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__modifyJunkEntryRequest, SOAP_TYPE_PointerTo_ngwm__modifyJunkEntryRequest);
	soap_serialize_PointerTo_ngwm__modifyJunkEntryRequest(soap, &a->ngwm__modifyJunkEntryRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__modifyJunkEntryRequest(struct soap *soap, struct __ngw__modifyJunkEntryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__modifyJunkEntryRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__modifyJunkEntryRequest(struct soap *soap, const struct __ngw__modifyJunkEntryRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__modifyJunkEntryRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__modifyJunkEntryRequest(struct soap *soap, const char *tag, int id, const struct __ngw__modifyJunkEntryRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__modifyJunkEntryRequest(soap, "ngwm:modifyJunkEntryRequest", -1, &a->ngwm__modifyJunkEntryRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__modifyJunkEntryRequest * SOAP_FMAC4 soap_get___ngw__modifyJunkEntryRequest(struct soap *soap, struct __ngw__modifyJunkEntryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__modifyJunkEntryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__modifyJunkEntryRequest * SOAP_FMAC4 soap_in___ngw__modifyJunkEntryRequest(struct soap *soap, const char *tag, struct __ngw__modifyJunkEntryRequest *a, const char *type)
{
	short soap_flag_ngwm__modifyJunkEntryRequest = 1;
	a = (struct __ngw__modifyJunkEntryRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__modifyJunkEntryRequest, sizeof(struct __ngw__modifyJunkEntryRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__modifyJunkEntryRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__modifyJunkEntryRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__modifyJunkEntryRequest(soap, "ngwm:modifyJunkEntryRequest", &a->ngwm__modifyJunkEntryRequest, ""))
				{	soap_flag_ngwm__modifyJunkEntryRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__modifyItemRequest(struct soap *soap, const struct __ngw__modifyItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__modifyItemRequest, SOAP_TYPE_PointerTo_ngwm__modifyItemRequest);
	soap_serialize_PointerTo_ngwm__modifyItemRequest(soap, &a->ngwm__modifyItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__modifyItemRequest(struct soap *soap, struct __ngw__modifyItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__modifyItemRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__modifyItemRequest(struct soap *soap, const struct __ngw__modifyItemRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__modifyItemRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__modifyItemRequest(struct soap *soap, const char *tag, int id, const struct __ngw__modifyItemRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__modifyItemRequest(soap, "ngwm:modifyItemRequest", -1, &a->ngwm__modifyItemRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__modifyItemRequest * SOAP_FMAC4 soap_get___ngw__modifyItemRequest(struct soap *soap, struct __ngw__modifyItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__modifyItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__modifyItemRequest * SOAP_FMAC4 soap_in___ngw__modifyItemRequest(struct soap *soap, const char *tag, struct __ngw__modifyItemRequest *a, const char *type)
{
	short soap_flag_ngwm__modifyItemRequest = 1;
	a = (struct __ngw__modifyItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__modifyItemRequest, sizeof(struct __ngw__modifyItemRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__modifyItemRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__modifyItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__modifyItemRequest(soap, "ngwm:modifyItemRequest", &a->ngwm__modifyItemRequest, ""))
				{	soap_flag_ngwm__modifyItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__markUnReadRequest(struct soap *soap, const struct __ngw__markUnReadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__markUnReadRequest, SOAP_TYPE_PointerTo_ngwm__markUnReadRequest);
	soap_serialize_PointerTo_ngwm__markUnReadRequest(soap, &a->ngwm__markUnReadRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__markUnReadRequest(struct soap *soap, struct __ngw__markUnReadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__markUnReadRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__markUnReadRequest(struct soap *soap, const struct __ngw__markUnReadRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__markUnReadRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__markUnReadRequest(struct soap *soap, const char *tag, int id, const struct __ngw__markUnReadRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__markUnReadRequest(soap, "ngwm:markUnReadRequest", -1, &a->ngwm__markUnReadRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__markUnReadRequest * SOAP_FMAC4 soap_get___ngw__markUnReadRequest(struct soap *soap, struct __ngw__markUnReadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__markUnReadRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__markUnReadRequest * SOAP_FMAC4 soap_in___ngw__markUnReadRequest(struct soap *soap, const char *tag, struct __ngw__markUnReadRequest *a, const char *type)
{
	short soap_flag_ngwm__markUnReadRequest = 1;
	a = (struct __ngw__markUnReadRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__markUnReadRequest, sizeof(struct __ngw__markUnReadRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__markUnReadRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__markUnReadRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__markUnReadRequest(soap, "ngwm:markUnReadRequest", &a->ngwm__markUnReadRequest, ""))
				{	soap_flag_ngwm__markUnReadRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__markUnPrivateRequest(struct soap *soap, const struct __ngw__markUnPrivateRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__markUnPrivateRequest, SOAP_TYPE_PointerTo_ngwm__markUnPrivateRequest);
	soap_serialize_PointerTo_ngwm__markUnPrivateRequest(soap, &a->ngwm__markUnPrivateRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__markUnPrivateRequest(struct soap *soap, struct __ngw__markUnPrivateRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__markUnPrivateRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__markUnPrivateRequest(struct soap *soap, const struct __ngw__markUnPrivateRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__markUnPrivateRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__markUnPrivateRequest(struct soap *soap, const char *tag, int id, const struct __ngw__markUnPrivateRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__markUnPrivateRequest(soap, "ngwm:markUnPrivateRequest", -1, &a->ngwm__markUnPrivateRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__markUnPrivateRequest * SOAP_FMAC4 soap_get___ngw__markUnPrivateRequest(struct soap *soap, struct __ngw__markUnPrivateRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__markUnPrivateRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__markUnPrivateRequest * SOAP_FMAC4 soap_in___ngw__markUnPrivateRequest(struct soap *soap, const char *tag, struct __ngw__markUnPrivateRequest *a, const char *type)
{
	short soap_flag_ngwm__markUnPrivateRequest = 1;
	a = (struct __ngw__markUnPrivateRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__markUnPrivateRequest, sizeof(struct __ngw__markUnPrivateRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__markUnPrivateRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__markUnPrivateRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__markUnPrivateRequest(soap, "ngwm:markUnPrivateRequest", &a->ngwm__markUnPrivateRequest, ""))
				{	soap_flag_ngwm__markUnPrivateRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__markReadRequest(struct soap *soap, const struct __ngw__markReadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__markReadRequest, SOAP_TYPE_PointerTo_ngwm__markReadRequest);
	soap_serialize_PointerTo_ngwm__markReadRequest(soap, &a->ngwm__markReadRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__markReadRequest(struct soap *soap, struct __ngw__markReadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__markReadRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__markReadRequest(struct soap *soap, const struct __ngw__markReadRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__markReadRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__markReadRequest(struct soap *soap, const char *tag, int id, const struct __ngw__markReadRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__markReadRequest(soap, "ngwm:markReadRequest", -1, &a->ngwm__markReadRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__markReadRequest * SOAP_FMAC4 soap_get___ngw__markReadRequest(struct soap *soap, struct __ngw__markReadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__markReadRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__markReadRequest * SOAP_FMAC4 soap_in___ngw__markReadRequest(struct soap *soap, const char *tag, struct __ngw__markReadRequest *a, const char *type)
{
	short soap_flag_ngwm__markReadRequest = 1;
	a = (struct __ngw__markReadRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__markReadRequest, sizeof(struct __ngw__markReadRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__markReadRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__markReadRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__markReadRequest(soap, "ngwm:markReadRequest", &a->ngwm__markReadRequest, ""))
				{	soap_flag_ngwm__markReadRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__markPrivateRequest(struct soap *soap, const struct __ngw__markPrivateRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__markPrivateRequest, SOAP_TYPE_PointerTo_ngwm__markPrivateRequest);
	soap_serialize_PointerTo_ngwm__markPrivateRequest(soap, &a->ngwm__markPrivateRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__markPrivateRequest(struct soap *soap, struct __ngw__markPrivateRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__markPrivateRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__markPrivateRequest(struct soap *soap, const struct __ngw__markPrivateRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__markPrivateRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__markPrivateRequest(struct soap *soap, const char *tag, int id, const struct __ngw__markPrivateRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__markPrivateRequest(soap, "ngwm:markPrivateRequest", -1, &a->ngwm__markPrivateRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__markPrivateRequest * SOAP_FMAC4 soap_get___ngw__markPrivateRequest(struct soap *soap, struct __ngw__markPrivateRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__markPrivateRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__markPrivateRequest * SOAP_FMAC4 soap_in___ngw__markPrivateRequest(struct soap *soap, const char *tag, struct __ngw__markPrivateRequest *a, const char *type)
{
	short soap_flag_ngwm__markPrivateRequest = 1;
	a = (struct __ngw__markPrivateRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__markPrivateRequest, sizeof(struct __ngw__markPrivateRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__markPrivateRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__markPrivateRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__markPrivateRequest(soap, "ngwm:markPrivateRequest", &a->ngwm__markPrivateRequest, ""))
				{	soap_flag_ngwm__markPrivateRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__logoutRequest(struct soap *soap, const struct __ngw__logoutRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__logoutRequest, SOAP_TYPE_PointerTo_ngwm__logoutRequest);
	soap_serialize_PointerTo_ngwm__logoutRequest(soap, &a->ngwm__logoutRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__logoutRequest(struct soap *soap, struct __ngw__logoutRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__logoutRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__logoutRequest(struct soap *soap, const struct __ngw__logoutRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__logoutRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__logoutRequest(struct soap *soap, const char *tag, int id, const struct __ngw__logoutRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__logoutRequest(soap, "ngwm:logoutRequest", -1, &a->ngwm__logoutRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__logoutRequest * SOAP_FMAC4 soap_get___ngw__logoutRequest(struct soap *soap, struct __ngw__logoutRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__logoutRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__logoutRequest * SOAP_FMAC4 soap_in___ngw__logoutRequest(struct soap *soap, const char *tag, struct __ngw__logoutRequest *a, const char *type)
{
	short soap_flag_ngwm__logoutRequest = 1;
	a = (struct __ngw__logoutRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__logoutRequest, sizeof(struct __ngw__logoutRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__logoutRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__logoutRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__logoutRequest(soap, "ngwm:logoutRequest", &a->ngwm__logoutRequest, ""))
				{	soap_flag_ngwm__logoutRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__loginRequest(struct soap *soap, const struct __ngw__loginRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__loginRequest, SOAP_TYPE_PointerTo_ngwm__loginRequest);
	soap_serialize_PointerTo_ngwm__loginRequest(soap, &a->ngwm__loginRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__loginRequest(struct soap *soap, struct __ngw__loginRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__loginRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__loginRequest(struct soap *soap, const struct __ngw__loginRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__loginRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__loginRequest(struct soap *soap, const char *tag, int id, const struct __ngw__loginRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__loginRequest(soap, "ngwm:loginRequest", -1, &a->ngwm__loginRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__loginRequest * SOAP_FMAC4 soap_get___ngw__loginRequest(struct soap *soap, struct __ngw__loginRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__loginRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__loginRequest * SOAP_FMAC4 soap_in___ngw__loginRequest(struct soap *soap, const char *tag, struct __ngw__loginRequest *a, const char *type)
{
	short soap_flag_ngwm__loginRequest = 1;
	a = (struct __ngw__loginRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__loginRequest, sizeof(struct __ngw__loginRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__loginRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__loginRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__loginRequest(soap, "ngwm:loginRequest", &a->ngwm__loginRequest, ""))
				{	soap_flag_ngwm__loginRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getUserListRequest(struct soap *soap, const struct __ngw__getUserListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getUserListRequest, SOAP_TYPE_PointerTo_ngwm__getUserListRequest);
	soap_serialize_PointerTo_ngwm__getUserListRequest(soap, &a->ngwm__getUserListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getUserListRequest(struct soap *soap, struct __ngw__getUserListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getUserListRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getUserListRequest(struct soap *soap, const struct __ngw__getUserListRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getUserListRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getUserListRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getUserListRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getUserListRequest(soap, "ngwm:getUserListRequest", -1, &a->ngwm__getUserListRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getUserListRequest * SOAP_FMAC4 soap_get___ngw__getUserListRequest(struct soap *soap, struct __ngw__getUserListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getUserListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getUserListRequest * SOAP_FMAC4 soap_in___ngw__getUserListRequest(struct soap *soap, const char *tag, struct __ngw__getUserListRequest *a, const char *type)
{
	short soap_flag_ngwm__getUserListRequest = 1;
	a = (struct __ngw__getUserListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getUserListRequest, sizeof(struct __ngw__getUserListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getUserListRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getUserListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getUserListRequest(soap, "ngwm:getUserListRequest", &a->ngwm__getUserListRequest, ""))
				{	soap_flag_ngwm__getUserListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getTimezoneListRequest(struct soap *soap, const struct __ngw__getTimezoneListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getTimezoneListRequest, SOAP_TYPE_PointerTo_ngwm__getTimezoneListRequest);
	soap_serialize_PointerTo_ngwm__getTimezoneListRequest(soap, &a->ngwm__getTimezoneListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getTimezoneListRequest(struct soap *soap, struct __ngw__getTimezoneListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getTimezoneListRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getTimezoneListRequest(struct soap *soap, const struct __ngw__getTimezoneListRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getTimezoneListRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getTimezoneListRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getTimezoneListRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getTimezoneListRequest(soap, "ngwm:getTimezoneListRequest", -1, &a->ngwm__getTimezoneListRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getTimezoneListRequest * SOAP_FMAC4 soap_get___ngw__getTimezoneListRequest(struct soap *soap, struct __ngw__getTimezoneListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getTimezoneListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getTimezoneListRequest * SOAP_FMAC4 soap_in___ngw__getTimezoneListRequest(struct soap *soap, const char *tag, struct __ngw__getTimezoneListRequest *a, const char *type)
{
	short soap_flag_ngwm__getTimezoneListRequest = 1;
	a = (struct __ngw__getTimezoneListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getTimezoneListRequest, sizeof(struct __ngw__getTimezoneListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getTimezoneListRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getTimezoneListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getTimezoneListRequest(soap, "ngwm:getTimezoneListRequest", &a->ngwm__getTimezoneListRequest, ""))
				{	soap_flag_ngwm__getTimezoneListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getTimestampRequest(struct soap *soap, const struct __ngw__getTimestampRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getTimestampRequest, SOAP_TYPE_PointerTo_ngwm__getTimestampRequest);
	soap_serialize_PointerTo_ngwm__getTimestampRequest(soap, &a->ngwm__getTimestampRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getTimestampRequest(struct soap *soap, struct __ngw__getTimestampRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getTimestampRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getTimestampRequest(struct soap *soap, const struct __ngw__getTimestampRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getTimestampRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getTimestampRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getTimestampRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getTimestampRequest(soap, "ngwm:getTimestampRequest", -1, &a->ngwm__getTimestampRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getTimestampRequest * SOAP_FMAC4 soap_get___ngw__getTimestampRequest(struct soap *soap, struct __ngw__getTimestampRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getTimestampRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getTimestampRequest * SOAP_FMAC4 soap_in___ngw__getTimestampRequest(struct soap *soap, const char *tag, struct __ngw__getTimestampRequest *a, const char *type)
{
	short soap_flag_ngwm__getTimestampRequest = 1;
	a = (struct __ngw__getTimestampRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getTimestampRequest, sizeof(struct __ngw__getTimestampRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getTimestampRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getTimestampRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getTimestampRequest(soap, "ngwm:getTimestampRequest", &a->ngwm__getTimestampRequest, ""))
				{	soap_flag_ngwm__getTimestampRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getSignaturesRequest(struct soap *soap, const struct __ngw__getSignaturesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getSignaturesRequest, SOAP_TYPE_PointerTo_ngwm__getSignaturesRequest);
	soap_serialize_PointerTo_ngwm__getSignaturesRequest(soap, &a->ngwm__getSignaturesRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getSignaturesRequest(struct soap *soap, struct __ngw__getSignaturesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getSignaturesRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getSignaturesRequest(struct soap *soap, const struct __ngw__getSignaturesRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getSignaturesRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getSignaturesRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getSignaturesRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getSignaturesRequest(soap, "ngwm:getSignaturesRequest", -1, &a->ngwm__getSignaturesRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getSignaturesRequest * SOAP_FMAC4 soap_get___ngw__getSignaturesRequest(struct soap *soap, struct __ngw__getSignaturesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getSignaturesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getSignaturesRequest * SOAP_FMAC4 soap_in___ngw__getSignaturesRequest(struct soap *soap, const char *tag, struct __ngw__getSignaturesRequest *a, const char *type)
{
	short soap_flag_ngwm__getSignaturesRequest = 1;
	a = (struct __ngw__getSignaturesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getSignaturesRequest, sizeof(struct __ngw__getSignaturesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getSignaturesRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getSignaturesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getSignaturesRequest(soap, "ngwm:getSignaturesRequest", &a->ngwm__getSignaturesRequest, ""))
				{	soap_flag_ngwm__getSignaturesRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getSettingsRequest(struct soap *soap, const struct __ngw__getSettingsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getSettingsRequest, SOAP_TYPE_PointerTo_ngwm__getSettingsRequest);
	soap_serialize_PointerTo_ngwm__getSettingsRequest(soap, &a->ngwm__getSettingsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getSettingsRequest(struct soap *soap, struct __ngw__getSettingsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getSettingsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getSettingsRequest(struct soap *soap, const struct __ngw__getSettingsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getSettingsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getSettingsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getSettingsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getSettingsRequest(soap, "ngwm:getSettingsRequest", -1, &a->ngwm__getSettingsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getSettingsRequest * SOAP_FMAC4 soap_get___ngw__getSettingsRequest(struct soap *soap, struct __ngw__getSettingsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getSettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getSettingsRequest * SOAP_FMAC4 soap_in___ngw__getSettingsRequest(struct soap *soap, const char *tag, struct __ngw__getSettingsRequest *a, const char *type)
{
	short soap_flag_ngwm__getSettingsRequest = 1;
	a = (struct __ngw__getSettingsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getSettingsRequest, sizeof(struct __ngw__getSettingsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getSettingsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getSettingsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getSettingsRequest(soap, "ngwm:getSettingsRequest", &a->ngwm__getSettingsRequest, ""))
				{	soap_flag_ngwm__getSettingsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getRuleListRequest(struct soap *soap, const struct __ngw__getRuleListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getRuleListRequest, SOAP_TYPE_PointerTo_ngwm__getRuleListRequest);
	soap_serialize_PointerTo_ngwm__getRuleListRequest(soap, &a->ngwm__getRuleListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getRuleListRequest(struct soap *soap, struct __ngw__getRuleListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getRuleListRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getRuleListRequest(struct soap *soap, const struct __ngw__getRuleListRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getRuleListRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getRuleListRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getRuleListRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getRuleListRequest(soap, "ngwm:getRuleListRequest", -1, &a->ngwm__getRuleListRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getRuleListRequest * SOAP_FMAC4 soap_get___ngw__getRuleListRequest(struct soap *soap, struct __ngw__getRuleListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getRuleListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getRuleListRequest * SOAP_FMAC4 soap_in___ngw__getRuleListRequest(struct soap *soap, const char *tag, struct __ngw__getRuleListRequest *a, const char *type)
{
	short soap_flag_ngwm__getRuleListRequest = 1;
	a = (struct __ngw__getRuleListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getRuleListRequest, sizeof(struct __ngw__getRuleListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getRuleListRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getRuleListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getRuleListRequest(soap, "ngwm:getRuleListRequest", &a->ngwm__getRuleListRequest, ""))
				{	soap_flag_ngwm__getRuleListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getProxyListRequest(struct soap *soap, const struct __ngw__getProxyListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getProxyListRequest, SOAP_TYPE_PointerTo_ngwm__getProxyListRequest);
	soap_serialize_PointerTo_ngwm__getProxyListRequest(soap, &a->ngwm__getProxyListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getProxyListRequest(struct soap *soap, struct __ngw__getProxyListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getProxyListRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getProxyListRequest(struct soap *soap, const struct __ngw__getProxyListRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getProxyListRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getProxyListRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getProxyListRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getProxyListRequest(soap, "ngwm:getProxyListRequest", -1, &a->ngwm__getProxyListRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getProxyListRequest * SOAP_FMAC4 soap_get___ngw__getProxyListRequest(struct soap *soap, struct __ngw__getProxyListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getProxyListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getProxyListRequest * SOAP_FMAC4 soap_in___ngw__getProxyListRequest(struct soap *soap, const char *tag, struct __ngw__getProxyListRequest *a, const char *type)
{
	short soap_flag_ngwm__getProxyListRequest = 1;
	a = (struct __ngw__getProxyListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getProxyListRequest, sizeof(struct __ngw__getProxyListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getProxyListRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getProxyListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getProxyListRequest(soap, "ngwm:getProxyListRequest", &a->ngwm__getProxyListRequest, ""))
				{	soap_flag_ngwm__getProxyListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getProxyAccessListRequest(struct soap *soap, const struct __ngw__getProxyAccessListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getProxyAccessListRequest, SOAP_TYPE_PointerTo_ngwm__getProxyAccessListRequest);
	soap_serialize_PointerTo_ngwm__getProxyAccessListRequest(soap, &a->ngwm__getProxyAccessListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getProxyAccessListRequest(struct soap *soap, struct __ngw__getProxyAccessListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getProxyAccessListRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getProxyAccessListRequest(struct soap *soap, const struct __ngw__getProxyAccessListRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getProxyAccessListRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getProxyAccessListRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getProxyAccessListRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getProxyAccessListRequest(soap, "ngwm:getProxyAccessListRequest", -1, &a->ngwm__getProxyAccessListRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getProxyAccessListRequest * SOAP_FMAC4 soap_get___ngw__getProxyAccessListRequest(struct soap *soap, struct __ngw__getProxyAccessListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getProxyAccessListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getProxyAccessListRequest * SOAP_FMAC4 soap_in___ngw__getProxyAccessListRequest(struct soap *soap, const char *tag, struct __ngw__getProxyAccessListRequest *a, const char *type)
{
	short soap_flag_ngwm__getProxyAccessListRequest = 1;
	a = (struct __ngw__getProxyAccessListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getProxyAccessListRequest, sizeof(struct __ngw__getProxyAccessListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getProxyAccessListRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getProxyAccessListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getProxyAccessListRequest(soap, "ngwm:getProxyAccessListRequest", &a->ngwm__getProxyAccessListRequest, ""))
				{	soap_flag_ngwm__getProxyAccessListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getQuickMessagesRequest(struct soap *soap, const struct __ngw__getQuickMessagesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getQuickMessagesRequest, SOAP_TYPE_PointerTo_ngwm__getQuickMessagesRequest);
	soap_serialize_PointerTo_ngwm__getQuickMessagesRequest(soap, &a->ngwm__getQuickMessagesRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getQuickMessagesRequest(struct soap *soap, struct __ngw__getQuickMessagesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getQuickMessagesRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getQuickMessagesRequest(struct soap *soap, const struct __ngw__getQuickMessagesRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getQuickMessagesRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getQuickMessagesRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getQuickMessagesRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getQuickMessagesRequest(soap, "ngwm:getQuickMessagesRequest", -1, &a->ngwm__getQuickMessagesRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getQuickMessagesRequest * SOAP_FMAC4 soap_get___ngw__getQuickMessagesRequest(struct soap *soap, struct __ngw__getQuickMessagesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getQuickMessagesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getQuickMessagesRequest * SOAP_FMAC4 soap_in___ngw__getQuickMessagesRequest(struct soap *soap, const char *tag, struct __ngw__getQuickMessagesRequest *a, const char *type)
{
	short soap_flag_ngwm__getQuickMessagesRequest = 1;
	a = (struct __ngw__getQuickMessagesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getQuickMessagesRequest, sizeof(struct __ngw__getQuickMessagesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getQuickMessagesRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getQuickMessagesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getQuickMessagesRequest(soap, "ngwm:getQuickMessagesRequest", &a->ngwm__getQuickMessagesRequest, ""))
				{	soap_flag_ngwm__getQuickMessagesRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getLibraryListRequest(struct soap *soap, const struct __ngw__getLibraryListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getLibraryListRequest, SOAP_TYPE_PointerTo_ngwm__getLibraryListRequest);
	soap_serialize_PointerTo_ngwm__getLibraryListRequest(soap, &a->ngwm__getLibraryListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getLibraryListRequest(struct soap *soap, struct __ngw__getLibraryListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getLibraryListRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getLibraryListRequest(struct soap *soap, const struct __ngw__getLibraryListRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getLibraryListRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getLibraryListRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getLibraryListRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getLibraryListRequest(soap, "ngwm:getLibraryListRequest", -1, &a->ngwm__getLibraryListRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getLibraryListRequest * SOAP_FMAC4 soap_get___ngw__getLibraryListRequest(struct soap *soap, struct __ngw__getLibraryListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getLibraryListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getLibraryListRequest * SOAP_FMAC4 soap_in___ngw__getLibraryListRequest(struct soap *soap, const char *tag, struct __ngw__getLibraryListRequest *a, const char *type)
{
	short soap_flag_ngwm__getLibraryListRequest = 1;
	a = (struct __ngw__getLibraryListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getLibraryListRequest, sizeof(struct __ngw__getLibraryListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getLibraryListRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getLibraryListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getLibraryListRequest(soap, "ngwm:getLibraryListRequest", &a->ngwm__getLibraryListRequest, ""))
				{	soap_flag_ngwm__getLibraryListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getLibraryItemRequest(struct soap *soap, const struct __ngw__getLibraryItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getLibraryItemRequest, SOAP_TYPE_PointerTo_ngwm__getLibraryItemRequest);
	soap_serialize_PointerTo_ngwm__getLibraryItemRequest(soap, &a->ngwm__getLibraryItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getLibraryItemRequest(struct soap *soap, struct __ngw__getLibraryItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getLibraryItemRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getLibraryItemRequest(struct soap *soap, const struct __ngw__getLibraryItemRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getLibraryItemRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getLibraryItemRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getLibraryItemRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getLibraryItemRequest(soap, "ngwm:getLibraryItemRequest", -1, &a->ngwm__getLibraryItemRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getLibraryItemRequest * SOAP_FMAC4 soap_get___ngw__getLibraryItemRequest(struct soap *soap, struct __ngw__getLibraryItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getLibraryItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getLibraryItemRequest * SOAP_FMAC4 soap_in___ngw__getLibraryItemRequest(struct soap *soap, const char *tag, struct __ngw__getLibraryItemRequest *a, const char *type)
{
	short soap_flag_ngwm__getLibraryItemRequest = 1;
	a = (struct __ngw__getLibraryItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getLibraryItemRequest, sizeof(struct __ngw__getLibraryItemRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getLibraryItemRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getLibraryItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getLibraryItemRequest(soap, "ngwm:getLibraryItemRequest", &a->ngwm__getLibraryItemRequest, ""))
				{	soap_flag_ngwm__getLibraryItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getJunkMailSettingsRequest(struct soap *soap, const struct __ngw__getJunkMailSettingsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getJunkMailSettingsRequest, SOAP_TYPE_PointerTo_ngwm__getJunkMailSettingsRequest);
	soap_serialize_PointerTo_ngwm__getJunkMailSettingsRequest(soap, &a->ngwm__getJunkMailSettingsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getJunkMailSettingsRequest(struct soap *soap, struct __ngw__getJunkMailSettingsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getJunkMailSettingsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getJunkMailSettingsRequest(struct soap *soap, const struct __ngw__getJunkMailSettingsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getJunkMailSettingsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getJunkMailSettingsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getJunkMailSettingsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getJunkMailSettingsRequest(soap, "ngwm:getJunkMailSettingsRequest", -1, &a->ngwm__getJunkMailSettingsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getJunkMailSettingsRequest * SOAP_FMAC4 soap_get___ngw__getJunkMailSettingsRequest(struct soap *soap, struct __ngw__getJunkMailSettingsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getJunkMailSettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getJunkMailSettingsRequest * SOAP_FMAC4 soap_in___ngw__getJunkMailSettingsRequest(struct soap *soap, const char *tag, struct __ngw__getJunkMailSettingsRequest *a, const char *type)
{
	short soap_flag_ngwm__getJunkMailSettingsRequest = 1;
	a = (struct __ngw__getJunkMailSettingsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getJunkMailSettingsRequest, sizeof(struct __ngw__getJunkMailSettingsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getJunkMailSettingsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getJunkMailSettingsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getJunkMailSettingsRequest(soap, "ngwm:getJunkMailSettingsRequest", &a->ngwm__getJunkMailSettingsRequest, ""))
				{	soap_flag_ngwm__getJunkMailSettingsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getJunkEntriesRequest(struct soap *soap, const struct __ngw__getJunkEntriesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getJunkEntriesRequest, SOAP_TYPE_PointerTo_ngwm__getJunkEntriesRequest);
	soap_serialize_PointerTo_ngwm__getJunkEntriesRequest(soap, &a->ngwm__getJunkEntriesRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getJunkEntriesRequest(struct soap *soap, struct __ngw__getJunkEntriesRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getJunkEntriesRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getJunkEntriesRequest(struct soap *soap, const struct __ngw__getJunkEntriesRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getJunkEntriesRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getJunkEntriesRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getJunkEntriesRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getJunkEntriesRequest(soap, "ngwm:getJunkEntriesRequest", -1, &a->ngwm__getJunkEntriesRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getJunkEntriesRequest * SOAP_FMAC4 soap_get___ngw__getJunkEntriesRequest(struct soap *soap, struct __ngw__getJunkEntriesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getJunkEntriesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getJunkEntriesRequest * SOAP_FMAC4 soap_in___ngw__getJunkEntriesRequest(struct soap *soap, const char *tag, struct __ngw__getJunkEntriesRequest *a, const char *type)
{
	short soap_flag_ngwm__getJunkEntriesRequest = 1;
	a = (struct __ngw__getJunkEntriesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getJunkEntriesRequest, sizeof(struct __ngw__getJunkEntriesRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getJunkEntriesRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getJunkEntriesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getJunkEntriesRequest(soap, "ngwm:getJunkEntriesRequest", &a->ngwm__getJunkEntriesRequest, ""))
				{	soap_flag_ngwm__getJunkEntriesRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getItemsRequest(struct soap *soap, const struct __ngw__getItemsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getItemsRequest, SOAP_TYPE_PointerTo_ngwm__getItemsRequest);
	soap_serialize_PointerTo_ngwm__getItemsRequest(soap, &a->ngwm__getItemsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getItemsRequest(struct soap *soap, struct __ngw__getItemsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getItemsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getItemsRequest(struct soap *soap, const struct __ngw__getItemsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getItemsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getItemsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getItemsRequest(soap, "ngwm:getItemsRequest", -1, &a->ngwm__getItemsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getItemsRequest * SOAP_FMAC4 soap_get___ngw__getItemsRequest(struct soap *soap, struct __ngw__getItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getItemsRequest * SOAP_FMAC4 soap_in___ngw__getItemsRequest(struct soap *soap, const char *tag, struct __ngw__getItemsRequest *a, const char *type)
{
	short soap_flag_ngwm__getItemsRequest = 1;
	a = (struct __ngw__getItemsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getItemsRequest, sizeof(struct __ngw__getItemsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getItemsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getItemsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getItemsRequest(soap, "ngwm:getItemsRequest", &a->ngwm__getItemsRequest, ""))
				{	soap_flag_ngwm__getItemsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getItemRequest(struct soap *soap, const struct __ngw__getItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getItemRequest, SOAP_TYPE_PointerTo_ngwm__getItemRequest);
	soap_serialize_PointerTo_ngwm__getItemRequest(soap, &a->ngwm__getItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getItemRequest(struct soap *soap, struct __ngw__getItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getItemRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getItemRequest(struct soap *soap, const struct __ngw__getItemRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getItemRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getItemRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getItemRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getItemRequest(soap, "ngwm:getItemRequest", -1, &a->ngwm__getItemRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getItemRequest * SOAP_FMAC4 soap_get___ngw__getItemRequest(struct soap *soap, struct __ngw__getItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getItemRequest * SOAP_FMAC4 soap_in___ngw__getItemRequest(struct soap *soap, const char *tag, struct __ngw__getItemRequest *a, const char *type)
{
	short soap_flag_ngwm__getItemRequest = 1;
	a = (struct __ngw__getItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getItemRequest, sizeof(struct __ngw__getItemRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getItemRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getItemRequest(soap, "ngwm:getItemRequest", &a->ngwm__getItemRequest, ""))
				{	soap_flag_ngwm__getItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getFreeBusyRequest(struct soap *soap, const struct __ngw__getFreeBusyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getFreeBusyRequest, SOAP_TYPE_PointerTo_ngwm__getFreeBusyRequest);
	soap_serialize_PointerTo_ngwm__getFreeBusyRequest(soap, &a->ngwm__getFreeBusyRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getFreeBusyRequest(struct soap *soap, struct __ngw__getFreeBusyRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getFreeBusyRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getFreeBusyRequest(struct soap *soap, const struct __ngw__getFreeBusyRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getFreeBusyRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getFreeBusyRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getFreeBusyRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getFreeBusyRequest(soap, "ngwm:getFreeBusyRequest", -1, &a->ngwm__getFreeBusyRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getFreeBusyRequest * SOAP_FMAC4 soap_get___ngw__getFreeBusyRequest(struct soap *soap, struct __ngw__getFreeBusyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getFreeBusyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getFreeBusyRequest * SOAP_FMAC4 soap_in___ngw__getFreeBusyRequest(struct soap *soap, const char *tag, struct __ngw__getFreeBusyRequest *a, const char *type)
{
	short soap_flag_ngwm__getFreeBusyRequest = 1;
	a = (struct __ngw__getFreeBusyRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getFreeBusyRequest, sizeof(struct __ngw__getFreeBusyRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getFreeBusyRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getFreeBusyRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getFreeBusyRequest(soap, "ngwm:getFreeBusyRequest", &a->ngwm__getFreeBusyRequest, ""))
				{	soap_flag_ngwm__getFreeBusyRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getFolderListRequest(struct soap *soap, const struct __ngw__getFolderListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getFolderListRequest, SOAP_TYPE_PointerTo_ngwm__getFolderListRequest);
	soap_serialize_PointerTo_ngwm__getFolderListRequest(soap, &a->ngwm__getFolderListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getFolderListRequest(struct soap *soap, struct __ngw__getFolderListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getFolderListRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getFolderListRequest(struct soap *soap, const struct __ngw__getFolderListRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getFolderListRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getFolderListRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getFolderListRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getFolderListRequest(soap, "ngwm:getFolderListRequest", -1, &a->ngwm__getFolderListRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getFolderListRequest * SOAP_FMAC4 soap_get___ngw__getFolderListRequest(struct soap *soap, struct __ngw__getFolderListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getFolderListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getFolderListRequest * SOAP_FMAC4 soap_in___ngw__getFolderListRequest(struct soap *soap, const char *tag, struct __ngw__getFolderListRequest *a, const char *type)
{
	short soap_flag_ngwm__getFolderListRequest = 1;
	a = (struct __ngw__getFolderListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getFolderListRequest, sizeof(struct __ngw__getFolderListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getFolderListRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getFolderListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getFolderListRequest(soap, "ngwm:getFolderListRequest", &a->ngwm__getFolderListRequest, ""))
				{	soap_flag_ngwm__getFolderListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getFolderRequest(struct soap *soap, const struct __ngw__getFolderRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getFolderRequest, SOAP_TYPE_PointerTo_ngwm__getFolderRequest);
	soap_serialize_PointerTo_ngwm__getFolderRequest(soap, &a->ngwm__getFolderRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getFolderRequest(struct soap *soap, struct __ngw__getFolderRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getFolderRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getFolderRequest(struct soap *soap, const struct __ngw__getFolderRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getFolderRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getFolderRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getFolderRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getFolderRequest(soap, "ngwm:getFolderRequest", -1, &a->ngwm__getFolderRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getFolderRequest * SOAP_FMAC4 soap_get___ngw__getFolderRequest(struct soap *soap, struct __ngw__getFolderRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getFolderRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getFolderRequest * SOAP_FMAC4 soap_in___ngw__getFolderRequest(struct soap *soap, const char *tag, struct __ngw__getFolderRequest *a, const char *type)
{
	short soap_flag_ngwm__getFolderRequest = 1;
	a = (struct __ngw__getFolderRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getFolderRequest, sizeof(struct __ngw__getFolderRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getFolderRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getFolderRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getFolderRequest(soap, "ngwm:getFolderRequest", &a->ngwm__getFolderRequest, ""))
				{	soap_flag_ngwm__getFolderRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getDocumentTypeListRequest(struct soap *soap, const struct __ngw__getDocumentTypeListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getDocumentTypeListRequest, SOAP_TYPE_PointerTo_ngwm__getDocumentTypeListRequest);
	soap_serialize_PointerTo_ngwm__getDocumentTypeListRequest(soap, &a->ngwm__getDocumentTypeListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getDocumentTypeListRequest(struct soap *soap, struct __ngw__getDocumentTypeListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getDocumentTypeListRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getDocumentTypeListRequest(struct soap *soap, const struct __ngw__getDocumentTypeListRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getDocumentTypeListRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getDocumentTypeListRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getDocumentTypeListRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getDocumentTypeListRequest(soap, "ngwm:getDocumentTypeListRequest", -1, &a->ngwm__getDocumentTypeListRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getDocumentTypeListRequest * SOAP_FMAC4 soap_get___ngw__getDocumentTypeListRequest(struct soap *soap, struct __ngw__getDocumentTypeListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getDocumentTypeListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getDocumentTypeListRequest * SOAP_FMAC4 soap_in___ngw__getDocumentTypeListRequest(struct soap *soap, const char *tag, struct __ngw__getDocumentTypeListRequest *a, const char *type)
{
	short soap_flag_ngwm__getDocumentTypeListRequest = 1;
	a = (struct __ngw__getDocumentTypeListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getDocumentTypeListRequest, sizeof(struct __ngw__getDocumentTypeListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getDocumentTypeListRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getDocumentTypeListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getDocumentTypeListRequest(soap, "ngwm:getDocumentTypeListRequest", &a->ngwm__getDocumentTypeListRequest, ""))
				{	soap_flag_ngwm__getDocumentTypeListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getDeltaInfoRequest(struct soap *soap, const struct __ngw__getDeltaInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getDeltaInfoRequest, SOAP_TYPE_PointerTo_ngwm__getDeltaInfoRequest);
	soap_serialize_PointerTo_ngwm__getDeltaInfoRequest(soap, &a->ngwm__getDeltaInfoRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getDeltaInfoRequest(struct soap *soap, struct __ngw__getDeltaInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getDeltaInfoRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getDeltaInfoRequest(struct soap *soap, const struct __ngw__getDeltaInfoRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getDeltaInfoRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getDeltaInfoRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getDeltaInfoRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getDeltaInfoRequest(soap, "ngwm:getDeltaInfoRequest", -1, &a->ngwm__getDeltaInfoRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getDeltaInfoRequest * SOAP_FMAC4 soap_get___ngw__getDeltaInfoRequest(struct soap *soap, struct __ngw__getDeltaInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getDeltaInfoRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getDeltaInfoRequest * SOAP_FMAC4 soap_in___ngw__getDeltaInfoRequest(struct soap *soap, const char *tag, struct __ngw__getDeltaInfoRequest *a, const char *type)
{
	short soap_flag_ngwm__getDeltaInfoRequest = 1;
	a = (struct __ngw__getDeltaInfoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getDeltaInfoRequest, sizeof(struct __ngw__getDeltaInfoRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getDeltaInfoRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getDeltaInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getDeltaInfoRequest(soap, "ngwm:getDeltaInfoRequest", &a->ngwm__getDeltaInfoRequest, ""))
				{	soap_flag_ngwm__getDeltaInfoRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getDeltasRequest(struct soap *soap, const struct __ngw__getDeltasRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getDeltasRequest, SOAP_TYPE_PointerTo_ngwm__getDeltasRequest);
	soap_serialize_PointerTo_ngwm__getDeltasRequest(soap, &a->ngwm__getDeltasRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getDeltasRequest(struct soap *soap, struct __ngw__getDeltasRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getDeltasRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getDeltasRequest(struct soap *soap, const struct __ngw__getDeltasRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getDeltasRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getDeltasRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getDeltasRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getDeltasRequest(soap, "ngwm:getDeltasRequest", -1, &a->ngwm__getDeltasRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getDeltasRequest * SOAP_FMAC4 soap_get___ngw__getDeltasRequest(struct soap *soap, struct __ngw__getDeltasRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getDeltasRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getDeltasRequest * SOAP_FMAC4 soap_in___ngw__getDeltasRequest(struct soap *soap, const char *tag, struct __ngw__getDeltasRequest *a, const char *type)
{
	short soap_flag_ngwm__getDeltasRequest = 1;
	a = (struct __ngw__getDeltasRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getDeltasRequest, sizeof(struct __ngw__getDeltasRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getDeltasRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getDeltasRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getDeltasRequest(soap, "ngwm:getDeltasRequest", &a->ngwm__getDeltasRequest, ""))
				{	soap_flag_ngwm__getDeltasRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getCustomListRequest(struct soap *soap, const struct __ngw__getCustomListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getCustomListRequest, SOAP_TYPE_PointerTo_ngwm__getCustomListRequest);
	soap_serialize_PointerTo_ngwm__getCustomListRequest(soap, &a->ngwm__getCustomListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getCustomListRequest(struct soap *soap, struct __ngw__getCustomListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getCustomListRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getCustomListRequest(struct soap *soap, const struct __ngw__getCustomListRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getCustomListRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getCustomListRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getCustomListRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getCustomListRequest(soap, "ngwm:getCustomListRequest", -1, &a->ngwm__getCustomListRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getCustomListRequest * SOAP_FMAC4 soap_get___ngw__getCustomListRequest(struct soap *soap, struct __ngw__getCustomListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getCustomListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getCustomListRequest * SOAP_FMAC4 soap_in___ngw__getCustomListRequest(struct soap *soap, const char *tag, struct __ngw__getCustomListRequest *a, const char *type)
{
	short soap_flag_ngwm__getCustomListRequest = 1;
	a = (struct __ngw__getCustomListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getCustomListRequest, sizeof(struct __ngw__getCustomListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getCustomListRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getCustomListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getCustomListRequest(soap, "ngwm:getCustomListRequest", &a->ngwm__getCustomListRequest, ""))
				{	soap_flag_ngwm__getCustomListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getCategoryListRequest(struct soap *soap, const struct __ngw__getCategoryListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getCategoryListRequest, SOAP_TYPE_PointerTo_ngwm__getCategoryListRequest);
	soap_serialize_PointerTo_ngwm__getCategoryListRequest(soap, &a->ngwm__getCategoryListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getCategoryListRequest(struct soap *soap, struct __ngw__getCategoryListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getCategoryListRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getCategoryListRequest(struct soap *soap, const struct __ngw__getCategoryListRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getCategoryListRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getCategoryListRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getCategoryListRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getCategoryListRequest(soap, "ngwm:getCategoryListRequest", -1, &a->ngwm__getCategoryListRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getCategoryListRequest * SOAP_FMAC4 soap_get___ngw__getCategoryListRequest(struct soap *soap, struct __ngw__getCategoryListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getCategoryListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getCategoryListRequest * SOAP_FMAC4 soap_in___ngw__getCategoryListRequest(struct soap *soap, const char *tag, struct __ngw__getCategoryListRequest *a, const char *type)
{
	short soap_flag_ngwm__getCategoryListRequest = 1;
	a = (struct __ngw__getCategoryListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getCategoryListRequest, sizeof(struct __ngw__getCategoryListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getCategoryListRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getCategoryListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getCategoryListRequest(soap, "ngwm:getCategoryListRequest", &a->ngwm__getCategoryListRequest, ""))
				{	soap_flag_ngwm__getCategoryListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getAttachmentRequestMessage(struct soap *soap, const struct __ngw__getAttachmentRequestMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getAttachmentRequest, SOAP_TYPE_PointerTo_ngwm__getAttachmentRequest);
	soap_serialize_PointerTo_ngwm__getAttachmentRequest(soap, &a->ngwm__getAttachmentRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getAttachmentRequestMessage(struct soap *soap, struct __ngw__getAttachmentRequestMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getAttachmentRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getAttachmentRequestMessage(struct soap *soap, const struct __ngw__getAttachmentRequestMessage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getAttachmentRequestMessage(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getAttachmentRequestMessage(struct soap *soap, const char *tag, int id, const struct __ngw__getAttachmentRequestMessage *a, const char *type)
{
	soap_out_PointerTo_ngwm__getAttachmentRequest(soap, "ngwm:getAttachmentRequest", -1, &a->ngwm__getAttachmentRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getAttachmentRequestMessage * SOAP_FMAC4 soap_get___ngw__getAttachmentRequestMessage(struct soap *soap, struct __ngw__getAttachmentRequestMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getAttachmentRequestMessage(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getAttachmentRequestMessage * SOAP_FMAC4 soap_in___ngw__getAttachmentRequestMessage(struct soap *soap, const char *tag, struct __ngw__getAttachmentRequestMessage *a, const char *type)
{
	short soap_flag_ngwm__getAttachmentRequest = 1;
	a = (struct __ngw__getAttachmentRequestMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getAttachmentRequestMessage, sizeof(struct __ngw__getAttachmentRequestMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getAttachmentRequestMessage(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getAttachmentRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getAttachmentRequest(soap, "ngwm:getAttachmentRequest", &a->ngwm__getAttachmentRequest, ""))
				{	soap_flag_ngwm__getAttachmentRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__getAddressBookListRequest(struct soap *soap, const struct __ngw__getAddressBookListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__getAddressBookListRequest, SOAP_TYPE_PointerTo_ngwm__getAddressBookListRequest);
	soap_serialize_PointerTo_ngwm__getAddressBookListRequest(soap, &a->ngwm__getAddressBookListRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__getAddressBookListRequest(struct soap *soap, struct __ngw__getAddressBookListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__getAddressBookListRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__getAddressBookListRequest(struct soap *soap, const struct __ngw__getAddressBookListRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__getAddressBookListRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__getAddressBookListRequest(struct soap *soap, const char *tag, int id, const struct __ngw__getAddressBookListRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__getAddressBookListRequest(soap, "ngwm:getAddressBookListRequest", -1, &a->ngwm__getAddressBookListRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__getAddressBookListRequest * SOAP_FMAC4 soap_get___ngw__getAddressBookListRequest(struct soap *soap, struct __ngw__getAddressBookListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__getAddressBookListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__getAddressBookListRequest * SOAP_FMAC4 soap_in___ngw__getAddressBookListRequest(struct soap *soap, const char *tag, struct __ngw__getAddressBookListRequest *a, const char *type)
{
	short soap_flag_ngwm__getAddressBookListRequest = 1;
	a = (struct __ngw__getAddressBookListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__getAddressBookListRequest, sizeof(struct __ngw__getAddressBookListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__getAddressBookListRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__getAddressBookListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__getAddressBookListRequest(soap, "ngwm:getAddressBookListRequest", &a->ngwm__getAddressBookListRequest, ""))
				{	soap_flag_ngwm__getAddressBookListRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__forwardRequest(struct soap *soap, const struct __ngw__forwardRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__forwardRequest, SOAP_TYPE_PointerTo_ngwm__forwardRequest);
	soap_serialize_PointerTo_ngwm__forwardRequest(soap, &a->ngwm__forwardRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__forwardRequest(struct soap *soap, struct __ngw__forwardRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__forwardRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__forwardRequest(struct soap *soap, const struct __ngw__forwardRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__forwardRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__forwardRequest(struct soap *soap, const char *tag, int id, const struct __ngw__forwardRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__forwardRequest(soap, "ngwm:forwardRequest", -1, &a->ngwm__forwardRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__forwardRequest * SOAP_FMAC4 soap_get___ngw__forwardRequest(struct soap *soap, struct __ngw__forwardRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__forwardRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__forwardRequest * SOAP_FMAC4 soap_in___ngw__forwardRequest(struct soap *soap, const char *tag, struct __ngw__forwardRequest *a, const char *type)
{
	short soap_flag_ngwm__forwardRequest = 1;
	a = (struct __ngw__forwardRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__forwardRequest, sizeof(struct __ngw__forwardRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__forwardRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__forwardRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__forwardRequest(soap, "ngwm:forwardRequest", &a->ngwm__forwardRequest, ""))
				{	soap_flag_ngwm__forwardRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__executeRuleRequest(struct soap *soap, const struct __ngw__executeRuleRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__executeRuleRequest, SOAP_TYPE_PointerTo_ngwm__executeRuleRequest);
	soap_serialize_PointerTo_ngwm__executeRuleRequest(soap, &a->ngwm__executeRuleRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__executeRuleRequest(struct soap *soap, struct __ngw__executeRuleRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__executeRuleRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__executeRuleRequest(struct soap *soap, const struct __ngw__executeRuleRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__executeRuleRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__executeRuleRequest(struct soap *soap, const char *tag, int id, const struct __ngw__executeRuleRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__executeRuleRequest(soap, "ngwm:executeRuleRequest", -1, &a->ngwm__executeRuleRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__executeRuleRequest * SOAP_FMAC4 soap_get___ngw__executeRuleRequest(struct soap *soap, struct __ngw__executeRuleRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__executeRuleRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__executeRuleRequest * SOAP_FMAC4 soap_in___ngw__executeRuleRequest(struct soap *soap, const char *tag, struct __ngw__executeRuleRequest *a, const char *type)
{
	short soap_flag_ngwm__executeRuleRequest = 1;
	a = (struct __ngw__executeRuleRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__executeRuleRequest, sizeof(struct __ngw__executeRuleRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__executeRuleRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__executeRuleRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__executeRuleRequest(soap, "ngwm:executeRuleRequest", &a->ngwm__executeRuleRequest, ""))
				{	soap_flag_ngwm__executeRuleRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__destroyCursorRequest(struct soap *soap, const struct __ngw__destroyCursorRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__destroyCursorRequest, SOAP_TYPE_PointerTo_ngwm__destroyCursorRequest);
	soap_serialize_PointerTo_ngwm__destroyCursorRequest(soap, &a->ngwm__destroyCursorRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__destroyCursorRequest(struct soap *soap, struct __ngw__destroyCursorRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__destroyCursorRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__destroyCursorRequest(struct soap *soap, const struct __ngw__destroyCursorRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__destroyCursorRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__destroyCursorRequest(struct soap *soap, const char *tag, int id, const struct __ngw__destroyCursorRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__destroyCursorRequest(soap, "ngwm:destroyCursorRequest", -1, &a->ngwm__destroyCursorRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__destroyCursorRequest * SOAP_FMAC4 soap_get___ngw__destroyCursorRequest(struct soap *soap, struct __ngw__destroyCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__destroyCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__destroyCursorRequest * SOAP_FMAC4 soap_in___ngw__destroyCursorRequest(struct soap *soap, const char *tag, struct __ngw__destroyCursorRequest *a, const char *type)
{
	short soap_flag_ngwm__destroyCursorRequest = 1;
	a = (struct __ngw__destroyCursorRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__destroyCursorRequest, sizeof(struct __ngw__destroyCursorRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__destroyCursorRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__destroyCursorRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__destroyCursorRequest(soap, "ngwm:destroyCursorRequest", &a->ngwm__destroyCursorRequest, ""))
				{	soap_flag_ngwm__destroyCursorRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__delegateRequest(struct soap *soap, const struct __ngw__delegateRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__delegateRequest, SOAP_TYPE_PointerTo_ngwm__delegateRequest);
	soap_serialize_PointerTo_ngwm__delegateRequest(soap, &a->ngwm__delegateRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__delegateRequest(struct soap *soap, struct __ngw__delegateRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__delegateRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__delegateRequest(struct soap *soap, const struct __ngw__delegateRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__delegateRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__delegateRequest(struct soap *soap, const char *tag, int id, const struct __ngw__delegateRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__delegateRequest(soap, "ngwm:delegateRequest", -1, &a->ngwm__delegateRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__delegateRequest * SOAP_FMAC4 soap_get___ngw__delegateRequest(struct soap *soap, struct __ngw__delegateRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__delegateRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__delegateRequest * SOAP_FMAC4 soap_in___ngw__delegateRequest(struct soap *soap, const char *tag, struct __ngw__delegateRequest *a, const char *type)
{
	short soap_flag_ngwm__delegateRequest = 1;
	a = (struct __ngw__delegateRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__delegateRequest, sizeof(struct __ngw__delegateRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__delegateRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__delegateRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__delegateRequest(soap, "ngwm:delegateRequest", &a->ngwm__delegateRequest, ""))
				{	soap_flag_ngwm__delegateRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__declineRequest(struct soap *soap, const struct __ngw__declineRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__declineRequest, SOAP_TYPE_PointerTo_ngwm__declineRequest);
	soap_serialize_PointerTo_ngwm__declineRequest(soap, &a->ngwm__declineRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__declineRequest(struct soap *soap, struct __ngw__declineRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__declineRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__declineRequest(struct soap *soap, const struct __ngw__declineRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__declineRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__declineRequest(struct soap *soap, const char *tag, int id, const struct __ngw__declineRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__declineRequest(soap, "ngwm:declineRequest", -1, &a->ngwm__declineRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__declineRequest * SOAP_FMAC4 soap_get___ngw__declineRequest(struct soap *soap, struct __ngw__declineRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__declineRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__declineRequest * SOAP_FMAC4 soap_in___ngw__declineRequest(struct soap *soap, const char *tag, struct __ngw__declineRequest *a, const char *type)
{
	short soap_flag_ngwm__declineRequest = 1;
	a = (struct __ngw__declineRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__declineRequest, sizeof(struct __ngw__declineRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__declineRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__declineRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__declineRequest(soap, "ngwm:declineRequest", &a->ngwm__declineRequest, ""))
				{	soap_flag_ngwm__declineRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__createSignatureRequest(struct soap *soap, const struct __ngw__createSignatureRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__createSignatureRequest, SOAP_TYPE_PointerTo_ngwm__createSignatureRequest);
	soap_serialize_PointerTo_ngwm__createSignatureRequest(soap, &a->ngwm__createSignatureRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__createSignatureRequest(struct soap *soap, struct __ngw__createSignatureRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__createSignatureRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__createSignatureRequest(struct soap *soap, const struct __ngw__createSignatureRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__createSignatureRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__createSignatureRequest(struct soap *soap, const char *tag, int id, const struct __ngw__createSignatureRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__createSignatureRequest(soap, "ngwm:createSignatureRequest", -1, &a->ngwm__createSignatureRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__createSignatureRequest * SOAP_FMAC4 soap_get___ngw__createSignatureRequest(struct soap *soap, struct __ngw__createSignatureRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__createSignatureRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__createSignatureRequest * SOAP_FMAC4 soap_in___ngw__createSignatureRequest(struct soap *soap, const char *tag, struct __ngw__createSignatureRequest *a, const char *type)
{
	short soap_flag_ngwm__createSignatureRequest = 1;
	a = (struct __ngw__createSignatureRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__createSignatureRequest, sizeof(struct __ngw__createSignatureRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__createSignatureRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__createSignatureRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__createSignatureRequest(soap, "ngwm:createSignatureRequest", &a->ngwm__createSignatureRequest, ""))
				{	soap_flag_ngwm__createSignatureRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__createProxyAccessRequest(struct soap *soap, const struct __ngw__createProxyAccessRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__createProxyAccessRequest, SOAP_TYPE_PointerTo_ngwm__createProxyAccessRequest);
	soap_serialize_PointerTo_ngwm__createProxyAccessRequest(soap, &a->ngwm__createProxyAccessRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__createProxyAccessRequest(struct soap *soap, struct __ngw__createProxyAccessRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__createProxyAccessRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__createProxyAccessRequest(struct soap *soap, const struct __ngw__createProxyAccessRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__createProxyAccessRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__createProxyAccessRequest(struct soap *soap, const char *tag, int id, const struct __ngw__createProxyAccessRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__createProxyAccessRequest(soap, "ngwm:createProxyAccessRequest", -1, &a->ngwm__createProxyAccessRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__createProxyAccessRequest * SOAP_FMAC4 soap_get___ngw__createProxyAccessRequest(struct soap *soap, struct __ngw__createProxyAccessRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__createProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__createProxyAccessRequest * SOAP_FMAC4 soap_in___ngw__createProxyAccessRequest(struct soap *soap, const char *tag, struct __ngw__createProxyAccessRequest *a, const char *type)
{
	short soap_flag_ngwm__createProxyAccessRequest = 1;
	a = (struct __ngw__createProxyAccessRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__createProxyAccessRequest, sizeof(struct __ngw__createProxyAccessRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__createProxyAccessRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__createProxyAccessRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__createProxyAccessRequest(soap, "ngwm:createProxyAccessRequest", &a->ngwm__createProxyAccessRequest, ""))
				{	soap_flag_ngwm__createProxyAccessRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__createJunkEntryRequest(struct soap *soap, const struct __ngw__createJunkEntryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__createJunkEntryRequest, SOAP_TYPE_PointerTo_ngwm__createJunkEntryRequest);
	soap_serialize_PointerTo_ngwm__createJunkEntryRequest(soap, &a->ngwm__createJunkEntryRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__createJunkEntryRequest(struct soap *soap, struct __ngw__createJunkEntryRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__createJunkEntryRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__createJunkEntryRequest(struct soap *soap, const struct __ngw__createJunkEntryRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__createJunkEntryRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__createJunkEntryRequest(struct soap *soap, const char *tag, int id, const struct __ngw__createJunkEntryRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__createJunkEntryRequest(soap, "ngwm:createJunkEntryRequest", -1, &a->ngwm__createJunkEntryRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__createJunkEntryRequest * SOAP_FMAC4 soap_get___ngw__createJunkEntryRequest(struct soap *soap, struct __ngw__createJunkEntryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__createJunkEntryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__createJunkEntryRequest * SOAP_FMAC4 soap_in___ngw__createJunkEntryRequest(struct soap *soap, const char *tag, struct __ngw__createJunkEntryRequest *a, const char *type)
{
	short soap_flag_ngwm__createJunkEntryRequest = 1;
	a = (struct __ngw__createJunkEntryRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__createJunkEntryRequest, sizeof(struct __ngw__createJunkEntryRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__createJunkEntryRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__createJunkEntryRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__createJunkEntryRequest(soap, "ngwm:createJunkEntryRequest", &a->ngwm__createJunkEntryRequest, ""))
				{	soap_flag_ngwm__createJunkEntryRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__createItemsRequest(struct soap *soap, const struct __ngw__createItemsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__createItemsRequest, SOAP_TYPE_PointerTo_ngwm__createItemsRequest);
	soap_serialize_PointerTo_ngwm__createItemsRequest(soap, &a->ngwm__createItemsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__createItemsRequest(struct soap *soap, struct __ngw__createItemsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__createItemsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__createItemsRequest(struct soap *soap, const struct __ngw__createItemsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__createItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__createItemsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__createItemsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__createItemsRequest(soap, "ngwm:createItemsRequest", -1, &a->ngwm__createItemsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__createItemsRequest * SOAP_FMAC4 soap_get___ngw__createItemsRequest(struct soap *soap, struct __ngw__createItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__createItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__createItemsRequest * SOAP_FMAC4 soap_in___ngw__createItemsRequest(struct soap *soap, const char *tag, struct __ngw__createItemsRequest *a, const char *type)
{
	short soap_flag_ngwm__createItemsRequest = 1;
	a = (struct __ngw__createItemsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__createItemsRequest, sizeof(struct __ngw__createItemsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__createItemsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__createItemsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__createItemsRequest(soap, "ngwm:createItemsRequest", &a->ngwm__createItemsRequest, ""))
				{	soap_flag_ngwm__createItemsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__createItemRequest(struct soap *soap, const struct __ngw__createItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__createItemRequest, SOAP_TYPE_PointerTo_ngwm__createItemRequest);
	soap_serialize_PointerTo_ngwm__createItemRequest(soap, &a->ngwm__createItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__createItemRequest(struct soap *soap, struct __ngw__createItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__createItemRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__createItemRequest(struct soap *soap, const struct __ngw__createItemRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__createItemRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__createItemRequest(struct soap *soap, const char *tag, int id, const struct __ngw__createItemRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__createItemRequest(soap, "ngwm:createItemRequest", -1, &a->ngwm__createItemRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__createItemRequest * SOAP_FMAC4 soap_get___ngw__createItemRequest(struct soap *soap, struct __ngw__createItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__createItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__createItemRequest * SOAP_FMAC4 soap_in___ngw__createItemRequest(struct soap *soap, const char *tag, struct __ngw__createItemRequest *a, const char *type)
{
	short soap_flag_ngwm__createItemRequest = 1;
	a = (struct __ngw__createItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__createItemRequest, sizeof(struct __ngw__createItemRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__createItemRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__createItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__createItemRequest(soap, "ngwm:createItemRequest", &a->ngwm__createItemRequest, ""))
				{	soap_flag_ngwm__createItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__createCursorRequest(struct soap *soap, const struct __ngw__createCursorRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__createCursorRequest, SOAP_TYPE_PointerTo_ngwm__createCursorRequest);
	soap_serialize_PointerTo_ngwm__createCursorRequest(soap, &a->ngwm__createCursorRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__createCursorRequest(struct soap *soap, struct __ngw__createCursorRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__createCursorRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__createCursorRequest(struct soap *soap, const struct __ngw__createCursorRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__createCursorRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__createCursorRequest(struct soap *soap, const char *tag, int id, const struct __ngw__createCursorRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__createCursorRequest(soap, "ngwm:createCursorRequest", -1, &a->ngwm__createCursorRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__createCursorRequest * SOAP_FMAC4 soap_get___ngw__createCursorRequest(struct soap *soap, struct __ngw__createCursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__createCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__createCursorRequest * SOAP_FMAC4 soap_in___ngw__createCursorRequest(struct soap *soap, const char *tag, struct __ngw__createCursorRequest *a, const char *type)
{
	short soap_flag_ngwm__createCursorRequest = 1;
	a = (struct __ngw__createCursorRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__createCursorRequest, sizeof(struct __ngw__createCursorRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__createCursorRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__createCursorRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__createCursorRequest(soap, "ngwm:createCursorRequest", &a->ngwm__createCursorRequest, ""))
				{	soap_flag_ngwm__createCursorRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__completeRequest(struct soap *soap, const struct __ngw__completeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__completeRequest, SOAP_TYPE_PointerTo_ngwm__completeRequest);
	soap_serialize_PointerTo_ngwm__completeRequest(soap, &a->ngwm__completeRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__completeRequest(struct soap *soap, struct __ngw__completeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__completeRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__completeRequest(struct soap *soap, const struct __ngw__completeRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__completeRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__completeRequest(struct soap *soap, const char *tag, int id, const struct __ngw__completeRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__completeRequest(soap, "ngwm:completeRequest", -1, &a->ngwm__completeRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__completeRequest * SOAP_FMAC4 soap_get___ngw__completeRequest(struct soap *soap, struct __ngw__completeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__completeRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__completeRequest * SOAP_FMAC4 soap_in___ngw__completeRequest(struct soap *soap, const char *tag, struct __ngw__completeRequest *a, const char *type)
{
	short soap_flag_ngwm__completeRequest = 1;
	a = (struct __ngw__completeRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__completeRequest, sizeof(struct __ngw__completeRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__completeRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__completeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__completeRequest(soap, "ngwm:completeRequest", &a->ngwm__completeRequest, ""))
				{	soap_flag_ngwm__completeRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__closeFreeBusySessionRequest(struct soap *soap, const struct __ngw__closeFreeBusySessionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__closeFreeBusySessionRequest, SOAP_TYPE_PointerTo_ngwm__closeFreeBusySessionRequest);
	soap_serialize_PointerTo_ngwm__closeFreeBusySessionRequest(soap, &a->ngwm__closeFreeBusySessionRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__closeFreeBusySessionRequest(struct soap *soap, struct __ngw__closeFreeBusySessionRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__closeFreeBusySessionRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__closeFreeBusySessionRequest(struct soap *soap, const struct __ngw__closeFreeBusySessionRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__closeFreeBusySessionRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__closeFreeBusySessionRequest(struct soap *soap, const char *tag, int id, const struct __ngw__closeFreeBusySessionRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__closeFreeBusySessionRequest(soap, "ngwm:closeFreeBusySessionRequest", -1, &a->ngwm__closeFreeBusySessionRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__closeFreeBusySessionRequest * SOAP_FMAC4 soap_get___ngw__closeFreeBusySessionRequest(struct soap *soap, struct __ngw__closeFreeBusySessionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__closeFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__closeFreeBusySessionRequest * SOAP_FMAC4 soap_in___ngw__closeFreeBusySessionRequest(struct soap *soap, const char *tag, struct __ngw__closeFreeBusySessionRequest *a, const char *type)
{
	short soap_flag_ngwm__closeFreeBusySessionRequest = 1;
	a = (struct __ngw__closeFreeBusySessionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__closeFreeBusySessionRequest, sizeof(struct __ngw__closeFreeBusySessionRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__closeFreeBusySessionRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__closeFreeBusySessionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__closeFreeBusySessionRequest(soap, "ngwm:closeFreeBusySessionRequest", &a->ngwm__closeFreeBusySessionRequest, ""))
				{	soap_flag_ngwm__closeFreeBusySessionRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__addMembersRequest(struct soap *soap, const struct __ngw__addMembersRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__addMembersRequest, SOAP_TYPE_PointerTo_ngwm__addMembersRequest);
	soap_serialize_PointerTo_ngwm__addMembersRequest(soap, &a->ngwm__addMembersRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__addMembersRequest(struct soap *soap, struct __ngw__addMembersRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__addMembersRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__addMembersRequest(struct soap *soap, const struct __ngw__addMembersRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__addMembersRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__addMembersRequest(struct soap *soap, const char *tag, int id, const struct __ngw__addMembersRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__addMembersRequest(soap, "ngwm:addMembersRequest", -1, &a->ngwm__addMembersRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__addMembersRequest * SOAP_FMAC4 soap_get___ngw__addMembersRequest(struct soap *soap, struct __ngw__addMembersRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__addMembersRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__addMembersRequest * SOAP_FMAC4 soap_in___ngw__addMembersRequest(struct soap *soap, const char *tag, struct __ngw__addMembersRequest *a, const char *type)
{
	short soap_flag_ngwm__addMembersRequest = 1;
	a = (struct __ngw__addMembersRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__addMembersRequest, sizeof(struct __ngw__addMembersRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__addMembersRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__addMembersRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__addMembersRequest(soap, "ngwm:addMembersRequest", &a->ngwm__addMembersRequest, ""))
				{	soap_flag_ngwm__addMembersRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__addItemsRequest(struct soap *soap, const struct __ngw__addItemsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__addItemsRequest, SOAP_TYPE_PointerTo_ngwm__addItemsRequest);
	soap_serialize_PointerTo_ngwm__addItemsRequest(soap, &a->ngwm__addItemsRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__addItemsRequest(struct soap *soap, struct __ngw__addItemsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__addItemsRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__addItemsRequest(struct soap *soap, const struct __ngw__addItemsRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__addItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__addItemsRequest(struct soap *soap, const char *tag, int id, const struct __ngw__addItemsRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__addItemsRequest(soap, "ngwm:addItemsRequest", -1, &a->ngwm__addItemsRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__addItemsRequest * SOAP_FMAC4 soap_get___ngw__addItemsRequest(struct soap *soap, struct __ngw__addItemsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__addItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__addItemsRequest * SOAP_FMAC4 soap_in___ngw__addItemsRequest(struct soap *soap, const char *tag, struct __ngw__addItemsRequest *a, const char *type)
{
	short soap_flag_ngwm__addItemsRequest = 1;
	a = (struct __ngw__addItemsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__addItemsRequest, sizeof(struct __ngw__addItemsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__addItemsRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__addItemsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__addItemsRequest(soap, "ngwm:addItemsRequest", &a->ngwm__addItemsRequest, ""))
				{	soap_flag_ngwm__addItemsRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__addItemRequest(struct soap *soap, const struct __ngw__addItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__addItemRequest, SOAP_TYPE_PointerTo_ngwm__addItemRequest);
	soap_serialize_PointerTo_ngwm__addItemRequest(soap, &a->ngwm__addItemRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__addItemRequest(struct soap *soap, struct __ngw__addItemRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__addItemRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__addItemRequest(struct soap *soap, const struct __ngw__addItemRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__addItemRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__addItemRequest(struct soap *soap, const char *tag, int id, const struct __ngw__addItemRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__addItemRequest(soap, "ngwm:addItemRequest", -1, &a->ngwm__addItemRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__addItemRequest * SOAP_FMAC4 soap_get___ngw__addItemRequest(struct soap *soap, struct __ngw__addItemRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__addItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__addItemRequest * SOAP_FMAC4 soap_in___ngw__addItemRequest(struct soap *soap, const char *tag, struct __ngw__addItemRequest *a, const char *type)
{
	short soap_flag_ngwm__addItemRequest = 1;
	a = (struct __ngw__addItemRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__addItemRequest, sizeof(struct __ngw__addItemRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__addItemRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__addItemRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__addItemRequest(soap, "ngwm:addItemRequest", &a->ngwm__addItemRequest, ""))
				{	soap_flag_ngwm__addItemRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__acceptShareRequest(struct soap *soap, const struct __ngw__acceptShareRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__acceptShareRequest, SOAP_TYPE_PointerTo_ngwm__acceptShareRequest);
	soap_serialize_PointerTo_ngwm__acceptShareRequest(soap, &a->ngwm__acceptShareRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__acceptShareRequest(struct soap *soap, struct __ngw__acceptShareRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__acceptShareRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__acceptShareRequest(struct soap *soap, const struct __ngw__acceptShareRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__acceptShareRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__acceptShareRequest(struct soap *soap, const char *tag, int id, const struct __ngw__acceptShareRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__acceptShareRequest(soap, "ngwm:acceptShareRequest", -1, &a->ngwm__acceptShareRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__acceptShareRequest * SOAP_FMAC4 soap_get___ngw__acceptShareRequest(struct soap *soap, struct __ngw__acceptShareRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__acceptShareRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__acceptShareRequest * SOAP_FMAC4 soap_in___ngw__acceptShareRequest(struct soap *soap, const char *tag, struct __ngw__acceptShareRequest *a, const char *type)
{
	short soap_flag_ngwm__acceptShareRequest = 1;
	a = (struct __ngw__acceptShareRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__acceptShareRequest, sizeof(struct __ngw__acceptShareRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__acceptShareRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__acceptShareRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__acceptShareRequest(soap, "ngwm:acceptShareRequest", &a->ngwm__acceptShareRequest, ""))
				{	soap_flag_ngwm__acceptShareRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ngw__acceptRequest(struct soap *soap, const struct __ngw__acceptRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwm__acceptRequest, SOAP_TYPE_PointerTo_ngwm__acceptRequest);
	soap_serialize_PointerTo_ngwm__acceptRequest(soap, &a->ngwm__acceptRequest);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ngw__acceptRequest(struct soap *soap, struct __ngw__acceptRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ngwm__acceptRequest = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ngw__acceptRequest(struct soap *soap, const struct __ngw__acceptRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ngw__acceptRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ngw__acceptRequest(struct soap *soap, const char *tag, int id, const struct __ngw__acceptRequest *a, const char *type)
{
	soap_out_PointerTo_ngwm__acceptRequest(soap, "ngwm:acceptRequest", -1, &a->ngwm__acceptRequest, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ngw__acceptRequest * SOAP_FMAC4 soap_get___ngw__acceptRequest(struct soap *soap, struct __ngw__acceptRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ngw__acceptRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ngw__acceptRequest * SOAP_FMAC4 soap_in___ngw__acceptRequest(struct soap *soap, const char *tag, struct __ngw__acceptRequest *a, const char *type)
{
	short soap_flag_ngwm__acceptRequest = 1;
	a = (struct __ngw__acceptRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ngw__acceptRequest, sizeof(struct __ngw__acceptRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ngw__acceptRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwm__acceptRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ngwm__acceptRequest(soap, "ngwm:acceptRequest", &a->ngwm__acceptRequest, ""))
				{	soap_flag_ngwm__acceptRequest = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ngwt__gwTrace, SOAP_TYPE_bool);
	soap_embedded(soap, &a->ngwt__session, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->ngwt__session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->ngwt__gwTrace);
	soap_default_std__string(soap, &a->ngwt__session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	soap_out_bool(soap, "ngwt:gwTrace", -1, &a->ngwt__gwTrace, "");
	soap_out_std__string(soap, "ngwt:session", -1, &a->ngwt__session, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	short soap_flag_ngwt__gwTrace = 1, soap_flag_ngwt__session = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Header *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ngwt__gwTrace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ngwt:gwTrace", &a->ngwt__gwTrace, ""))
				{	soap_flag_ngwt__gwTrace = 0;
					continue;
				}
			if (soap_flag_ngwt__session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ngwt:session", &a->ngwt__session, ""))
				{	soap_flag_ngwt__session = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ngwt__gwTrace || soap_flag_ngwt__session))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, soap_copy_SOAP_ENV__Header);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__removeEventsResponse(struct soap *soap, _ngwe__removeEventsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__removeEventsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__removeEventsResponse(struct soap *soap, _ngwe__removeEventsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__removeEventsResponse);
	if (soap_out_PointerTo_ngwe__removeEventsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__removeEventsResponse(struct soap *soap, const char *tag, int id, _ngwe__removeEventsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__removeEventsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__removeEventsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwe__removeEventsResponse(struct soap *soap, _ngwe__removeEventsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__removeEventsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__removeEventsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwe__removeEventsResponse(struct soap *soap, const char *tag, _ngwe__removeEventsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__removeEventsResponse **)soap_malloc(soap, sizeof(_ngwe__removeEventsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__removeEventsResponse *)soap_instantiate__ngwe__removeEventsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__removeEventsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__removeEventsResponse, sizeof(_ngwe__removeEventsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__removeEventsRequest(struct soap *soap, _ngwe__removeEventsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__removeEventsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__removeEventsRequest(struct soap *soap, _ngwe__removeEventsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__removeEventsRequest);
	if (soap_out_PointerTo_ngwe__removeEventsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__removeEventsRequest(struct soap *soap, const char *tag, int id, _ngwe__removeEventsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__removeEventsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__removeEventsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwe__removeEventsRequest(struct soap *soap, _ngwe__removeEventsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__removeEventsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__removeEventsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwe__removeEventsRequest(struct soap *soap, const char *tag, _ngwe__removeEventsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__removeEventsRequest **)soap_malloc(soap, sizeof(_ngwe__removeEventsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__removeEventsRequest *)soap_instantiate__ngwe__removeEventsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__removeEventsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__removeEventsRequest, sizeof(_ngwe__removeEventsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__removeEventConfigurationResponse(struct soap *soap, _ngwe__removeEventConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__removeEventConfigurationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__removeEventConfigurationResponse(struct soap *soap, _ngwe__removeEventConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__removeEventConfigurationResponse);
	if (soap_out_PointerTo_ngwe__removeEventConfigurationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__removeEventConfigurationResponse(struct soap *soap, const char *tag, int id, _ngwe__removeEventConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__removeEventConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__removeEventConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwe__removeEventConfigurationResponse(struct soap *soap, _ngwe__removeEventConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__removeEventConfigurationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__removeEventConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwe__removeEventConfigurationResponse(struct soap *soap, const char *tag, _ngwe__removeEventConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__removeEventConfigurationResponse **)soap_malloc(soap, sizeof(_ngwe__removeEventConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__removeEventConfigurationResponse *)soap_instantiate__ngwe__removeEventConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__removeEventConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__removeEventConfigurationResponse, sizeof(_ngwe__removeEventConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__removeEventConfigurationRequest(struct soap *soap, _ngwe__removeEventConfigurationRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__removeEventConfigurationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__removeEventConfigurationRequest(struct soap *soap, _ngwe__removeEventConfigurationRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__removeEventConfigurationRequest);
	if (soap_out_PointerTo_ngwe__removeEventConfigurationRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__removeEventConfigurationRequest(struct soap *soap, const char *tag, int id, _ngwe__removeEventConfigurationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__removeEventConfigurationRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__removeEventConfigurationRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwe__removeEventConfigurationRequest(struct soap *soap, _ngwe__removeEventConfigurationRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__removeEventConfigurationRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__removeEventConfigurationRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwe__removeEventConfigurationRequest(struct soap *soap, const char *tag, _ngwe__removeEventConfigurationRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__removeEventConfigurationRequest **)soap_malloc(soap, sizeof(_ngwe__removeEventConfigurationRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__removeEventConfigurationRequest *)soap_instantiate__ngwe__removeEventConfigurationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__removeEventConfigurationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__removeEventConfigurationRequest, sizeof(_ngwe__removeEventConfigurationRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__getEventsResponse(struct soap *soap, _ngwe__getEventsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__getEventsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__getEventsResponse(struct soap *soap, _ngwe__getEventsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__getEventsResponse);
	if (soap_out_PointerTo_ngwe__getEventsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__getEventsResponse(struct soap *soap, const char *tag, int id, _ngwe__getEventsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__getEventsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__getEventsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwe__getEventsResponse(struct soap *soap, _ngwe__getEventsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__getEventsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__getEventsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwe__getEventsResponse(struct soap *soap, const char *tag, _ngwe__getEventsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__getEventsResponse **)soap_malloc(soap, sizeof(_ngwe__getEventsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__getEventsResponse *)soap_instantiate__ngwe__getEventsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__getEventsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__getEventsResponse, sizeof(_ngwe__getEventsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__getEventsRequest(struct soap *soap, _ngwe__getEventsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__getEventsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__getEventsRequest(struct soap *soap, _ngwe__getEventsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__getEventsRequest);
	if (soap_out_PointerTo_ngwe__getEventsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__getEventsRequest(struct soap *soap, const char *tag, int id, _ngwe__getEventsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__getEventsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__getEventsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwe__getEventsRequest(struct soap *soap, _ngwe__getEventsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__getEventsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__getEventsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwe__getEventsRequest(struct soap *soap, const char *tag, _ngwe__getEventsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__getEventsRequest **)soap_malloc(soap, sizeof(_ngwe__getEventsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__getEventsRequest *)soap_instantiate__ngwe__getEventsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__getEventsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__getEventsRequest, sizeof(_ngwe__getEventsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__getEventConfigurationResponse(struct soap *soap, _ngwe__getEventConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__getEventConfigurationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__getEventConfigurationResponse(struct soap *soap, _ngwe__getEventConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__getEventConfigurationResponse);
	if (soap_out_PointerTo_ngwe__getEventConfigurationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__getEventConfigurationResponse(struct soap *soap, const char *tag, int id, _ngwe__getEventConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__getEventConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__getEventConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwe__getEventConfigurationResponse(struct soap *soap, _ngwe__getEventConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__getEventConfigurationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__getEventConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwe__getEventConfigurationResponse(struct soap *soap, const char *tag, _ngwe__getEventConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__getEventConfigurationResponse **)soap_malloc(soap, sizeof(_ngwe__getEventConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__getEventConfigurationResponse *)soap_instantiate__ngwe__getEventConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__getEventConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__getEventConfigurationResponse, sizeof(_ngwe__getEventConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__getEventConfigurationRequest(struct soap *soap, _ngwe__getEventConfigurationRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__getEventConfigurationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__getEventConfigurationRequest(struct soap *soap, _ngwe__getEventConfigurationRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__getEventConfigurationRequest);
	if (soap_out_PointerTo_ngwe__getEventConfigurationRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__getEventConfigurationRequest(struct soap *soap, const char *tag, int id, _ngwe__getEventConfigurationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__getEventConfigurationRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__getEventConfigurationRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwe__getEventConfigurationRequest(struct soap *soap, _ngwe__getEventConfigurationRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__getEventConfigurationRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__getEventConfigurationRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwe__getEventConfigurationRequest(struct soap *soap, const char *tag, _ngwe__getEventConfigurationRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__getEventConfigurationRequest **)soap_malloc(soap, sizeof(_ngwe__getEventConfigurationRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__getEventConfigurationRequest *)soap_instantiate__ngwe__getEventConfigurationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__getEventConfigurationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__getEventConfigurationRequest, sizeof(_ngwe__getEventConfigurationRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__configureEventsResponse(struct soap *soap, _ngwe__configureEventsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__configureEventsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__configureEventsResponse(struct soap *soap, _ngwe__configureEventsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__configureEventsResponse);
	if (soap_out_PointerTo_ngwe__configureEventsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__configureEventsResponse(struct soap *soap, const char *tag, int id, _ngwe__configureEventsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__configureEventsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__configureEventsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwe__configureEventsResponse(struct soap *soap, _ngwe__configureEventsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__configureEventsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__configureEventsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwe__configureEventsResponse(struct soap *soap, const char *tag, _ngwe__configureEventsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__configureEventsResponse **)soap_malloc(soap, sizeof(_ngwe__configureEventsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__configureEventsResponse *)soap_instantiate__ngwe__configureEventsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__configureEventsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__configureEventsResponse, sizeof(_ngwe__configureEventsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__configureEventsRequest(struct soap *soap, _ngwe__configureEventsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__configureEventsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__configureEventsRequest(struct soap *soap, _ngwe__configureEventsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__configureEventsRequest);
	if (soap_out_PointerTo_ngwe__configureEventsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__configureEventsRequest(struct soap *soap, const char *tag, int id, _ngwe__configureEventsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__configureEventsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__configureEventsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwe__configureEventsRequest(struct soap *soap, _ngwe__configureEventsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__configureEventsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__configureEventsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwe__configureEventsRequest(struct soap *soap, const char *tag, _ngwe__configureEventsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__configureEventsRequest **)soap_malloc(soap, sizeof(_ngwe__configureEventsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__configureEventsRequest *)soap_instantiate__ngwe__configureEventsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__configureEventsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__configureEventsRequest, sizeof(_ngwe__configureEventsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__cleanEventConfigurationResponse(struct soap *soap, _ngwe__cleanEventConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__cleanEventConfigurationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__cleanEventConfigurationResponse(struct soap *soap, _ngwe__cleanEventConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__cleanEventConfigurationResponse);
	if (soap_out_PointerTo_ngwe__cleanEventConfigurationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__cleanEventConfigurationResponse(struct soap *soap, const char *tag, int id, _ngwe__cleanEventConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__cleanEventConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__cleanEventConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwe__cleanEventConfigurationResponse(struct soap *soap, _ngwe__cleanEventConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__cleanEventConfigurationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__cleanEventConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwe__cleanEventConfigurationResponse(struct soap *soap, const char *tag, _ngwe__cleanEventConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__cleanEventConfigurationResponse **)soap_malloc(soap, sizeof(_ngwe__cleanEventConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__cleanEventConfigurationResponse *)soap_instantiate__ngwe__cleanEventConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__cleanEventConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__cleanEventConfigurationResponse, sizeof(_ngwe__cleanEventConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwe__cleanEventConfigurationRequest(struct soap *soap, _ngwe__cleanEventConfigurationRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwe__cleanEventConfigurationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwe__cleanEventConfigurationRequest(struct soap *soap, _ngwe__cleanEventConfigurationRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwe__cleanEventConfigurationRequest);
	if (soap_out_PointerTo_ngwe__cleanEventConfigurationRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwe__cleanEventConfigurationRequest(struct soap *soap, const char *tag, int id, _ngwe__cleanEventConfigurationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwe__cleanEventConfigurationRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwe__cleanEventConfigurationRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwe__cleanEventConfigurationRequest(struct soap *soap, _ngwe__cleanEventConfigurationRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwe__cleanEventConfigurationRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwe__cleanEventConfigurationRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwe__cleanEventConfigurationRequest(struct soap *soap, const char *tag, _ngwe__cleanEventConfigurationRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwe__cleanEventConfigurationRequest **)soap_malloc(soap, sizeof(_ngwe__cleanEventConfigurationRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwe__cleanEventConfigurationRequest *)soap_instantiate__ngwe__cleanEventConfigurationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwe__cleanEventConfigurationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwe__cleanEventConfigurationRequest, sizeof(_ngwe__cleanEventConfigurationRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__updateVersionStatusResponse(struct soap *soap, _ngwm__updateVersionStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__updateVersionStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__updateVersionStatusResponse(struct soap *soap, _ngwm__updateVersionStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__updateVersionStatusResponse);
	if (soap_out_PointerTo_ngwm__updateVersionStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__updateVersionStatusResponse(struct soap *soap, const char *tag, int id, _ngwm__updateVersionStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__updateVersionStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__updateVersionStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__updateVersionStatusResponse(struct soap *soap, _ngwm__updateVersionStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__updateVersionStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__updateVersionStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__updateVersionStatusResponse(struct soap *soap, const char *tag, _ngwm__updateVersionStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__updateVersionStatusResponse **)soap_malloc(soap, sizeof(_ngwm__updateVersionStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__updateVersionStatusResponse *)soap_instantiate__ngwm__updateVersionStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__updateVersionStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__updateVersionStatusResponse, sizeof(_ngwm__updateVersionStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__updateVersionStatusRequest(struct soap *soap, _ngwm__updateVersionStatusRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__updateVersionStatusRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__updateVersionStatusRequest(struct soap *soap, _ngwm__updateVersionStatusRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__updateVersionStatusRequest);
	if (soap_out_PointerTo_ngwm__updateVersionStatusRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__updateVersionStatusRequest(struct soap *soap, const char *tag, int id, _ngwm__updateVersionStatusRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__updateVersionStatusRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__updateVersionStatusRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__updateVersionStatusRequest(struct soap *soap, _ngwm__updateVersionStatusRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__updateVersionStatusRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__updateVersionStatusRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__updateVersionStatusRequest(struct soap *soap, const char *tag, _ngwm__updateVersionStatusRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__updateVersionStatusRequest **)soap_malloc(soap, sizeof(_ngwm__updateVersionStatusRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__updateVersionStatusRequest *)soap_instantiate__ngwm__updateVersionStatusRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__updateVersionStatusRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__updateVersionStatusRequest, sizeof(_ngwm__updateVersionStatusRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__uncompleteResponse(struct soap *soap, _ngwm__uncompleteResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__uncompleteResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__uncompleteResponse(struct soap *soap, _ngwm__uncompleteResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__uncompleteResponse);
	if (soap_out_PointerTo_ngwm__uncompleteResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__uncompleteResponse(struct soap *soap, const char *tag, int id, _ngwm__uncompleteResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__uncompleteResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__uncompleteResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__uncompleteResponse(struct soap *soap, _ngwm__uncompleteResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__uncompleteResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__uncompleteResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__uncompleteResponse(struct soap *soap, const char *tag, _ngwm__uncompleteResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__uncompleteResponse **)soap_malloc(soap, sizeof(_ngwm__uncompleteResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__uncompleteResponse *)soap_instantiate__ngwm__uncompleteResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__uncompleteResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__uncompleteResponse, sizeof(_ngwm__uncompleteResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__uncompleteRequest(struct soap *soap, _ngwm__uncompleteRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__uncompleteRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__uncompleteRequest(struct soap *soap, _ngwm__uncompleteRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__uncompleteRequest);
	if (soap_out_PointerTo_ngwm__uncompleteRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__uncompleteRequest(struct soap *soap, const char *tag, int id, _ngwm__uncompleteRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__uncompleteRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__uncompleteRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__uncompleteRequest(struct soap *soap, _ngwm__uncompleteRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__uncompleteRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__uncompleteRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__uncompleteRequest(struct soap *soap, const char *tag, _ngwm__uncompleteRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__uncompleteRequest **)soap_malloc(soap, sizeof(_ngwm__uncompleteRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__uncompleteRequest *)soap_instantiate__ngwm__uncompleteRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__uncompleteRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__uncompleteRequest, sizeof(_ngwm__uncompleteRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__unacceptResponse(struct soap *soap, _ngwm__unacceptResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__unacceptResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__unacceptResponse(struct soap *soap, _ngwm__unacceptResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__unacceptResponse);
	if (soap_out_PointerTo_ngwm__unacceptResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__unacceptResponse(struct soap *soap, const char *tag, int id, _ngwm__unacceptResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__unacceptResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__unacceptResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__unacceptResponse(struct soap *soap, _ngwm__unacceptResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__unacceptResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__unacceptResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__unacceptResponse(struct soap *soap, const char *tag, _ngwm__unacceptResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__unacceptResponse **)soap_malloc(soap, sizeof(_ngwm__unacceptResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__unacceptResponse *)soap_instantiate__ngwm__unacceptResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__unacceptResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__unacceptResponse, sizeof(_ngwm__unacceptResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__unacceptRequest(struct soap *soap, _ngwm__unacceptRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__unacceptRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__unacceptRequest(struct soap *soap, _ngwm__unacceptRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__unacceptRequest);
	if (soap_out_PointerTo_ngwm__unacceptRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__unacceptRequest(struct soap *soap, const char *tag, int id, _ngwm__unacceptRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__unacceptRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__unacceptRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__unacceptRequest(struct soap *soap, _ngwm__unacceptRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__unacceptRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__unacceptRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__unacceptRequest(struct soap *soap, const char *tag, _ngwm__unacceptRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__unacceptRequest **)soap_malloc(soap, sizeof(_ngwm__unacceptRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__unacceptRequest *)soap_instantiate__ngwm__unacceptRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__unacceptRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__unacceptRequest, sizeof(_ngwm__unacceptRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__startFreeBusySessionResponse(struct soap *soap, _ngwm__startFreeBusySessionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__startFreeBusySessionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__startFreeBusySessionResponse(struct soap *soap, _ngwm__startFreeBusySessionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__startFreeBusySessionResponse);
	if (soap_out_PointerTo_ngwm__startFreeBusySessionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__startFreeBusySessionResponse(struct soap *soap, const char *tag, int id, _ngwm__startFreeBusySessionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__startFreeBusySessionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__startFreeBusySessionResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__startFreeBusySessionResponse(struct soap *soap, _ngwm__startFreeBusySessionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__startFreeBusySessionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__startFreeBusySessionResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__startFreeBusySessionResponse(struct soap *soap, const char *tag, _ngwm__startFreeBusySessionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__startFreeBusySessionResponse **)soap_malloc(soap, sizeof(_ngwm__startFreeBusySessionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__startFreeBusySessionResponse *)soap_instantiate__ngwm__startFreeBusySessionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__startFreeBusySessionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__startFreeBusySessionResponse, sizeof(_ngwm__startFreeBusySessionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__startFreeBusySessionRequest(struct soap *soap, _ngwm__startFreeBusySessionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__startFreeBusySessionRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__startFreeBusySessionRequest(struct soap *soap, _ngwm__startFreeBusySessionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__startFreeBusySessionRequest);
	if (soap_out_PointerTo_ngwm__startFreeBusySessionRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__startFreeBusySessionRequest(struct soap *soap, const char *tag, int id, _ngwm__startFreeBusySessionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__startFreeBusySessionRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__startFreeBusySessionRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__startFreeBusySessionRequest(struct soap *soap, _ngwm__startFreeBusySessionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__startFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__startFreeBusySessionRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__startFreeBusySessionRequest(struct soap *soap, const char *tag, _ngwm__startFreeBusySessionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__startFreeBusySessionRequest **)soap_malloc(soap, sizeof(_ngwm__startFreeBusySessionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__startFreeBusySessionRequest *)soap_instantiate__ngwm__startFreeBusySessionRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__startFreeBusySessionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__startFreeBusySessionRequest, sizeof(_ngwm__startFreeBusySessionRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__setTimestampResponse(struct soap *soap, _ngwm__setTimestampResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__setTimestampResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__setTimestampResponse(struct soap *soap, _ngwm__setTimestampResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__setTimestampResponse);
	if (soap_out_PointerTo_ngwm__setTimestampResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__setTimestampResponse(struct soap *soap, const char *tag, int id, _ngwm__setTimestampResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__setTimestampResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__setTimestampResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__setTimestampResponse(struct soap *soap, _ngwm__setTimestampResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__setTimestampResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__setTimestampResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__setTimestampResponse(struct soap *soap, const char *tag, _ngwm__setTimestampResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__setTimestampResponse **)soap_malloc(soap, sizeof(_ngwm__setTimestampResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__setTimestampResponse *)soap_instantiate__ngwm__setTimestampResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__setTimestampResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__setTimestampResponse, sizeof(_ngwm__setTimestampResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__setTimestampRequest(struct soap *soap, _ngwm__setTimestampRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__setTimestampRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__setTimestampRequest(struct soap *soap, _ngwm__setTimestampRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__setTimestampRequest);
	if (soap_out_PointerTo_ngwm__setTimestampRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__setTimestampRequest(struct soap *soap, const char *tag, int id, _ngwm__setTimestampRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__setTimestampRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__setTimestampRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__setTimestampRequest(struct soap *soap, _ngwm__setTimestampRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__setTimestampRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__setTimestampRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__setTimestampRequest(struct soap *soap, const char *tag, _ngwm__setTimestampRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__setTimestampRequest **)soap_malloc(soap, sizeof(_ngwm__setTimestampRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__setTimestampRequest *)soap_instantiate__ngwm__setTimestampRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__setTimestampRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__setTimestampRequest, sizeof(_ngwm__setTimestampRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__sendItemResponse(struct soap *soap, _ngwm__sendItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__sendItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__sendItemResponse(struct soap *soap, _ngwm__sendItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__sendItemResponse);
	if (soap_out_PointerTo_ngwm__sendItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__sendItemResponse(struct soap *soap, const char *tag, int id, _ngwm__sendItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__sendItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__sendItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__sendItemResponse(struct soap *soap, _ngwm__sendItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__sendItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__sendItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__sendItemResponse(struct soap *soap, const char *tag, _ngwm__sendItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__sendItemResponse **)soap_malloc(soap, sizeof(_ngwm__sendItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__sendItemResponse *)soap_instantiate__ngwm__sendItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__sendItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__sendItemResponse, sizeof(_ngwm__sendItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__sendItemRequest(struct soap *soap, _ngwm__sendItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__sendItemRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__sendItemRequest(struct soap *soap, _ngwm__sendItemRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__sendItemRequest);
	if (soap_out_PointerTo_ngwm__sendItemRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__sendItemRequest(struct soap *soap, const char *tag, int id, _ngwm__sendItemRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__sendItemRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__sendItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__sendItemRequest(struct soap *soap, _ngwm__sendItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__sendItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__sendItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__sendItemRequest(struct soap *soap, const char *tag, _ngwm__sendItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__sendItemRequest **)soap_malloc(soap, sizeof(_ngwm__sendItemRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__sendItemRequest *)soap_instantiate__ngwm__sendItemRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__sendItemRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__sendItemRequest, sizeof(_ngwm__sendItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__retractResponse(struct soap *soap, _ngwm__retractResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__retractResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__retractResponse(struct soap *soap, _ngwm__retractResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__retractResponse);
	if (soap_out_PointerTo_ngwm__retractResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__retractResponse(struct soap *soap, const char *tag, int id, _ngwm__retractResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__retractResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__retractResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__retractResponse(struct soap *soap, _ngwm__retractResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__retractResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__retractResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__retractResponse(struct soap *soap, const char *tag, _ngwm__retractResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__retractResponse **)soap_malloc(soap, sizeof(_ngwm__retractResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__retractResponse *)soap_instantiate__ngwm__retractResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__retractResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__retractResponse, sizeof(_ngwm__retractResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__retractRequest(struct soap *soap, _ngwm__retractRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__retractRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__retractRequest(struct soap *soap, _ngwm__retractRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__retractRequest);
	if (soap_out_PointerTo_ngwm__retractRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__retractRequest(struct soap *soap, const char *tag, int id, _ngwm__retractRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__retractRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__retractRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__retractRequest(struct soap *soap, _ngwm__retractRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__retractRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__retractRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__retractRequest(struct soap *soap, const char *tag, _ngwm__retractRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__retractRequest **)soap_malloc(soap, sizeof(_ngwm__retractRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__retractRequest *)soap_instantiate__ngwm__retractRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__retractRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__retractRequest, sizeof(_ngwm__retractRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__replyResponse(struct soap *soap, _ngwm__replyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__replyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__replyResponse(struct soap *soap, _ngwm__replyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__replyResponse);
	if (soap_out_PointerTo_ngwm__replyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__replyResponse(struct soap *soap, const char *tag, int id, _ngwm__replyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__replyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__replyResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__replyResponse(struct soap *soap, _ngwm__replyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__replyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__replyResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__replyResponse(struct soap *soap, const char *tag, _ngwm__replyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__replyResponse **)soap_malloc(soap, sizeof(_ngwm__replyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__replyResponse *)soap_instantiate__ngwm__replyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__replyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__replyResponse, sizeof(_ngwm__replyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__replyRequest(struct soap *soap, _ngwm__replyRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__replyRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__replyRequest(struct soap *soap, _ngwm__replyRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__replyRequest);
	if (soap_out_PointerTo_ngwm__replyRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__replyRequest(struct soap *soap, const char *tag, int id, _ngwm__replyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__replyRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__replyRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__replyRequest(struct soap *soap, _ngwm__replyRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__replyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__replyRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__replyRequest(struct soap *soap, const char *tag, _ngwm__replyRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__replyRequest **)soap_malloc(soap, sizeof(_ngwm__replyRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__replyRequest *)soap_instantiate__ngwm__replyRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__replyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__replyRequest, sizeof(_ngwm__replyRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeSignatureResponse(struct soap *soap, _ngwm__removeSignatureResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeSignatureResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeSignatureResponse(struct soap *soap, _ngwm__removeSignatureResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeSignatureResponse);
	if (soap_out_PointerTo_ngwm__removeSignatureResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeSignatureResponse(struct soap *soap, const char *tag, int id, _ngwm__removeSignatureResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeSignatureResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeSignatureResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeSignatureResponse(struct soap *soap, _ngwm__removeSignatureResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeSignatureResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeSignatureResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeSignatureResponse(struct soap *soap, const char *tag, _ngwm__removeSignatureResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeSignatureResponse **)soap_malloc(soap, sizeof(_ngwm__removeSignatureResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeSignatureResponse *)soap_instantiate__ngwm__removeSignatureResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeSignatureResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeSignatureResponse, sizeof(_ngwm__removeSignatureResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeSignatureRequest(struct soap *soap, _ngwm__removeSignatureRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeSignatureRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeSignatureRequest(struct soap *soap, _ngwm__removeSignatureRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeSignatureRequest);
	if (soap_out_PointerTo_ngwm__removeSignatureRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeSignatureRequest(struct soap *soap, const char *tag, int id, _ngwm__removeSignatureRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeSignatureRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeSignatureRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeSignatureRequest(struct soap *soap, _ngwm__removeSignatureRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeSignatureRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeSignatureRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeSignatureRequest(struct soap *soap, const char *tag, _ngwm__removeSignatureRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeSignatureRequest **)soap_malloc(soap, sizeof(_ngwm__removeSignatureRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeSignatureRequest *)soap_instantiate__ngwm__removeSignatureRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeSignatureRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeSignatureRequest, sizeof(_ngwm__removeSignatureRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeProxyUserResponse(struct soap *soap, _ngwm__removeProxyUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeProxyUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeProxyUserResponse(struct soap *soap, _ngwm__removeProxyUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeProxyUserResponse);
	if (soap_out_PointerTo_ngwm__removeProxyUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeProxyUserResponse(struct soap *soap, const char *tag, int id, _ngwm__removeProxyUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeProxyUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeProxyUserResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeProxyUserResponse(struct soap *soap, _ngwm__removeProxyUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeProxyUserResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeProxyUserResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeProxyUserResponse(struct soap *soap, const char *tag, _ngwm__removeProxyUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeProxyUserResponse **)soap_malloc(soap, sizeof(_ngwm__removeProxyUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeProxyUserResponse *)soap_instantiate__ngwm__removeProxyUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeProxyUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeProxyUserResponse, sizeof(_ngwm__removeProxyUserResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeProxyUserRequest(struct soap *soap, _ngwm__removeProxyUserRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeProxyUserRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeProxyUserRequest(struct soap *soap, _ngwm__removeProxyUserRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeProxyUserRequest);
	if (soap_out_PointerTo_ngwm__removeProxyUserRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeProxyUserRequest(struct soap *soap, const char *tag, int id, _ngwm__removeProxyUserRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeProxyUserRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeProxyUserRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeProxyUserRequest(struct soap *soap, _ngwm__removeProxyUserRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeProxyUserRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeProxyUserRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeProxyUserRequest(struct soap *soap, const char *tag, _ngwm__removeProxyUserRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeProxyUserRequest **)soap_malloc(soap, sizeof(_ngwm__removeProxyUserRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeProxyUserRequest *)soap_instantiate__ngwm__removeProxyUserRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeProxyUserRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeProxyUserRequest, sizeof(_ngwm__removeProxyUserRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeProxyAccessResponse(struct soap *soap, _ngwm__removeProxyAccessResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeProxyAccessResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeProxyAccessResponse(struct soap *soap, _ngwm__removeProxyAccessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeProxyAccessResponse);
	if (soap_out_PointerTo_ngwm__removeProxyAccessResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeProxyAccessResponse(struct soap *soap, const char *tag, int id, _ngwm__removeProxyAccessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeProxyAccessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeProxyAccessResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeProxyAccessResponse(struct soap *soap, _ngwm__removeProxyAccessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeProxyAccessResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeProxyAccessResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeProxyAccessResponse(struct soap *soap, const char *tag, _ngwm__removeProxyAccessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeProxyAccessResponse **)soap_malloc(soap, sizeof(_ngwm__removeProxyAccessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeProxyAccessResponse *)soap_instantiate__ngwm__removeProxyAccessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeProxyAccessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeProxyAccessResponse, sizeof(_ngwm__removeProxyAccessResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeProxyAccessRequest(struct soap *soap, _ngwm__removeProxyAccessRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeProxyAccessRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeProxyAccessRequest(struct soap *soap, _ngwm__removeProxyAccessRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeProxyAccessRequest);
	if (soap_out_PointerTo_ngwm__removeProxyAccessRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeProxyAccessRequest(struct soap *soap, const char *tag, int id, _ngwm__removeProxyAccessRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeProxyAccessRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeProxyAccessRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeProxyAccessRequest(struct soap *soap, _ngwm__removeProxyAccessRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeProxyAccessRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeProxyAccessRequest(struct soap *soap, const char *tag, _ngwm__removeProxyAccessRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeProxyAccessRequest **)soap_malloc(soap, sizeof(_ngwm__removeProxyAccessRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeProxyAccessRequest *)soap_instantiate__ngwm__removeProxyAccessRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeProxyAccessRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeProxyAccessRequest, sizeof(_ngwm__removeProxyAccessRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeMembersResponse(struct soap *soap, _ngwm__removeMembersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeMembersResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeMembersResponse(struct soap *soap, _ngwm__removeMembersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeMembersResponse);
	if (soap_out_PointerTo_ngwm__removeMembersResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeMembersResponse(struct soap *soap, const char *tag, int id, _ngwm__removeMembersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeMembersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeMembersResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeMembersResponse(struct soap *soap, _ngwm__removeMembersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeMembersResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeMembersResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeMembersResponse(struct soap *soap, const char *tag, _ngwm__removeMembersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeMembersResponse **)soap_malloc(soap, sizeof(_ngwm__removeMembersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeMembersResponse *)soap_instantiate__ngwm__removeMembersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeMembersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeMembersResponse, sizeof(_ngwm__removeMembersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeMembersRequest(struct soap *soap, _ngwm__removeMembersRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeMembersRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeMembersRequest(struct soap *soap, _ngwm__removeMembersRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeMembersRequest);
	if (soap_out_PointerTo_ngwm__removeMembersRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeMembersRequest(struct soap *soap, const char *tag, int id, _ngwm__removeMembersRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeMembersRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeMembersRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeMembersRequest(struct soap *soap, _ngwm__removeMembersRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeMembersRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeMembersRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeMembersRequest(struct soap *soap, const char *tag, _ngwm__removeMembersRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeMembersRequest **)soap_malloc(soap, sizeof(_ngwm__removeMembersRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeMembersRequest *)soap_instantiate__ngwm__removeMembersRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeMembersRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeMembersRequest, sizeof(_ngwm__removeMembersRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeJunkEntryResponse(struct soap *soap, _ngwm__removeJunkEntryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeJunkEntryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeJunkEntryResponse(struct soap *soap, _ngwm__removeJunkEntryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeJunkEntryResponse);
	if (soap_out_PointerTo_ngwm__removeJunkEntryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeJunkEntryResponse(struct soap *soap, const char *tag, int id, _ngwm__removeJunkEntryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeJunkEntryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeJunkEntryResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeJunkEntryResponse(struct soap *soap, _ngwm__removeJunkEntryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeJunkEntryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeJunkEntryResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeJunkEntryResponse(struct soap *soap, const char *tag, _ngwm__removeJunkEntryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeJunkEntryResponse **)soap_malloc(soap, sizeof(_ngwm__removeJunkEntryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeJunkEntryResponse *)soap_instantiate__ngwm__removeJunkEntryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeJunkEntryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeJunkEntryResponse, sizeof(_ngwm__removeJunkEntryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeJunkEntryRequest(struct soap *soap, _ngwm__removeJunkEntryRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeJunkEntryRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeJunkEntryRequest(struct soap *soap, _ngwm__removeJunkEntryRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeJunkEntryRequest);
	if (soap_out_PointerTo_ngwm__removeJunkEntryRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeJunkEntryRequest(struct soap *soap, const char *tag, int id, _ngwm__removeJunkEntryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeJunkEntryRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeJunkEntryRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeJunkEntryRequest(struct soap *soap, _ngwm__removeJunkEntryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeJunkEntryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeJunkEntryRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeJunkEntryRequest(struct soap *soap, const char *tag, _ngwm__removeJunkEntryRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeJunkEntryRequest **)soap_malloc(soap, sizeof(_ngwm__removeJunkEntryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeJunkEntryRequest *)soap_instantiate__ngwm__removeJunkEntryRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeJunkEntryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeJunkEntryRequest, sizeof(_ngwm__removeJunkEntryRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeItemsResponse(struct soap *soap, _ngwm__removeItemsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeItemsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeItemsResponse(struct soap *soap, _ngwm__removeItemsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeItemsResponse);
	if (soap_out_PointerTo_ngwm__removeItemsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeItemsResponse(struct soap *soap, const char *tag, int id, _ngwm__removeItemsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeItemsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeItemsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeItemsResponse(struct soap *soap, _ngwm__removeItemsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeItemsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeItemsResponse(struct soap *soap, const char *tag, _ngwm__removeItemsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeItemsResponse **)soap_malloc(soap, sizeof(_ngwm__removeItemsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeItemsResponse *)soap_instantiate__ngwm__removeItemsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeItemsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeItemsResponse, sizeof(_ngwm__removeItemsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeItemsRequest(struct soap *soap, _ngwm__removeItemsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeItemsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeItemsRequest(struct soap *soap, _ngwm__removeItemsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeItemsRequest);
	if (soap_out_PointerTo_ngwm__removeItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeItemsRequest(struct soap *soap, const char *tag, int id, _ngwm__removeItemsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeItemsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeItemsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeItemsRequest(struct soap *soap, _ngwm__removeItemsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeItemsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeItemsRequest(struct soap *soap, const char *tag, _ngwm__removeItemsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeItemsRequest **)soap_malloc(soap, sizeof(_ngwm__removeItemsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeItemsRequest *)soap_instantiate__ngwm__removeItemsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeItemsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeItemsRequest, sizeof(_ngwm__removeItemsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeItemResponse(struct soap *soap, _ngwm__removeItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeItemResponse(struct soap *soap, _ngwm__removeItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeItemResponse);
	if (soap_out_PointerTo_ngwm__removeItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeItemResponse(struct soap *soap, const char *tag, int id, _ngwm__removeItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeItemResponse(struct soap *soap, _ngwm__removeItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeItemResponse(struct soap *soap, const char *tag, _ngwm__removeItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeItemResponse **)soap_malloc(soap, sizeof(_ngwm__removeItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeItemResponse *)soap_instantiate__ngwm__removeItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeItemResponse, sizeof(_ngwm__removeItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeItemRequest(struct soap *soap, _ngwm__removeItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeItemRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeItemRequest(struct soap *soap, _ngwm__removeItemRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeItemRequest);
	if (soap_out_PointerTo_ngwm__removeItemRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeItemRequest(struct soap *soap, const char *tag, int id, _ngwm__removeItemRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeItemRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeItemRequest(struct soap *soap, _ngwm__removeItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeItemRequest(struct soap *soap, const char *tag, _ngwm__removeItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeItemRequest **)soap_malloc(soap, sizeof(_ngwm__removeItemRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeItemRequest *)soap_instantiate__ngwm__removeItemRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeItemRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeItemRequest, sizeof(_ngwm__removeItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeCustomDefinitionResponse(struct soap *soap, _ngwm__removeCustomDefinitionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeCustomDefinitionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeCustomDefinitionResponse(struct soap *soap, _ngwm__removeCustomDefinitionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeCustomDefinitionResponse);
	if (soap_out_PointerTo_ngwm__removeCustomDefinitionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeCustomDefinitionResponse(struct soap *soap, const char *tag, int id, _ngwm__removeCustomDefinitionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeCustomDefinitionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeCustomDefinitionResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeCustomDefinitionResponse(struct soap *soap, _ngwm__removeCustomDefinitionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeCustomDefinitionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeCustomDefinitionResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeCustomDefinitionResponse(struct soap *soap, const char *tag, _ngwm__removeCustomDefinitionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeCustomDefinitionResponse **)soap_malloc(soap, sizeof(_ngwm__removeCustomDefinitionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeCustomDefinitionResponse *)soap_instantiate__ngwm__removeCustomDefinitionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeCustomDefinitionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeCustomDefinitionResponse, sizeof(_ngwm__removeCustomDefinitionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__removeCustomDefinitionRequest(struct soap *soap, _ngwm__removeCustomDefinitionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__removeCustomDefinitionRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__removeCustomDefinitionRequest(struct soap *soap, _ngwm__removeCustomDefinitionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__removeCustomDefinitionRequest);
	if (soap_out_PointerTo_ngwm__removeCustomDefinitionRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__removeCustomDefinitionRequest(struct soap *soap, const char *tag, int id, _ngwm__removeCustomDefinitionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__removeCustomDefinitionRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__removeCustomDefinitionRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__removeCustomDefinitionRequest(struct soap *soap, _ngwm__removeCustomDefinitionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__removeCustomDefinitionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__removeCustomDefinitionRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__removeCustomDefinitionRequest(struct soap *soap, const char *tag, _ngwm__removeCustomDefinitionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__removeCustomDefinitionRequest **)soap_malloc(soap, sizeof(_ngwm__removeCustomDefinitionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__removeCustomDefinitionRequest *)soap_instantiate__ngwm__removeCustomDefinitionRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__removeCustomDefinitionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__removeCustomDefinitionRequest, sizeof(_ngwm__removeCustomDefinitionRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__readCursorResponse(struct soap *soap, _ngwm__readCursorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__readCursorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__readCursorResponse(struct soap *soap, _ngwm__readCursorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__readCursorResponse);
	if (soap_out_PointerTo_ngwm__readCursorResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__readCursorResponse(struct soap *soap, const char *tag, int id, _ngwm__readCursorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__readCursorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__readCursorResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__readCursorResponse(struct soap *soap, _ngwm__readCursorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__readCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__readCursorResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__readCursorResponse(struct soap *soap, const char *tag, _ngwm__readCursorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__readCursorResponse **)soap_malloc(soap, sizeof(_ngwm__readCursorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__readCursorResponse *)soap_instantiate__ngwm__readCursorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__readCursorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__readCursorResponse, sizeof(_ngwm__readCursorResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__readCursorRequest(struct soap *soap, _ngwm__readCursorRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__readCursorRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__readCursorRequest(struct soap *soap, _ngwm__readCursorRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__readCursorRequest);
	if (soap_out_PointerTo_ngwm__readCursorRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__readCursorRequest(struct soap *soap, const char *tag, int id, _ngwm__readCursorRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__readCursorRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__readCursorRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__readCursorRequest(struct soap *soap, _ngwm__readCursorRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__readCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__readCursorRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__readCursorRequest(struct soap *soap, const char *tag, _ngwm__readCursorRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__readCursorRequest **)soap_malloc(soap, sizeof(_ngwm__readCursorRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__readCursorRequest *)soap_instantiate__ngwm__readCursorRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__readCursorRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__readCursorRequest, sizeof(_ngwm__readCursorRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__purgeResponse(struct soap *soap, _ngwm__purgeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__purgeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__purgeResponse(struct soap *soap, _ngwm__purgeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__purgeResponse);
	if (soap_out_PointerTo_ngwm__purgeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__purgeResponse(struct soap *soap, const char *tag, int id, _ngwm__purgeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__purgeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__purgeResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__purgeResponse(struct soap *soap, _ngwm__purgeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__purgeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__purgeResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__purgeResponse(struct soap *soap, const char *tag, _ngwm__purgeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__purgeResponse **)soap_malloc(soap, sizeof(_ngwm__purgeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__purgeResponse *)soap_instantiate__ngwm__purgeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__purgeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__purgeResponse, sizeof(_ngwm__purgeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__purgeRequest(struct soap *soap, _ngwm__purgeRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__purgeRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__purgeRequest(struct soap *soap, _ngwm__purgeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__purgeRequest);
	if (soap_out_PointerTo_ngwm__purgeRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__purgeRequest(struct soap *soap, const char *tag, int id, _ngwm__purgeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__purgeRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__purgeRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__purgeRequest(struct soap *soap, _ngwm__purgeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__purgeRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__purgeRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__purgeRequest(struct soap *soap, const char *tag, _ngwm__purgeRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__purgeRequest **)soap_malloc(soap, sizeof(_ngwm__purgeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__purgeRequest *)soap_instantiate__ngwm__purgeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__purgeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__purgeRequest, sizeof(_ngwm__purgeRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__purgeDeletedItemsResponse(struct soap *soap, _ngwm__purgeDeletedItemsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__purgeDeletedItemsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__purgeDeletedItemsResponse(struct soap *soap, _ngwm__purgeDeletedItemsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__purgeDeletedItemsResponse);
	if (soap_out_PointerTo_ngwm__purgeDeletedItemsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__purgeDeletedItemsResponse(struct soap *soap, const char *tag, int id, _ngwm__purgeDeletedItemsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__purgeDeletedItemsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__purgeDeletedItemsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__purgeDeletedItemsResponse(struct soap *soap, _ngwm__purgeDeletedItemsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__purgeDeletedItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__purgeDeletedItemsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__purgeDeletedItemsResponse(struct soap *soap, const char *tag, _ngwm__purgeDeletedItemsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__purgeDeletedItemsResponse **)soap_malloc(soap, sizeof(_ngwm__purgeDeletedItemsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__purgeDeletedItemsResponse *)soap_instantiate__ngwm__purgeDeletedItemsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__purgeDeletedItemsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__purgeDeletedItemsResponse, sizeof(_ngwm__purgeDeletedItemsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__purgeDeletedItemsRequest(struct soap *soap, _ngwm__purgeDeletedItemsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__purgeDeletedItemsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__purgeDeletedItemsRequest(struct soap *soap, _ngwm__purgeDeletedItemsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__purgeDeletedItemsRequest);
	if (soap_out_PointerTo_ngwm__purgeDeletedItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__purgeDeletedItemsRequest(struct soap *soap, const char *tag, int id, _ngwm__purgeDeletedItemsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__purgeDeletedItemsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__purgeDeletedItemsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__purgeDeletedItemsRequest(struct soap *soap, _ngwm__purgeDeletedItemsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__purgeDeletedItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__purgeDeletedItemsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__purgeDeletedItemsRequest(struct soap *soap, const char *tag, _ngwm__purgeDeletedItemsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__purgeDeletedItemsRequest **)soap_malloc(soap, sizeof(_ngwm__purgeDeletedItemsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__purgeDeletedItemsRequest *)soap_instantiate__ngwm__purgeDeletedItemsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__purgeDeletedItemsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__purgeDeletedItemsRequest, sizeof(_ngwm__purgeDeletedItemsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__positionCursorResponse(struct soap *soap, _ngwm__positionCursorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__positionCursorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__positionCursorResponse(struct soap *soap, _ngwm__positionCursorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__positionCursorResponse);
	if (soap_out_PointerTo_ngwm__positionCursorResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__positionCursorResponse(struct soap *soap, const char *tag, int id, _ngwm__positionCursorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__positionCursorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__positionCursorResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__positionCursorResponse(struct soap *soap, _ngwm__positionCursorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__positionCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__positionCursorResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__positionCursorResponse(struct soap *soap, const char *tag, _ngwm__positionCursorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__positionCursorResponse **)soap_malloc(soap, sizeof(_ngwm__positionCursorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__positionCursorResponse *)soap_instantiate__ngwm__positionCursorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__positionCursorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__positionCursorResponse, sizeof(_ngwm__positionCursorResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__positionCursorRequest(struct soap *soap, _ngwm__positionCursorRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__positionCursorRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__positionCursorRequest(struct soap *soap, _ngwm__positionCursorRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__positionCursorRequest);
	if (soap_out_PointerTo_ngwm__positionCursorRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__positionCursorRequest(struct soap *soap, const char *tag, int id, _ngwm__positionCursorRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__positionCursorRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__positionCursorRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__positionCursorRequest(struct soap *soap, _ngwm__positionCursorRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__positionCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__positionCursorRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__positionCursorRequest(struct soap *soap, const char *tag, _ngwm__positionCursorRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__positionCursorRequest **)soap_malloc(soap, sizeof(_ngwm__positionCursorRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__positionCursorRequest *)soap_instantiate__ngwm__positionCursorRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__positionCursorRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__positionCursorRequest, sizeof(_ngwm__positionCursorRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__moveItemResponse(struct soap *soap, _ngwm__moveItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__moveItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__moveItemResponse(struct soap *soap, _ngwm__moveItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__moveItemResponse);
	if (soap_out_PointerTo_ngwm__moveItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__moveItemResponse(struct soap *soap, const char *tag, int id, _ngwm__moveItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__moveItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__moveItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__moveItemResponse(struct soap *soap, _ngwm__moveItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__moveItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__moveItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__moveItemResponse(struct soap *soap, const char *tag, _ngwm__moveItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__moveItemResponse **)soap_malloc(soap, sizeof(_ngwm__moveItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__moveItemResponse *)soap_instantiate__ngwm__moveItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__moveItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__moveItemResponse, sizeof(_ngwm__moveItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__moveItemRequest(struct soap *soap, _ngwm__moveItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__moveItemRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__moveItemRequest(struct soap *soap, _ngwm__moveItemRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__moveItemRequest);
	if (soap_out_PointerTo_ngwm__moveItemRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__moveItemRequest(struct soap *soap, const char *tag, int id, _ngwm__moveItemRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__moveItemRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__moveItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__moveItemRequest(struct soap *soap, _ngwm__moveItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__moveItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__moveItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__moveItemRequest(struct soap *soap, const char *tag, _ngwm__moveItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__moveItemRequest **)soap_malloc(soap, sizeof(_ngwm__moveItemRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__moveItemRequest *)soap_instantiate__ngwm__moveItemRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__moveItemRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__moveItemRequest, sizeof(_ngwm__moveItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifySignaturesResponse(struct soap *soap, _ngwm__modifySignaturesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifySignaturesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifySignaturesResponse(struct soap *soap, _ngwm__modifySignaturesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifySignaturesResponse);
	if (soap_out_PointerTo_ngwm__modifySignaturesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifySignaturesResponse(struct soap *soap, const char *tag, int id, _ngwm__modifySignaturesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifySignaturesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifySignaturesResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifySignaturesResponse(struct soap *soap, _ngwm__modifySignaturesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifySignaturesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifySignaturesResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifySignaturesResponse(struct soap *soap, const char *tag, _ngwm__modifySignaturesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifySignaturesResponse **)soap_malloc(soap, sizeof(_ngwm__modifySignaturesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifySignaturesResponse *)soap_instantiate__ngwm__modifySignaturesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifySignaturesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifySignaturesResponse, sizeof(_ngwm__modifySignaturesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifySignaturesRequest(struct soap *soap, _ngwm__modifySignaturesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifySignaturesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifySignaturesRequest(struct soap *soap, _ngwm__modifySignaturesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifySignaturesRequest);
	if (soap_out_PointerTo_ngwm__modifySignaturesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifySignaturesRequest(struct soap *soap, const char *tag, int id, _ngwm__modifySignaturesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifySignaturesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifySignaturesRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifySignaturesRequest(struct soap *soap, _ngwm__modifySignaturesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifySignaturesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifySignaturesRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifySignaturesRequest(struct soap *soap, const char *tag, _ngwm__modifySignaturesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifySignaturesRequest **)soap_malloc(soap, sizeof(_ngwm__modifySignaturesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifySignaturesRequest *)soap_instantiate__ngwm__modifySignaturesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifySignaturesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifySignaturesRequest, sizeof(_ngwm__modifySignaturesRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifySettingsResponse(struct soap *soap, _ngwm__modifySettingsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifySettingsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifySettingsResponse(struct soap *soap, _ngwm__modifySettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifySettingsResponse);
	if (soap_out_PointerTo_ngwm__modifySettingsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifySettingsResponse(struct soap *soap, const char *tag, int id, _ngwm__modifySettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifySettingsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifySettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifySettingsResponse(struct soap *soap, _ngwm__modifySettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifySettingsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifySettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifySettingsResponse(struct soap *soap, const char *tag, _ngwm__modifySettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifySettingsResponse **)soap_malloc(soap, sizeof(_ngwm__modifySettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifySettingsResponse *)soap_instantiate__ngwm__modifySettingsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifySettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifySettingsResponse, sizeof(_ngwm__modifySettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifySettingsRequest(struct soap *soap, _ngwm__modifySettingsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifySettingsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifySettingsRequest(struct soap *soap, _ngwm__modifySettingsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifySettingsRequest);
	if (soap_out_PointerTo_ngwm__modifySettingsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifySettingsRequest(struct soap *soap, const char *tag, int id, _ngwm__modifySettingsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifySettingsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifySettingsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifySettingsRequest(struct soap *soap, _ngwm__modifySettingsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifySettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifySettingsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifySettingsRequest(struct soap *soap, const char *tag, _ngwm__modifySettingsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifySettingsRequest **)soap_malloc(soap, sizeof(_ngwm__modifySettingsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifySettingsRequest *)soap_instantiate__ngwm__modifySettingsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifySettingsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifySettingsRequest, sizeof(_ngwm__modifySettingsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifyProxyAccessResponse(struct soap *soap, _ngwm__modifyProxyAccessResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifyProxyAccessResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifyProxyAccessResponse(struct soap *soap, _ngwm__modifyProxyAccessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifyProxyAccessResponse);
	if (soap_out_PointerTo_ngwm__modifyProxyAccessResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifyProxyAccessResponse(struct soap *soap, const char *tag, int id, _ngwm__modifyProxyAccessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifyProxyAccessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifyProxyAccessResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifyProxyAccessResponse(struct soap *soap, _ngwm__modifyProxyAccessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifyProxyAccessResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifyProxyAccessResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifyProxyAccessResponse(struct soap *soap, const char *tag, _ngwm__modifyProxyAccessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifyProxyAccessResponse **)soap_malloc(soap, sizeof(_ngwm__modifyProxyAccessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifyProxyAccessResponse *)soap_instantiate__ngwm__modifyProxyAccessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyProxyAccessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyProxyAccessResponse, sizeof(_ngwm__modifyProxyAccessResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifyProxyAccessRequest(struct soap *soap, _ngwm__modifyProxyAccessRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifyProxyAccessRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifyProxyAccessRequest(struct soap *soap, _ngwm__modifyProxyAccessRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifyProxyAccessRequest);
	if (soap_out_PointerTo_ngwm__modifyProxyAccessRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifyProxyAccessRequest(struct soap *soap, const char *tag, int id, _ngwm__modifyProxyAccessRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifyProxyAccessRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifyProxyAccessRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifyProxyAccessRequest(struct soap *soap, _ngwm__modifyProxyAccessRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifyProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifyProxyAccessRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifyProxyAccessRequest(struct soap *soap, const char *tag, _ngwm__modifyProxyAccessRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifyProxyAccessRequest **)soap_malloc(soap, sizeof(_ngwm__modifyProxyAccessRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifyProxyAccessRequest *)soap_instantiate__ngwm__modifyProxyAccessRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyProxyAccessRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyProxyAccessRequest, sizeof(_ngwm__modifyProxyAccessRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifyPasswordResponse(struct soap *soap, _ngwm__modifyPasswordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifyPasswordResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifyPasswordResponse(struct soap *soap, _ngwm__modifyPasswordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifyPasswordResponse);
	if (soap_out_PointerTo_ngwm__modifyPasswordResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifyPasswordResponse(struct soap *soap, const char *tag, int id, _ngwm__modifyPasswordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifyPasswordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifyPasswordResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifyPasswordResponse(struct soap *soap, _ngwm__modifyPasswordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifyPasswordResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifyPasswordResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifyPasswordResponse(struct soap *soap, const char *tag, _ngwm__modifyPasswordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifyPasswordResponse **)soap_malloc(soap, sizeof(_ngwm__modifyPasswordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifyPasswordResponse *)soap_instantiate__ngwm__modifyPasswordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyPasswordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyPasswordResponse, sizeof(_ngwm__modifyPasswordResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifyPasswordRequest(struct soap *soap, _ngwm__modifyPasswordRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifyPasswordRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifyPasswordRequest(struct soap *soap, _ngwm__modifyPasswordRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifyPasswordRequest);
	if (soap_out_PointerTo_ngwm__modifyPasswordRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifyPasswordRequest(struct soap *soap, const char *tag, int id, _ngwm__modifyPasswordRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifyPasswordRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifyPasswordRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifyPasswordRequest(struct soap *soap, _ngwm__modifyPasswordRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifyPasswordRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifyPasswordRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifyPasswordRequest(struct soap *soap, const char *tag, _ngwm__modifyPasswordRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifyPasswordRequest **)soap_malloc(soap, sizeof(_ngwm__modifyPasswordRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifyPasswordRequest *)soap_instantiate__ngwm__modifyPasswordRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyPasswordRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyPasswordRequest, sizeof(_ngwm__modifyPasswordRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifyJunkMailSettingsResponse(struct soap *soap, _ngwm__modifyJunkMailSettingsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifyJunkMailSettingsResponse(struct soap *soap, _ngwm__modifyJunkMailSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifyJunkMailSettingsResponse);
	if (soap_out_PointerTo_ngwm__modifyJunkMailSettingsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifyJunkMailSettingsResponse(struct soap *soap, const char *tag, int id, _ngwm__modifyJunkMailSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifyJunkMailSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifyJunkMailSettingsResponse(struct soap *soap, _ngwm__modifyJunkMailSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifyJunkMailSettingsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifyJunkMailSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifyJunkMailSettingsResponse(struct soap *soap, const char *tag, _ngwm__modifyJunkMailSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifyJunkMailSettingsResponse **)soap_malloc(soap, sizeof(_ngwm__modifyJunkMailSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifyJunkMailSettingsResponse *)soap_instantiate__ngwm__modifyJunkMailSettingsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyJunkMailSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyJunkMailSettingsResponse, sizeof(_ngwm__modifyJunkMailSettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifyJunkMailSettingsRequest(struct soap *soap, _ngwm__modifyJunkMailSettingsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifyJunkMailSettingsRequest(struct soap *soap, _ngwm__modifyJunkMailSettingsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifyJunkMailSettingsRequest);
	if (soap_out_PointerTo_ngwm__modifyJunkMailSettingsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifyJunkMailSettingsRequest(struct soap *soap, const char *tag, int id, _ngwm__modifyJunkMailSettingsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifyJunkMailSettingsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifyJunkMailSettingsRequest(struct soap *soap, _ngwm__modifyJunkMailSettingsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifyJunkMailSettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifyJunkMailSettingsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifyJunkMailSettingsRequest(struct soap *soap, const char *tag, _ngwm__modifyJunkMailSettingsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifyJunkMailSettingsRequest **)soap_malloc(soap, sizeof(_ngwm__modifyJunkMailSettingsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifyJunkMailSettingsRequest *)soap_instantiate__ngwm__modifyJunkMailSettingsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyJunkMailSettingsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyJunkMailSettingsRequest, sizeof(_ngwm__modifyJunkMailSettingsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifyJunkEntryResponse(struct soap *soap, _ngwm__modifyJunkEntryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifyJunkEntryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifyJunkEntryResponse(struct soap *soap, _ngwm__modifyJunkEntryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifyJunkEntryResponse);
	if (soap_out_PointerTo_ngwm__modifyJunkEntryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifyJunkEntryResponse(struct soap *soap, const char *tag, int id, _ngwm__modifyJunkEntryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifyJunkEntryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifyJunkEntryResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifyJunkEntryResponse(struct soap *soap, _ngwm__modifyJunkEntryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifyJunkEntryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifyJunkEntryResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifyJunkEntryResponse(struct soap *soap, const char *tag, _ngwm__modifyJunkEntryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifyJunkEntryResponse **)soap_malloc(soap, sizeof(_ngwm__modifyJunkEntryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifyJunkEntryResponse *)soap_instantiate__ngwm__modifyJunkEntryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyJunkEntryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyJunkEntryResponse, sizeof(_ngwm__modifyJunkEntryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifyJunkEntryRequest(struct soap *soap, _ngwm__modifyJunkEntryRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifyJunkEntryRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifyJunkEntryRequest(struct soap *soap, _ngwm__modifyJunkEntryRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifyJunkEntryRequest);
	if (soap_out_PointerTo_ngwm__modifyJunkEntryRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifyJunkEntryRequest(struct soap *soap, const char *tag, int id, _ngwm__modifyJunkEntryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifyJunkEntryRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifyJunkEntryRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifyJunkEntryRequest(struct soap *soap, _ngwm__modifyJunkEntryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifyJunkEntryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifyJunkEntryRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifyJunkEntryRequest(struct soap *soap, const char *tag, _ngwm__modifyJunkEntryRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifyJunkEntryRequest **)soap_malloc(soap, sizeof(_ngwm__modifyJunkEntryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifyJunkEntryRequest *)soap_instantiate__ngwm__modifyJunkEntryRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyJunkEntryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyJunkEntryRequest, sizeof(_ngwm__modifyJunkEntryRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifyItemResponse(struct soap *soap, _ngwm__modifyItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifyItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifyItemResponse(struct soap *soap, _ngwm__modifyItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifyItemResponse);
	if (soap_out_PointerTo_ngwm__modifyItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifyItemResponse(struct soap *soap, const char *tag, int id, _ngwm__modifyItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifyItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifyItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifyItemResponse(struct soap *soap, _ngwm__modifyItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifyItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifyItemResponse(struct soap *soap, const char *tag, _ngwm__modifyItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifyItemResponse **)soap_malloc(soap, sizeof(_ngwm__modifyItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifyItemResponse *)soap_instantiate__ngwm__modifyItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyItemResponse, sizeof(_ngwm__modifyItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__modifyItemRequest(struct soap *soap, _ngwm__modifyItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__modifyItemRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__modifyItemRequest(struct soap *soap, _ngwm__modifyItemRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__modifyItemRequest);
	if (soap_out_PointerTo_ngwm__modifyItemRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__modifyItemRequest(struct soap *soap, const char *tag, int id, _ngwm__modifyItemRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__modifyItemRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__modifyItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__modifyItemRequest(struct soap *soap, _ngwm__modifyItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__modifyItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__modifyItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__modifyItemRequest(struct soap *soap, const char *tag, _ngwm__modifyItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__modifyItemRequest **)soap_malloc(soap, sizeof(_ngwm__modifyItemRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__modifyItemRequest *)soap_instantiate__ngwm__modifyItemRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__modifyItemRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__modifyItemRequest, sizeof(_ngwm__modifyItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__markUnReadResponse(struct soap *soap, _ngwm__markUnReadResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__markUnReadResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__markUnReadResponse(struct soap *soap, _ngwm__markUnReadResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__markUnReadResponse);
	if (soap_out_PointerTo_ngwm__markUnReadResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__markUnReadResponse(struct soap *soap, const char *tag, int id, _ngwm__markUnReadResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__markUnReadResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__markUnReadResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__markUnReadResponse(struct soap *soap, _ngwm__markUnReadResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__markUnReadResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__markUnReadResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__markUnReadResponse(struct soap *soap, const char *tag, _ngwm__markUnReadResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__markUnReadResponse **)soap_malloc(soap, sizeof(_ngwm__markUnReadResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__markUnReadResponse *)soap_instantiate__ngwm__markUnReadResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__markUnReadResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markUnReadResponse, sizeof(_ngwm__markUnReadResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__markUnReadRequest(struct soap *soap, _ngwm__markUnReadRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__markUnReadRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__markUnReadRequest(struct soap *soap, _ngwm__markUnReadRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__markUnReadRequest);
	if (soap_out_PointerTo_ngwm__markUnReadRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__markUnReadRequest(struct soap *soap, const char *tag, int id, _ngwm__markUnReadRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__markUnReadRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__markUnReadRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__markUnReadRequest(struct soap *soap, _ngwm__markUnReadRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__markUnReadRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__markUnReadRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__markUnReadRequest(struct soap *soap, const char *tag, _ngwm__markUnReadRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__markUnReadRequest **)soap_malloc(soap, sizeof(_ngwm__markUnReadRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__markUnReadRequest *)soap_instantiate__ngwm__markUnReadRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__markUnReadRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markUnReadRequest, sizeof(_ngwm__markUnReadRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__markUnPrivateResponse(struct soap *soap, _ngwm__markUnPrivateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__markUnPrivateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__markUnPrivateResponse(struct soap *soap, _ngwm__markUnPrivateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__markUnPrivateResponse);
	if (soap_out_PointerTo_ngwm__markUnPrivateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__markUnPrivateResponse(struct soap *soap, const char *tag, int id, _ngwm__markUnPrivateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__markUnPrivateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__markUnPrivateResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__markUnPrivateResponse(struct soap *soap, _ngwm__markUnPrivateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__markUnPrivateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__markUnPrivateResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__markUnPrivateResponse(struct soap *soap, const char *tag, _ngwm__markUnPrivateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__markUnPrivateResponse **)soap_malloc(soap, sizeof(_ngwm__markUnPrivateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__markUnPrivateResponse *)soap_instantiate__ngwm__markUnPrivateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__markUnPrivateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markUnPrivateResponse, sizeof(_ngwm__markUnPrivateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__markUnPrivateRequest(struct soap *soap, _ngwm__markUnPrivateRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__markUnPrivateRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__markUnPrivateRequest(struct soap *soap, _ngwm__markUnPrivateRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__markUnPrivateRequest);
	if (soap_out_PointerTo_ngwm__markUnPrivateRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__markUnPrivateRequest(struct soap *soap, const char *tag, int id, _ngwm__markUnPrivateRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__markUnPrivateRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__markUnPrivateRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__markUnPrivateRequest(struct soap *soap, _ngwm__markUnPrivateRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__markUnPrivateRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__markUnPrivateRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__markUnPrivateRequest(struct soap *soap, const char *tag, _ngwm__markUnPrivateRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__markUnPrivateRequest **)soap_malloc(soap, sizeof(_ngwm__markUnPrivateRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__markUnPrivateRequest *)soap_instantiate__ngwm__markUnPrivateRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__markUnPrivateRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markUnPrivateRequest, sizeof(_ngwm__markUnPrivateRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__markReadResponse(struct soap *soap, _ngwm__markReadResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__markReadResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__markReadResponse(struct soap *soap, _ngwm__markReadResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__markReadResponse);
	if (soap_out_PointerTo_ngwm__markReadResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__markReadResponse(struct soap *soap, const char *tag, int id, _ngwm__markReadResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__markReadResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__markReadResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__markReadResponse(struct soap *soap, _ngwm__markReadResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__markReadResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__markReadResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__markReadResponse(struct soap *soap, const char *tag, _ngwm__markReadResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__markReadResponse **)soap_malloc(soap, sizeof(_ngwm__markReadResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__markReadResponse *)soap_instantiate__ngwm__markReadResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__markReadResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markReadResponse, sizeof(_ngwm__markReadResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__markReadRequest(struct soap *soap, _ngwm__markReadRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__markReadRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__markReadRequest(struct soap *soap, _ngwm__markReadRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__markReadRequest);
	if (soap_out_PointerTo_ngwm__markReadRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__markReadRequest(struct soap *soap, const char *tag, int id, _ngwm__markReadRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__markReadRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__markReadRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__markReadRequest(struct soap *soap, _ngwm__markReadRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__markReadRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__markReadRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__markReadRequest(struct soap *soap, const char *tag, _ngwm__markReadRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__markReadRequest **)soap_malloc(soap, sizeof(_ngwm__markReadRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__markReadRequest *)soap_instantiate__ngwm__markReadRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__markReadRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markReadRequest, sizeof(_ngwm__markReadRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__markPrivateResponse(struct soap *soap, _ngwm__markPrivateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__markPrivateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__markPrivateResponse(struct soap *soap, _ngwm__markPrivateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__markPrivateResponse);
	if (soap_out_PointerTo_ngwm__markPrivateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__markPrivateResponse(struct soap *soap, const char *tag, int id, _ngwm__markPrivateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__markPrivateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__markPrivateResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__markPrivateResponse(struct soap *soap, _ngwm__markPrivateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__markPrivateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__markPrivateResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__markPrivateResponse(struct soap *soap, const char *tag, _ngwm__markPrivateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__markPrivateResponse **)soap_malloc(soap, sizeof(_ngwm__markPrivateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__markPrivateResponse *)soap_instantiate__ngwm__markPrivateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__markPrivateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markPrivateResponse, sizeof(_ngwm__markPrivateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__markPrivateRequest(struct soap *soap, _ngwm__markPrivateRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__markPrivateRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__markPrivateRequest(struct soap *soap, _ngwm__markPrivateRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__markPrivateRequest);
	if (soap_out_PointerTo_ngwm__markPrivateRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__markPrivateRequest(struct soap *soap, const char *tag, int id, _ngwm__markPrivateRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__markPrivateRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__markPrivateRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__markPrivateRequest(struct soap *soap, _ngwm__markPrivateRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__markPrivateRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__markPrivateRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__markPrivateRequest(struct soap *soap, const char *tag, _ngwm__markPrivateRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__markPrivateRequest **)soap_malloc(soap, sizeof(_ngwm__markPrivateRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__markPrivateRequest *)soap_instantiate__ngwm__markPrivateRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__markPrivateRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__markPrivateRequest, sizeof(_ngwm__markPrivateRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__logoutResponse(struct soap *soap, _ngwm__logoutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__logoutResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__logoutResponse(struct soap *soap, _ngwm__logoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__logoutResponse);
	if (soap_out_PointerTo_ngwm__logoutResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__logoutResponse(struct soap *soap, const char *tag, int id, _ngwm__logoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__logoutResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__logoutResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__logoutResponse(struct soap *soap, _ngwm__logoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__logoutResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__logoutResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__logoutResponse(struct soap *soap, const char *tag, _ngwm__logoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__logoutResponse **)soap_malloc(soap, sizeof(_ngwm__logoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__logoutResponse *)soap_instantiate__ngwm__logoutResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__logoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__logoutResponse, sizeof(_ngwm__logoutResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__logoutRequest(struct soap *soap, _ngwm__logoutRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__logoutRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__logoutRequest(struct soap *soap, _ngwm__logoutRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__logoutRequest);
	if (soap_out_PointerTo_ngwm__logoutRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__logoutRequest(struct soap *soap, const char *tag, int id, _ngwm__logoutRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__logoutRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__logoutRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__logoutRequest(struct soap *soap, _ngwm__logoutRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__logoutRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__logoutRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__logoutRequest(struct soap *soap, const char *tag, _ngwm__logoutRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__logoutRequest **)soap_malloc(soap, sizeof(_ngwm__logoutRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__logoutRequest *)soap_instantiate__ngwm__logoutRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__logoutRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__logoutRequest, sizeof(_ngwm__logoutRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__loginResponse(struct soap *soap, _ngwm__loginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__loginResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__loginResponse(struct soap *soap, _ngwm__loginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__loginResponse);
	if (soap_out_PointerTo_ngwm__loginResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__loginResponse(struct soap *soap, const char *tag, int id, _ngwm__loginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__loginResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__loginResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__loginResponse(struct soap *soap, _ngwm__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__loginResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__loginResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__loginResponse(struct soap *soap, const char *tag, _ngwm__loginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__loginResponse **)soap_malloc(soap, sizeof(_ngwm__loginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__loginResponse *)soap_instantiate__ngwm__loginResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__loginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__loginResponse, sizeof(_ngwm__loginResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__loginRequest(struct soap *soap, _ngwm__loginRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__loginRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__loginRequest(struct soap *soap, _ngwm__loginRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__loginRequest);
	if (soap_out_PointerTo_ngwm__loginRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__loginRequest(struct soap *soap, const char *tag, int id, _ngwm__loginRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__loginRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__loginRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__loginRequest(struct soap *soap, _ngwm__loginRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__loginRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__loginRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__loginRequest(struct soap *soap, const char *tag, _ngwm__loginRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__loginRequest **)soap_malloc(soap, sizeof(_ngwm__loginRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__loginRequest *)soap_instantiate__ngwm__loginRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__loginRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__loginRequest, sizeof(_ngwm__loginRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getUserListResponse(struct soap *soap, _ngwm__getUserListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getUserListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getUserListResponse(struct soap *soap, _ngwm__getUserListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getUserListResponse);
	if (soap_out_PointerTo_ngwm__getUserListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getUserListResponse(struct soap *soap, const char *tag, int id, _ngwm__getUserListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getUserListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getUserListResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getUserListResponse(struct soap *soap, _ngwm__getUserListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getUserListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getUserListResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getUserListResponse(struct soap *soap, const char *tag, _ngwm__getUserListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getUserListResponse **)soap_malloc(soap, sizeof(_ngwm__getUserListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getUserListResponse *)soap_instantiate__ngwm__getUserListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getUserListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getUserListResponse, sizeof(_ngwm__getUserListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getUserListRequest(struct soap *soap, _ngwm__getUserListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getUserListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getUserListRequest(struct soap *soap, _ngwm__getUserListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getUserListRequest);
	if (soap_out_PointerTo_ngwm__getUserListRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getUserListRequest(struct soap *soap, const char *tag, int id, _ngwm__getUserListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getUserListRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getUserListRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getUserListRequest(struct soap *soap, _ngwm__getUserListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getUserListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getUserListRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getUserListRequest(struct soap *soap, const char *tag, _ngwm__getUserListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getUserListRequest **)soap_malloc(soap, sizeof(_ngwm__getUserListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getUserListRequest *)soap_instantiate__ngwm__getUserListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getUserListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getUserListRequest, sizeof(_ngwm__getUserListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getTimezoneListResponse(struct soap *soap, _ngwm__getTimezoneListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getTimezoneListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getTimezoneListResponse(struct soap *soap, _ngwm__getTimezoneListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getTimezoneListResponse);
	if (soap_out_PointerTo_ngwm__getTimezoneListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getTimezoneListResponse(struct soap *soap, const char *tag, int id, _ngwm__getTimezoneListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getTimezoneListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getTimezoneListResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getTimezoneListResponse(struct soap *soap, _ngwm__getTimezoneListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getTimezoneListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getTimezoneListResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getTimezoneListResponse(struct soap *soap, const char *tag, _ngwm__getTimezoneListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getTimezoneListResponse **)soap_malloc(soap, sizeof(_ngwm__getTimezoneListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getTimezoneListResponse *)soap_instantiate__ngwm__getTimezoneListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getTimezoneListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getTimezoneListResponse, sizeof(_ngwm__getTimezoneListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getTimezoneListRequest(struct soap *soap, _ngwm__getTimezoneListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getTimezoneListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getTimezoneListRequest(struct soap *soap, _ngwm__getTimezoneListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getTimezoneListRequest);
	if (soap_out_PointerTo_ngwm__getTimezoneListRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getTimezoneListRequest(struct soap *soap, const char *tag, int id, _ngwm__getTimezoneListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getTimezoneListRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getTimezoneListRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getTimezoneListRequest(struct soap *soap, _ngwm__getTimezoneListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getTimezoneListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getTimezoneListRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getTimezoneListRequest(struct soap *soap, const char *tag, _ngwm__getTimezoneListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getTimezoneListRequest **)soap_malloc(soap, sizeof(_ngwm__getTimezoneListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getTimezoneListRequest *)soap_instantiate__ngwm__getTimezoneListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getTimezoneListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getTimezoneListRequest, sizeof(_ngwm__getTimezoneListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getTimestampResponse(struct soap *soap, _ngwm__getTimestampResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getTimestampResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getTimestampResponse(struct soap *soap, _ngwm__getTimestampResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getTimestampResponse);
	if (soap_out_PointerTo_ngwm__getTimestampResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getTimestampResponse(struct soap *soap, const char *tag, int id, _ngwm__getTimestampResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getTimestampResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getTimestampResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getTimestampResponse(struct soap *soap, _ngwm__getTimestampResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getTimestampResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getTimestampResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getTimestampResponse(struct soap *soap, const char *tag, _ngwm__getTimestampResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getTimestampResponse **)soap_malloc(soap, sizeof(_ngwm__getTimestampResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getTimestampResponse *)soap_instantiate__ngwm__getTimestampResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getTimestampResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getTimestampResponse, sizeof(_ngwm__getTimestampResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getTimestampRequest(struct soap *soap, _ngwm__getTimestampRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getTimestampRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getTimestampRequest(struct soap *soap, _ngwm__getTimestampRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getTimestampRequest);
	if (soap_out_PointerTo_ngwm__getTimestampRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getTimestampRequest(struct soap *soap, const char *tag, int id, _ngwm__getTimestampRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getTimestampRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getTimestampRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getTimestampRequest(struct soap *soap, _ngwm__getTimestampRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getTimestampRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getTimestampRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getTimestampRequest(struct soap *soap, const char *tag, _ngwm__getTimestampRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getTimestampRequest **)soap_malloc(soap, sizeof(_ngwm__getTimestampRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getTimestampRequest *)soap_instantiate__ngwm__getTimestampRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getTimestampRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getTimestampRequest, sizeof(_ngwm__getTimestampRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getSignaturesResponse(struct soap *soap, _ngwm__getSignaturesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getSignaturesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getSignaturesResponse(struct soap *soap, _ngwm__getSignaturesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getSignaturesResponse);
	if (soap_out_PointerTo_ngwm__getSignaturesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getSignaturesResponse(struct soap *soap, const char *tag, int id, _ngwm__getSignaturesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getSignaturesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getSignaturesResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getSignaturesResponse(struct soap *soap, _ngwm__getSignaturesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getSignaturesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getSignaturesResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getSignaturesResponse(struct soap *soap, const char *tag, _ngwm__getSignaturesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getSignaturesResponse **)soap_malloc(soap, sizeof(_ngwm__getSignaturesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getSignaturesResponse *)soap_instantiate__ngwm__getSignaturesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getSignaturesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getSignaturesResponse, sizeof(_ngwm__getSignaturesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getSignaturesRequest(struct soap *soap, _ngwm__getSignaturesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getSignaturesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getSignaturesRequest(struct soap *soap, _ngwm__getSignaturesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getSignaturesRequest);
	if (soap_out_PointerTo_ngwm__getSignaturesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getSignaturesRequest(struct soap *soap, const char *tag, int id, _ngwm__getSignaturesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getSignaturesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getSignaturesRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getSignaturesRequest(struct soap *soap, _ngwm__getSignaturesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getSignaturesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getSignaturesRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getSignaturesRequest(struct soap *soap, const char *tag, _ngwm__getSignaturesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getSignaturesRequest **)soap_malloc(soap, sizeof(_ngwm__getSignaturesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getSignaturesRequest *)soap_instantiate__ngwm__getSignaturesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getSignaturesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getSignaturesRequest, sizeof(_ngwm__getSignaturesRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getSettingsResponse(struct soap *soap, _ngwm__getSettingsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getSettingsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getSettingsResponse(struct soap *soap, _ngwm__getSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getSettingsResponse);
	if (soap_out_PointerTo_ngwm__getSettingsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getSettingsResponse(struct soap *soap, const char *tag, int id, _ngwm__getSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getSettingsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getSettingsResponse(struct soap *soap, _ngwm__getSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getSettingsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getSettingsResponse(struct soap *soap, const char *tag, _ngwm__getSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getSettingsResponse **)soap_malloc(soap, sizeof(_ngwm__getSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getSettingsResponse *)soap_instantiate__ngwm__getSettingsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getSettingsResponse, sizeof(_ngwm__getSettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getSettingsRequest(struct soap *soap, _ngwm__getSettingsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getSettingsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getSettingsRequest(struct soap *soap, _ngwm__getSettingsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getSettingsRequest);
	if (soap_out_PointerTo_ngwm__getSettingsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getSettingsRequest(struct soap *soap, const char *tag, int id, _ngwm__getSettingsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getSettingsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getSettingsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getSettingsRequest(struct soap *soap, _ngwm__getSettingsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getSettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getSettingsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getSettingsRequest(struct soap *soap, const char *tag, _ngwm__getSettingsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getSettingsRequest **)soap_malloc(soap, sizeof(_ngwm__getSettingsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getSettingsRequest *)soap_instantiate__ngwm__getSettingsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getSettingsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getSettingsRequest, sizeof(_ngwm__getSettingsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getRuleListResponse(struct soap *soap, _ngwm__getRuleListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getRuleListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getRuleListResponse(struct soap *soap, _ngwm__getRuleListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getRuleListResponse);
	if (soap_out_PointerTo_ngwm__getRuleListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getRuleListResponse(struct soap *soap, const char *tag, int id, _ngwm__getRuleListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getRuleListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getRuleListResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getRuleListResponse(struct soap *soap, _ngwm__getRuleListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getRuleListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getRuleListResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getRuleListResponse(struct soap *soap, const char *tag, _ngwm__getRuleListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getRuleListResponse **)soap_malloc(soap, sizeof(_ngwm__getRuleListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getRuleListResponse *)soap_instantiate__ngwm__getRuleListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getRuleListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getRuleListResponse, sizeof(_ngwm__getRuleListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getRuleListRequest(struct soap *soap, _ngwm__getRuleListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getRuleListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getRuleListRequest(struct soap *soap, _ngwm__getRuleListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getRuleListRequest);
	if (soap_out_PointerTo_ngwm__getRuleListRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getRuleListRequest(struct soap *soap, const char *tag, int id, _ngwm__getRuleListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getRuleListRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getRuleListRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getRuleListRequest(struct soap *soap, _ngwm__getRuleListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getRuleListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getRuleListRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getRuleListRequest(struct soap *soap, const char *tag, _ngwm__getRuleListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getRuleListRequest **)soap_malloc(soap, sizeof(_ngwm__getRuleListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getRuleListRequest *)soap_instantiate__ngwm__getRuleListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getRuleListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getRuleListRequest, sizeof(_ngwm__getRuleListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getProxyListResponse(struct soap *soap, _ngwm__getProxyListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getProxyListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getProxyListResponse(struct soap *soap, _ngwm__getProxyListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getProxyListResponse);
	if (soap_out_PointerTo_ngwm__getProxyListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getProxyListResponse(struct soap *soap, const char *tag, int id, _ngwm__getProxyListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getProxyListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getProxyListResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getProxyListResponse(struct soap *soap, _ngwm__getProxyListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getProxyListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getProxyListResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getProxyListResponse(struct soap *soap, const char *tag, _ngwm__getProxyListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getProxyListResponse **)soap_malloc(soap, sizeof(_ngwm__getProxyListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getProxyListResponse *)soap_instantiate__ngwm__getProxyListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getProxyListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getProxyListResponse, sizeof(_ngwm__getProxyListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getProxyListRequest(struct soap *soap, _ngwm__getProxyListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getProxyListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getProxyListRequest(struct soap *soap, _ngwm__getProxyListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getProxyListRequest);
	if (soap_out_PointerTo_ngwm__getProxyListRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getProxyListRequest(struct soap *soap, const char *tag, int id, _ngwm__getProxyListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getProxyListRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getProxyListRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getProxyListRequest(struct soap *soap, _ngwm__getProxyListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getProxyListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getProxyListRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getProxyListRequest(struct soap *soap, const char *tag, _ngwm__getProxyListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getProxyListRequest **)soap_malloc(soap, sizeof(_ngwm__getProxyListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getProxyListRequest *)soap_instantiate__ngwm__getProxyListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getProxyListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getProxyListRequest, sizeof(_ngwm__getProxyListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getProxyAccessListResponse(struct soap *soap, _ngwm__getProxyAccessListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getProxyAccessListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getProxyAccessListResponse(struct soap *soap, _ngwm__getProxyAccessListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getProxyAccessListResponse);
	if (soap_out_PointerTo_ngwm__getProxyAccessListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getProxyAccessListResponse(struct soap *soap, const char *tag, int id, _ngwm__getProxyAccessListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getProxyAccessListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getProxyAccessListResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getProxyAccessListResponse(struct soap *soap, _ngwm__getProxyAccessListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getProxyAccessListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getProxyAccessListResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getProxyAccessListResponse(struct soap *soap, const char *tag, _ngwm__getProxyAccessListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getProxyAccessListResponse **)soap_malloc(soap, sizeof(_ngwm__getProxyAccessListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getProxyAccessListResponse *)soap_instantiate__ngwm__getProxyAccessListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getProxyAccessListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getProxyAccessListResponse, sizeof(_ngwm__getProxyAccessListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getProxyAccessListRequest(struct soap *soap, _ngwm__getProxyAccessListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getProxyAccessListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getProxyAccessListRequest(struct soap *soap, _ngwm__getProxyAccessListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getProxyAccessListRequest);
	if (soap_out_PointerTo_ngwm__getProxyAccessListRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getProxyAccessListRequest(struct soap *soap, const char *tag, int id, _ngwm__getProxyAccessListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getProxyAccessListRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getProxyAccessListRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getProxyAccessListRequest(struct soap *soap, _ngwm__getProxyAccessListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getProxyAccessListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getProxyAccessListRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getProxyAccessListRequest(struct soap *soap, const char *tag, _ngwm__getProxyAccessListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getProxyAccessListRequest **)soap_malloc(soap, sizeof(_ngwm__getProxyAccessListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getProxyAccessListRequest *)soap_instantiate__ngwm__getProxyAccessListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getProxyAccessListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getProxyAccessListRequest, sizeof(_ngwm__getProxyAccessListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getQuickMessagesResponse(struct soap *soap, _ngwm__getQuickMessagesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getQuickMessagesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getQuickMessagesResponse(struct soap *soap, _ngwm__getQuickMessagesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getQuickMessagesResponse);
	if (soap_out_PointerTo_ngwm__getQuickMessagesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getQuickMessagesResponse(struct soap *soap, const char *tag, int id, _ngwm__getQuickMessagesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getQuickMessagesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getQuickMessagesResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getQuickMessagesResponse(struct soap *soap, _ngwm__getQuickMessagesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getQuickMessagesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getQuickMessagesResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getQuickMessagesResponse(struct soap *soap, const char *tag, _ngwm__getQuickMessagesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getQuickMessagesResponse **)soap_malloc(soap, sizeof(_ngwm__getQuickMessagesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getQuickMessagesResponse *)soap_instantiate__ngwm__getQuickMessagesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getQuickMessagesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getQuickMessagesResponse, sizeof(_ngwm__getQuickMessagesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getQuickMessagesRequest(struct soap *soap, _ngwm__getQuickMessagesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getQuickMessagesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getQuickMessagesRequest(struct soap *soap, _ngwm__getQuickMessagesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getQuickMessagesRequest);
	if (soap_out_PointerTo_ngwm__getQuickMessagesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getQuickMessagesRequest(struct soap *soap, const char *tag, int id, _ngwm__getQuickMessagesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getQuickMessagesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getQuickMessagesRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getQuickMessagesRequest(struct soap *soap, _ngwm__getQuickMessagesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getQuickMessagesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getQuickMessagesRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getQuickMessagesRequest(struct soap *soap, const char *tag, _ngwm__getQuickMessagesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getQuickMessagesRequest **)soap_malloc(soap, sizeof(_ngwm__getQuickMessagesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getQuickMessagesRequest *)soap_instantiate__ngwm__getQuickMessagesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getQuickMessagesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getQuickMessagesRequest, sizeof(_ngwm__getQuickMessagesRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getLibraryListResponse(struct soap *soap, _ngwm__getLibraryListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getLibraryListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getLibraryListResponse(struct soap *soap, _ngwm__getLibraryListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getLibraryListResponse);
	if (soap_out_PointerTo_ngwm__getLibraryListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getLibraryListResponse(struct soap *soap, const char *tag, int id, _ngwm__getLibraryListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getLibraryListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getLibraryListResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getLibraryListResponse(struct soap *soap, _ngwm__getLibraryListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getLibraryListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getLibraryListResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getLibraryListResponse(struct soap *soap, const char *tag, _ngwm__getLibraryListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getLibraryListResponse **)soap_malloc(soap, sizeof(_ngwm__getLibraryListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getLibraryListResponse *)soap_instantiate__ngwm__getLibraryListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getLibraryListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getLibraryListResponse, sizeof(_ngwm__getLibraryListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getLibraryListRequest(struct soap *soap, _ngwm__getLibraryListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getLibraryListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getLibraryListRequest(struct soap *soap, _ngwm__getLibraryListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getLibraryListRequest);
	if (soap_out_PointerTo_ngwm__getLibraryListRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getLibraryListRequest(struct soap *soap, const char *tag, int id, _ngwm__getLibraryListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getLibraryListRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getLibraryListRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getLibraryListRequest(struct soap *soap, _ngwm__getLibraryListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getLibraryListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getLibraryListRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getLibraryListRequest(struct soap *soap, const char *tag, _ngwm__getLibraryListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getLibraryListRequest **)soap_malloc(soap, sizeof(_ngwm__getLibraryListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getLibraryListRequest *)soap_instantiate__ngwm__getLibraryListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getLibraryListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getLibraryListRequest, sizeof(_ngwm__getLibraryListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getLibraryItemResponse(struct soap *soap, _ngwm__getLibraryItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getLibraryItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getLibraryItemResponse(struct soap *soap, _ngwm__getLibraryItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getLibraryItemResponse);
	if (soap_out_PointerTo_ngwm__getLibraryItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getLibraryItemResponse(struct soap *soap, const char *tag, int id, _ngwm__getLibraryItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getLibraryItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getLibraryItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getLibraryItemResponse(struct soap *soap, _ngwm__getLibraryItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getLibraryItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getLibraryItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getLibraryItemResponse(struct soap *soap, const char *tag, _ngwm__getLibraryItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getLibraryItemResponse **)soap_malloc(soap, sizeof(_ngwm__getLibraryItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getLibraryItemResponse *)soap_instantiate__ngwm__getLibraryItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getLibraryItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getLibraryItemResponse, sizeof(_ngwm__getLibraryItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getLibraryItemRequest(struct soap *soap, _ngwm__getLibraryItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getLibraryItemRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getLibraryItemRequest(struct soap *soap, _ngwm__getLibraryItemRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getLibraryItemRequest);
	if (soap_out_PointerTo_ngwm__getLibraryItemRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getLibraryItemRequest(struct soap *soap, const char *tag, int id, _ngwm__getLibraryItemRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getLibraryItemRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getLibraryItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getLibraryItemRequest(struct soap *soap, _ngwm__getLibraryItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getLibraryItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getLibraryItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getLibraryItemRequest(struct soap *soap, const char *tag, _ngwm__getLibraryItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getLibraryItemRequest **)soap_malloc(soap, sizeof(_ngwm__getLibraryItemRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getLibraryItemRequest *)soap_instantiate__ngwm__getLibraryItemRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getLibraryItemRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getLibraryItemRequest, sizeof(_ngwm__getLibraryItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getJunkMailSettingsResponse(struct soap *soap, _ngwm__getJunkMailSettingsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getJunkMailSettingsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getJunkMailSettingsResponse(struct soap *soap, _ngwm__getJunkMailSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getJunkMailSettingsResponse);
	if (soap_out_PointerTo_ngwm__getJunkMailSettingsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getJunkMailSettingsResponse(struct soap *soap, const char *tag, int id, _ngwm__getJunkMailSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getJunkMailSettingsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getJunkMailSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getJunkMailSettingsResponse(struct soap *soap, _ngwm__getJunkMailSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getJunkMailSettingsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getJunkMailSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getJunkMailSettingsResponse(struct soap *soap, const char *tag, _ngwm__getJunkMailSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getJunkMailSettingsResponse **)soap_malloc(soap, sizeof(_ngwm__getJunkMailSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getJunkMailSettingsResponse *)soap_instantiate__ngwm__getJunkMailSettingsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getJunkMailSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getJunkMailSettingsResponse, sizeof(_ngwm__getJunkMailSettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getJunkMailSettingsRequest(struct soap *soap, _ngwm__getJunkMailSettingsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getJunkMailSettingsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getJunkMailSettingsRequest(struct soap *soap, _ngwm__getJunkMailSettingsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getJunkMailSettingsRequest);
	if (soap_out_PointerTo_ngwm__getJunkMailSettingsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getJunkMailSettingsRequest(struct soap *soap, const char *tag, int id, _ngwm__getJunkMailSettingsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getJunkMailSettingsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getJunkMailSettingsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getJunkMailSettingsRequest(struct soap *soap, _ngwm__getJunkMailSettingsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getJunkMailSettingsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getJunkMailSettingsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getJunkMailSettingsRequest(struct soap *soap, const char *tag, _ngwm__getJunkMailSettingsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getJunkMailSettingsRequest **)soap_malloc(soap, sizeof(_ngwm__getJunkMailSettingsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getJunkMailSettingsRequest *)soap_instantiate__ngwm__getJunkMailSettingsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getJunkMailSettingsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getJunkMailSettingsRequest, sizeof(_ngwm__getJunkMailSettingsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getJunkEntriesResponse(struct soap *soap, _ngwm__getJunkEntriesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getJunkEntriesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getJunkEntriesResponse(struct soap *soap, _ngwm__getJunkEntriesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getJunkEntriesResponse);
	if (soap_out_PointerTo_ngwm__getJunkEntriesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getJunkEntriesResponse(struct soap *soap, const char *tag, int id, _ngwm__getJunkEntriesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getJunkEntriesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getJunkEntriesResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getJunkEntriesResponse(struct soap *soap, _ngwm__getJunkEntriesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getJunkEntriesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getJunkEntriesResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getJunkEntriesResponse(struct soap *soap, const char *tag, _ngwm__getJunkEntriesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getJunkEntriesResponse **)soap_malloc(soap, sizeof(_ngwm__getJunkEntriesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getJunkEntriesResponse *)soap_instantiate__ngwm__getJunkEntriesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getJunkEntriesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getJunkEntriesResponse, sizeof(_ngwm__getJunkEntriesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getJunkEntriesRequest(struct soap *soap, _ngwm__getJunkEntriesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getJunkEntriesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getJunkEntriesRequest(struct soap *soap, _ngwm__getJunkEntriesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getJunkEntriesRequest);
	if (soap_out_PointerTo_ngwm__getJunkEntriesRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getJunkEntriesRequest(struct soap *soap, const char *tag, int id, _ngwm__getJunkEntriesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getJunkEntriesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getJunkEntriesRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getJunkEntriesRequest(struct soap *soap, _ngwm__getJunkEntriesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getJunkEntriesRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getJunkEntriesRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getJunkEntriesRequest(struct soap *soap, const char *tag, _ngwm__getJunkEntriesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getJunkEntriesRequest **)soap_malloc(soap, sizeof(_ngwm__getJunkEntriesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getJunkEntriesRequest *)soap_instantiate__ngwm__getJunkEntriesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getJunkEntriesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getJunkEntriesRequest, sizeof(_ngwm__getJunkEntriesRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getItemsResponse(struct soap *soap, _ngwm__getItemsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getItemsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getItemsResponse(struct soap *soap, _ngwm__getItemsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getItemsResponse);
	if (soap_out_PointerTo_ngwm__getItemsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getItemsResponse(struct soap *soap, const char *tag, int id, _ngwm__getItemsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getItemsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getItemsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getItemsResponse(struct soap *soap, _ngwm__getItemsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getItemsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getItemsResponse(struct soap *soap, const char *tag, _ngwm__getItemsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getItemsResponse **)soap_malloc(soap, sizeof(_ngwm__getItemsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getItemsResponse *)soap_instantiate__ngwm__getItemsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getItemsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getItemsResponse, sizeof(_ngwm__getItemsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getItemsRequest(struct soap *soap, _ngwm__getItemsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getItemsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getItemsRequest(struct soap *soap, _ngwm__getItemsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getItemsRequest);
	if (soap_out_PointerTo_ngwm__getItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getItemsRequest(struct soap *soap, const char *tag, int id, _ngwm__getItemsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getItemsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getItemsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getItemsRequest(struct soap *soap, _ngwm__getItemsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getItemsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getItemsRequest(struct soap *soap, const char *tag, _ngwm__getItemsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getItemsRequest **)soap_malloc(soap, sizeof(_ngwm__getItemsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getItemsRequest *)soap_instantiate__ngwm__getItemsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getItemsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getItemsRequest, sizeof(_ngwm__getItemsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getItemResponse(struct soap *soap, _ngwm__getItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getItemResponse(struct soap *soap, _ngwm__getItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getItemResponse);
	if (soap_out_PointerTo_ngwm__getItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getItemResponse(struct soap *soap, const char *tag, int id, _ngwm__getItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getItemResponse(struct soap *soap, _ngwm__getItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getItemResponse(struct soap *soap, const char *tag, _ngwm__getItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getItemResponse **)soap_malloc(soap, sizeof(_ngwm__getItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getItemResponse *)soap_instantiate__ngwm__getItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getItemResponse, sizeof(_ngwm__getItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getItemRequest(struct soap *soap, _ngwm__getItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getItemRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getItemRequest(struct soap *soap, _ngwm__getItemRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getItemRequest);
	if (soap_out_PointerTo_ngwm__getItemRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getItemRequest(struct soap *soap, const char *tag, int id, _ngwm__getItemRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getItemRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getItemRequest(struct soap *soap, _ngwm__getItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getItemRequest(struct soap *soap, const char *tag, _ngwm__getItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getItemRequest **)soap_malloc(soap, sizeof(_ngwm__getItemRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getItemRequest *)soap_instantiate__ngwm__getItemRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getItemRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getItemRequest, sizeof(_ngwm__getItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getFreeBusyResponse(struct soap *soap, _ngwm__getFreeBusyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getFreeBusyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getFreeBusyResponse(struct soap *soap, _ngwm__getFreeBusyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getFreeBusyResponse);
	if (soap_out_PointerTo_ngwm__getFreeBusyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getFreeBusyResponse(struct soap *soap, const char *tag, int id, _ngwm__getFreeBusyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getFreeBusyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getFreeBusyResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getFreeBusyResponse(struct soap *soap, _ngwm__getFreeBusyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getFreeBusyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getFreeBusyResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getFreeBusyResponse(struct soap *soap, const char *tag, _ngwm__getFreeBusyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getFreeBusyResponse **)soap_malloc(soap, sizeof(_ngwm__getFreeBusyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getFreeBusyResponse *)soap_instantiate__ngwm__getFreeBusyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getFreeBusyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFreeBusyResponse, sizeof(_ngwm__getFreeBusyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getFreeBusyRequest(struct soap *soap, _ngwm__getFreeBusyRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getFreeBusyRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getFreeBusyRequest(struct soap *soap, _ngwm__getFreeBusyRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getFreeBusyRequest);
	if (soap_out_PointerTo_ngwm__getFreeBusyRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getFreeBusyRequest(struct soap *soap, const char *tag, int id, _ngwm__getFreeBusyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getFreeBusyRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getFreeBusyRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getFreeBusyRequest(struct soap *soap, _ngwm__getFreeBusyRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getFreeBusyRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getFreeBusyRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getFreeBusyRequest(struct soap *soap, const char *tag, _ngwm__getFreeBusyRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getFreeBusyRequest **)soap_malloc(soap, sizeof(_ngwm__getFreeBusyRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getFreeBusyRequest *)soap_instantiate__ngwm__getFreeBusyRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getFreeBusyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFreeBusyRequest, sizeof(_ngwm__getFreeBusyRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getFolderListResponse(struct soap *soap, _ngwm__getFolderListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getFolderListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getFolderListResponse(struct soap *soap, _ngwm__getFolderListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getFolderListResponse);
	if (soap_out_PointerTo_ngwm__getFolderListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getFolderListResponse(struct soap *soap, const char *tag, int id, _ngwm__getFolderListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getFolderListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getFolderListResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getFolderListResponse(struct soap *soap, _ngwm__getFolderListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getFolderListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getFolderListResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getFolderListResponse(struct soap *soap, const char *tag, _ngwm__getFolderListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getFolderListResponse **)soap_malloc(soap, sizeof(_ngwm__getFolderListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getFolderListResponse *)soap_instantiate__ngwm__getFolderListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getFolderListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFolderListResponse, sizeof(_ngwm__getFolderListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getFolderListRequest(struct soap *soap, _ngwm__getFolderListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getFolderListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getFolderListRequest(struct soap *soap, _ngwm__getFolderListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getFolderListRequest);
	if (soap_out_PointerTo_ngwm__getFolderListRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getFolderListRequest(struct soap *soap, const char *tag, int id, _ngwm__getFolderListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getFolderListRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getFolderListRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getFolderListRequest(struct soap *soap, _ngwm__getFolderListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getFolderListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getFolderListRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getFolderListRequest(struct soap *soap, const char *tag, _ngwm__getFolderListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getFolderListRequest **)soap_malloc(soap, sizeof(_ngwm__getFolderListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getFolderListRequest *)soap_instantiate__ngwm__getFolderListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getFolderListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFolderListRequest, sizeof(_ngwm__getFolderListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getFolderResponse(struct soap *soap, _ngwm__getFolderResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getFolderResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getFolderResponse(struct soap *soap, _ngwm__getFolderResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getFolderResponse);
	if (soap_out_PointerTo_ngwm__getFolderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getFolderResponse(struct soap *soap, const char *tag, int id, _ngwm__getFolderResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getFolderResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getFolderResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getFolderResponse(struct soap *soap, _ngwm__getFolderResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getFolderResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getFolderResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getFolderResponse(struct soap *soap, const char *tag, _ngwm__getFolderResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getFolderResponse **)soap_malloc(soap, sizeof(_ngwm__getFolderResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getFolderResponse *)soap_instantiate__ngwm__getFolderResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getFolderResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFolderResponse, sizeof(_ngwm__getFolderResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getFolderRequest(struct soap *soap, _ngwm__getFolderRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getFolderRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getFolderRequest(struct soap *soap, _ngwm__getFolderRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getFolderRequest);
	if (soap_out_PointerTo_ngwm__getFolderRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getFolderRequest(struct soap *soap, const char *tag, int id, _ngwm__getFolderRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getFolderRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getFolderRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getFolderRequest(struct soap *soap, _ngwm__getFolderRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getFolderRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getFolderRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getFolderRequest(struct soap *soap, const char *tag, _ngwm__getFolderRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getFolderRequest **)soap_malloc(soap, sizeof(_ngwm__getFolderRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getFolderRequest *)soap_instantiate__ngwm__getFolderRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getFolderRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getFolderRequest, sizeof(_ngwm__getFolderRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getDocumentTypeListResponse(struct soap *soap, _ngwm__getDocumentTypeListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getDocumentTypeListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getDocumentTypeListResponse(struct soap *soap, _ngwm__getDocumentTypeListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getDocumentTypeListResponse);
	if (soap_out_PointerTo_ngwm__getDocumentTypeListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getDocumentTypeListResponse(struct soap *soap, const char *tag, int id, _ngwm__getDocumentTypeListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getDocumentTypeListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getDocumentTypeListResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getDocumentTypeListResponse(struct soap *soap, _ngwm__getDocumentTypeListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getDocumentTypeListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getDocumentTypeListResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getDocumentTypeListResponse(struct soap *soap, const char *tag, _ngwm__getDocumentTypeListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getDocumentTypeListResponse **)soap_malloc(soap, sizeof(_ngwm__getDocumentTypeListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getDocumentTypeListResponse *)soap_instantiate__ngwm__getDocumentTypeListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getDocumentTypeListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDocumentTypeListResponse, sizeof(_ngwm__getDocumentTypeListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getDocumentTypeListRequest(struct soap *soap, _ngwm__getDocumentTypeListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getDocumentTypeListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getDocumentTypeListRequest(struct soap *soap, _ngwm__getDocumentTypeListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getDocumentTypeListRequest);
	if (soap_out_PointerTo_ngwm__getDocumentTypeListRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getDocumentTypeListRequest(struct soap *soap, const char *tag, int id, _ngwm__getDocumentTypeListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getDocumentTypeListRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getDocumentTypeListRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getDocumentTypeListRequest(struct soap *soap, _ngwm__getDocumentTypeListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getDocumentTypeListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getDocumentTypeListRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getDocumentTypeListRequest(struct soap *soap, const char *tag, _ngwm__getDocumentTypeListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getDocumentTypeListRequest **)soap_malloc(soap, sizeof(_ngwm__getDocumentTypeListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getDocumentTypeListRequest *)soap_instantiate__ngwm__getDocumentTypeListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getDocumentTypeListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDocumentTypeListRequest, sizeof(_ngwm__getDocumentTypeListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getDeltaInfoResponse(struct soap *soap, _ngwm__getDeltaInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getDeltaInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getDeltaInfoResponse(struct soap *soap, _ngwm__getDeltaInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getDeltaInfoResponse);
	if (soap_out_PointerTo_ngwm__getDeltaInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getDeltaInfoResponse(struct soap *soap, const char *tag, int id, _ngwm__getDeltaInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getDeltaInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getDeltaInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getDeltaInfoResponse(struct soap *soap, _ngwm__getDeltaInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getDeltaInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getDeltaInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getDeltaInfoResponse(struct soap *soap, const char *tag, _ngwm__getDeltaInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getDeltaInfoResponse **)soap_malloc(soap, sizeof(_ngwm__getDeltaInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getDeltaInfoResponse *)soap_instantiate__ngwm__getDeltaInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getDeltaInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDeltaInfoResponse, sizeof(_ngwm__getDeltaInfoResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getDeltaInfoRequest(struct soap *soap, _ngwm__getDeltaInfoRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getDeltaInfoRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getDeltaInfoRequest(struct soap *soap, _ngwm__getDeltaInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getDeltaInfoRequest);
	if (soap_out_PointerTo_ngwm__getDeltaInfoRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getDeltaInfoRequest(struct soap *soap, const char *tag, int id, _ngwm__getDeltaInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getDeltaInfoRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getDeltaInfoRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getDeltaInfoRequest(struct soap *soap, _ngwm__getDeltaInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getDeltaInfoRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getDeltaInfoRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getDeltaInfoRequest(struct soap *soap, const char *tag, _ngwm__getDeltaInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getDeltaInfoRequest **)soap_malloc(soap, sizeof(_ngwm__getDeltaInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getDeltaInfoRequest *)soap_instantiate__ngwm__getDeltaInfoRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getDeltaInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDeltaInfoRequest, sizeof(_ngwm__getDeltaInfoRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getDeltasResponse(struct soap *soap, _ngwm__getDeltasResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getDeltasResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getDeltasResponse(struct soap *soap, _ngwm__getDeltasResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getDeltasResponse);
	if (soap_out_PointerTo_ngwm__getDeltasResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getDeltasResponse(struct soap *soap, const char *tag, int id, _ngwm__getDeltasResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getDeltasResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getDeltasResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getDeltasResponse(struct soap *soap, _ngwm__getDeltasResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getDeltasResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getDeltasResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getDeltasResponse(struct soap *soap, const char *tag, _ngwm__getDeltasResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getDeltasResponse **)soap_malloc(soap, sizeof(_ngwm__getDeltasResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getDeltasResponse *)soap_instantiate__ngwm__getDeltasResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getDeltasResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDeltasResponse, sizeof(_ngwm__getDeltasResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getDeltasRequest(struct soap *soap, _ngwm__getDeltasRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getDeltasRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getDeltasRequest(struct soap *soap, _ngwm__getDeltasRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getDeltasRequest);
	if (soap_out_PointerTo_ngwm__getDeltasRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getDeltasRequest(struct soap *soap, const char *tag, int id, _ngwm__getDeltasRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getDeltasRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getDeltasRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getDeltasRequest(struct soap *soap, _ngwm__getDeltasRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getDeltasRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getDeltasRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getDeltasRequest(struct soap *soap, const char *tag, _ngwm__getDeltasRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getDeltasRequest **)soap_malloc(soap, sizeof(_ngwm__getDeltasRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getDeltasRequest *)soap_instantiate__ngwm__getDeltasRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getDeltasRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getDeltasRequest, sizeof(_ngwm__getDeltasRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getCustomListResponse(struct soap *soap, _ngwm__getCustomListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getCustomListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getCustomListResponse(struct soap *soap, _ngwm__getCustomListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getCustomListResponse);
	if (soap_out_PointerTo_ngwm__getCustomListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getCustomListResponse(struct soap *soap, const char *tag, int id, _ngwm__getCustomListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getCustomListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getCustomListResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getCustomListResponse(struct soap *soap, _ngwm__getCustomListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getCustomListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getCustomListResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getCustomListResponse(struct soap *soap, const char *tag, _ngwm__getCustomListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getCustomListResponse **)soap_malloc(soap, sizeof(_ngwm__getCustomListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getCustomListResponse *)soap_instantiate__ngwm__getCustomListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getCustomListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getCustomListResponse, sizeof(_ngwm__getCustomListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getCustomListRequest(struct soap *soap, _ngwm__getCustomListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getCustomListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getCustomListRequest(struct soap *soap, _ngwm__getCustomListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getCustomListRequest);
	if (soap_out_PointerTo_ngwm__getCustomListRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getCustomListRequest(struct soap *soap, const char *tag, int id, _ngwm__getCustomListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getCustomListRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getCustomListRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getCustomListRequest(struct soap *soap, _ngwm__getCustomListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getCustomListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getCustomListRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getCustomListRequest(struct soap *soap, const char *tag, _ngwm__getCustomListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getCustomListRequest **)soap_malloc(soap, sizeof(_ngwm__getCustomListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getCustomListRequest *)soap_instantiate__ngwm__getCustomListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getCustomListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getCustomListRequest, sizeof(_ngwm__getCustomListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getCategoryListResponse(struct soap *soap, _ngwm__getCategoryListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getCategoryListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getCategoryListResponse(struct soap *soap, _ngwm__getCategoryListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getCategoryListResponse);
	if (soap_out_PointerTo_ngwm__getCategoryListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getCategoryListResponse(struct soap *soap, const char *tag, int id, _ngwm__getCategoryListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getCategoryListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getCategoryListResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getCategoryListResponse(struct soap *soap, _ngwm__getCategoryListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getCategoryListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getCategoryListResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getCategoryListResponse(struct soap *soap, const char *tag, _ngwm__getCategoryListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getCategoryListResponse **)soap_malloc(soap, sizeof(_ngwm__getCategoryListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getCategoryListResponse *)soap_instantiate__ngwm__getCategoryListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getCategoryListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getCategoryListResponse, sizeof(_ngwm__getCategoryListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getCategoryListRequest(struct soap *soap, _ngwm__getCategoryListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getCategoryListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getCategoryListRequest(struct soap *soap, _ngwm__getCategoryListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getCategoryListRequest);
	if (soap_out_PointerTo_ngwm__getCategoryListRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getCategoryListRequest(struct soap *soap, const char *tag, int id, _ngwm__getCategoryListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getCategoryListRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getCategoryListRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getCategoryListRequest(struct soap *soap, _ngwm__getCategoryListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getCategoryListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getCategoryListRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getCategoryListRequest(struct soap *soap, const char *tag, _ngwm__getCategoryListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getCategoryListRequest **)soap_malloc(soap, sizeof(_ngwm__getCategoryListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getCategoryListRequest *)soap_instantiate__ngwm__getCategoryListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getCategoryListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getCategoryListRequest, sizeof(_ngwm__getCategoryListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getAttachmentResponse(struct soap *soap, _ngwm__getAttachmentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getAttachmentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getAttachmentResponse(struct soap *soap, _ngwm__getAttachmentResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getAttachmentResponse);
	if (soap_out_PointerTo_ngwm__getAttachmentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getAttachmentResponse(struct soap *soap, const char *tag, int id, _ngwm__getAttachmentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getAttachmentResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getAttachmentResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getAttachmentResponse(struct soap *soap, _ngwm__getAttachmentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getAttachmentResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getAttachmentResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getAttachmentResponse(struct soap *soap, const char *tag, _ngwm__getAttachmentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getAttachmentResponse **)soap_malloc(soap, sizeof(_ngwm__getAttachmentResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getAttachmentResponse *)soap_instantiate__ngwm__getAttachmentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getAttachmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getAttachmentResponse, sizeof(_ngwm__getAttachmentResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getAttachmentRequest(struct soap *soap, _ngwm__getAttachmentRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getAttachmentRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getAttachmentRequest(struct soap *soap, _ngwm__getAttachmentRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getAttachmentRequest);
	if (soap_out_PointerTo_ngwm__getAttachmentRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getAttachmentRequest(struct soap *soap, const char *tag, int id, _ngwm__getAttachmentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getAttachmentRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getAttachmentRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getAttachmentRequest(struct soap *soap, _ngwm__getAttachmentRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getAttachmentRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getAttachmentRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getAttachmentRequest(struct soap *soap, const char *tag, _ngwm__getAttachmentRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getAttachmentRequest **)soap_malloc(soap, sizeof(_ngwm__getAttachmentRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getAttachmentRequest *)soap_instantiate__ngwm__getAttachmentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getAttachmentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getAttachmentRequest, sizeof(_ngwm__getAttachmentRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getAddressBookListResponse(struct soap *soap, _ngwm__getAddressBookListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getAddressBookListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getAddressBookListResponse(struct soap *soap, _ngwm__getAddressBookListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getAddressBookListResponse);
	if (soap_out_PointerTo_ngwm__getAddressBookListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getAddressBookListResponse(struct soap *soap, const char *tag, int id, _ngwm__getAddressBookListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getAddressBookListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getAddressBookListResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getAddressBookListResponse(struct soap *soap, _ngwm__getAddressBookListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getAddressBookListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getAddressBookListResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getAddressBookListResponse(struct soap *soap, const char *tag, _ngwm__getAddressBookListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getAddressBookListResponse **)soap_malloc(soap, sizeof(_ngwm__getAddressBookListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getAddressBookListResponse *)soap_instantiate__ngwm__getAddressBookListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getAddressBookListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getAddressBookListResponse, sizeof(_ngwm__getAddressBookListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__getAddressBookListRequest(struct soap *soap, _ngwm__getAddressBookListRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__getAddressBookListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__getAddressBookListRequest(struct soap *soap, _ngwm__getAddressBookListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__getAddressBookListRequest);
	if (soap_out_PointerTo_ngwm__getAddressBookListRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__getAddressBookListRequest(struct soap *soap, const char *tag, int id, _ngwm__getAddressBookListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__getAddressBookListRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__getAddressBookListRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__getAddressBookListRequest(struct soap *soap, _ngwm__getAddressBookListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__getAddressBookListRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__getAddressBookListRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__getAddressBookListRequest(struct soap *soap, const char *tag, _ngwm__getAddressBookListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__getAddressBookListRequest **)soap_malloc(soap, sizeof(_ngwm__getAddressBookListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__getAddressBookListRequest *)soap_instantiate__ngwm__getAddressBookListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__getAddressBookListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__getAddressBookListRequest, sizeof(_ngwm__getAddressBookListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__forwardResponse(struct soap *soap, _ngwm__forwardResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__forwardResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__forwardResponse(struct soap *soap, _ngwm__forwardResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__forwardResponse);
	if (soap_out_PointerTo_ngwm__forwardResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__forwardResponse(struct soap *soap, const char *tag, int id, _ngwm__forwardResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__forwardResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__forwardResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__forwardResponse(struct soap *soap, _ngwm__forwardResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__forwardResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__forwardResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__forwardResponse(struct soap *soap, const char *tag, _ngwm__forwardResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__forwardResponse **)soap_malloc(soap, sizeof(_ngwm__forwardResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__forwardResponse *)soap_instantiate__ngwm__forwardResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__forwardResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__forwardResponse, sizeof(_ngwm__forwardResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__forwardRequest(struct soap *soap, _ngwm__forwardRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__forwardRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__forwardRequest(struct soap *soap, _ngwm__forwardRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__forwardRequest);
	if (soap_out_PointerTo_ngwm__forwardRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__forwardRequest(struct soap *soap, const char *tag, int id, _ngwm__forwardRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__forwardRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__forwardRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__forwardRequest(struct soap *soap, _ngwm__forwardRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__forwardRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__forwardRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__forwardRequest(struct soap *soap, const char *tag, _ngwm__forwardRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__forwardRequest **)soap_malloc(soap, sizeof(_ngwm__forwardRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__forwardRequest *)soap_instantiate__ngwm__forwardRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__forwardRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__forwardRequest, sizeof(_ngwm__forwardRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__executeRuleResponse(struct soap *soap, _ngwm__executeRuleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__executeRuleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__executeRuleResponse(struct soap *soap, _ngwm__executeRuleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__executeRuleResponse);
	if (soap_out_PointerTo_ngwm__executeRuleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__executeRuleResponse(struct soap *soap, const char *tag, int id, _ngwm__executeRuleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__executeRuleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__executeRuleResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__executeRuleResponse(struct soap *soap, _ngwm__executeRuleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__executeRuleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__executeRuleResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__executeRuleResponse(struct soap *soap, const char *tag, _ngwm__executeRuleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__executeRuleResponse **)soap_malloc(soap, sizeof(_ngwm__executeRuleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__executeRuleResponse *)soap_instantiate__ngwm__executeRuleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__executeRuleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__executeRuleResponse, sizeof(_ngwm__executeRuleResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__executeRuleRequest(struct soap *soap, _ngwm__executeRuleRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__executeRuleRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__executeRuleRequest(struct soap *soap, _ngwm__executeRuleRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__executeRuleRequest);
	if (soap_out_PointerTo_ngwm__executeRuleRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__executeRuleRequest(struct soap *soap, const char *tag, int id, _ngwm__executeRuleRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__executeRuleRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__executeRuleRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__executeRuleRequest(struct soap *soap, _ngwm__executeRuleRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__executeRuleRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__executeRuleRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__executeRuleRequest(struct soap *soap, const char *tag, _ngwm__executeRuleRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__executeRuleRequest **)soap_malloc(soap, sizeof(_ngwm__executeRuleRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__executeRuleRequest *)soap_instantiate__ngwm__executeRuleRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__executeRuleRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__executeRuleRequest, sizeof(_ngwm__executeRuleRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__destroyCursorResponse(struct soap *soap, _ngwm__destroyCursorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__destroyCursorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__destroyCursorResponse(struct soap *soap, _ngwm__destroyCursorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__destroyCursorResponse);
	if (soap_out_PointerTo_ngwm__destroyCursorResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__destroyCursorResponse(struct soap *soap, const char *tag, int id, _ngwm__destroyCursorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__destroyCursorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__destroyCursorResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__destroyCursorResponse(struct soap *soap, _ngwm__destroyCursorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__destroyCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__destroyCursorResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__destroyCursorResponse(struct soap *soap, const char *tag, _ngwm__destroyCursorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__destroyCursorResponse **)soap_malloc(soap, sizeof(_ngwm__destroyCursorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__destroyCursorResponse *)soap_instantiate__ngwm__destroyCursorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__destroyCursorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__destroyCursorResponse, sizeof(_ngwm__destroyCursorResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__destroyCursorRequest(struct soap *soap, _ngwm__destroyCursorRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__destroyCursorRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__destroyCursorRequest(struct soap *soap, _ngwm__destroyCursorRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__destroyCursorRequest);
	if (soap_out_PointerTo_ngwm__destroyCursorRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__destroyCursorRequest(struct soap *soap, const char *tag, int id, _ngwm__destroyCursorRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__destroyCursorRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__destroyCursorRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__destroyCursorRequest(struct soap *soap, _ngwm__destroyCursorRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__destroyCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__destroyCursorRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__destroyCursorRequest(struct soap *soap, const char *tag, _ngwm__destroyCursorRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__destroyCursorRequest **)soap_malloc(soap, sizeof(_ngwm__destroyCursorRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__destroyCursorRequest *)soap_instantiate__ngwm__destroyCursorRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__destroyCursorRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__destroyCursorRequest, sizeof(_ngwm__destroyCursorRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__delegateResponse(struct soap *soap, _ngwm__delegateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__delegateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__delegateResponse(struct soap *soap, _ngwm__delegateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__delegateResponse);
	if (soap_out_PointerTo_ngwm__delegateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__delegateResponse(struct soap *soap, const char *tag, int id, _ngwm__delegateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__delegateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__delegateResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__delegateResponse(struct soap *soap, _ngwm__delegateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__delegateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__delegateResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__delegateResponse(struct soap *soap, const char *tag, _ngwm__delegateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__delegateResponse **)soap_malloc(soap, sizeof(_ngwm__delegateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__delegateResponse *)soap_instantiate__ngwm__delegateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__delegateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__delegateResponse, sizeof(_ngwm__delegateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__delegateRequest(struct soap *soap, _ngwm__delegateRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__delegateRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__delegateRequest(struct soap *soap, _ngwm__delegateRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__delegateRequest);
	if (soap_out_PointerTo_ngwm__delegateRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__delegateRequest(struct soap *soap, const char *tag, int id, _ngwm__delegateRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__delegateRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__delegateRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__delegateRequest(struct soap *soap, _ngwm__delegateRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__delegateRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__delegateRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__delegateRequest(struct soap *soap, const char *tag, _ngwm__delegateRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__delegateRequest **)soap_malloc(soap, sizeof(_ngwm__delegateRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__delegateRequest *)soap_instantiate__ngwm__delegateRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__delegateRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__delegateRequest, sizeof(_ngwm__delegateRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__declineResponse(struct soap *soap, _ngwm__declineResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__declineResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__declineResponse(struct soap *soap, _ngwm__declineResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__declineResponse);
	if (soap_out_PointerTo_ngwm__declineResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__declineResponse(struct soap *soap, const char *tag, int id, _ngwm__declineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__declineResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__declineResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__declineResponse(struct soap *soap, _ngwm__declineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__declineResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__declineResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__declineResponse(struct soap *soap, const char *tag, _ngwm__declineResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__declineResponse **)soap_malloc(soap, sizeof(_ngwm__declineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__declineResponse *)soap_instantiate__ngwm__declineResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__declineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__declineResponse, sizeof(_ngwm__declineResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__declineRequest(struct soap *soap, _ngwm__declineRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__declineRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__declineRequest(struct soap *soap, _ngwm__declineRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__declineRequest);
	if (soap_out_PointerTo_ngwm__declineRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__declineRequest(struct soap *soap, const char *tag, int id, _ngwm__declineRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__declineRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__declineRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__declineRequest(struct soap *soap, _ngwm__declineRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__declineRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__declineRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__declineRequest(struct soap *soap, const char *tag, _ngwm__declineRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__declineRequest **)soap_malloc(soap, sizeof(_ngwm__declineRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__declineRequest *)soap_instantiate__ngwm__declineRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__declineRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__declineRequest, sizeof(_ngwm__declineRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createSignatureResponse(struct soap *soap, _ngwm__createSignatureResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createSignatureResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createSignatureResponse(struct soap *soap, _ngwm__createSignatureResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createSignatureResponse);
	if (soap_out_PointerTo_ngwm__createSignatureResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createSignatureResponse(struct soap *soap, const char *tag, int id, _ngwm__createSignatureResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createSignatureResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createSignatureResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createSignatureResponse(struct soap *soap, _ngwm__createSignatureResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createSignatureResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createSignatureResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createSignatureResponse(struct soap *soap, const char *tag, _ngwm__createSignatureResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createSignatureResponse **)soap_malloc(soap, sizeof(_ngwm__createSignatureResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createSignatureResponse *)soap_instantiate__ngwm__createSignatureResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createSignatureResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createSignatureResponse, sizeof(_ngwm__createSignatureResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createSignatureRequest(struct soap *soap, _ngwm__createSignatureRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createSignatureRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createSignatureRequest(struct soap *soap, _ngwm__createSignatureRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createSignatureRequest);
	if (soap_out_PointerTo_ngwm__createSignatureRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createSignatureRequest(struct soap *soap, const char *tag, int id, _ngwm__createSignatureRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createSignatureRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createSignatureRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createSignatureRequest(struct soap *soap, _ngwm__createSignatureRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createSignatureRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createSignatureRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createSignatureRequest(struct soap *soap, const char *tag, _ngwm__createSignatureRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createSignatureRequest **)soap_malloc(soap, sizeof(_ngwm__createSignatureRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createSignatureRequest *)soap_instantiate__ngwm__createSignatureRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createSignatureRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createSignatureRequest, sizeof(_ngwm__createSignatureRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createProxyAccessResponse(struct soap *soap, _ngwm__createProxyAccessResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createProxyAccessResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createProxyAccessResponse(struct soap *soap, _ngwm__createProxyAccessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createProxyAccessResponse);
	if (soap_out_PointerTo_ngwm__createProxyAccessResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createProxyAccessResponse(struct soap *soap, const char *tag, int id, _ngwm__createProxyAccessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createProxyAccessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createProxyAccessResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createProxyAccessResponse(struct soap *soap, _ngwm__createProxyAccessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createProxyAccessResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createProxyAccessResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createProxyAccessResponse(struct soap *soap, const char *tag, _ngwm__createProxyAccessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createProxyAccessResponse **)soap_malloc(soap, sizeof(_ngwm__createProxyAccessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createProxyAccessResponse *)soap_instantiate__ngwm__createProxyAccessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createProxyAccessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createProxyAccessResponse, sizeof(_ngwm__createProxyAccessResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createProxyAccessRequest(struct soap *soap, _ngwm__createProxyAccessRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createProxyAccessRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createProxyAccessRequest(struct soap *soap, _ngwm__createProxyAccessRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createProxyAccessRequest);
	if (soap_out_PointerTo_ngwm__createProxyAccessRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createProxyAccessRequest(struct soap *soap, const char *tag, int id, _ngwm__createProxyAccessRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createProxyAccessRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createProxyAccessRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createProxyAccessRequest(struct soap *soap, _ngwm__createProxyAccessRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createProxyAccessRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createProxyAccessRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createProxyAccessRequest(struct soap *soap, const char *tag, _ngwm__createProxyAccessRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createProxyAccessRequest **)soap_malloc(soap, sizeof(_ngwm__createProxyAccessRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createProxyAccessRequest *)soap_instantiate__ngwm__createProxyAccessRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createProxyAccessRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createProxyAccessRequest, sizeof(_ngwm__createProxyAccessRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createJunkEntryResponse(struct soap *soap, _ngwm__createJunkEntryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createJunkEntryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createJunkEntryResponse(struct soap *soap, _ngwm__createJunkEntryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createJunkEntryResponse);
	if (soap_out_PointerTo_ngwm__createJunkEntryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createJunkEntryResponse(struct soap *soap, const char *tag, int id, _ngwm__createJunkEntryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createJunkEntryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createJunkEntryResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createJunkEntryResponse(struct soap *soap, _ngwm__createJunkEntryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createJunkEntryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createJunkEntryResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createJunkEntryResponse(struct soap *soap, const char *tag, _ngwm__createJunkEntryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createJunkEntryResponse **)soap_malloc(soap, sizeof(_ngwm__createJunkEntryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createJunkEntryResponse *)soap_instantiate__ngwm__createJunkEntryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createJunkEntryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createJunkEntryResponse, sizeof(_ngwm__createJunkEntryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createJunkEntryRequest(struct soap *soap, _ngwm__createJunkEntryRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createJunkEntryRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createJunkEntryRequest(struct soap *soap, _ngwm__createJunkEntryRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createJunkEntryRequest);
	if (soap_out_PointerTo_ngwm__createJunkEntryRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createJunkEntryRequest(struct soap *soap, const char *tag, int id, _ngwm__createJunkEntryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createJunkEntryRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createJunkEntryRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createJunkEntryRequest(struct soap *soap, _ngwm__createJunkEntryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createJunkEntryRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createJunkEntryRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createJunkEntryRequest(struct soap *soap, const char *tag, _ngwm__createJunkEntryRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createJunkEntryRequest **)soap_malloc(soap, sizeof(_ngwm__createJunkEntryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createJunkEntryRequest *)soap_instantiate__ngwm__createJunkEntryRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createJunkEntryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createJunkEntryRequest, sizeof(_ngwm__createJunkEntryRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createItemsResponse(struct soap *soap, _ngwm__createItemsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createItemsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createItemsResponse(struct soap *soap, _ngwm__createItemsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createItemsResponse);
	if (soap_out_PointerTo_ngwm__createItemsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createItemsResponse(struct soap *soap, const char *tag, int id, _ngwm__createItemsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createItemsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createItemsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createItemsResponse(struct soap *soap, _ngwm__createItemsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createItemsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createItemsResponse(struct soap *soap, const char *tag, _ngwm__createItemsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createItemsResponse **)soap_malloc(soap, sizeof(_ngwm__createItemsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createItemsResponse *)soap_instantiate__ngwm__createItemsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createItemsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createItemsResponse, sizeof(_ngwm__createItemsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createItemsRequest(struct soap *soap, _ngwm__createItemsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createItemsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createItemsRequest(struct soap *soap, _ngwm__createItemsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createItemsRequest);
	if (soap_out_PointerTo_ngwm__createItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createItemsRequest(struct soap *soap, const char *tag, int id, _ngwm__createItemsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createItemsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createItemsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createItemsRequest(struct soap *soap, _ngwm__createItemsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createItemsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createItemsRequest(struct soap *soap, const char *tag, _ngwm__createItemsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createItemsRequest **)soap_malloc(soap, sizeof(_ngwm__createItemsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createItemsRequest *)soap_instantiate__ngwm__createItemsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createItemsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createItemsRequest, sizeof(_ngwm__createItemsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createItemResponse(struct soap *soap, _ngwm__createItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createItemResponse(struct soap *soap, _ngwm__createItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createItemResponse);
	if (soap_out_PointerTo_ngwm__createItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createItemResponse(struct soap *soap, const char *tag, int id, _ngwm__createItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createItemResponse(struct soap *soap, _ngwm__createItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createItemResponse(struct soap *soap, const char *tag, _ngwm__createItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createItemResponse **)soap_malloc(soap, sizeof(_ngwm__createItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createItemResponse *)soap_instantiate__ngwm__createItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createItemResponse, sizeof(_ngwm__createItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createItemRequest(struct soap *soap, _ngwm__createItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createItemRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createItemRequest(struct soap *soap, _ngwm__createItemRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createItemRequest);
	if (soap_out_PointerTo_ngwm__createItemRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createItemRequest(struct soap *soap, const char *tag, int id, _ngwm__createItemRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createItemRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createItemRequest(struct soap *soap, _ngwm__createItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createItemRequest(struct soap *soap, const char *tag, _ngwm__createItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createItemRequest **)soap_malloc(soap, sizeof(_ngwm__createItemRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createItemRequest *)soap_instantiate__ngwm__createItemRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createItemRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createItemRequest, sizeof(_ngwm__createItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createCursorResponse(struct soap *soap, _ngwm__createCursorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createCursorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createCursorResponse(struct soap *soap, _ngwm__createCursorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createCursorResponse);
	if (soap_out_PointerTo_ngwm__createCursorResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createCursorResponse(struct soap *soap, const char *tag, int id, _ngwm__createCursorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createCursorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createCursorResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createCursorResponse(struct soap *soap, _ngwm__createCursorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createCursorResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createCursorResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createCursorResponse(struct soap *soap, const char *tag, _ngwm__createCursorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createCursorResponse **)soap_malloc(soap, sizeof(_ngwm__createCursorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createCursorResponse *)soap_instantiate__ngwm__createCursorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createCursorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createCursorResponse, sizeof(_ngwm__createCursorResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__createCursorRequest(struct soap *soap, _ngwm__createCursorRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__createCursorRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__createCursorRequest(struct soap *soap, _ngwm__createCursorRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__createCursorRequest);
	if (soap_out_PointerTo_ngwm__createCursorRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__createCursorRequest(struct soap *soap, const char *tag, int id, _ngwm__createCursorRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__createCursorRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__createCursorRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__createCursorRequest(struct soap *soap, _ngwm__createCursorRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__createCursorRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__createCursorRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__createCursorRequest(struct soap *soap, const char *tag, _ngwm__createCursorRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__createCursorRequest **)soap_malloc(soap, sizeof(_ngwm__createCursorRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__createCursorRequest *)soap_instantiate__ngwm__createCursorRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__createCursorRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__createCursorRequest, sizeof(_ngwm__createCursorRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__completeResponse(struct soap *soap, _ngwm__completeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__completeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__completeResponse(struct soap *soap, _ngwm__completeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__completeResponse);
	if (soap_out_PointerTo_ngwm__completeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__completeResponse(struct soap *soap, const char *tag, int id, _ngwm__completeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__completeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__completeResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__completeResponse(struct soap *soap, _ngwm__completeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__completeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__completeResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__completeResponse(struct soap *soap, const char *tag, _ngwm__completeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__completeResponse **)soap_malloc(soap, sizeof(_ngwm__completeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__completeResponse *)soap_instantiate__ngwm__completeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__completeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__completeResponse, sizeof(_ngwm__completeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__completeRequest(struct soap *soap, _ngwm__completeRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__completeRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__completeRequest(struct soap *soap, _ngwm__completeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__completeRequest);
	if (soap_out_PointerTo_ngwm__completeRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__completeRequest(struct soap *soap, const char *tag, int id, _ngwm__completeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__completeRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__completeRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__completeRequest(struct soap *soap, _ngwm__completeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__completeRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__completeRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__completeRequest(struct soap *soap, const char *tag, _ngwm__completeRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__completeRequest **)soap_malloc(soap, sizeof(_ngwm__completeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__completeRequest *)soap_instantiate__ngwm__completeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__completeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__completeRequest, sizeof(_ngwm__completeRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__closeFreeBusySessionResponse(struct soap *soap, _ngwm__closeFreeBusySessionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__closeFreeBusySessionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__closeFreeBusySessionResponse(struct soap *soap, _ngwm__closeFreeBusySessionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__closeFreeBusySessionResponse);
	if (soap_out_PointerTo_ngwm__closeFreeBusySessionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__closeFreeBusySessionResponse(struct soap *soap, const char *tag, int id, _ngwm__closeFreeBusySessionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__closeFreeBusySessionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__closeFreeBusySessionResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__closeFreeBusySessionResponse(struct soap *soap, _ngwm__closeFreeBusySessionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__closeFreeBusySessionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__closeFreeBusySessionResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__closeFreeBusySessionResponse(struct soap *soap, const char *tag, _ngwm__closeFreeBusySessionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__closeFreeBusySessionResponse **)soap_malloc(soap, sizeof(_ngwm__closeFreeBusySessionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__closeFreeBusySessionResponse *)soap_instantiate__ngwm__closeFreeBusySessionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__closeFreeBusySessionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__closeFreeBusySessionResponse, sizeof(_ngwm__closeFreeBusySessionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__closeFreeBusySessionRequest(struct soap *soap, _ngwm__closeFreeBusySessionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__closeFreeBusySessionRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__closeFreeBusySessionRequest(struct soap *soap, _ngwm__closeFreeBusySessionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__closeFreeBusySessionRequest);
	if (soap_out_PointerTo_ngwm__closeFreeBusySessionRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__closeFreeBusySessionRequest(struct soap *soap, const char *tag, int id, _ngwm__closeFreeBusySessionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__closeFreeBusySessionRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__closeFreeBusySessionRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__closeFreeBusySessionRequest(struct soap *soap, _ngwm__closeFreeBusySessionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__closeFreeBusySessionRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__closeFreeBusySessionRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__closeFreeBusySessionRequest(struct soap *soap, const char *tag, _ngwm__closeFreeBusySessionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__closeFreeBusySessionRequest **)soap_malloc(soap, sizeof(_ngwm__closeFreeBusySessionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__closeFreeBusySessionRequest *)soap_instantiate__ngwm__closeFreeBusySessionRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__closeFreeBusySessionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__closeFreeBusySessionRequest, sizeof(_ngwm__closeFreeBusySessionRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__addMembersResponse(struct soap *soap, _ngwm__addMembersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__addMembersResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__addMembersResponse(struct soap *soap, _ngwm__addMembersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__addMembersResponse);
	if (soap_out_PointerTo_ngwm__addMembersResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__addMembersResponse(struct soap *soap, const char *tag, int id, _ngwm__addMembersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__addMembersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__addMembersResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__addMembersResponse(struct soap *soap, _ngwm__addMembersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__addMembersResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__addMembersResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__addMembersResponse(struct soap *soap, const char *tag, _ngwm__addMembersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__addMembersResponse **)soap_malloc(soap, sizeof(_ngwm__addMembersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__addMembersResponse *)soap_instantiate__ngwm__addMembersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__addMembersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addMembersResponse, sizeof(_ngwm__addMembersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__addMembersRequest(struct soap *soap, _ngwm__addMembersRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__addMembersRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__addMembersRequest(struct soap *soap, _ngwm__addMembersRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__addMembersRequest);
	if (soap_out_PointerTo_ngwm__addMembersRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__addMembersRequest(struct soap *soap, const char *tag, int id, _ngwm__addMembersRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__addMembersRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__addMembersRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__addMembersRequest(struct soap *soap, _ngwm__addMembersRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__addMembersRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__addMembersRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__addMembersRequest(struct soap *soap, const char *tag, _ngwm__addMembersRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__addMembersRequest **)soap_malloc(soap, sizeof(_ngwm__addMembersRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__addMembersRequest *)soap_instantiate__ngwm__addMembersRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__addMembersRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addMembersRequest, sizeof(_ngwm__addMembersRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__addItemsResponse(struct soap *soap, _ngwm__addItemsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__addItemsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__addItemsResponse(struct soap *soap, _ngwm__addItemsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__addItemsResponse);
	if (soap_out_PointerTo_ngwm__addItemsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__addItemsResponse(struct soap *soap, const char *tag, int id, _ngwm__addItemsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__addItemsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__addItemsResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__addItemsResponse(struct soap *soap, _ngwm__addItemsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__addItemsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__addItemsResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__addItemsResponse(struct soap *soap, const char *tag, _ngwm__addItemsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__addItemsResponse **)soap_malloc(soap, sizeof(_ngwm__addItemsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__addItemsResponse *)soap_instantiate__ngwm__addItemsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__addItemsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addItemsResponse, sizeof(_ngwm__addItemsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__addItemsRequest(struct soap *soap, _ngwm__addItemsRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__addItemsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__addItemsRequest(struct soap *soap, _ngwm__addItemsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__addItemsRequest);
	if (soap_out_PointerTo_ngwm__addItemsRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__addItemsRequest(struct soap *soap, const char *tag, int id, _ngwm__addItemsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__addItemsRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__addItemsRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__addItemsRequest(struct soap *soap, _ngwm__addItemsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__addItemsRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__addItemsRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__addItemsRequest(struct soap *soap, const char *tag, _ngwm__addItemsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__addItemsRequest **)soap_malloc(soap, sizeof(_ngwm__addItemsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__addItemsRequest *)soap_instantiate__ngwm__addItemsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__addItemsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addItemsRequest, sizeof(_ngwm__addItemsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__addItemResponse(struct soap *soap, _ngwm__addItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__addItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__addItemResponse(struct soap *soap, _ngwm__addItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__addItemResponse);
	if (soap_out_PointerTo_ngwm__addItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__addItemResponse(struct soap *soap, const char *tag, int id, _ngwm__addItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__addItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__addItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__addItemResponse(struct soap *soap, _ngwm__addItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__addItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__addItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__addItemResponse(struct soap *soap, const char *tag, _ngwm__addItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__addItemResponse **)soap_malloc(soap, sizeof(_ngwm__addItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__addItemResponse *)soap_instantiate__ngwm__addItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__addItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addItemResponse, sizeof(_ngwm__addItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__addItemRequest(struct soap *soap, _ngwm__addItemRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__addItemRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__addItemRequest(struct soap *soap, _ngwm__addItemRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__addItemRequest);
	if (soap_out_PointerTo_ngwm__addItemRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__addItemRequest(struct soap *soap, const char *tag, int id, _ngwm__addItemRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__addItemRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__addItemRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__addItemRequest(struct soap *soap, _ngwm__addItemRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__addItemRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__addItemRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__addItemRequest(struct soap *soap, const char *tag, _ngwm__addItemRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__addItemRequest **)soap_malloc(soap, sizeof(_ngwm__addItemRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__addItemRequest *)soap_instantiate__ngwm__addItemRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__addItemRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__addItemRequest, sizeof(_ngwm__addItemRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__acceptShareResponse(struct soap *soap, _ngwm__acceptShareResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__acceptShareResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__acceptShareResponse(struct soap *soap, _ngwm__acceptShareResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__acceptShareResponse);
	if (soap_out_PointerTo_ngwm__acceptShareResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__acceptShareResponse(struct soap *soap, const char *tag, int id, _ngwm__acceptShareResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__acceptShareResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__acceptShareResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__acceptShareResponse(struct soap *soap, _ngwm__acceptShareResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__acceptShareResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__acceptShareResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__acceptShareResponse(struct soap *soap, const char *tag, _ngwm__acceptShareResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__acceptShareResponse **)soap_malloc(soap, sizeof(_ngwm__acceptShareResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__acceptShareResponse *)soap_instantiate__ngwm__acceptShareResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__acceptShareResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__acceptShareResponse, sizeof(_ngwm__acceptShareResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__acceptShareRequest(struct soap *soap, _ngwm__acceptShareRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__acceptShareRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__acceptShareRequest(struct soap *soap, _ngwm__acceptShareRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__acceptShareRequest);
	if (soap_out_PointerTo_ngwm__acceptShareRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__acceptShareRequest(struct soap *soap, const char *tag, int id, _ngwm__acceptShareRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__acceptShareRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__acceptShareRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__acceptShareRequest(struct soap *soap, _ngwm__acceptShareRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__acceptShareRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__acceptShareRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__acceptShareRequest(struct soap *soap, const char *tag, _ngwm__acceptShareRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__acceptShareRequest **)soap_malloc(soap, sizeof(_ngwm__acceptShareRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__acceptShareRequest *)soap_instantiate__ngwm__acceptShareRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__acceptShareRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__acceptShareRequest, sizeof(_ngwm__acceptShareRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__acceptResponse(struct soap *soap, _ngwm__acceptResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__acceptResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__acceptResponse(struct soap *soap, _ngwm__acceptResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__acceptResponse);
	if (soap_out_PointerTo_ngwm__acceptResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__acceptResponse(struct soap *soap, const char *tag, int id, _ngwm__acceptResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__acceptResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__acceptResponse ** SOAP_FMAC4 soap_get_PointerTo_ngwm__acceptResponse(struct soap *soap, _ngwm__acceptResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__acceptResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__acceptResponse ** SOAP_FMAC4 soap_in_PointerTo_ngwm__acceptResponse(struct soap *soap, const char *tag, _ngwm__acceptResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__acceptResponse **)soap_malloc(soap, sizeof(_ngwm__acceptResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__acceptResponse *)soap_instantiate__ngwm__acceptResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__acceptResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__acceptResponse, sizeof(_ngwm__acceptResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ngwm__acceptRequest(struct soap *soap, _ngwm__acceptRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ngwm__acceptRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ngwm__acceptRequest(struct soap *soap, _ngwm__acceptRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ngwm__acceptRequest);
	if (soap_out_PointerTo_ngwm__acceptRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ngwm__acceptRequest(struct soap *soap, const char *tag, int id, _ngwm__acceptRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ngwm__acceptRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ngwm__acceptRequest ** SOAP_FMAC4 soap_get_PointerTo_ngwm__acceptRequest(struct soap *soap, _ngwm__acceptRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ngwm__acceptRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ngwm__acceptRequest ** SOAP_FMAC4 soap_in_PointerTo_ngwm__acceptRequest(struct soap *soap, const char *tag, _ngwm__acceptRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (_ngwm__acceptRequest **)soap_malloc(soap, sizeof(_ngwm__acceptRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ngwm__acceptRequest *)soap_instantiate__ngwm__acceptRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ngwm__acceptRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ngwm__acceptRequest, sizeof(_ngwm__acceptRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Alarm(struct soap *soap, ngwt__Alarm *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Alarm))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Alarm(struct soap *soap, ngwt__Alarm *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Alarm);
	if (soap_out_PointerTongwt__Alarm(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Alarm(struct soap *soap, const char *tag, int id, ngwt__Alarm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Alarm);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Alarm ** SOAP_FMAC4 soap_get_PointerTongwt__Alarm(struct soap *soap, ngwt__Alarm **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Alarm(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Alarm ** SOAP_FMAC4 soap_in_PointerTongwt__Alarm(struct soap *soap, const char *tag, ngwt__Alarm **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Alarm **)soap_malloc(soap, sizeof(ngwt__Alarm *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Alarm *)soap_instantiate_ngwt__Alarm(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Alarm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Alarm, sizeof(ngwt__Alarm), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__PhoneFlags(struct soap *soap, ngwt__PhoneFlags *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__PhoneFlags))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__PhoneFlags(struct soap *soap, ngwt__PhoneFlags *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__PhoneFlags);
	if (soap_out_PointerTongwt__PhoneFlags(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__PhoneFlags(struct soap *soap, const char *tag, int id, ngwt__PhoneFlags *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__PhoneFlags);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__PhoneFlags ** SOAP_FMAC4 soap_get_PointerTongwt__PhoneFlags(struct soap *soap, ngwt__PhoneFlags **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__PhoneFlags(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__PhoneFlags ** SOAP_FMAC4 soap_in_PointerTongwt__PhoneFlags(struct soap *soap, const char *tag, ngwt__PhoneFlags **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__PhoneFlags **)soap_malloc(soap, sizeof(ngwt__PhoneFlags *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__PhoneFlags *)soap_instantiate_ngwt__PhoneFlags(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__PhoneFlags **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PhoneFlags, sizeof(ngwt__PhoneFlags), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__RecurrenceRule(struct soap *soap, ngwt__RecurrenceRule *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__RecurrenceRule))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__RecurrenceRule(struct soap *soap, ngwt__RecurrenceRule *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__RecurrenceRule);
	if (soap_out_PointerTongwt__RecurrenceRule(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__RecurrenceRule(struct soap *soap, const char *tag, int id, ngwt__RecurrenceRule *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__RecurrenceRule);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__RecurrenceRule ** SOAP_FMAC4 soap_get_PointerTongwt__RecurrenceRule(struct soap *soap, ngwt__RecurrenceRule **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__RecurrenceRule(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__RecurrenceRule ** SOAP_FMAC4 soap_in_PointerTongwt__RecurrenceRule(struct soap *soap, const char *tag, ngwt__RecurrenceRule **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__RecurrenceRule **)soap_malloc(soap, sizeof(ngwt__RecurrenceRule *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__RecurrenceRule *)soap_instantiate_ngwt__RecurrenceRule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__RecurrenceRule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RecurrenceRule, sizeof(ngwt__RecurrenceRule), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__RecurrenceDateType(struct soap *soap, ngwt__RecurrenceDateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__RecurrenceDateType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__RecurrenceDateType(struct soap *soap, ngwt__RecurrenceDateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__RecurrenceDateType);
	if (soap_out_PointerTongwt__RecurrenceDateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__RecurrenceDateType(struct soap *soap, const char *tag, int id, ngwt__RecurrenceDateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__RecurrenceDateType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__RecurrenceDateType ** SOAP_FMAC4 soap_get_PointerTongwt__RecurrenceDateType(struct soap *soap, ngwt__RecurrenceDateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__RecurrenceDateType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__RecurrenceDateType ** SOAP_FMAC4 soap_in_PointerTongwt__RecurrenceDateType(struct soap *soap, const char *tag, ngwt__RecurrenceDateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__RecurrenceDateType **)soap_malloc(soap, sizeof(ngwt__RecurrenceDateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__RecurrenceDateType *)soap_instantiate_ngwt__RecurrenceDateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__RecurrenceDateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RecurrenceDateType, sizeof(ngwt__RecurrenceDateType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__SMimeOperation(struct soap *soap, ngwt__SMimeOperation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__SMimeOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__SMimeOperation(struct soap *soap, ngwt__SMimeOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__SMimeOperation);
	if (soap_out_PointerTongwt__SMimeOperation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__SMimeOperation(struct soap *soap, const char *tag, int id, ngwt__SMimeOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__SMimeOperation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__SMimeOperation ** SOAP_FMAC4 soap_get_PointerTongwt__SMimeOperation(struct soap *soap, ngwt__SMimeOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__SMimeOperation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__SMimeOperation ** SOAP_FMAC4 soap_in_PointerTongwt__SMimeOperation(struct soap *soap, const char *tag, ngwt__SMimeOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__SMimeOperation **)soap_malloc(soap, sizeof(ngwt__SMimeOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__SMimeOperation *)soap_instantiate_ngwt__SMimeOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__SMimeOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SMimeOperation, sizeof(ngwt__SMimeOperation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__LinkInfo(struct soap *soap, ngwt__LinkInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__LinkInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__LinkInfo(struct soap *soap, ngwt__LinkInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__LinkInfo);
	if (soap_out_PointerTongwt__LinkInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__LinkInfo(struct soap *soap, const char *tag, int id, ngwt__LinkInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__LinkInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__LinkInfo ** SOAP_FMAC4 soap_get_PointerTongwt__LinkInfo(struct soap *soap, ngwt__LinkInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__LinkInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__LinkInfo ** SOAP_FMAC4 soap_in_PointerTongwt__LinkInfo(struct soap *soap, const char *tag, ngwt__LinkInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__LinkInfo **)soap_malloc(soap, sizeof(ngwt__LinkInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__LinkInfo *)soap_instantiate_ngwt__LinkInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__LinkInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__LinkInfo, sizeof(ngwt__LinkInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ItemOptions(struct soap *soap, ngwt__ItemOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ItemOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ItemOptions(struct soap *soap, ngwt__ItemOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ItemOptions);
	if (soap_out_PointerTongwt__ItemOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ItemOptions(struct soap *soap, const char *tag, int id, ngwt__ItemOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ItemOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ItemOptions ** SOAP_FMAC4 soap_get_PointerTongwt__ItemOptions(struct soap *soap, ngwt__ItemOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ItemOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ItemOptions ** SOAP_FMAC4 soap_in_PointerTongwt__ItemOptions(struct soap *soap, const char *tag, ngwt__ItemOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ItemOptions **)soap_malloc(soap, sizeof(ngwt__ItemOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ItemOptions *)soap_instantiate_ngwt__ItemOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ItemOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemOptions, sizeof(ngwt__ItemOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AttachmentInfo(struct soap *soap, ngwt__AttachmentInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AttachmentInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AttachmentInfo(struct soap *soap, ngwt__AttachmentInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AttachmentInfo);
	if (soap_out_PointerTongwt__AttachmentInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AttachmentInfo(struct soap *soap, const char *tag, int id, ngwt__AttachmentInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AttachmentInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AttachmentInfo ** SOAP_FMAC4 soap_get_PointerTongwt__AttachmentInfo(struct soap *soap, ngwt__AttachmentInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AttachmentInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AttachmentInfo ** SOAP_FMAC4 soap_in_PointerTongwt__AttachmentInfo(struct soap *soap, const char *tag, ngwt__AttachmentInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AttachmentInfo **)soap_malloc(soap, sizeof(ngwt__AttachmentInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AttachmentInfo *)soap_instantiate_ngwt__AttachmentInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AttachmentInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AttachmentInfo, sizeof(ngwt__AttachmentInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__MessageBody(struct soap *soap, ngwt__MessageBody *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__MessageBody))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__MessageBody(struct soap *soap, ngwt__MessageBody *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__MessageBody);
	if (soap_out_PointerTongwt__MessageBody(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__MessageBody(struct soap *soap, const char *tag, int id, ngwt__MessageBody *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__MessageBody);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__MessageBody ** SOAP_FMAC4 soap_get_PointerTongwt__MessageBody(struct soap *soap, ngwt__MessageBody **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__MessageBody(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__MessageBody ** SOAP_FMAC4 soap_in_PointerTongwt__MessageBody(struct soap *soap, const char *tag, ngwt__MessageBody **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__MessageBody **)soap_malloc(soap, sizeof(ngwt__MessageBody *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__MessageBody *)soap_instantiate_ngwt__MessageBody(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__MessageBody **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__MessageBody, sizeof(ngwt__MessageBody), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ReferenceInfo(struct soap *soap, ngwt__ReferenceInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ReferenceInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ReferenceInfo(struct soap *soap, ngwt__ReferenceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ReferenceInfo);
	if (soap_out_PointerTongwt__ReferenceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ReferenceInfo(struct soap *soap, const char *tag, int id, ngwt__ReferenceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ReferenceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ReferenceInfo ** SOAP_FMAC4 soap_get_PointerTongwt__ReferenceInfo(struct soap *soap, ngwt__ReferenceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ReferenceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ReferenceInfo ** SOAP_FMAC4 soap_in_PointerTongwt__ReferenceInfo(struct soap *soap, const char *tag, ngwt__ReferenceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ReferenceInfo **)soap_malloc(soap, sizeof(ngwt__ReferenceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ReferenceInfo *)soap_instantiate_ngwt__ReferenceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ReferenceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ReferenceInfo, sizeof(ngwt__ReferenceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__PersonalInfo(struct soap *soap, ngwt__PersonalInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__PersonalInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__PersonalInfo(struct soap *soap, ngwt__PersonalInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__PersonalInfo);
	if (soap_out_PointerTongwt__PersonalInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__PersonalInfo(struct soap *soap, const char *tag, int id, ngwt__PersonalInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__PersonalInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__PersonalInfo ** SOAP_FMAC4 soap_get_PointerTongwt__PersonalInfo(struct soap *soap, ngwt__PersonalInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__PersonalInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__PersonalInfo ** SOAP_FMAC4 soap_in_PointerTongwt__PersonalInfo(struct soap *soap, const char *tag, ngwt__PersonalInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__PersonalInfo **)soap_malloc(soap, sizeof(ngwt__PersonalInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__PersonalInfo *)soap_instantiate_ngwt__PersonalInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__PersonalInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PersonalInfo, sizeof(ngwt__PersonalInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__OfficeInfo(struct soap *soap, ngwt__OfficeInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__OfficeInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__OfficeInfo(struct soap *soap, ngwt__OfficeInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__OfficeInfo);
	if (soap_out_PointerTongwt__OfficeInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__OfficeInfo(struct soap *soap, const char *tag, int id, ngwt__OfficeInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__OfficeInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__OfficeInfo ** SOAP_FMAC4 soap_get_PointerTongwt__OfficeInfo(struct soap *soap, ngwt__OfficeInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__OfficeInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__OfficeInfo ** SOAP_FMAC4 soap_in_PointerTongwt__OfficeInfo(struct soap *soap, const char *tag, ngwt__OfficeInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__OfficeInfo **)soap_malloc(soap, sizeof(ngwt__OfficeInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__OfficeInfo *)soap_instantiate_ngwt__OfficeInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__OfficeInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__OfficeInfo, sizeof(ngwt__OfficeInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__PostalAddressList(struct soap *soap, ngwt__PostalAddressList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__PostalAddressList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__PostalAddressList(struct soap *soap, ngwt__PostalAddressList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__PostalAddressList);
	if (soap_out_PointerTongwt__PostalAddressList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__PostalAddressList(struct soap *soap, const char *tag, int id, ngwt__PostalAddressList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__PostalAddressList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__PostalAddressList ** SOAP_FMAC4 soap_get_PointerTongwt__PostalAddressList(struct soap *soap, ngwt__PostalAddressList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__PostalAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__PostalAddressList ** SOAP_FMAC4 soap_in_PointerTongwt__PostalAddressList(struct soap *soap, const char *tag, ngwt__PostalAddressList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__PostalAddressList **)soap_malloc(soap, sizeof(ngwt__PostalAddressList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__PostalAddressList *)soap_instantiate_ngwt__PostalAddressList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__PostalAddressList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PostalAddressList, sizeof(ngwt__PostalAddressList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__PhoneList(struct soap *soap, ngwt__PhoneList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__PhoneList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__PhoneList(struct soap *soap, ngwt__PhoneList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__PhoneList);
	if (soap_out_PointerTongwt__PhoneList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__PhoneList(struct soap *soap, const char *tag, int id, ngwt__PhoneList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__PhoneList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__PhoneList ** SOAP_FMAC4 soap_get_PointerTongwt__PhoneList(struct soap *soap, ngwt__PhoneList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__PhoneList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__PhoneList ** SOAP_FMAC4 soap_in_PointerTongwt__PhoneList(struct soap *soap, const char *tag, ngwt__PhoneList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__PhoneList **)soap_malloc(soap, sizeof(ngwt__PhoneList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__PhoneList *)soap_instantiate_ngwt__PhoneList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__PhoneList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PhoneList, sizeof(ngwt__PhoneList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ImAddressList(struct soap *soap, ngwt__ImAddressList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ImAddressList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ImAddressList(struct soap *soap, ngwt__ImAddressList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ImAddressList);
	if (soap_out_PointerTongwt__ImAddressList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ImAddressList(struct soap *soap, const char *tag, int id, ngwt__ImAddressList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ImAddressList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ImAddressList ** SOAP_FMAC4 soap_get_PointerTongwt__ImAddressList(struct soap *soap, ngwt__ImAddressList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ImAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ImAddressList ** SOAP_FMAC4 soap_in_PointerTongwt__ImAddressList(struct soap *soap, const char *tag, ngwt__ImAddressList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ImAddressList **)soap_malloc(soap, sizeof(ngwt__ImAddressList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ImAddressList *)soap_instantiate_ngwt__ImAddressList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ImAddressList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ImAddressList, sizeof(ngwt__ImAddressList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__EmailAddressList(struct soap *soap, ngwt__EmailAddressList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__EmailAddressList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__EmailAddressList(struct soap *soap, ngwt__EmailAddressList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__EmailAddressList);
	if (soap_out_PointerTongwt__EmailAddressList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__EmailAddressList(struct soap *soap, const char *tag, int id, ngwt__EmailAddressList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__EmailAddressList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__EmailAddressList ** SOAP_FMAC4 soap_get_PointerTongwt__EmailAddressList(struct soap *soap, ngwt__EmailAddressList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__EmailAddressList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__EmailAddressList ** SOAP_FMAC4 soap_in_PointerTongwt__EmailAddressList(struct soap *soap, const char *tag, ngwt__EmailAddressList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__EmailAddressList **)soap_malloc(soap, sizeof(ngwt__EmailAddressList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__EmailAddressList *)soap_instantiate_ngwt__EmailAddressList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__EmailAddressList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__EmailAddressList, sizeof(ngwt__EmailAddressList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FullName(struct soap *soap, ngwt__FullName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__FullName))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FullName(struct soap *soap, ngwt__FullName *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FullName);
	if (soap_out_PointerTongwt__FullName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FullName(struct soap *soap, const char *tag, int id, ngwt__FullName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FullName);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__FullName ** SOAP_FMAC4 soap_get_PointerTongwt__FullName(struct soap *soap, ngwt__FullName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FullName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__FullName ** SOAP_FMAC4 soap_in_PointerTongwt__FullName(struct soap *soap, const char *tag, ngwt__FullName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__FullName **)soap_malloc(soap, sizeof(ngwt__FullName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__FullName *)soap_instantiate_ngwt__FullName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__FullName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FullName, sizeof(ngwt__FullName), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__VersionStatus(struct soap *soap, enum ngwt__VersionStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__VersionStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__VersionStatus(struct soap *soap, enum ngwt__VersionStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__VersionStatus);
	if (soap_out_PointerTongwt__VersionStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__VersionStatus(struct soap *soap, const char *tag, int id, enum ngwt__VersionStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__VersionStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__VersionStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__VersionStatus ** SOAP_FMAC4 soap_get_PointerTongwt__VersionStatus(struct soap *soap, enum ngwt__VersionStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__VersionStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__VersionStatus ** SOAP_FMAC4 soap_in_PointerTongwt__VersionStatus(struct soap *soap, const char *tag, enum ngwt__VersionStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__VersionStatus **)soap_malloc(soap, sizeof(enum ngwt__VersionStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__VersionStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__VersionStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__VersionStatus, sizeof(enum ngwt__VersionStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FolderACL(struct soap *soap, ngwt__FolderACL *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__FolderACL))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FolderACL(struct soap *soap, ngwt__FolderACL *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FolderACL);
	if (soap_out_PointerTongwt__FolderACL(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FolderACL(struct soap *soap, const char *tag, int id, ngwt__FolderACL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FolderACL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__FolderACL ** SOAP_FMAC4 soap_get_PointerTongwt__FolderACL(struct soap *soap, ngwt__FolderACL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FolderACL(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__FolderACL ** SOAP_FMAC4 soap_in_PointerTongwt__FolderACL(struct soap *soap, const char *tag, ngwt__FolderACL **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__FolderACL **)soap_malloc(soap, sizeof(ngwt__FolderACL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__FolderACL *)soap_instantiate_ngwt__FolderACL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__FolderACL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FolderACL, sizeof(ngwt__FolderACL), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__RuleActionList(struct soap *soap, ngwt__RuleActionList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__RuleActionList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__RuleActionList(struct soap *soap, ngwt__RuleActionList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__RuleActionList);
	if (soap_out_PointerTongwt__RuleActionList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__RuleActionList(struct soap *soap, const char *tag, int id, ngwt__RuleActionList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__RuleActionList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__RuleActionList ** SOAP_FMAC4 soap_get_PointerTongwt__RuleActionList(struct soap *soap, ngwt__RuleActionList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__RuleActionList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__RuleActionList ** SOAP_FMAC4 soap_in_PointerTongwt__RuleActionList(struct soap *soap, const char *tag, ngwt__RuleActionList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__RuleActionList **)soap_malloc(soap, sizeof(ngwt__RuleActionList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__RuleActionList *)soap_instantiate_ngwt__RuleActionList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__RuleActionList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RuleActionList, sizeof(ngwt__RuleActionList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Execution(struct soap *soap, enum ngwt__Execution *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__Execution);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Execution(struct soap *soap, enum ngwt__Execution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Execution);
	if (soap_out_PointerTongwt__Execution(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Execution(struct soap *soap, const char *tag, int id, enum ngwt__Execution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Execution);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__Execution(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__Execution ** SOAP_FMAC4 soap_get_PointerTongwt__Execution(struct soap *soap, enum ngwt__Execution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Execution(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__Execution ** SOAP_FMAC4 soap_in_PointerTongwt__Execution(struct soap *soap, const char *tag, enum ngwt__Execution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__Execution **)soap_malloc(soap, sizeof(enum ngwt__Execution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__Execution(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__Execution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Execution, sizeof(enum ngwt__Execution), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Query(struct soap *soap, ngwt__Query *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Query))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Query(struct soap *soap, ngwt__Query *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Query);
	if (soap_out_PointerTongwt__Query(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Query(struct soap *soap, const char *tag, int id, ngwt__Query *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Query);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Query ** SOAP_FMAC4 soap_get_PointerTongwt__Query(struct soap *soap, ngwt__Query **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Query(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Query ** SOAP_FMAC4 soap_in_PointerTongwt__Query(struct soap *soap, const char *tag, ngwt__Query **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Query **)soap_malloc(soap, sizeof(ngwt__Query *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Query *)soap_instantiate_ngwt__Query(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Query **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Query, sizeof(ngwt__Query), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FolderACLStatus(struct soap *soap, enum ngwt__FolderACLStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__FolderACLStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FolderACLStatus(struct soap *soap, enum ngwt__FolderACLStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FolderACLStatus);
	if (soap_out_PointerTongwt__FolderACLStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FolderACLStatus(struct soap *soap, const char *tag, int id, enum ngwt__FolderACLStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FolderACLStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__FolderACLStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__FolderACLStatus ** SOAP_FMAC4 soap_get_PointerTongwt__FolderACLStatus(struct soap *soap, enum ngwt__FolderACLStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FolderACLStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__FolderACLStatus ** SOAP_FMAC4 soap_in_PointerTongwt__FolderACLStatus(struct soap *soap, const char *tag, enum ngwt__FolderACLStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__FolderACLStatus **)soap_malloc(soap, sizeof(enum ngwt__FolderACLStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__FolderACLStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__FolderACLStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FolderACLStatus, sizeof(enum ngwt__FolderACLStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AccessControlList(struct soap *soap, ngwt__AccessControlList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AccessControlList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AccessControlList(struct soap *soap, ngwt__AccessControlList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AccessControlList);
	if (soap_out_PointerTongwt__AccessControlList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AccessControlList(struct soap *soap, const char *tag, int id, ngwt__AccessControlList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AccessControlList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AccessControlList ** SOAP_FMAC4 soap_get_PointerTongwt__AccessControlList(struct soap *soap, ngwt__AccessControlList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AccessControlList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AccessControlList ** SOAP_FMAC4 soap_in_PointerTongwt__AccessControlList(struct soap *soap, const char *tag, ngwt__AccessControlList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AccessControlList **)soap_malloc(soap, sizeof(ngwt__AccessControlList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AccessControlList *)soap_instantiate_ngwt__AccessControlList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AccessControlList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessControlList, sizeof(ngwt__AccessControlList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__WeekOfYear(struct soap *soap, short *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__WeekOfYear);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__WeekOfYear(struct soap *soap, short *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__WeekOfYear);
	if (soap_out_PointerTongwt__WeekOfYear(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__WeekOfYear(struct soap *soap, const char *tag, int id, short *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__WeekOfYear);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__WeekOfYear(soap, tag, id, *a, type);
}

SOAP_FMAC3 short ** SOAP_FMAC4 soap_get_PointerTongwt__WeekOfYear(struct soap *soap, short **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__WeekOfYear(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short ** SOAP_FMAC4 soap_in_PointerTongwt__WeekOfYear(struct soap *soap, const char *tag, short **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (short **)soap_malloc(soap, sizeof(short *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__WeekOfYear(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (short **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__WeekOfYear, sizeof(short), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__OccurrenceType(struct soap *soap, enum ngwt__OccurrenceType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__OccurrenceType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__OccurrenceType(struct soap *soap, enum ngwt__OccurrenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__OccurrenceType);
	if (soap_out_PointerTongwt__OccurrenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__OccurrenceType(struct soap *soap, const char *tag, int id, enum ngwt__OccurrenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__OccurrenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__OccurrenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__OccurrenceType ** SOAP_FMAC4 soap_get_PointerTongwt__OccurrenceType(struct soap *soap, enum ngwt__OccurrenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__OccurrenceType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__OccurrenceType ** SOAP_FMAC4 soap_in_PointerTongwt__OccurrenceType(struct soap *soap, const char *tag, enum ngwt__OccurrenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__OccurrenceType **)soap_malloc(soap, sizeof(enum ngwt__OccurrenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__OccurrenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__OccurrenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__OccurrenceType, sizeof(enum ngwt__OccurrenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ItemSecurity(struct soap *soap, enum ngwt__ItemSecurity *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__ItemSecurity);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ItemSecurity(struct soap *soap, enum ngwt__ItemSecurity *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ItemSecurity);
	if (soap_out_PointerTongwt__ItemSecurity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ItemSecurity(struct soap *soap, const char *tag, int id, enum ngwt__ItemSecurity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ItemSecurity);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__ItemSecurity(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__ItemSecurity ** SOAP_FMAC4 soap_get_PointerTongwt__ItemSecurity(struct soap *soap, enum ngwt__ItemSecurity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ItemSecurity(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__ItemSecurity ** SOAP_FMAC4 soap_in_PointerTongwt__ItemSecurity(struct soap *soap, const char *tag, enum ngwt__ItemSecurity **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__ItemSecurity **)soap_malloc(soap, sizeof(enum ngwt__ItemSecurity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__ItemSecurity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__ItemSecurity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemSecurity, sizeof(enum ngwt__ItemSecurity), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ItemClass(struct soap *soap, enum ngwt__ItemClass *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__ItemClass);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ItemClass(struct soap *soap, enum ngwt__ItemClass *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ItemClass);
	if (soap_out_PointerTongwt__ItemClass(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ItemClass(struct soap *soap, const char *tag, int id, enum ngwt__ItemClass *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ItemClass);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__ItemClass(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__ItemClass ** SOAP_FMAC4 soap_get_PointerTongwt__ItemClass(struct soap *soap, enum ngwt__ItemClass **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ItemClass(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__ItemClass ** SOAP_FMAC4 soap_in_PointerTongwt__ItemClass(struct soap *soap, const char *tag, enum ngwt__ItemClass **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__ItemClass **)soap_malloc(soap, sizeof(enum ngwt__ItemClass *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__ItemClass(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__ItemClass **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemClass, sizeof(enum ngwt__ItemClass), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ItemSource(struct soap *soap, enum ngwt__ItemSource *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__ItemSource);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ItemSource(struct soap *soap, enum ngwt__ItemSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ItemSource);
	if (soap_out_PointerTongwt__ItemSource(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ItemSource(struct soap *soap, const char *tag, int id, enum ngwt__ItemSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ItemSource);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__ItemSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__ItemSource ** SOAP_FMAC4 soap_get_PointerTongwt__ItemSource(struct soap *soap, enum ngwt__ItemSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ItemSource(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__ItemSource ** SOAP_FMAC4 soap_in_PointerTongwt__ItemSource(struct soap *soap, const char *tag, enum ngwt__ItemSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__ItemSource **)soap_malloc(soap, sizeof(enum ngwt__ItemSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__ItemSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__ItemSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemSource, sizeof(enum ngwt__ItemSource), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ItemStatus(struct soap *soap, ngwt__ItemStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ItemStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ItemStatus(struct soap *soap, ngwt__ItemStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ItemStatus);
	if (soap_out_PointerTongwt__ItemStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ItemStatus(struct soap *soap, const char *tag, int id, ngwt__ItemStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ItemStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ItemStatus ** SOAP_FMAC4 soap_get_PointerTongwt__ItemStatus(struct soap *soap, ngwt__ItemStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ItemStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ItemStatus ** SOAP_FMAC4 soap_in_PointerTongwt__ItemStatus(struct soap *soap, const char *tag, ngwt__ItemStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ItemStatus **)soap_malloc(soap, sizeof(ngwt__ItemStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ItemStatus *)soap_instantiate_ngwt__ItemStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ItemStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemStatus, sizeof(ngwt__ItemStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__DeltaSyncType(struct soap *soap, enum ngwt__DeltaSyncType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__DeltaSyncType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__DeltaSyncType(struct soap *soap, enum ngwt__DeltaSyncType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__DeltaSyncType);
	if (soap_out_PointerTongwt__DeltaSyncType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__DeltaSyncType(struct soap *soap, const char *tag, int id, enum ngwt__DeltaSyncType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__DeltaSyncType);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__DeltaSyncType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__DeltaSyncType ** SOAP_FMAC4 soap_get_PointerTongwt__DeltaSyncType(struct soap *soap, enum ngwt__DeltaSyncType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__DeltaSyncType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__DeltaSyncType ** SOAP_FMAC4 soap_in_PointerTongwt__DeltaSyncType(struct soap *soap, const char *tag, enum ngwt__DeltaSyncType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__DeltaSyncType **)soap_malloc(soap, sizeof(enum ngwt__DeltaSyncType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__DeltaSyncType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__DeltaSyncType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DeltaSyncType, sizeof(enum ngwt__DeltaSyncType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__RecipientStatus(struct soap *soap, ngwt__RecipientStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__RecipientStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__RecipientStatus(struct soap *soap, ngwt__RecipientStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__RecipientStatus);
	if (soap_out_PointerTongwt__RecipientStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__RecipientStatus(struct soap *soap, const char *tag, int id, ngwt__RecipientStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__RecipientStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__RecipientStatus ** SOAP_FMAC4 soap_get_PointerTongwt__RecipientStatus(struct soap *soap, ngwt__RecipientStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__RecipientStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__RecipientStatus ** SOAP_FMAC4 soap_in_PointerTongwt__RecipientStatus(struct soap *soap, const char *tag, ngwt__RecipientStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__RecipientStatus **)soap_malloc(soap, sizeof(ngwt__RecipientStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__RecipientStatus *)soap_instantiate_ngwt__RecipientStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__RecipientStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RecipientStatus, sizeof(ngwt__RecipientStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FreeBusyBlockList(struct soap *soap, ngwt__FreeBusyBlockList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__FreeBusyBlockList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FreeBusyBlockList(struct soap *soap, ngwt__FreeBusyBlockList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FreeBusyBlockList);
	if (soap_out_PointerTongwt__FreeBusyBlockList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FreeBusyBlockList(struct soap *soap, const char *tag, int id, ngwt__FreeBusyBlockList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FreeBusyBlockList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__FreeBusyBlockList ** SOAP_FMAC4 soap_get_PointerTongwt__FreeBusyBlockList(struct soap *soap, ngwt__FreeBusyBlockList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FreeBusyBlockList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__FreeBusyBlockList ** SOAP_FMAC4 soap_in_PointerTongwt__FreeBusyBlockList(struct soap *soap, const char *tag, ngwt__FreeBusyBlockList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__FreeBusyBlockList **)soap_malloc(soap, sizeof(ngwt__FreeBusyBlockList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__FreeBusyBlockList *)soap_instantiate_ngwt__FreeBusyBlockList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyBlockList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyBlockList, sizeof(ngwt__FreeBusyBlockList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__CalendarFolderAttribute(struct soap *soap, ngwt__CalendarFolderAttribute *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__CalendarFolderAttribute))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__CalendarFolderAttribute(struct soap *soap, ngwt__CalendarFolderAttribute *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__CalendarFolderAttribute);
	if (soap_out_PointerTongwt__CalendarFolderAttribute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__CalendarFolderAttribute(struct soap *soap, const char *tag, int id, ngwt__CalendarFolderAttribute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__CalendarFolderAttribute);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__CalendarFolderAttribute ** SOAP_FMAC4 soap_get_PointerTongwt__CalendarFolderAttribute(struct soap *soap, ngwt__CalendarFolderAttribute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__CalendarFolderAttribute(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__CalendarFolderAttribute ** SOAP_FMAC4 soap_in_PointerTongwt__CalendarFolderAttribute(struct soap *soap, const char *tag, ngwt__CalendarFolderAttribute **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__CalendarFolderAttribute **)soap_malloc(soap, sizeof(ngwt__CalendarFolderAttribute *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__CalendarFolderAttribute *)soap_instantiate_ngwt__CalendarFolderAttribute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__CalendarFolderAttribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CalendarFolderAttribute, sizeof(ngwt__CalendarFolderAttribute), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FilterDate(struct soap *soap, enum ngwt__FilterDate *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__FilterDate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FilterDate(struct soap *soap, enum ngwt__FilterDate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FilterDate);
	if (soap_out_PointerTongwt__FilterDate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FilterDate(struct soap *soap, const char *tag, int id, enum ngwt__FilterDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FilterDate);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__FilterDate(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__FilterDate ** SOAP_FMAC4 soap_get_PointerTongwt__FilterDate(struct soap *soap, enum ngwt__FilterDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FilterDate(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__FilterDate ** SOAP_FMAC4 soap_in_PointerTongwt__FilterDate(struct soap *soap, const char *tag, enum ngwt__FilterDate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__FilterDate **)soap_malloc(soap, sizeof(enum ngwt__FilterDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__FilterDate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__FilterDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FilterDate, sizeof(enum ngwt__FilterDate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ContainerRef(struct soap *soap, ngwt__ContainerRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ContainerRef))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ContainerRef(struct soap *soap, ngwt__ContainerRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ContainerRef);
	if (soap_out_PointerTongwt__ContainerRef(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ContainerRef(struct soap *soap, const char *tag, int id, ngwt__ContainerRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ContainerRef);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ContainerRef ** SOAP_FMAC4 soap_get_PointerTongwt__ContainerRef(struct soap *soap, ngwt__ContainerRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ContainerRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ContainerRef ** SOAP_FMAC4 soap_in_PointerTongwt__ContainerRef(struct soap *soap, const char *tag, ngwt__ContainerRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ContainerRef **)soap_malloc(soap, sizeof(ngwt__ContainerRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ContainerRef *)soap_instantiate_ngwt__ContainerRef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ContainerRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ContainerRef, sizeof(ngwt__ContainerRef), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__CategoryType(struct soap *soap, enum ngwt__CategoryType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__CategoryType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__CategoryType(struct soap *soap, enum ngwt__CategoryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__CategoryType);
	if (soap_out_PointerTongwt__CategoryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__CategoryType(struct soap *soap, const char *tag, int id, enum ngwt__CategoryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__CategoryType);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__CategoryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__CategoryType ** SOAP_FMAC4 soap_get_PointerTongwt__CategoryType(struct soap *soap, enum ngwt__CategoryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__CategoryType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__CategoryType ** SOAP_FMAC4 soap_in_PointerTongwt__CategoryType(struct soap *soap, const char *tag, enum ngwt__CategoryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__CategoryType **)soap_malloc(soap, sizeof(enum ngwt__CategoryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__CategoryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__CategoryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CategoryType, sizeof(enum ngwt__CategoryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AccessMiscRight(struct soap *soap, ngwt__AccessMiscRight *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AccessMiscRight))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AccessMiscRight(struct soap *soap, ngwt__AccessMiscRight *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AccessMiscRight);
	if (soap_out_PointerTongwt__AccessMiscRight(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AccessMiscRight(struct soap *soap, const char *tag, int id, ngwt__AccessMiscRight *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AccessMiscRight);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AccessMiscRight ** SOAP_FMAC4 soap_get_PointerTongwt__AccessMiscRight(struct soap *soap, ngwt__AccessMiscRight **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AccessMiscRight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AccessMiscRight ** SOAP_FMAC4 soap_in_PointerTongwt__AccessMiscRight(struct soap *soap, const char *tag, ngwt__AccessMiscRight **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AccessMiscRight **)soap_malloc(soap, sizeof(ngwt__AccessMiscRight *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AccessMiscRight *)soap_instantiate_ngwt__AccessMiscRight(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AccessMiscRight **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessMiscRight, sizeof(ngwt__AccessMiscRight), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AccessRight(struct soap *soap, ngwt__AccessRight *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AccessRight))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AccessRight(struct soap *soap, ngwt__AccessRight *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AccessRight);
	if (soap_out_PointerTongwt__AccessRight(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AccessRight(struct soap *soap, const char *tag, int id, ngwt__AccessRight *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AccessRight);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AccessRight ** SOAP_FMAC4 soap_get_PointerTongwt__AccessRight(struct soap *soap, ngwt__AccessRight **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AccessRight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AccessRight ** SOAP_FMAC4 soap_in_PointerTongwt__AccessRight(struct soap *soap, const char *tag, ngwt__AccessRight **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AccessRight **)soap_malloc(soap, sizeof(ngwt__AccessRight *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AccessRight *)soap_instantiate_ngwt__AccessRight(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AccessRight **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessRight, sizeof(ngwt__AccessRight), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Rights(struct soap *soap, ngwt__Rights *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Rights))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Rights(struct soap *soap, ngwt__Rights *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Rights);
	if (soap_out_PointerTongwt__Rights(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Rights(struct soap *soap, const char *tag, int id, ngwt__Rights *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Rights);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Rights ** SOAP_FMAC4 soap_get_PointerTongwt__Rights(struct soap *soap, ngwt__Rights **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Rights(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Rights ** SOAP_FMAC4 soap_in_PointerTongwt__Rights(struct soap *soap, const char *tag, ngwt__Rights **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Rights **)soap_malloc(soap, sizeof(ngwt__Rights *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Rights *)soap_instantiate_ngwt__Rights(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Rights **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Rights, sizeof(ngwt__Rights), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwe__EventList(struct soap *soap, ngwe__EventList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwe__EventList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwe__EventList(struct soap *soap, ngwe__EventList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwe__EventList);
	if (soap_out_PointerTongwe__EventList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwe__EventList(struct soap *soap, const char *tag, int id, ngwe__EventList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwe__EventList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwe__EventList ** SOAP_FMAC4 soap_get_PointerTongwe__EventList(struct soap *soap, ngwe__EventList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwe__EventList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwe__EventList ** SOAP_FMAC4 soap_in_PointerTongwe__EventList(struct soap *soap, const char *tag, ngwe__EventList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwe__EventList **)soap_malloc(soap, sizeof(ngwe__EventList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwe__EventList *)soap_instantiate_ngwe__EventList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwe__EventList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__EventList, sizeof(ngwe__EventList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwe__EventsList(struct soap *soap, ngwe__EventsList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwe__EventsList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwe__EventsList(struct soap *soap, ngwe__EventsList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwe__EventsList);
	if (soap_out_PointerTongwe__EventsList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwe__EventsList(struct soap *soap, const char *tag, int id, ngwe__EventsList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwe__EventsList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwe__EventsList ** SOAP_FMAC4 soap_get_PointerTongwe__EventsList(struct soap *soap, ngwe__EventsList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwe__EventsList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwe__EventsList ** SOAP_FMAC4 soap_in_PointerTongwe__EventsList(struct soap *soap, const char *tag, ngwe__EventsList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwe__EventsList **)soap_malloc(soap, sizeof(ngwe__EventsList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwe__EventsList *)soap_instantiate_ngwe__EventsList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwe__EventsList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__EventsList, sizeof(ngwe__EventsList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwe__Events(struct soap *soap, ngwe__Events *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwe__Events))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwe__Events(struct soap *soap, ngwe__Events *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwe__Events);
	if (soap_out_PointerTongwe__Events(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwe__Events(struct soap *soap, const char *tag, int id, ngwe__Events *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwe__Events);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwe__Events ** SOAP_FMAC4 soap_get_PointerTongwe__Events(struct soap *soap, ngwe__Events **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwe__Events(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwe__Events ** SOAP_FMAC4 soap_in_PointerTongwe__Events(struct soap *soap, const char *tag, ngwe__Events **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwe__Events **)soap_malloc(soap, sizeof(ngwe__Events *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwe__Events *)soap_instantiate_ngwe__Events(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwe__Events **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__Events, sizeof(ngwe__Events), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwe__EventDefinition(struct soap *soap, ngwe__EventDefinition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwe__EventDefinition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwe__EventDefinition(struct soap *soap, ngwe__EventDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwe__EventDefinition);
	if (soap_out_PointerTongwe__EventDefinition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwe__EventDefinition(struct soap *soap, const char *tag, int id, ngwe__EventDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwe__EventDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwe__EventDefinition ** SOAP_FMAC4 soap_get_PointerTongwe__EventDefinition(struct soap *soap, ngwe__EventDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwe__EventDefinition(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwe__EventDefinition ** SOAP_FMAC4 soap_in_PointerTongwe__EventDefinition(struct soap *soap, const char *tag, ngwe__EventDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwe__EventDefinition **)soap_malloc(soap, sizeof(ngwe__EventDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwe__EventDefinition *)soap_instantiate_ngwe__EventDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwe__EventDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__EventDefinition, sizeof(ngwe__EventDefinition), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__duration))
		soap_serialize_xsd__duration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__duration);
	if (soap_out_PointerToxsd__duration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwe__Event(struct soap *soap, ngwe__Event *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwe__Event))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwe__Event(struct soap *soap, ngwe__Event *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwe__Event);
	if (soap_out_PointerTongwe__Event(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwe__Event(struct soap *soap, const char *tag, int id, ngwe__Event *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwe__Event);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwe__Event ** SOAP_FMAC4 soap_get_PointerTongwe__Event(struct soap *soap, ngwe__Event **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwe__Event(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwe__Event ** SOAP_FMAC4 soap_in_PointerTongwe__Event(struct soap *soap, const char *tag, ngwe__Event **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwe__Event **)soap_malloc(soap, sizeof(ngwe__Event *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwe__Event *)soap_instantiate_ngwe__Event(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwe__Event **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__Event, sizeof(ngwe__Event), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwe__ContainerList(struct soap *soap, ngwe__ContainerList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwe__ContainerList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwe__ContainerList(struct soap *soap, ngwe__ContainerList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwe__ContainerList);
	if (soap_out_PointerTongwe__ContainerList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwe__ContainerList(struct soap *soap, const char *tag, int id, ngwe__ContainerList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwe__ContainerList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwe__ContainerList ** SOAP_FMAC4 soap_get_PointerTongwe__ContainerList(struct soap *soap, ngwe__ContainerList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwe__ContainerList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwe__ContainerList ** SOAP_FMAC4 soap_in_PointerTongwe__ContainerList(struct soap *soap, const char *tag, ngwe__ContainerList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwe__ContainerList **)soap_malloc(soap, sizeof(ngwe__ContainerList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwe__ContainerList *)soap_instantiate_ngwe__ContainerList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwe__ContainerList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__ContainerList, sizeof(ngwe__ContainerList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwe__ItemTypeList(struct soap *soap, enum ngwe__ItemTypeList *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwe__ItemTypeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwe__ItemTypeList(struct soap *soap, enum ngwe__ItemTypeList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwe__ItemTypeList);
	if (soap_out_PointerTongwe__ItemTypeList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwe__ItemTypeList(struct soap *soap, const char *tag, int id, enum ngwe__ItemTypeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwe__ItemTypeList);
	if (id < 0)
		return soap->error;
	return soap_out_ngwe__ItemTypeList(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwe__ItemTypeList ** SOAP_FMAC4 soap_get_PointerTongwe__ItemTypeList(struct soap *soap, enum ngwe__ItemTypeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwe__ItemTypeList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwe__ItemTypeList ** SOAP_FMAC4 soap_in_PointerTongwe__ItemTypeList(struct soap *soap, const char *tag, enum ngwe__ItemTypeList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwe__ItemTypeList **)soap_malloc(soap, sizeof(enum ngwe__ItemTypeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwe__ItemTypeList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwe__ItemTypeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__ItemTypeList, sizeof(enum ngwe__ItemTypeList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwe__EventTypeList(struct soap *soap, ngwe__EventTypeList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwe__EventTypeList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwe__EventTypeList(struct soap *soap, ngwe__EventTypeList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwe__EventTypeList);
	if (soap_out_PointerTongwe__EventTypeList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwe__EventTypeList(struct soap *soap, const char *tag, int id, ngwe__EventTypeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwe__EventTypeList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwe__EventTypeList ** SOAP_FMAC4 soap_get_PointerTongwe__EventTypeList(struct soap *soap, ngwe__EventTypeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwe__EventTypeList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwe__EventTypeList ** SOAP_FMAC4 soap_in_PointerTongwe__EventTypeList(struct soap *soap, const char *tag, ngwe__EventTypeList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwe__EventTypeList **)soap_malloc(soap, sizeof(ngwe__EventTypeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwe__EventTypeList *)soap_instantiate_ngwe__EventTypeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwe__EventTypeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__EventTypeList, sizeof(ngwe__EventTypeList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwe__ItemType(struct soap *soap, enum ngwe__ItemType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwe__ItemType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwe__ItemType(struct soap *soap, enum ngwe__ItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwe__ItemType);
	if (soap_out_PointerTongwe__ItemType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwe__ItemType(struct soap *soap, const char *tag, int id, enum ngwe__ItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwe__ItemType);
	if (id < 0)
		return soap->error;
	return soap_out_ngwe__ItemType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwe__ItemType ** SOAP_FMAC4 soap_get_PointerTongwe__ItemType(struct soap *soap, enum ngwe__ItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwe__ItemType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwe__ItemType ** SOAP_FMAC4 soap_in_PointerTongwe__ItemType(struct soap *soap, const char *tag, enum ngwe__ItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwe__ItemType **)soap_malloc(soap, sizeof(enum ngwe__ItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwe__ItemType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwe__ItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__ItemType, sizeof(enum ngwe__ItemType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwe__FieldList(struct soap *soap, enum ngwe__FieldList *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwe__FieldList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwe__FieldList(struct soap *soap, enum ngwe__FieldList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwe__FieldList);
	if (soap_out_PointerTongwe__FieldList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwe__FieldList(struct soap *soap, const char *tag, int id, enum ngwe__FieldList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwe__FieldList);
	if (id < 0)
		return soap->error;
	return soap_out_ngwe__FieldList(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwe__FieldList ** SOAP_FMAC4 soap_get_PointerTongwe__FieldList(struct soap *soap, enum ngwe__FieldList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwe__FieldList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwe__FieldList ** SOAP_FMAC4 soap_in_PointerTongwe__FieldList(struct soap *soap, const char *tag, enum ngwe__FieldList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwe__FieldList **)soap_malloc(soap, sizeof(enum ngwe__FieldList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwe__FieldList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwe__FieldList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwe__FieldList, sizeof(enum ngwe__FieldList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FreeBusyUserList(struct soap *soap, ngwt__FreeBusyUserList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__FreeBusyUserList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FreeBusyUserList(struct soap *soap, ngwt__FreeBusyUserList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FreeBusyUserList);
	if (soap_out_PointerTongwt__FreeBusyUserList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FreeBusyUserList(struct soap *soap, const char *tag, int id, ngwt__FreeBusyUserList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FreeBusyUserList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__FreeBusyUserList ** SOAP_FMAC4 soap_get_PointerTongwt__FreeBusyUserList(struct soap *soap, ngwt__FreeBusyUserList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FreeBusyUserList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__FreeBusyUserList ** SOAP_FMAC4 soap_in_PointerTongwt__FreeBusyUserList(struct soap *soap, const char *tag, ngwt__FreeBusyUserList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__FreeBusyUserList **)soap_malloc(soap, sizeof(ngwt__FreeBusyUserList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__FreeBusyUserList *)soap_instantiate_ngwt__FreeBusyUserList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyUserList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyUserList, sizeof(ngwt__FreeBusyUserList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__RetractType(struct soap *soap, enum ngwt__RetractType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__RetractType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__RetractType(struct soap *soap, enum ngwt__RetractType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__RetractType);
	if (soap_out_PointerTongwt__RetractType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__RetractType(struct soap *soap, const char *tag, int id, enum ngwt__RetractType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__RetractType);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__RetractType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__RetractType ** SOAP_FMAC4 soap_get_PointerTongwt__RetractType(struct soap *soap, enum ngwt__RetractType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__RetractType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__RetractType ** SOAP_FMAC4 soap_in_PointerTongwt__RetractType(struct soap *soap, const char *tag, enum ngwt__RetractType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__RetractType **)soap_malloc(soap, sizeof(enum ngwt__RetractType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__RetractType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__RetractType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RetractType, sizeof(enum ngwt__RetractType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ItemList(struct soap *soap, ngwt__ItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ItemList(struct soap *soap, ngwt__ItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ItemList);
	if (soap_out_PointerTongwt__ItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ItemList(struct soap *soap, const char *tag, int id, ngwt__ItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ItemList ** SOAP_FMAC4 soap_get_PointerTongwt__ItemList(struct soap *soap, ngwt__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ItemList ** SOAP_FMAC4 soap_in_PointerTongwt__ItemList(struct soap *soap, const char *tag, ngwt__ItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ItemList **)soap_malloc(soap, sizeof(ngwt__ItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ItemList *)soap_instantiate_ngwt__ItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemList, sizeof(ngwt__ItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__CursorSeek(struct soap *soap, enum ngwt__CursorSeek *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__CursorSeek);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__CursorSeek(struct soap *soap, enum ngwt__CursorSeek *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__CursorSeek);
	if (soap_out_PointerTongwt__CursorSeek(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__CursorSeek(struct soap *soap, const char *tag, int id, enum ngwt__CursorSeek *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__CursorSeek);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__CursorSeek(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__CursorSeek ** SOAP_FMAC4 soap_get_PointerTongwt__CursorSeek(struct soap *soap, enum ngwt__CursorSeek **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__CursorSeek(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__CursorSeek ** SOAP_FMAC4 soap_in_PointerTongwt__CursorSeek(struct soap *soap, const char *tag, enum ngwt__CursorSeek **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__CursorSeek **)soap_malloc(soap, sizeof(enum ngwt__CursorSeek *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__CursorSeek(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__CursorSeek **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CursorSeek, sizeof(enum ngwt__CursorSeek), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AccessRightChanges(struct soap *soap, ngwt__AccessRightChanges *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AccessRightChanges))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AccessRightChanges(struct soap *soap, ngwt__AccessRightChanges *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AccessRightChanges);
	if (soap_out_PointerTongwt__AccessRightChanges(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AccessRightChanges(struct soap *soap, const char *tag, int id, ngwt__AccessRightChanges *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AccessRightChanges);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AccessRightChanges ** SOAP_FMAC4 soap_get_PointerTongwt__AccessRightChanges(struct soap *soap, ngwt__AccessRightChanges **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AccessRightChanges(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AccessRightChanges ** SOAP_FMAC4 soap_in_PointerTongwt__AccessRightChanges(struct soap *soap, const char *tag, ngwt__AccessRightChanges **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AccessRightChanges **)soap_malloc(soap, sizeof(ngwt__AccessRightChanges *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AccessRightChanges *)soap_instantiate_ngwt__AccessRightChanges(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AccessRightChanges **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessRightChanges, sizeof(ngwt__AccessRightChanges), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ModifyItem(struct soap *soap, ngwt__ModifyItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ModifyItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ModifyItem(struct soap *soap, ngwt__ModifyItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ModifyItem);
	if (soap_out_PointerTongwt__ModifyItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ModifyItem(struct soap *soap, const char *tag, int id, ngwt__ModifyItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ModifyItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ModifyItem ** SOAP_FMAC4 soap_get_PointerTongwt__ModifyItem(struct soap *soap, ngwt__ModifyItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ModifyItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ModifyItem ** SOAP_FMAC4 soap_in_PointerTongwt__ModifyItem(struct soap *soap, const char *tag, ngwt__ModifyItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ModifyItem **)soap_malloc(soap, sizeof(ngwt__ModifyItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ModifyItem *)soap_instantiate_ngwt__ModifyItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ModifyItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ModifyItem, sizeof(ngwt__ModifyItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Host(struct soap *soap, ngwt__Host *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Host))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Host(struct soap *soap, ngwt__Host *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Host);
	if (soap_out_PointerTongwt__Host(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Host(struct soap *soap, const char *tag, int id, ngwt__Host *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Host);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Host ** SOAP_FMAC4 soap_get_PointerTongwt__Host(struct soap *soap, ngwt__Host **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Host(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Host ** SOAP_FMAC4 soap_in_PointerTongwt__Host(struct soap *soap, const char *tag, ngwt__Host **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Host **)soap_malloc(soap, sizeof(ngwt__Host *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Host *)soap_instantiate_ngwt__Host(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Host **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Host, sizeof(ngwt__Host), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Authentication(struct soap *soap, ngwt__Authentication *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Authentication))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Authentication(struct soap *soap, ngwt__Authentication *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Authentication);
	if (soap_out_PointerTongwt__Authentication(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Authentication(struct soap *soap, const char *tag, int id, ngwt__Authentication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Authentication);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Authentication ** SOAP_FMAC4 soap_get_PointerTongwt__Authentication(struct soap *soap, ngwt__Authentication **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Authentication(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Authentication ** SOAP_FMAC4 soap_in_PointerTongwt__Authentication(struct soap *soap, const char *tag, ngwt__Authentication **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Authentication **)soap_malloc(soap, sizeof(ngwt__Authentication *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Authentication *)soap_instantiate_ngwt__Authentication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Authentication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Authentication, sizeof(ngwt__Authentication), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__UserList(struct soap *soap, ngwt__UserList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__UserList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__UserList(struct soap *soap, ngwt__UserList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__UserList);
	if (soap_out_PointerTongwt__UserList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__UserList(struct soap *soap, const char *tag, int id, ngwt__UserList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__UserList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__UserList ** SOAP_FMAC4 soap_get_PointerTongwt__UserList(struct soap *soap, ngwt__UserList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__UserList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__UserList ** SOAP_FMAC4 soap_in_PointerTongwt__UserList(struct soap *soap, const char *tag, ngwt__UserList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__UserList **)soap_malloc(soap, sizeof(ngwt__UserList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__UserList *)soap_instantiate_ngwt__UserList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__UserList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__UserList, sizeof(ngwt__UserList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__TimezoneList(struct soap *soap, ngwt__TimezoneList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__TimezoneList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__TimezoneList(struct soap *soap, ngwt__TimezoneList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__TimezoneList);
	if (soap_out_PointerTongwt__TimezoneList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__TimezoneList(struct soap *soap, const char *tag, int id, ngwt__TimezoneList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__TimezoneList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__TimezoneList ** SOAP_FMAC4 soap_get_PointerTongwt__TimezoneList(struct soap *soap, ngwt__TimezoneList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__TimezoneList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__TimezoneList ** SOAP_FMAC4 soap_in_PointerTongwt__TimezoneList(struct soap *soap, const char *tag, ngwt__TimezoneList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__TimezoneList **)soap_malloc(soap, sizeof(ngwt__TimezoneList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__TimezoneList *)soap_instantiate_ngwt__TimezoneList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__TimezoneList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__TimezoneList, sizeof(ngwt__TimezoneList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Signatures(struct soap *soap, ngwt__Signatures *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Signatures))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Signatures(struct soap *soap, ngwt__Signatures *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Signatures);
	if (soap_out_PointerTongwt__Signatures(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Signatures(struct soap *soap, const char *tag, int id, ngwt__Signatures *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Signatures);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Signatures ** SOAP_FMAC4 soap_get_PointerTongwt__Signatures(struct soap *soap, ngwt__Signatures **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Signatures(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Signatures ** SOAP_FMAC4 soap_in_PointerTongwt__Signatures(struct soap *soap, const char *tag, ngwt__Signatures **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Signatures **)soap_malloc(soap, sizeof(ngwt__Signatures *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Signatures *)soap_instantiate_ngwt__Signatures(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Signatures **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Signatures, sizeof(ngwt__Signatures), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Settings(struct soap *soap, ngwt__Settings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Settings))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Settings(struct soap *soap, ngwt__Settings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Settings);
	if (soap_out_PointerTongwt__Settings(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Settings(struct soap *soap, const char *tag, int id, ngwt__Settings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Settings);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Settings ** SOAP_FMAC4 soap_get_PointerTongwt__Settings(struct soap *soap, ngwt__Settings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Settings(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Settings ** SOAP_FMAC4 soap_in_PointerTongwt__Settings(struct soap *soap, const char *tag, ngwt__Settings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Settings **)soap_malloc(soap, sizeof(ngwt__Settings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Settings *)soap_instantiate_ngwt__Settings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Settings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Settings, sizeof(ngwt__Settings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__RuleList(struct soap *soap, ngwt__RuleList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__RuleList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__RuleList(struct soap *soap, ngwt__RuleList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__RuleList);
	if (soap_out_PointerTongwt__RuleList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__RuleList(struct soap *soap, const char *tag, int id, ngwt__RuleList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__RuleList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__RuleList ** SOAP_FMAC4 soap_get_PointerTongwt__RuleList(struct soap *soap, ngwt__RuleList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__RuleList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__RuleList ** SOAP_FMAC4 soap_in_PointerTongwt__RuleList(struct soap *soap, const char *tag, ngwt__RuleList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__RuleList **)soap_malloc(soap, sizeof(ngwt__RuleList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__RuleList *)soap_instantiate_ngwt__RuleList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__RuleList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RuleList, sizeof(ngwt__RuleList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ProxyList(struct soap *soap, ngwt__ProxyList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ProxyList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ProxyList(struct soap *soap, ngwt__ProxyList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ProxyList);
	if (soap_out_PointerTongwt__ProxyList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ProxyList(struct soap *soap, const char *tag, int id, ngwt__ProxyList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ProxyList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ProxyList ** SOAP_FMAC4 soap_get_PointerTongwt__ProxyList(struct soap *soap, ngwt__ProxyList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ProxyList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ProxyList ** SOAP_FMAC4 soap_in_PointerTongwt__ProxyList(struct soap *soap, const char *tag, ngwt__ProxyList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ProxyList **)soap_malloc(soap, sizeof(ngwt__ProxyList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ProxyList *)soap_instantiate_ngwt__ProxyList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ProxyList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ProxyList, sizeof(ngwt__ProxyList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AccessRightList(struct soap *soap, ngwt__AccessRightList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AccessRightList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AccessRightList(struct soap *soap, ngwt__AccessRightList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AccessRightList);
	if (soap_out_PointerTongwt__AccessRightList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AccessRightList(struct soap *soap, const char *tag, int id, ngwt__AccessRightList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AccessRightList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AccessRightList ** SOAP_FMAC4 soap_get_PointerTongwt__AccessRightList(struct soap *soap, ngwt__AccessRightList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AccessRightList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AccessRightList ** SOAP_FMAC4 soap_in_PointerTongwt__AccessRightList(struct soap *soap, const char *tag, ngwt__AccessRightList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AccessRightList **)soap_malloc(soap, sizeof(ngwt__AccessRightList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AccessRightList *)soap_instantiate_ngwt__AccessRightList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AccessRightList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessRightList, sizeof(ngwt__AccessRightList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__LibraryList(struct soap *soap, ngwt__LibraryList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__LibraryList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__LibraryList(struct soap *soap, ngwt__LibraryList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__LibraryList);
	if (soap_out_PointerTongwt__LibraryList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__LibraryList(struct soap *soap, const char *tag, int id, ngwt__LibraryList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__LibraryList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__LibraryList ** SOAP_FMAC4 soap_get_PointerTongwt__LibraryList(struct soap *soap, ngwt__LibraryList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__LibraryList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__LibraryList ** SOAP_FMAC4 soap_in_PointerTongwt__LibraryList(struct soap *soap, const char *tag, ngwt__LibraryList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__LibraryList **)soap_malloc(soap, sizeof(ngwt__LibraryList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__LibraryList *)soap_instantiate_ngwt__LibraryList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__LibraryList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__LibraryList, sizeof(ngwt__LibraryList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__SettingsList(struct soap *soap, ngwt__SettingsList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__SettingsList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__SettingsList(struct soap *soap, ngwt__SettingsList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__SettingsList);
	if (soap_out_PointerTongwt__SettingsList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__SettingsList(struct soap *soap, const char *tag, int id, ngwt__SettingsList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__SettingsList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__SettingsList ** SOAP_FMAC4 soap_get_PointerTongwt__SettingsList(struct soap *soap, ngwt__SettingsList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__SettingsList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__SettingsList ** SOAP_FMAC4 soap_in_PointerTongwt__SettingsList(struct soap *soap, const char *tag, ngwt__SettingsList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__SettingsList **)soap_malloc(soap, sizeof(ngwt__SettingsList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__SettingsList *)soap_instantiate_ngwt__SettingsList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__SettingsList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SettingsList, sizeof(ngwt__SettingsList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__JunkHandlingList(struct soap *soap, ngwt__JunkHandlingList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__JunkHandlingList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__JunkHandlingList(struct soap *soap, ngwt__JunkHandlingList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__JunkHandlingList);
	if (soap_out_PointerTongwt__JunkHandlingList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__JunkHandlingList(struct soap *soap, const char *tag, int id, ngwt__JunkHandlingList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__JunkHandlingList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__JunkHandlingList ** SOAP_FMAC4 soap_get_PointerTongwt__JunkHandlingList(struct soap *soap, ngwt__JunkHandlingList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__JunkHandlingList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__JunkHandlingList ** SOAP_FMAC4 soap_in_PointerTongwt__JunkHandlingList(struct soap *soap, const char *tag, ngwt__JunkHandlingList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__JunkHandlingList **)soap_malloc(soap, sizeof(ngwt__JunkHandlingList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__JunkHandlingList *)soap_instantiate_ngwt__JunkHandlingList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__JunkHandlingList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__JunkHandlingList, sizeof(ngwt__JunkHandlingList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FreeBusyInfoList(struct soap *soap, ngwt__FreeBusyInfoList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__FreeBusyInfoList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FreeBusyInfoList(struct soap *soap, ngwt__FreeBusyInfoList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FreeBusyInfoList);
	if (soap_out_PointerTongwt__FreeBusyInfoList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FreeBusyInfoList(struct soap *soap, const char *tag, int id, ngwt__FreeBusyInfoList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FreeBusyInfoList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__FreeBusyInfoList ** SOAP_FMAC4 soap_get_PointerTongwt__FreeBusyInfoList(struct soap *soap, ngwt__FreeBusyInfoList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FreeBusyInfoList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__FreeBusyInfoList ** SOAP_FMAC4 soap_in_PointerTongwt__FreeBusyInfoList(struct soap *soap, const char *tag, ngwt__FreeBusyInfoList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__FreeBusyInfoList **)soap_malloc(soap, sizeof(ngwt__FreeBusyInfoList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__FreeBusyInfoList *)soap_instantiate_ngwt__FreeBusyInfoList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyInfoList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyInfoList, sizeof(ngwt__FreeBusyInfoList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FreeBusyStats(struct soap *soap, ngwt__FreeBusyStats *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__FreeBusyStats))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FreeBusyStats(struct soap *soap, ngwt__FreeBusyStats *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FreeBusyStats);
	if (soap_out_PointerTongwt__FreeBusyStats(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FreeBusyStats(struct soap *soap, const char *tag, int id, ngwt__FreeBusyStats *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FreeBusyStats);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__FreeBusyStats ** SOAP_FMAC4 soap_get_PointerTongwt__FreeBusyStats(struct soap *soap, ngwt__FreeBusyStats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FreeBusyStats(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__FreeBusyStats ** SOAP_FMAC4 soap_in_PointerTongwt__FreeBusyStats(struct soap *soap, const char *tag, ngwt__FreeBusyStats **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__FreeBusyStats **)soap_malloc(soap, sizeof(ngwt__FreeBusyStats *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__FreeBusyStats *)soap_instantiate_ngwt__FreeBusyStats(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyStats **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyStats, sizeof(ngwt__FreeBusyStats), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FolderList(struct soap *soap, ngwt__FolderList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__FolderList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FolderList(struct soap *soap, ngwt__FolderList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FolderList);
	if (soap_out_PointerTongwt__FolderList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FolderList(struct soap *soap, const char *tag, int id, ngwt__FolderList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FolderList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__FolderList ** SOAP_FMAC4 soap_get_PointerTongwt__FolderList(struct soap *soap, ngwt__FolderList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FolderList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__FolderList ** SOAP_FMAC4 soap_in_PointerTongwt__FolderList(struct soap *soap, const char *tag, ngwt__FolderList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__FolderList **)soap_malloc(soap, sizeof(ngwt__FolderList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__FolderList *)soap_instantiate_ngwt__FolderList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__FolderList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FolderList, sizeof(ngwt__FolderList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ItemSourceList(struct soap *soap, enum ngwt__ItemSourceList *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__ItemSourceList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ItemSourceList(struct soap *soap, enum ngwt__ItemSourceList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ItemSourceList);
	if (soap_out_PointerTongwt__ItemSourceList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ItemSourceList(struct soap *soap, const char *tag, int id, enum ngwt__ItemSourceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ItemSourceList);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__ItemSourceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__ItemSourceList ** SOAP_FMAC4 soap_get_PointerTongwt__ItemSourceList(struct soap *soap, enum ngwt__ItemSourceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ItemSourceList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__ItemSourceList ** SOAP_FMAC4 soap_in_PointerTongwt__ItemSourceList(struct soap *soap, const char *tag, enum ngwt__ItemSourceList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__ItemSourceList **)soap_malloc(soap, sizeof(enum ngwt__ItemSourceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__ItemSourceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__ItemSourceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemSourceList, sizeof(enum ngwt__ItemSourceList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__MessageTypeList(struct soap *soap, enum ngwt__MessageTypeList *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__MessageTypeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__MessageTypeList(struct soap *soap, enum ngwt__MessageTypeList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__MessageTypeList);
	if (soap_out_PointerTongwt__MessageTypeList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__MessageTypeList(struct soap *soap, const char *tag, int id, enum ngwt__MessageTypeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__MessageTypeList);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__MessageTypeList(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__MessageTypeList ** SOAP_FMAC4 soap_get_PointerTongwt__MessageTypeList(struct soap *soap, enum ngwt__MessageTypeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__MessageTypeList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__MessageTypeList ** SOAP_FMAC4 soap_in_PointerTongwt__MessageTypeList(struct soap *soap, const char *tag, enum ngwt__MessageTypeList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__MessageTypeList **)soap_malloc(soap, sizeof(enum ngwt__MessageTypeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__MessageTypeList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__MessageTypeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__MessageTypeList, sizeof(enum ngwt__MessageTypeList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FolderType(struct soap *soap, enum ngwt__FolderType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__FolderType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FolderType(struct soap *soap, enum ngwt__FolderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FolderType);
	if (soap_out_PointerTongwt__FolderType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FolderType(struct soap *soap, const char *tag, int id, enum ngwt__FolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FolderType);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__FolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__FolderType ** SOAP_FMAC4 soap_get_PointerTongwt__FolderType(struct soap *soap, enum ngwt__FolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FolderType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__FolderType ** SOAP_FMAC4 soap_in_PointerTongwt__FolderType(struct soap *soap, const char *tag, enum ngwt__FolderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__FolderType **)soap_malloc(soap, sizeof(enum ngwt__FolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__FolderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__FolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FolderType, sizeof(enum ngwt__FolderType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__DocumentTypeList(struct soap *soap, ngwt__DocumentTypeList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__DocumentTypeList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__DocumentTypeList(struct soap *soap, ngwt__DocumentTypeList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__DocumentTypeList);
	if (soap_out_PointerTongwt__DocumentTypeList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__DocumentTypeList(struct soap *soap, const char *tag, int id, ngwt__DocumentTypeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__DocumentTypeList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__DocumentTypeList ** SOAP_FMAC4 soap_get_PointerTongwt__DocumentTypeList(struct soap *soap, ngwt__DocumentTypeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__DocumentTypeList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__DocumentTypeList ** SOAP_FMAC4 soap_in_PointerTongwt__DocumentTypeList(struct soap *soap, const char *tag, ngwt__DocumentTypeList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__DocumentTypeList **)soap_malloc(soap, sizeof(ngwt__DocumentTypeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__DocumentTypeList *)soap_instantiate_ngwt__DocumentTypeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__DocumentTypeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DocumentTypeList, sizeof(ngwt__DocumentTypeList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Items(struct soap *soap, ngwt__Items *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Items))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Items(struct soap *soap, ngwt__Items *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Items);
	if (soap_out_PointerTongwt__Items(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Items(struct soap *soap, const char *tag, int id, ngwt__Items *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Items);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Items ** SOAP_FMAC4 soap_get_PointerTongwt__Items(struct soap *soap, ngwt__Items **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Items(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Items ** SOAP_FMAC4 soap_in_PointerTongwt__Items(struct soap *soap, const char *tag, ngwt__Items **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Items **)soap_malloc(soap, sizeof(ngwt__Items *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Items *)soap_instantiate_ngwt__Items(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Items **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Items, sizeof(ngwt__Items), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__DeltaInfo(struct soap *soap, ngwt__DeltaInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__DeltaInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__DeltaInfo(struct soap *soap, ngwt__DeltaInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__DeltaInfo);
	if (soap_out_PointerTongwt__DeltaInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__DeltaInfo(struct soap *soap, const char *tag, int id, ngwt__DeltaInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__DeltaInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__DeltaInfo ** SOAP_FMAC4 soap_get_PointerTongwt__DeltaInfo(struct soap *soap, ngwt__DeltaInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__DeltaInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__DeltaInfo ** SOAP_FMAC4 soap_in_PointerTongwt__DeltaInfo(struct soap *soap, const char *tag, ngwt__DeltaInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__DeltaInfo **)soap_malloc(soap, sizeof(ngwt__DeltaInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__DeltaInfo *)soap_instantiate_ngwt__DeltaInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__DeltaInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DeltaInfo, sizeof(ngwt__DeltaInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__CustomList(struct soap *soap, ngwt__CustomList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__CustomList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__CustomList(struct soap *soap, ngwt__CustomList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__CustomList);
	if (soap_out_PointerTongwt__CustomList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__CustomList(struct soap *soap, const char *tag, int id, ngwt__CustomList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__CustomList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__CustomList ** SOAP_FMAC4 soap_get_PointerTongwt__CustomList(struct soap *soap, ngwt__CustomList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__CustomList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__CustomList ** SOAP_FMAC4 soap_in_PointerTongwt__CustomList(struct soap *soap, const char *tag, ngwt__CustomList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__CustomList **)soap_malloc(soap, sizeof(ngwt__CustomList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__CustomList *)soap_instantiate_ngwt__CustomList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__CustomList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CustomList, sizeof(ngwt__CustomList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__CategoryList(struct soap *soap, ngwt__CategoryList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__CategoryList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__CategoryList(struct soap *soap, ngwt__CategoryList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__CategoryList);
	if (soap_out_PointerTongwt__CategoryList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__CategoryList(struct soap *soap, const char *tag, int id, ngwt__CategoryList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__CategoryList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__CategoryList ** SOAP_FMAC4 soap_get_PointerTongwt__CategoryList(struct soap *soap, ngwt__CategoryList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__CategoryList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__CategoryList ** SOAP_FMAC4 soap_in_PointerTongwt__CategoryList(struct soap *soap, const char *tag, ngwt__CategoryList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__CategoryList **)soap_malloc(soap, sizeof(ngwt__CategoryList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__CategoryList *)soap_instantiate_ngwt__CategoryList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__CategoryList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CategoryList, sizeof(ngwt__CategoryList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AddressBookList(struct soap *soap, ngwt__AddressBookList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AddressBookList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AddressBookList(struct soap *soap, ngwt__AddressBookList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AddressBookList);
	if (soap_out_PointerTongwt__AddressBookList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AddressBookList(struct soap *soap, const char *tag, int id, ngwt__AddressBookList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AddressBookList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AddressBookList ** SOAP_FMAC4 soap_get_PointerTongwt__AddressBookList(struct soap *soap, ngwt__AddressBookList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AddressBookList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AddressBookList ** SOAP_FMAC4 soap_in_PointerTongwt__AddressBookList(struct soap *soap, const char *tag, ngwt__AddressBookList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AddressBookList **)soap_malloc(soap, sizeof(ngwt__AddressBookList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AddressBookList *)soap_instantiate_ngwt__AddressBookList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AddressBookList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AddressBookList, sizeof(ngwt__AddressBookList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Distribution(struct soap *soap, ngwt__Distribution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Distribution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Distribution(struct soap *soap, ngwt__Distribution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Distribution);
	if (soap_out_PointerTongwt__Distribution(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Distribution(struct soap *soap, const char *tag, int id, ngwt__Distribution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Distribution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Distribution ** SOAP_FMAC4 soap_get_PointerTongwt__Distribution(struct soap *soap, ngwt__Distribution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Distribution(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Distribution ** SOAP_FMAC4 soap_in_PointerTongwt__Distribution(struct soap *soap, const char *tag, ngwt__Distribution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Distribution **)soap_malloc(soap, sizeof(ngwt__Distribution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Distribution *)soap_instantiate_ngwt__Distribution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Distribution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Distribution, sizeof(ngwt__Distribution), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__View(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__View))
		soap_serialize_ngwt__View(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__View(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__View);
	if (soap_out_PointerTongwt__View(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__View(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__View);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__View(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTongwt__View(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__View(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTongwt__View(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__View(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__View, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Status(struct soap *soap, ngwt__Status *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Status))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Status(struct soap *soap, ngwt__Status *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Status);
	if (soap_out_PointerTongwt__Status(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Status(struct soap *soap, const char *tag, int id, ngwt__Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Status);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Status ** SOAP_FMAC4 soap_get_PointerTongwt__Status(struct soap *soap, ngwt__Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Status(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Status ** SOAP_FMAC4 soap_in_PointerTongwt__Status(struct soap *soap, const char *tag, ngwt__Status **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Status **)soap_malloc(soap, sizeof(ngwt__Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Status *)soap_instantiate_ngwt__Status(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Status, sizeof(ngwt__Status), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ItemRefList(struct soap *soap, ngwt__ItemRefList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ItemRefList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ItemRefList(struct soap *soap, ngwt__ItemRefList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ItemRefList);
	if (soap_out_PointerTongwt__ItemRefList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ItemRefList(struct soap *soap, const char *tag, int id, ngwt__ItemRefList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ItemRefList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ItemRefList ** SOAP_FMAC4 soap_get_PointerTongwt__ItemRefList(struct soap *soap, ngwt__ItemRefList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ItemRefList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ItemRefList ** SOAP_FMAC4 soap_in_PointerTongwt__ItemRefList(struct soap *soap, const char *tag, ngwt__ItemRefList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ItemRefList **)soap_malloc(soap, sizeof(ngwt__ItemRefList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ItemRefList *)soap_instantiate_ngwt__ItemRefList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ItemRefList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemRefList, sizeof(ngwt__ItemRefList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__UserInfo(struct soap *soap, ngwt__UserInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__UserInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__UserInfo(struct soap *soap, ngwt__UserInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__UserInfo);
	if (soap_out_PointerTongwt__UserInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__UserInfo(struct soap *soap, const char *tag, int id, ngwt__UserInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__UserInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__UserInfo ** SOAP_FMAC4 soap_get_PointerTongwt__UserInfo(struct soap *soap, ngwt__UserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__UserInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__UserInfo ** SOAP_FMAC4 soap_in_PointerTongwt__UserInfo(struct soap *soap, const char *tag, ngwt__UserInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__UserInfo **)soap_malloc(soap, sizeof(ngwt__UserInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__UserInfo *)soap_instantiate_ngwt__UserInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__UserInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__UserInfo, sizeof(ngwt__UserInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__RecipientType(struct soap *soap, enum ngwt__RecipientType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__RecipientType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__RecipientType(struct soap *soap, enum ngwt__RecipientType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__RecipientType);
	if (soap_out_PointerTongwt__RecipientType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__RecipientType(struct soap *soap, const char *tag, int id, enum ngwt__RecipientType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__RecipientType);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__RecipientType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__RecipientType ** SOAP_FMAC4 soap_get_PointerTongwt__RecipientType(struct soap *soap, enum ngwt__RecipientType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__RecipientType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__RecipientType ** SOAP_FMAC4 soap_in_PointerTongwt__RecipientType(struct soap *soap, const char *tag, enum ngwt__RecipientType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__RecipientType **)soap_malloc(soap, sizeof(enum ngwt__RecipientType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__RecipientType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__RecipientType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RecipientType, sizeof(enum ngwt__RecipientType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Timezone(struct soap *soap, ngwt__Timezone *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Timezone))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Timezone(struct soap *soap, ngwt__Timezone *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Timezone);
	if (soap_out_PointerTongwt__Timezone(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Timezone(struct soap *soap, const char *tag, int id, ngwt__Timezone *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Timezone);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Timezone ** SOAP_FMAC4 soap_get_PointerTongwt__Timezone(struct soap *soap, ngwt__Timezone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Timezone(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Timezone ** SOAP_FMAC4 soap_in_PointerTongwt__Timezone(struct soap *soap, const char *tag, ngwt__Timezone **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Timezone **)soap_malloc(soap, sizeof(ngwt__Timezone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Timezone *)soap_instantiate_ngwt__Timezone(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Timezone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Timezone, sizeof(ngwt__Timezone), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Minute(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__Minute);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Minute(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Minute);
	if (soap_out_PointerTongwt__Minute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Minute(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Minute);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__Minute(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTongwt__Minute(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Minute(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTongwt__Minute(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__Minute(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Minute, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Hour(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__Hour);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Hour(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Hour);
	if (soap_out_PointerTongwt__Hour(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Hour(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Hour);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__Hour(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTongwt__Hour(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Hour(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTongwt__Hour(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__Hour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Hour, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__DayOfWeek(struct soap *soap, ngwt__DayOfWeek *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__DayOfWeek))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__DayOfWeek(struct soap *soap, ngwt__DayOfWeek *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__DayOfWeek);
	if (soap_out_PointerTongwt__DayOfWeek(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__DayOfWeek(struct soap *soap, const char *tag, int id, ngwt__DayOfWeek *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__DayOfWeek);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__DayOfWeek ** SOAP_FMAC4 soap_get_PointerTongwt__DayOfWeek(struct soap *soap, ngwt__DayOfWeek **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__DayOfWeek(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__DayOfWeek ** SOAP_FMAC4 soap_in_PointerTongwt__DayOfWeek(struct soap *soap, const char *tag, ngwt__DayOfWeek **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__DayOfWeek **)soap_malloc(soap, sizeof(ngwt__DayOfWeek *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__DayOfWeek *)soap_instantiate_ngwt__DayOfWeek(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__DayOfWeek **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DayOfWeek, sizeof(ngwt__DayOfWeek), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Day(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__Day);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Day(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Day);
	if (soap_out_PointerTongwt__Day(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Day(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Day);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__Day(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTongwt__Day(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Day(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTongwt__Day(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__Day(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Day, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Month(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__Month);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Month(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Month);
	if (soap_out_PointerTongwt__Month(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Month(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Month);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__Month(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTongwt__Month(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Month(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTongwt__Month(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__Month(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Month, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__TimezoneComponent(struct soap *soap, ngwt__TimezoneComponent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__TimezoneComponent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__TimezoneComponent(struct soap *soap, ngwt__TimezoneComponent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__TimezoneComponent);
	if (soap_out_PointerTongwt__TimezoneComponent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__TimezoneComponent(struct soap *soap, const char *tag, int id, ngwt__TimezoneComponent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__TimezoneComponent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__TimezoneComponent ** SOAP_FMAC4 soap_get_PointerTongwt__TimezoneComponent(struct soap *soap, ngwt__TimezoneComponent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__TimezoneComponent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__TimezoneComponent ** SOAP_FMAC4 soap_in_PointerTongwt__TimezoneComponent(struct soap *soap, const char *tag, ngwt__TimezoneComponent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__TimezoneComponent **)soap_malloc(soap, sizeof(ngwt__TimezoneComponent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__TimezoneComponent *)soap_instantiate_ngwt__TimezoneComponent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__TimezoneComponent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__TimezoneComponent, sizeof(ngwt__TimezoneComponent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ProblemList(struct soap *soap, ngwt__ProblemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ProblemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ProblemList(struct soap *soap, ngwt__ProblemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ProblemList);
	if (soap_out_PointerTongwt__ProblemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ProblemList(struct soap *soap, const char *tag, int id, ngwt__ProblemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ProblemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ProblemList ** SOAP_FMAC4 soap_get_PointerTongwt__ProblemList(struct soap *soap, ngwt__ProblemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ProblemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ProblemList ** SOAP_FMAC4 soap_in_PointerTongwt__ProblemList(struct soap *soap, const char *tag, ngwt__ProblemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ProblemList **)soap_malloc(soap, sizeof(ngwt__ProblemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ProblemList *)soap_instantiate_ngwt__ProblemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ProblemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ProblemList, sizeof(ngwt__ProblemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Signature(struct soap *soap, ngwt__Signature *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Signature))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Signature(struct soap *soap, ngwt__Signature *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Signature);
	if (soap_out_PointerTongwt__Signature(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Signature(struct soap *soap, const char *tag, int id, ngwt__Signature *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Signature);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Signature ** SOAP_FMAC4 soap_get_PointerTongwt__Signature(struct soap *soap, ngwt__Signature **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Signature(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Signature ** SOAP_FMAC4 soap_in_PointerTongwt__Signature(struct soap *soap, const char *tag, ngwt__Signature **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Signature **)soap_malloc(soap, sizeof(ngwt__Signature *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Signature *)soap_instantiate_ngwt__Signature(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Signature **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Signature, sizeof(ngwt__Signature), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__SignatureData(struct soap *soap, ngwt__SignatureData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__SignatureData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__SignatureData(struct soap *soap, ngwt__SignatureData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__SignatureData);
	if (soap_out_PointerTongwt__SignatureData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__SignatureData(struct soap *soap, const char *tag, int id, ngwt__SignatureData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__SignatureData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__SignatureData ** SOAP_FMAC4 soap_get_PointerTongwt__SignatureData(struct soap *soap, ngwt__SignatureData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__SignatureData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__SignatureData ** SOAP_FMAC4 soap_in_PointerTongwt__SignatureData(struct soap *soap, const char *tag, ngwt__SignatureData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__SignatureData **)soap_malloc(soap, sizeof(ngwt__SignatureData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__SignatureData *)soap_instantiate_ngwt__SignatureData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__SignatureData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SignatureData, sizeof(ngwt__SignatureData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__SettingsGroup(struct soap *soap, ngwt__SettingsGroup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__SettingsGroup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__SettingsGroup(struct soap *soap, ngwt__SettingsGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__SettingsGroup);
	if (soap_out_PointerTongwt__SettingsGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__SettingsGroup(struct soap *soap, const char *tag, int id, ngwt__SettingsGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__SettingsGroup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__SettingsGroup ** SOAP_FMAC4 soap_get_PointerTongwt__SettingsGroup(struct soap *soap, ngwt__SettingsGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__SettingsGroup(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__SettingsGroup ** SOAP_FMAC4 soap_in_PointerTongwt__SettingsGroup(struct soap *soap, const char *tag, ngwt__SettingsGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__SettingsGroup **)soap_malloc(soap, sizeof(ngwt__SettingsGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__SettingsGroup *)soap_instantiate_ngwt__SettingsGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__SettingsGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SettingsGroup, sizeof(ngwt__SettingsGroup), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ReturnNotification(struct soap *soap, ngwt__ReturnNotification *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ReturnNotification))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ReturnNotification(struct soap *soap, ngwt__ReturnNotification *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ReturnNotification);
	if (soap_out_PointerTongwt__ReturnNotification(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ReturnNotification(struct soap *soap, const char *tag, int id, ngwt__ReturnNotification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ReturnNotification);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ReturnNotification ** SOAP_FMAC4 soap_get_PointerTongwt__ReturnNotification(struct soap *soap, ngwt__ReturnNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ReturnNotification(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ReturnNotification ** SOAP_FMAC4 soap_in_PointerTongwt__ReturnNotification(struct soap *soap, const char *tag, ngwt__ReturnNotification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ReturnNotification **)soap_malloc(soap, sizeof(ngwt__ReturnNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ReturnNotification *)soap_instantiate_ngwt__ReturnNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ReturnNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ReturnNotification, sizeof(ngwt__ReturnNotification), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__StatusTracking(struct soap *soap, ngwt__StatusTracking *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__StatusTracking))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__StatusTracking(struct soap *soap, ngwt__StatusTracking *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__StatusTracking);
	if (soap_out_PointerTongwt__StatusTracking(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__StatusTracking(struct soap *soap, const char *tag, int id, ngwt__StatusTracking *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__StatusTracking);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__StatusTracking ** SOAP_FMAC4 soap_get_PointerTongwt__StatusTracking(struct soap *soap, ngwt__StatusTracking **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__StatusTracking(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__StatusTracking ** SOAP_FMAC4 soap_in_PointerTongwt__StatusTracking(struct soap *soap, const char *tag, ngwt__StatusTracking **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__StatusTracking **)soap_malloc(soap, sizeof(ngwt__StatusTracking *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__StatusTracking *)soap_instantiate_ngwt__StatusTracking(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__StatusTracking **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__StatusTracking, sizeof(ngwt__StatusTracking), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__SendOptionsRequestReply(struct soap *soap, ngwt__SendOptionsRequestReply *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__SendOptionsRequestReply))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__SendOptionsRequestReply(struct soap *soap, ngwt__SendOptionsRequestReply *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__SendOptionsRequestReply);
	if (soap_out_PointerTongwt__SendOptionsRequestReply(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__SendOptionsRequestReply(struct soap *soap, const char *tag, int id, ngwt__SendOptionsRequestReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__SendOptionsRequestReply);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__SendOptionsRequestReply ** SOAP_FMAC4 soap_get_PointerTongwt__SendOptionsRequestReply(struct soap *soap, ngwt__SendOptionsRequestReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__SendOptionsRequestReply(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__SendOptionsRequestReply ** SOAP_FMAC4 soap_in_PointerTongwt__SendOptionsRequestReply(struct soap *soap, const char *tag, ngwt__SendOptionsRequestReply **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__SendOptionsRequestReply **)soap_malloc(soap, sizeof(ngwt__SendOptionsRequestReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__SendOptionsRequestReply *)soap_instantiate_ngwt__SendOptionsRequestReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__SendOptionsRequestReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SendOptionsRequestReply, sizeof(ngwt__SendOptionsRequestReply), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Rule(struct soap *soap, ngwt__Rule *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Rule))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Rule(struct soap *soap, ngwt__Rule *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Rule);
	if (soap_out_PointerTongwt__Rule(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Rule(struct soap *soap, const char *tag, int id, ngwt__Rule *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Rule);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Rule ** SOAP_FMAC4 soap_get_PointerTongwt__Rule(struct soap *soap, ngwt__Rule **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Rule(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Rule ** SOAP_FMAC4 soap_in_PointerTongwt__Rule(struct soap *soap, const char *tag, ngwt__Rule **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Rule **)soap_malloc(soap, sizeof(ngwt__Rule *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Rule *)soap_instantiate_ngwt__Rule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Rule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Rule, sizeof(ngwt__Rule), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__RuleAction(struct soap *soap, ngwt__RuleAction *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__RuleAction))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__RuleAction(struct soap *soap, ngwt__RuleAction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__RuleAction);
	if (soap_out_PointerTongwt__RuleAction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__RuleAction(struct soap *soap, const char *tag, int id, ngwt__RuleAction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__RuleAction);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__RuleAction ** SOAP_FMAC4 soap_get_PointerTongwt__RuleAction(struct soap *soap, ngwt__RuleAction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__RuleAction(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__RuleAction ** SOAP_FMAC4 soap_in_PointerTongwt__RuleAction(struct soap *soap, const char *tag, ngwt__RuleAction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__RuleAction **)soap_malloc(soap, sizeof(ngwt__RuleAction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__RuleAction *)soap_instantiate_ngwt__RuleAction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__RuleAction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RuleAction, sizeof(ngwt__RuleAction), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__CategoryRefList(struct soap *soap, ngwt__CategoryRefList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__CategoryRefList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__CategoryRefList(struct soap *soap, ngwt__CategoryRefList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__CategoryRefList);
	if (soap_out_PointerTongwt__CategoryRefList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__CategoryRefList(struct soap *soap, const char *tag, int id, ngwt__CategoryRefList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__CategoryRefList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__CategoryRefList ** SOAP_FMAC4 soap_get_PointerTongwt__CategoryRefList(struct soap *soap, ngwt__CategoryRefList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__CategoryRefList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__CategoryRefList ** SOAP_FMAC4 soap_in_PointerTongwt__CategoryRefList(struct soap *soap, const char *tag, ngwt__CategoryRefList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__CategoryRefList **)soap_malloc(soap, sizeof(ngwt__CategoryRefList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__CategoryRefList *)soap_instantiate_ngwt__CategoryRefList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__CategoryRefList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CategoryRefList, sizeof(ngwt__CategoryRefList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Mail(struct soap *soap, ngwt__Mail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Mail))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Mail(struct soap *soap, ngwt__Mail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Mail);
	if (soap_out_PointerTongwt__Mail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Mail(struct soap *soap, const char *tag, int id, ngwt__Mail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Mail);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Mail ** SOAP_FMAC4 soap_get_PointerTongwt__Mail(struct soap *soap, ngwt__Mail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Mail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Mail ** SOAP_FMAC4 soap_in_PointerTongwt__Mail(struct soap *soap, const char *tag, ngwt__Mail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Mail **)soap_malloc(soap, sizeof(ngwt__Mail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Mail *)soap_instantiate_ngwt__Mail(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Mail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Mail, sizeof(ngwt__Mail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ReturnNotificationOptions(struct soap *soap, ngwt__ReturnNotificationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ReturnNotificationOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ReturnNotificationOptions(struct soap *soap, ngwt__ReturnNotificationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ReturnNotificationOptions);
	if (soap_out_PointerTongwt__ReturnNotificationOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ReturnNotificationOptions(struct soap *soap, const char *tag, int id, ngwt__ReturnNotificationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ReturnNotificationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ReturnNotificationOptions ** SOAP_FMAC4 soap_get_PointerTongwt__ReturnNotificationOptions(struct soap *soap, ngwt__ReturnNotificationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ReturnNotificationOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ReturnNotificationOptions ** SOAP_FMAC4 soap_in_PointerTongwt__ReturnNotificationOptions(struct soap *soap, const char *tag, ngwt__ReturnNotificationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ReturnNotificationOptions **)soap_malloc(soap, sizeof(ngwt__ReturnNotificationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ReturnNotificationOptions *)soap_instantiate_ngwt__ReturnNotificationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ReturnNotificationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ReturnNotificationOptions, sizeof(ngwt__ReturnNotificationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__MonthList(struct soap *soap, ngwt__MonthList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__MonthList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__MonthList(struct soap *soap, ngwt__MonthList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__MonthList);
	if (soap_out_PointerTongwt__MonthList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__MonthList(struct soap *soap, const char *tag, int id, ngwt__MonthList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__MonthList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__MonthList ** SOAP_FMAC4 soap_get_PointerTongwt__MonthList(struct soap *soap, ngwt__MonthList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__MonthList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__MonthList ** SOAP_FMAC4 soap_in_PointerTongwt__MonthList(struct soap *soap, const char *tag, ngwt__MonthList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__MonthList **)soap_malloc(soap, sizeof(ngwt__MonthList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__MonthList *)soap_instantiate_ngwt__MonthList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__MonthList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__MonthList, sizeof(ngwt__MonthList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__DayOfYearList(struct soap *soap, ngwt__DayOfYearList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__DayOfYearList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__DayOfYearList(struct soap *soap, ngwt__DayOfYearList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__DayOfYearList);
	if (soap_out_PointerTongwt__DayOfYearList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__DayOfYearList(struct soap *soap, const char *tag, int id, ngwt__DayOfYearList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__DayOfYearList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__DayOfYearList ** SOAP_FMAC4 soap_get_PointerTongwt__DayOfYearList(struct soap *soap, ngwt__DayOfYearList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__DayOfYearList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__DayOfYearList ** SOAP_FMAC4 soap_in_PointerTongwt__DayOfYearList(struct soap *soap, const char *tag, ngwt__DayOfYearList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__DayOfYearList **)soap_malloc(soap, sizeof(ngwt__DayOfYearList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__DayOfYearList *)soap_instantiate_ngwt__DayOfYearList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__DayOfYearList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DayOfYearList, sizeof(ngwt__DayOfYearList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__DayOfMonthList(struct soap *soap, ngwt__DayOfMonthList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__DayOfMonthList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__DayOfMonthList(struct soap *soap, ngwt__DayOfMonthList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__DayOfMonthList);
	if (soap_out_PointerTongwt__DayOfMonthList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__DayOfMonthList(struct soap *soap, const char *tag, int id, ngwt__DayOfMonthList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__DayOfMonthList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__DayOfMonthList ** SOAP_FMAC4 soap_get_PointerTongwt__DayOfMonthList(struct soap *soap, ngwt__DayOfMonthList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__DayOfMonthList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__DayOfMonthList ** SOAP_FMAC4 soap_in_PointerTongwt__DayOfMonthList(struct soap *soap, const char *tag, ngwt__DayOfMonthList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__DayOfMonthList **)soap_malloc(soap, sizeof(ngwt__DayOfMonthList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__DayOfMonthList *)soap_instantiate_ngwt__DayOfMonthList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__DayOfMonthList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DayOfMonthList, sizeof(ngwt__DayOfMonthList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__DayOfYearWeekList(struct soap *soap, ngwt__DayOfYearWeekList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__DayOfYearWeekList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__DayOfYearWeekList(struct soap *soap, ngwt__DayOfYearWeekList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__DayOfYearWeekList);
	if (soap_out_PointerTongwt__DayOfYearWeekList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__DayOfYearWeekList(struct soap *soap, const char *tag, int id, ngwt__DayOfYearWeekList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__DayOfYearWeekList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__DayOfYearWeekList ** SOAP_FMAC4 soap_get_PointerTongwt__DayOfYearWeekList(struct soap *soap, ngwt__DayOfYearWeekList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__DayOfYearWeekList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__DayOfYearWeekList ** SOAP_FMAC4 soap_in_PointerTongwt__DayOfYearWeekList(struct soap *soap, const char *tag, ngwt__DayOfYearWeekList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__DayOfYearWeekList **)soap_malloc(soap, sizeof(ngwt__DayOfYearWeekList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__DayOfYearWeekList *)soap_instantiate_ngwt__DayOfYearWeekList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__DayOfYearWeekList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DayOfYearWeekList, sizeof(ngwt__DayOfYearWeekList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Frequency(struct soap *soap, enum ngwt__Frequency *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__Frequency);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Frequency(struct soap *soap, enum ngwt__Frequency *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Frequency);
	if (soap_out_PointerTongwt__Frequency(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Frequency(struct soap *soap, const char *tag, int id, enum ngwt__Frequency *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Frequency);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__Frequency(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__Frequency ** SOAP_FMAC4 soap_get_PointerTongwt__Frequency(struct soap *soap, enum ngwt__Frequency **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Frequency(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__Frequency ** SOAP_FMAC4 soap_in_PointerTongwt__Frequency(struct soap *soap, const char *tag, enum ngwt__Frequency **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__Frequency **)soap_malloc(soap, sizeof(enum ngwt__Frequency *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__Frequency(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__Frequency **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Frequency, sizeof(enum ngwt__Frequency), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__DelegateeStatus(struct soap *soap, ngwt__DelegateeStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__DelegateeStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__DelegateeStatus(struct soap *soap, ngwt__DelegateeStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__DelegateeStatus);
	if (soap_out_PointerTongwt__DelegateeStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__DelegateeStatus(struct soap *soap, const char *tag, int id, ngwt__DelegateeStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__DelegateeStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__DelegateeStatus ** SOAP_FMAC4 soap_get_PointerTongwt__DelegateeStatus(struct soap *soap, ngwt__DelegateeStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__DelegateeStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__DelegateeStatus ** SOAP_FMAC4 soap_in_PointerTongwt__DelegateeStatus(struct soap *soap, const char *tag, ngwt__DelegateeStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__DelegateeStatus **)soap_malloc(soap, sizeof(ngwt__DelegateeStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__DelegateeStatus *)soap_instantiate_ngwt__DelegateeStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__DelegateeStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DelegateeStatus, sizeof(ngwt__DelegateeStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__DelegatedStatus(struct soap *soap, ngwt__DelegatedStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__DelegatedStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__DelegatedStatus(struct soap *soap, ngwt__DelegatedStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__DelegatedStatus);
	if (soap_out_PointerTongwt__DelegatedStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__DelegatedStatus(struct soap *soap, const char *tag, int id, ngwt__DelegatedStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__DelegatedStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__DelegatedStatus ** SOAP_FMAC4 soap_get_PointerTongwt__DelegatedStatus(struct soap *soap, ngwt__DelegatedStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__DelegatedStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__DelegatedStatus ** SOAP_FMAC4 soap_in_PointerTongwt__DelegatedStatus(struct soap *soap, const char *tag, ngwt__DelegatedStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__DelegatedStatus **)soap_malloc(soap, sizeof(ngwt__DelegatedStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__DelegatedStatus *)soap_instantiate_ngwt__DelegatedStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__DelegatedStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DelegatedStatus, sizeof(ngwt__DelegatedStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__CommentStatus(struct soap *soap, ngwt__CommentStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__CommentStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__CommentStatus(struct soap *soap, ngwt__CommentStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__CommentStatus);
	if (soap_out_PointerTongwt__CommentStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__CommentStatus(struct soap *soap, const char *tag, int id, ngwt__CommentStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__CommentStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__CommentStatus ** SOAP_FMAC4 soap_get_PointerTongwt__CommentStatus(struct soap *soap, ngwt__CommentStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__CommentStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__CommentStatus ** SOAP_FMAC4 soap_in_PointerTongwt__CommentStatus(struct soap *soap, const char *tag, ngwt__CommentStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__CommentStatus **)soap_malloc(soap, sizeof(ngwt__CommentStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__CommentStatus *)soap_instantiate_ngwt__CommentStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__CommentStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CommentStatus, sizeof(ngwt__CommentStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__TransferFailedStatus(struct soap *soap, ngwt__TransferFailedStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__TransferFailedStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__TransferFailedStatus(struct soap *soap, ngwt__TransferFailedStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__TransferFailedStatus);
	if (soap_out_PointerTongwt__TransferFailedStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__TransferFailedStatus(struct soap *soap, const char *tag, int id, ngwt__TransferFailedStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__TransferFailedStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__TransferFailedStatus ** SOAP_FMAC4 soap_get_PointerTongwt__TransferFailedStatus(struct soap *soap, ngwt__TransferFailedStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__TransferFailedStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__TransferFailedStatus ** SOAP_FMAC4 soap_in_PointerTongwt__TransferFailedStatus(struct soap *soap, const char *tag, ngwt__TransferFailedStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__TransferFailedStatus **)soap_malloc(soap, sizeof(ngwt__TransferFailedStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__TransferFailedStatus *)soap_instantiate_ngwt__TransferFailedStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__TransferFailedStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__TransferFailedStatus, sizeof(ngwt__TransferFailedStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Recipient(struct soap *soap, ngwt__Recipient *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Recipient))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Recipient(struct soap *soap, ngwt__Recipient *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Recipient);
	if (soap_out_PointerTongwt__Recipient(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Recipient(struct soap *soap, const char *tag, int id, ngwt__Recipient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Recipient);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Recipient ** SOAP_FMAC4 soap_get_PointerTongwt__Recipient(struct soap *soap, ngwt__Recipient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Recipient(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Recipient ** SOAP_FMAC4 soap_in_PointerTongwt__Recipient(struct soap *soap, const char *tag, ngwt__Recipient **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Recipient **)soap_malloc(soap, sizeof(ngwt__Recipient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Recipient *)soap_instantiate_ngwt__Recipient(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Recipient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Recipient, sizeof(ngwt__Recipient), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Filter(struct soap *soap, ngwt__Filter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Filter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Filter(struct soap *soap, ngwt__Filter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Filter);
	if (soap_out_PointerTongwt__Filter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Filter(struct soap *soap, const char *tag, int id, ngwt__Filter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Filter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Filter ** SOAP_FMAC4 soap_get_PointerTongwt__Filter(struct soap *soap, ngwt__Filter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Filter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Filter ** SOAP_FMAC4 soap_in_PointerTongwt__Filter(struct soap *soap, const char *tag, ngwt__Filter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Filter **)soap_malloc(soap, sizeof(ngwt__Filter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Filter *)soap_instantiate_ngwt__Filter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Filter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Filter, sizeof(ngwt__Filter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__QueryTarget(struct soap *soap, ngwt__QueryTarget *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__QueryTarget))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__QueryTarget(struct soap *soap, ngwt__QueryTarget *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__QueryTarget);
	if (soap_out_PointerTongwt__QueryTarget(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__QueryTarget(struct soap *soap, const char *tag, int id, ngwt__QueryTarget *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__QueryTarget);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__QueryTarget ** SOAP_FMAC4 soap_get_PointerTongwt__QueryTarget(struct soap *soap, ngwt__QueryTarget **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__QueryTarget(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__QueryTarget ** SOAP_FMAC4 soap_in_PointerTongwt__QueryTarget(struct soap *soap, const char *tag, ngwt__QueryTarget **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__QueryTarget **)soap_malloc(soap, sizeof(ngwt__QueryTarget *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__QueryTarget *)soap_instantiate_ngwt__QueryTarget(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__QueryTarget **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__QueryTarget, sizeof(ngwt__QueryTarget), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ProxyUser(struct soap *soap, ngwt__ProxyUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ProxyUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ProxyUser(struct soap *soap, ngwt__ProxyUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ProxyUser);
	if (soap_out_PointerTongwt__ProxyUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ProxyUser(struct soap *soap, const char *tag, int id, ngwt__ProxyUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ProxyUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ProxyUser ** SOAP_FMAC4 soap_get_PointerTongwt__ProxyUser(struct soap *soap, ngwt__ProxyUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ProxyUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ProxyUser ** SOAP_FMAC4 soap_in_PointerTongwt__ProxyUser(struct soap *soap, const char *tag, ngwt__ProxyUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ProxyUser **)soap_malloc(soap, sizeof(ngwt__ProxyUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ProxyUser *)soap_instantiate_ngwt__ProxyUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ProxyUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ProxyUser, sizeof(ngwt__ProxyUser), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ProblemEntry(struct soap *soap, ngwt__ProblemEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ProblemEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ProblemEntry(struct soap *soap, ngwt__ProblemEntry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ProblemEntry);
	if (soap_out_PointerTongwt__ProblemEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ProblemEntry(struct soap *soap, const char *tag, int id, ngwt__ProblemEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ProblemEntry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ProblemEntry ** SOAP_FMAC4 soap_get_PointerTongwt__ProblemEntry(struct soap *soap, ngwt__ProblemEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ProblemEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ProblemEntry ** SOAP_FMAC4 soap_in_PointerTongwt__ProblemEntry(struct soap *soap, const char *tag, ngwt__ProblemEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ProblemEntry **)soap_malloc(soap, sizeof(ngwt__ProblemEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ProblemEntry *)soap_instantiate_ngwt__ProblemEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ProblemEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ProblemEntry, sizeof(ngwt__ProblemEntry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__PostalAddress(struct soap *soap, ngwt__PostalAddress *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__PostalAddress))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__PostalAddress(struct soap *soap, ngwt__PostalAddress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__PostalAddress);
	if (soap_out_PointerTongwt__PostalAddress(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__PostalAddress(struct soap *soap, const char *tag, int id, ngwt__PostalAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__PostalAddress);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__PostalAddress ** SOAP_FMAC4 soap_get_PointerTongwt__PostalAddress(struct soap *soap, ngwt__PostalAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__PostalAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__PostalAddress ** SOAP_FMAC4 soap_in_PointerTongwt__PostalAddress(struct soap *soap, const char *tag, ngwt__PostalAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__PostalAddress **)soap_malloc(soap, sizeof(ngwt__PostalAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__PostalAddress *)soap_instantiate_ngwt__PostalAddress(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__PostalAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PostalAddress, sizeof(ngwt__PostalAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__PhoneNumber(struct soap *soap, ngwt__PhoneNumber *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__PhoneNumber))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__PhoneNumber(struct soap *soap, ngwt__PhoneNumber *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__PhoneNumber);
	if (soap_out_PointerTongwt__PhoneNumber(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__PhoneNumber(struct soap *soap, const char *tag, int id, ngwt__PhoneNumber *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__PhoneNumber);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__PhoneNumber ** SOAP_FMAC4 soap_get_PointerTongwt__PhoneNumber(struct soap *soap, ngwt__PhoneNumber **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__PhoneNumber(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__PhoneNumber ** SOAP_FMAC4 soap_in_PointerTongwt__PhoneNumber(struct soap *soap, const char *tag, ngwt__PhoneNumber **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__PhoneNumber **)soap_malloc(soap, sizeof(ngwt__PhoneNumber *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__PhoneNumber *)soap_instantiate_ngwt__PhoneNumber(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__PhoneNumber **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__PhoneNumber, sizeof(ngwt__PhoneNumber), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__date(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__date))
		soap_serialize_xsd__date(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__date(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__date);
	if (soap_out_PointerToxsd__date(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__date(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__date);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__date(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__date(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__date(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__date(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__date(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__date, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ItemRef(struct soap *soap, ngwt__ItemRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ItemRef))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ItemRef(struct soap *soap, ngwt__ItemRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ItemRef);
	if (soap_out_PointerTongwt__ItemRef(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ItemRef(struct soap *soap, const char *tag, int id, ngwt__ItemRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ItemRef);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ItemRef ** SOAP_FMAC4 soap_get_PointerTongwt__ItemRef(struct soap *soap, ngwt__ItemRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ItemRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ItemRef ** SOAP_FMAC4 soap_in_PointerTongwt__ItemRef(struct soap *soap, const char *tag, ngwt__ItemRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ItemRef **)soap_malloc(soap, sizeof(ngwt__ItemRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ItemRef *)soap_instantiate_ngwt__ItemRef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ItemRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemRef, sizeof(ngwt__ItemRef), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__UUID(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__UUID))
		soap_serialize_ngwt__UUID(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__UUID(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__UUID);
	if (soap_out_PointerTongwt__UUID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__UUID(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__UUID);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__UUID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTongwt__UUID(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__UUID(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTongwt__UUID(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__UUID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__UUID, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__SharedFolderNotification(struct soap *soap, ngwt__SharedFolderNotification *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__SharedFolderNotification))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__SharedFolderNotification(struct soap *soap, ngwt__SharedFolderNotification *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__SharedFolderNotification);
	if (soap_out_PointerTongwt__SharedFolderNotification(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__SharedFolderNotification(struct soap *soap, const char *tag, int id, ngwt__SharedFolderNotification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__SharedFolderNotification);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__SharedFolderNotification ** SOAP_FMAC4 soap_get_PointerTongwt__SharedFolderNotification(struct soap *soap, ngwt__SharedFolderNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__SharedFolderNotification(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__SharedFolderNotification ** SOAP_FMAC4 soap_in_PointerTongwt__SharedFolderNotification(struct soap *soap, const char *tag, ngwt__SharedFolderNotification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__SharedFolderNotification **)soap_malloc(soap, sizeof(ngwt__SharedFolderNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__SharedFolderNotification *)soap_instantiate_ngwt__SharedFolderNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__SharedFolderNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SharedFolderNotification, sizeof(ngwt__SharedFolderNotification), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__MessagePart(struct soap *soap, ngwt__MessagePart *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__MessagePart))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__MessagePart(struct soap *soap, ngwt__MessagePart *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__MessagePart);
	if (soap_out_PointerTongwt__MessagePart(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__MessagePart(struct soap *soap, const char *tag, int id, ngwt__MessagePart *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__MessagePart);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__MessagePart ** SOAP_FMAC4 soap_get_PointerTongwt__MessagePart(struct soap *soap, ngwt__MessagePart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__MessagePart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__MessagePart ** SOAP_FMAC4 soap_in_PointerTongwt__MessagePart(struct soap *soap, const char *tag, ngwt__MessagePart **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__MessagePart **)soap_malloc(soap, sizeof(ngwt__MessagePart *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__MessagePart *)soap_instantiate_ngwt__MessagePart(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__MessagePart **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__MessagePart, sizeof(ngwt__MessagePart), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Library(struct soap *soap, ngwt__Library *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Library))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Library(struct soap *soap, ngwt__Library *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Library);
	if (soap_out_PointerTongwt__Library(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Library(struct soap *soap, const char *tag, int id, ngwt__Library *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Library);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Library ** SOAP_FMAC4 soap_get_PointerTongwt__Library(struct soap *soap, ngwt__Library **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Library(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Library ** SOAP_FMAC4 soap_in_PointerTongwt__Library(struct soap *soap, const char *tag, ngwt__Library **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Library **)soap_malloc(soap, sizeof(ngwt__Library *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Library *)soap_instantiate_ngwt__Library(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Library **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Library, sizeof(ngwt__Library), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__JunkEntry(struct soap *soap, ngwt__JunkEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__JunkEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__JunkEntry(struct soap *soap, ngwt__JunkEntry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__JunkEntry);
	if (soap_out_PointerTongwt__JunkEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__JunkEntry(struct soap *soap, const char *tag, int id, ngwt__JunkEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__JunkEntry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__JunkEntry ** SOAP_FMAC4 soap_get_PointerTongwt__JunkEntry(struct soap *soap, ngwt__JunkEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__JunkEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__JunkEntry ** SOAP_FMAC4 soap_in_PointerTongwt__JunkEntry(struct soap *soap, const char *tag, ngwt__JunkEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__JunkEntry **)soap_malloc(soap, sizeof(ngwt__JunkEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__JunkEntry *)soap_instantiate_ngwt__JunkEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__JunkEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__JunkEntry, sizeof(ngwt__JunkEntry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__JunkHandlingListType(struct soap *soap, enum ngwt__JunkHandlingListType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__JunkHandlingListType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__JunkHandlingListType(struct soap *soap, enum ngwt__JunkHandlingListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__JunkHandlingListType);
	if (soap_out_PointerTongwt__JunkHandlingListType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__JunkHandlingListType(struct soap *soap, const char *tag, int id, enum ngwt__JunkHandlingListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__JunkHandlingListType);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__JunkHandlingListType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__JunkHandlingListType ** SOAP_FMAC4 soap_get_PointerTongwt__JunkHandlingListType(struct soap *soap, enum ngwt__JunkHandlingListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__JunkHandlingListType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__JunkHandlingListType ** SOAP_FMAC4 soap_in_PointerTongwt__JunkHandlingListType(struct soap *soap, const char *tag, enum ngwt__JunkHandlingListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__JunkHandlingListType **)soap_malloc(soap, sizeof(enum ngwt__JunkHandlingListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__JunkHandlingListType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__JunkHandlingListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__JunkHandlingListType, sizeof(enum ngwt__JunkHandlingListType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Item(struct soap *soap, ngwt__Item *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Item))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Item(struct soap *soap, ngwt__Item *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Item);
	if (soap_out_PointerTongwt__Item(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Item(struct soap *soap, const char *tag, int id, ngwt__Item *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Item);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Item ** SOAP_FMAC4 soap_get_PointerTongwt__Item(struct soap *soap, ngwt__Item **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Item(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Item ** SOAP_FMAC4 soap_in_PointerTongwt__Item(struct soap *soap, const char *tag, ngwt__Item **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Item **)soap_malloc(soap, sizeof(ngwt__Item *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Item *)soap_instantiate_ngwt__Item(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Item **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Item, sizeof(ngwt__Item), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ItemChanges(struct soap *soap, ngwt__ItemChanges *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ItemChanges))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ItemChanges(struct soap *soap, ngwt__ItemChanges *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ItemChanges);
	if (soap_out_PointerTongwt__ItemChanges(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ItemChanges(struct soap *soap, const char *tag, int id, ngwt__ItemChanges *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ItemChanges);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ItemChanges ** SOAP_FMAC4 soap_get_PointerTongwt__ItemChanges(struct soap *soap, ngwt__ItemChanges **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ItemChanges(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ItemChanges ** SOAP_FMAC4 soap_in_PointerTongwt__ItemChanges(struct soap *soap, const char *tag, ngwt__ItemChanges **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ItemChanges **)soap_malloc(soap, sizeof(ngwt__ItemChanges *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ItemChanges *)soap_instantiate_ngwt__ItemChanges(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ItemChanges **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ItemChanges, sizeof(ngwt__ItemChanges), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__ImAddress(struct soap *soap, ngwt__ImAddress *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__ImAddress))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__ImAddress(struct soap *soap, ngwt__ImAddress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__ImAddress);
	if (soap_out_PointerTongwt__ImAddress(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__ImAddress(struct soap *soap, const char *tag, int id, ngwt__ImAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__ImAddress);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__ImAddress ** SOAP_FMAC4 soap_get_PointerTongwt__ImAddress(struct soap *soap, ngwt__ImAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__ImAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__ImAddress ** SOAP_FMAC4 soap_in_PointerTongwt__ImAddress(struct soap *soap, const char *tag, ngwt__ImAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__ImAddress **)soap_malloc(soap, sizeof(ngwt__ImAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__ImAddress *)soap_instantiate_ngwt__ImAddress(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__ImAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__ImAddress, sizeof(ngwt__ImAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__GroupMember(struct soap *soap, ngwt__GroupMember *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__GroupMember))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__GroupMember(struct soap *soap, ngwt__GroupMember *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__GroupMember);
	if (soap_out_PointerTongwt__GroupMember(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__GroupMember(struct soap *soap, const char *tag, int id, ngwt__GroupMember *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__GroupMember);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__GroupMember ** SOAP_FMAC4 soap_get_PointerTongwt__GroupMember(struct soap *soap, ngwt__GroupMember **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__GroupMember(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__GroupMember ** SOAP_FMAC4 soap_in_PointerTongwt__GroupMember(struct soap *soap, const char *tag, ngwt__GroupMember **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__GroupMember **)soap_malloc(soap, sizeof(ngwt__GroupMember *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__GroupMember *)soap_instantiate_ngwt__GroupMember(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__GroupMember **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__GroupMember, sizeof(ngwt__GroupMember), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__GroupMemberList(struct soap *soap, ngwt__GroupMemberList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__GroupMemberList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__GroupMemberList(struct soap *soap, ngwt__GroupMemberList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__GroupMemberList);
	if (soap_out_PointerTongwt__GroupMemberList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__GroupMemberList(struct soap *soap, const char *tag, int id, ngwt__GroupMemberList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__GroupMemberList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__GroupMemberList ** SOAP_FMAC4 soap_get_PointerTongwt__GroupMemberList(struct soap *soap, ngwt__GroupMemberList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__GroupMemberList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__GroupMemberList ** SOAP_FMAC4 soap_in_PointerTongwt__GroupMemberList(struct soap *soap, const char *tag, ngwt__GroupMemberList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__GroupMemberList **)soap_malloc(soap, sizeof(ngwt__GroupMemberList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__GroupMemberList *)soap_instantiate_ngwt__GroupMemberList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__GroupMemberList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__GroupMemberList, sizeof(ngwt__GroupMemberList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FreeBusyInfo(struct soap *soap, ngwt__FreeBusyInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__FreeBusyInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FreeBusyInfo(struct soap *soap, ngwt__FreeBusyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FreeBusyInfo);
	if (soap_out_PointerTongwt__FreeBusyInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FreeBusyInfo(struct soap *soap, const char *tag, int id, ngwt__FreeBusyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FreeBusyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__FreeBusyInfo ** SOAP_FMAC4 soap_get_PointerTongwt__FreeBusyInfo(struct soap *soap, ngwt__FreeBusyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FreeBusyInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__FreeBusyInfo ** SOAP_FMAC4 soap_in_PointerTongwt__FreeBusyInfo(struct soap *soap, const char *tag, ngwt__FreeBusyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__FreeBusyInfo **)soap_malloc(soap, sizeof(ngwt__FreeBusyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__FreeBusyInfo *)soap_instantiate_ngwt__FreeBusyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyInfo, sizeof(ngwt__FreeBusyInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__NameAndEmail(struct soap *soap, ngwt__NameAndEmail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__NameAndEmail))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__NameAndEmail(struct soap *soap, ngwt__NameAndEmail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__NameAndEmail);
	if (soap_out_PointerTongwt__NameAndEmail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__NameAndEmail(struct soap *soap, const char *tag, int id, ngwt__NameAndEmail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__NameAndEmail);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__NameAndEmail ** SOAP_FMAC4 soap_get_PointerTongwt__NameAndEmail(struct soap *soap, ngwt__NameAndEmail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__NameAndEmail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__NameAndEmail ** SOAP_FMAC4 soap_in_PointerTongwt__NameAndEmail(struct soap *soap, const char *tag, ngwt__NameAndEmail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__NameAndEmail **)soap_malloc(soap, sizeof(ngwt__NameAndEmail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__NameAndEmail *)soap_instantiate_ngwt__NameAndEmail(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__NameAndEmail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__NameAndEmail, sizeof(ngwt__NameAndEmail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AcceptLevel(struct soap *soap, enum ngwt__AcceptLevel *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__AcceptLevel);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AcceptLevel(struct soap *soap, enum ngwt__AcceptLevel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AcceptLevel);
	if (soap_out_PointerTongwt__AcceptLevel(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AcceptLevel(struct soap *soap, const char *tag, int id, enum ngwt__AcceptLevel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AcceptLevel);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__AcceptLevel(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__AcceptLevel ** SOAP_FMAC4 soap_get_PointerTongwt__AcceptLevel(struct soap *soap, enum ngwt__AcceptLevel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AcceptLevel(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__AcceptLevel ** SOAP_FMAC4 soap_in_PointerTongwt__AcceptLevel(struct soap *soap, const char *tag, enum ngwt__AcceptLevel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__AcceptLevel **)soap_malloc(soap, sizeof(enum ngwt__AcceptLevel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__AcceptLevel(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__AcceptLevel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AcceptLevel, sizeof(enum ngwt__AcceptLevel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FreeBusyBlock(struct soap *soap, ngwt__FreeBusyBlock *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__FreeBusyBlock))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FreeBusyBlock(struct soap *soap, ngwt__FreeBusyBlock *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FreeBusyBlock);
	if (soap_out_PointerTongwt__FreeBusyBlock(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FreeBusyBlock(struct soap *soap, const char *tag, int id, ngwt__FreeBusyBlock *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FreeBusyBlock);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__FreeBusyBlock ** SOAP_FMAC4 soap_get_PointerTongwt__FreeBusyBlock(struct soap *soap, ngwt__FreeBusyBlock **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FreeBusyBlock(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__FreeBusyBlock ** SOAP_FMAC4 soap_in_PointerTongwt__FreeBusyBlock(struct soap *soap, const char *tag, ngwt__FreeBusyBlock **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__FreeBusyBlock **)soap_malloc(soap, sizeof(ngwt__FreeBusyBlock *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__FreeBusyBlock *)soap_instantiate_ngwt__FreeBusyBlock(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__FreeBusyBlock **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FreeBusyBlock, sizeof(ngwt__FreeBusyBlock), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Folder(struct soap *soap, ngwt__Folder *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Folder))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Folder(struct soap *soap, ngwt__Folder *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Folder);
	if (soap_out_PointerTongwt__Folder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Folder(struct soap *soap, const char *tag, int id, ngwt__Folder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Folder);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Folder ** SOAP_FMAC4 soap_get_PointerTongwt__Folder(struct soap *soap, ngwt__Folder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Folder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Folder ** SOAP_FMAC4 soap_in_PointerTongwt__Folder(struct soap *soap, const char *tag, ngwt__Folder **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Folder **)soap_malloc(soap, sizeof(ngwt__Folder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Folder *)soap_instantiate_ngwt__Folder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Folder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Folder, sizeof(ngwt__Folder), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FolderACLEntry(struct soap *soap, ngwt__FolderACLEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__FolderACLEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FolderACLEntry(struct soap *soap, ngwt__FolderACLEntry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FolderACLEntry);
	if (soap_out_PointerTongwt__FolderACLEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FolderACLEntry(struct soap *soap, const char *tag, int id, ngwt__FolderACLEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FolderACLEntry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__FolderACLEntry ** SOAP_FMAC4 soap_get_PointerTongwt__FolderACLEntry(struct soap *soap, ngwt__FolderACLEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FolderACLEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__FolderACLEntry ** SOAP_FMAC4 soap_in_PointerTongwt__FolderACLEntry(struct soap *soap, const char *tag, ngwt__FolderACLEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__FolderACLEntry **)soap_malloc(soap, sizeof(ngwt__FolderACLEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__FolderACLEntry *)soap_instantiate_ngwt__FolderACLEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__FolderACLEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FolderACLEntry, sizeof(ngwt__FolderACLEntry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__FilterElement(struct soap *soap, ngwt__FilterElement *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__FilterElement))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__FilterElement(struct soap *soap, ngwt__FilterElement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__FilterElement);
	if (soap_out_PointerTongwt__FilterElement(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__FilterElement(struct soap *soap, const char *tag, int id, ngwt__FilterElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__FilterElement);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__FilterElement ** SOAP_FMAC4 soap_get_PointerTongwt__FilterElement(struct soap *soap, ngwt__FilterElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__FilterElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__FilterElement ** SOAP_FMAC4 soap_in_PointerTongwt__FilterElement(struct soap *soap, const char *tag, ngwt__FilterElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__FilterElement **)soap_malloc(soap, sizeof(ngwt__FilterElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__FilterElement *)soap_instantiate_ngwt__FilterElement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__FilterElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__FilterElement, sizeof(ngwt__FilterElement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__DocumentType(struct soap *soap, ngwt__DocumentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__DocumentType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__DocumentType(struct soap *soap, ngwt__DocumentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__DocumentType);
	if (soap_out_PointerTongwt__DocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__DocumentType(struct soap *soap, const char *tag, int id, ngwt__DocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__DocumentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__DocumentType ** SOAP_FMAC4 soap_get_PointerTongwt__DocumentType(struct soap *soap, ngwt__DocumentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__DocumentType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__DocumentType ** SOAP_FMAC4 soap_in_PointerTongwt__DocumentType(struct soap *soap, const char *tag, ngwt__DocumentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__DocumentType **)soap_malloc(soap, sizeof(ngwt__DocumentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__DocumentType *)soap_instantiate_ngwt__DocumentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__DocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DocumentType, sizeof(ngwt__DocumentType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AgeAction(struct soap *soap, enum ngwt__AgeAction *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__AgeAction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AgeAction(struct soap *soap, enum ngwt__AgeAction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AgeAction);
	if (soap_out_PointerTongwt__AgeAction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AgeAction(struct soap *soap, const char *tag, int id, enum ngwt__AgeAction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AgeAction);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__AgeAction(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__AgeAction ** SOAP_FMAC4 soap_get_PointerTongwt__AgeAction(struct soap *soap, enum ngwt__AgeAction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AgeAction(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__AgeAction ** SOAP_FMAC4 soap_in_PointerTongwt__AgeAction(struct soap *soap, const char *tag, enum ngwt__AgeAction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__AgeAction **)soap_malloc(soap, sizeof(enum ngwt__AgeAction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__AgeAction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__AgeAction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AgeAction, sizeof(enum ngwt__AgeAction), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__SendOptions(struct soap *soap, ngwt__SendOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__SendOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__SendOptions(struct soap *soap, ngwt__SendOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__SendOptions);
	if (soap_out_PointerTongwt__SendOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__SendOptions(struct soap *soap, const char *tag, int id, ngwt__SendOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__SendOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__SendOptions ** SOAP_FMAC4 soap_get_PointerTongwt__SendOptions(struct soap *soap, ngwt__SendOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__SendOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__SendOptions ** SOAP_FMAC4 soap_in_PointerTongwt__SendOptions(struct soap *soap, const char *tag, ngwt__SendOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__SendOptions **)soap_malloc(soap, sizeof(ngwt__SendOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__SendOptions *)soap_instantiate_ngwt__SendOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__SendOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__SendOptions, sizeof(ngwt__SendOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__RecipientList(struct soap *soap, ngwt__RecipientList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__RecipientList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__RecipientList(struct soap *soap, ngwt__RecipientList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__RecipientList);
	if (soap_out_PointerTongwt__RecipientList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__RecipientList(struct soap *soap, const char *tag, int id, ngwt__RecipientList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__RecipientList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__RecipientList ** SOAP_FMAC4 soap_get_PointerTongwt__RecipientList(struct soap *soap, ngwt__RecipientList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__RecipientList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__RecipientList ** SOAP_FMAC4 soap_in_PointerTongwt__RecipientList(struct soap *soap, const char *tag, ngwt__RecipientList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__RecipientList **)soap_malloc(soap, sizeof(ngwt__RecipientList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__RecipientList *)soap_instantiate_ngwt__RecipientList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__RecipientList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__RecipientList, sizeof(ngwt__RecipientList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__From(struct soap *soap, ngwt__From *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__From))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__From(struct soap *soap, ngwt__From *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__From);
	if (soap_out_PointerTongwt__From(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__From(struct soap *soap, const char *tag, int id, ngwt__From *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__From);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__From ** SOAP_FMAC4 soap_get_PointerTongwt__From(struct soap *soap, ngwt__From **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__From(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__From ** SOAP_FMAC4 soap_in_PointerTongwt__From(struct soap *soap, const char *tag, ngwt__From **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__From **)soap_malloc(soap, sizeof(ngwt__From *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__From *)soap_instantiate_ngwt__From(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__From **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__From, sizeof(ngwt__From), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__DayOfYearWeek(struct soap *soap, ngwt__DayOfYearWeek *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__DayOfYearWeek))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__DayOfYearWeek(struct soap *soap, ngwt__DayOfYearWeek *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__DayOfYearWeek);
	if (soap_out_PointerTongwt__DayOfYearWeek(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__DayOfYearWeek(struct soap *soap, const char *tag, int id, ngwt__DayOfYearWeek *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__DayOfYearWeek);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__DayOfYearWeek ** SOAP_FMAC4 soap_get_PointerTongwt__DayOfYearWeek(struct soap *soap, ngwt__DayOfYearWeek **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__DayOfYearWeek(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__DayOfYearWeek ** SOAP_FMAC4 soap_in_PointerTongwt__DayOfYearWeek(struct soap *soap, const char *tag, ngwt__DayOfYearWeek **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__DayOfYearWeek **)soap_malloc(soap, sizeof(ngwt__DayOfYearWeek *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__DayOfYearWeek *)soap_instantiate_ngwt__DayOfYearWeek(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__DayOfYearWeek **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__DayOfYearWeek, sizeof(ngwt__DayOfYearWeek), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Custom(struct soap *soap, ngwt__Custom *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Custom))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Custom(struct soap *soap, ngwt__Custom *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Custom);
	if (soap_out_PointerTongwt__Custom(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Custom(struct soap *soap, const char *tag, int id, ngwt__Custom *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Custom);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Custom ** SOAP_FMAC4 soap_get_PointerTongwt__Custom(struct soap *soap, ngwt__Custom **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Custom(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Custom ** SOAP_FMAC4 soap_in_PointerTongwt__Custom(struct soap *soap, const char *tag, ngwt__Custom **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Custom **)soap_malloc(soap, sizeof(ngwt__Custom *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Custom *)soap_instantiate_ngwt__Custom(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Custom **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Custom, sizeof(ngwt__Custom), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__CustomType(struct soap *soap, enum ngwt__CustomType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ngwt__CustomType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__CustomType(struct soap *soap, enum ngwt__CustomType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__CustomType);
	if (soap_out_PointerTongwt__CustomType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__CustomType(struct soap *soap, const char *tag, int id, enum ngwt__CustomType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__CustomType);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__CustomType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ngwt__CustomType ** SOAP_FMAC4 soap_get_PointerTongwt__CustomType(struct soap *soap, enum ngwt__CustomType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__CustomType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ngwt__CustomType ** SOAP_FMAC4 soap_in_PointerTongwt__CustomType(struct soap *soap, const char *tag, enum ngwt__CustomType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (enum ngwt__CustomType **)soap_malloc(soap, sizeof(enum ngwt__CustomType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__CustomType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ngwt__CustomType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__CustomType, sizeof(enum ngwt__CustomType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__uid(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__uid))
		soap_serialize_ngwt__uid(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__uid(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__uid);
	if (soap_out_PointerTongwt__uid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__uid(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__uid);
	if (id < 0)
		return soap->error;
	return soap_out_ngwt__uid(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTongwt__uid(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__uid(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTongwt__uid(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ngwt__uid(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__uid, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__Category(struct soap *soap, ngwt__Category *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__Category))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__Category(struct soap *soap, ngwt__Category *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__Category);
	if (soap_out_PointerTongwt__Category(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__Category(struct soap *soap, const char *tag, int id, ngwt__Category *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__Category);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__Category ** SOAP_FMAC4 soap_get_PointerTongwt__Category(struct soap *soap, ngwt__Category **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__Category(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__Category ** SOAP_FMAC4 soap_in_PointerTongwt__Category(struct soap *soap, const char *tag, ngwt__Category **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__Category **)soap_malloc(soap, sizeof(ngwt__Category *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__Category *)soap_instantiate_ngwt__Category(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__Category **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__Category, sizeof(ngwt__Category), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedLong(struct soap *soap, unsigned long *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedLong(struct soap *soap, unsigned long *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedLong);
	if (soap_out_PointerTounsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedLong(struct soap *soap, const char *tag, int id, unsigned long *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedLong);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedLong(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned long ** SOAP_FMAC4 soap_get_PointerTounsignedLong(struct soap *soap, unsigned long **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned long ** SOAP_FMAC4 soap_in_PointerTounsignedLong(struct soap *soap, const char *tag, unsigned long **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (unsigned long **)soap_malloc(soap, sizeof(unsigned long *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedLong(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned long **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedLong, sizeof(unsigned long), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AttachmentID(struct soap *soap, ngwt__AttachmentID *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AttachmentID))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AttachmentID(struct soap *soap, ngwt__AttachmentID *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AttachmentID);
	if (soap_out_PointerTongwt__AttachmentID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AttachmentID(struct soap *soap, const char *tag, int id, ngwt__AttachmentID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AttachmentID);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AttachmentID ** SOAP_FMAC4 soap_get_PointerTongwt__AttachmentID(struct soap *soap, ngwt__AttachmentID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AttachmentID(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AttachmentID ** SOAP_FMAC4 soap_in_PointerTongwt__AttachmentID(struct soap *soap, const char *tag, ngwt__AttachmentID **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AttachmentID **)soap_malloc(soap, sizeof(ngwt__AttachmentID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AttachmentID *)soap_instantiate_ngwt__AttachmentID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AttachmentID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AttachmentID, sizeof(ngwt__AttachmentID), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AttachmentItemInfo(struct soap *soap, ngwt__AttachmentItemInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AttachmentItemInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AttachmentItemInfo(struct soap *soap, ngwt__AttachmentItemInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AttachmentItemInfo);
	if (soap_out_PointerTongwt__AttachmentItemInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AttachmentItemInfo(struct soap *soap, const char *tag, int id, ngwt__AttachmentItemInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AttachmentItemInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AttachmentItemInfo ** SOAP_FMAC4 soap_get_PointerTongwt__AttachmentItemInfo(struct soap *soap, ngwt__AttachmentItemInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AttachmentItemInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AttachmentItemInfo ** SOAP_FMAC4 soap_in_PointerTongwt__AttachmentItemInfo(struct soap *soap, const char *tag, ngwt__AttachmentItemInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AttachmentItemInfo **)soap_malloc(soap, sizeof(ngwt__AttachmentItemInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AttachmentItemInfo *)soap_instantiate_ngwt__AttachmentItemInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AttachmentItemInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AttachmentItemInfo, sizeof(ngwt__AttachmentItemInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AddressBook(struct soap *soap, ngwt__AddressBook *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AddressBook))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AddressBook(struct soap *soap, ngwt__AddressBook *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AddressBook);
	if (soap_out_PointerTongwt__AddressBook(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AddressBook(struct soap *soap, const char *tag, int id, ngwt__AddressBook *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AddressBook);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AddressBook ** SOAP_FMAC4 soap_get_PointerTongwt__AddressBook(struct soap *soap, ngwt__AddressBook **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AddressBook(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AddressBook ** SOAP_FMAC4 soap_in_PointerTongwt__AddressBook(struct soap *soap, const char *tag, ngwt__AddressBook **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AddressBook **)soap_malloc(soap, sizeof(ngwt__AddressBook *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AddressBook *)soap_instantiate_ngwt__AddressBook(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AddressBook **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AddressBook, sizeof(ngwt__AddressBook), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AccessRightEntry(struct soap *soap, ngwt__AccessRightEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AccessRightEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AccessRightEntry(struct soap *soap, ngwt__AccessRightEntry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AccessRightEntry);
	if (soap_out_PointerTongwt__AccessRightEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AccessRightEntry(struct soap *soap, const char *tag, int id, ngwt__AccessRightEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AccessRightEntry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AccessRightEntry ** SOAP_FMAC4 soap_get_PointerTongwt__AccessRightEntry(struct soap *soap, ngwt__AccessRightEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AccessRightEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AccessRightEntry ** SOAP_FMAC4 soap_in_PointerTongwt__AccessRightEntry(struct soap *soap, const char *tag, ngwt__AccessRightEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AccessRightEntry **)soap_malloc(soap, sizeof(ngwt__AccessRightEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AccessRightEntry *)soap_instantiate_ngwt__AccessRightEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AccessRightEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessRightEntry, sizeof(ngwt__AccessRightEntry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTongwt__AccessControlListEntry(struct soap *soap, ngwt__AccessControlListEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ngwt__AccessControlListEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTongwt__AccessControlListEntry(struct soap *soap, ngwt__AccessControlListEntry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTongwt__AccessControlListEntry);
	if (soap_out_PointerTongwt__AccessControlListEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTongwt__AccessControlListEntry(struct soap *soap, const char *tag, int id, ngwt__AccessControlListEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ngwt__AccessControlListEntry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ngwt__AccessControlListEntry ** SOAP_FMAC4 soap_get_PointerTongwt__AccessControlListEntry(struct soap *soap, ngwt__AccessControlListEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTongwt__AccessControlListEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ngwt__AccessControlListEntry ** SOAP_FMAC4 soap_in_PointerTongwt__AccessControlListEntry(struct soap *soap, const char *tag, ngwt__AccessControlListEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ngwt__AccessControlListEntry **)soap_malloc(soap, sizeof(ngwt__AccessControlListEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ngwt__AccessControlListEntry *)soap_instantiate_ngwt__AccessControlListEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ngwt__AccessControlListEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ngwt__AccessControlListEntry, sizeof(ngwt__AccessControlListEntry), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__FilterElement(struct soap *soap, const std::vector<ngwt__FilterElement * >*a)
{
	for (std::vector<ngwt__FilterElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__FilterElement(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__FilterElement(struct soap *soap, std::vector<ngwt__FilterElement * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__FilterElement(struct soap *soap, const std::vector<ngwt__FilterElement * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FilterElement);
	if (soap_out_std__vectorTemplateOfPointerTongwt__FilterElement(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__FilterElement(struct soap *soap, const char *tag, int id, const std::vector<ngwt__FilterElement * >*a, const char *type)
{
	for (std::vector<ngwt__FilterElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__FilterElement(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__FilterElement * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__FilterElement(struct soap *soap, std::vector<ngwt__FilterElement * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__FilterElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__FilterElement * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__FilterElement(struct soap *soap, const char *tag, std::vector<ngwt__FilterElement * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__FilterElement(soap, -1)))
		return NULL;
	ngwt__FilterElement *n;
	ngwt__FilterElement **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__FilterElement, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FilterElement, sizeof(ngwt__FilterElement), 1))
				break;
			if (!(p = soap_in_PointerTongwt__FilterElement(soap, tag, NULL, "ngwt:FilterElement")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__FilterElement(soap, tag, &n, "ngwt:FilterElement"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__FilterElement * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__FilterElement(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__FilterElement(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__FilterElement(struct soap *soap, std::vector<ngwt__FilterElement * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__FilterElement * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__FilterElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__FilterElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FilterElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__FilterElement * >;
		if (size)
			*size = sizeof(std::vector<ngwt__FilterElement * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__FilterElement * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__FilterElement * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__FilterElement * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__FilterElement(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__FilterElement * > %p -> %p\n", q, p));
	*(std::vector<ngwt__FilterElement * >*)p = *(std::vector<ngwt__FilterElement * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__ContainerRef(struct soap *soap, const std::vector<ngwt__ContainerRef * >*a)
{
	for (std::vector<ngwt__ContainerRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__ContainerRef(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__ContainerRef(struct soap *soap, std::vector<ngwt__ContainerRef * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__ContainerRef(struct soap *soap, const std::vector<ngwt__ContainerRef * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ContainerRef);
	if (soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__ContainerRef(struct soap *soap, const char *tag, int id, const std::vector<ngwt__ContainerRef * >*a, const char *type)
{
	for (std::vector<ngwt__ContainerRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__ContainerRef(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__ContainerRef * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__ContainerRef(struct soap *soap, std::vector<ngwt__ContainerRef * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__ContainerRef * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__ContainerRef(struct soap *soap, const char *tag, std::vector<ngwt__ContainerRef * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, -1)))
		return NULL;
	ngwt__ContainerRef *n;
	ngwt__ContainerRef **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__ContainerRef, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ContainerRef, sizeof(ngwt__ContainerRef), 1))
				break;
			if (!(p = soap_in_PointerTongwt__ContainerRef(soap, tag, NULL, "ngwt:ContainerRef")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__ContainerRef(soap, tag, &n, "ngwt:ContainerRef"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__ContainerRef * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__ContainerRef(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__ContainerRef(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__ContainerRef(struct soap *soap, std::vector<ngwt__ContainerRef * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__ContainerRef * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__ContainerRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__ContainerRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ContainerRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__ContainerRef * >;
		if (size)
			*size = sizeof(std::vector<ngwt__ContainerRef * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__ContainerRef * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__ContainerRef * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__ContainerRef * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__ContainerRef(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__ContainerRef * > %p -> %p\n", q, p));
	*(std::vector<ngwt__ContainerRef * >*)p = *(std::vector<ngwt__ContainerRef * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfngwe__EventType(struct soap *soap, const std::vector<enum ngwe__EventType >*a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfngwe__EventType(struct soap *soap, std::vector<enum ngwe__EventType >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfngwe__EventType(struct soap *soap, const std::vector<enum ngwe__EventType >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfngwe__EventType);
	if (soap_out_std__vectorTemplateOfngwe__EventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfngwe__EventType(struct soap *soap, const char *tag, int id, const std::vector<enum ngwe__EventType >*a, const char *type)
{
	for (std::vector<enum ngwe__EventType >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ngwe__EventType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ngwe__EventType >* SOAP_FMAC4 soap_get_std__vectorTemplateOfngwe__EventType(struct soap *soap, std::vector<enum ngwe__EventType >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfngwe__EventType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<enum ngwe__EventType >* SOAP_FMAC4 soap_in_std__vectorTemplateOfngwe__EventType(struct soap *soap, const char *tag, std::vector<enum ngwe__EventType >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfngwe__EventType(soap, -1)))
		return NULL;
	enum ngwe__EventType n;
	enum ngwe__EventType *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwe__EventType, SOAP_TYPE_std__vectorTemplateOfngwe__EventType, sizeof(enum ngwe__EventType), 0))
				break;
			if (!(p = soap_in_ngwe__EventType(soap, tag, NULL, "")))
				break;
		}
		else
		{	soap_default_ngwe__EventType(soap, &n);
			if (!soap_in_ngwe__EventType(soap, tag, &n, ""))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<enum ngwe__EventType > * SOAP_FMAC6 soap_new_std__vectorTemplateOfngwe__EventType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfngwe__EventType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfngwe__EventType(struct soap *soap, std::vector<enum ngwe__EventType >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<enum ngwe__EventType > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfngwe__EventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfngwe__EventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfngwe__EventType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<enum ngwe__EventType >;
		if (size)
			*size = sizeof(std::vector<enum ngwe__EventType >);
	}
	else
	{	cp->ptr = (void*)new std::vector<enum ngwe__EventType >[n];
		if (size)
			*size = n * sizeof(std::vector<enum ngwe__EventType >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ngwe__EventType >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfngwe__EventType(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ngwe__EventType > %p -> %p\n", q, p));
	*(std::vector<enum ngwe__EventType >*)p = *(std::vector<enum ngwe__EventType >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwe__Events(struct soap *soap, const std::vector<ngwe__Events * >*a)
{
	for (std::vector<ngwe__Events * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwe__Events(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwe__Events(struct soap *soap, std::vector<ngwe__Events * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwe__Events(struct soap *soap, const std::vector<ngwe__Events * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Events);
	if (soap_out_std__vectorTemplateOfPointerTongwe__Events(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwe__Events(struct soap *soap, const char *tag, int id, const std::vector<ngwe__Events * >*a, const char *type)
{
	for (std::vector<ngwe__Events * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwe__Events(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwe__Events * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwe__Events(struct soap *soap, std::vector<ngwe__Events * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwe__Events(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwe__Events * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwe__Events(struct soap *soap, const char *tag, std::vector<ngwe__Events * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwe__Events(soap, -1)))
		return NULL;
	ngwe__Events *n;
	ngwe__Events **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwe__Events, SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Events, sizeof(ngwe__Events), 1))
				break;
			if (!(p = soap_in_PointerTongwe__Events(soap, tag, NULL, "ngwe:Events")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwe__Events(soap, tag, &n, "ngwe:Events"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwe__Events * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwe__Events(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwe__Events(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwe__Events(struct soap *soap, std::vector<ngwe__Events * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwe__Events * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwe__Events(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwe__Events(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Events, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwe__Events * >;
		if (size)
			*size = sizeof(std::vector<ngwe__Events * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwe__Events * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwe__Events * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwe__Events * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwe__Events(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwe__Events * > %p -> %p\n", q, p));
	*(std::vector<ngwe__Events * >*)p = *(std::vector<ngwe__Events * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwe__Event(struct soap *soap, const std::vector<ngwe__Event * >*a)
{
	for (std::vector<ngwe__Event * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwe__Event(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwe__Event(struct soap *soap, std::vector<ngwe__Event * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwe__Event(struct soap *soap, const std::vector<ngwe__Event * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Event);
	if (soap_out_std__vectorTemplateOfPointerTongwe__Event(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwe__Event(struct soap *soap, const char *tag, int id, const std::vector<ngwe__Event * >*a, const char *type)
{
	for (std::vector<ngwe__Event * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwe__Event(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwe__Event * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwe__Event(struct soap *soap, std::vector<ngwe__Event * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwe__Event(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwe__Event * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwe__Event(struct soap *soap, const char *tag, std::vector<ngwe__Event * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwe__Event(soap, -1)))
		return NULL;
	ngwe__Event *n;
	ngwe__Event **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwe__Event, SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Event, sizeof(ngwe__Event), 1))
				break;
			if (!(p = soap_in_PointerTongwe__Event(soap, tag, NULL, "ngwe:Event")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwe__Event(soap, tag, &n, "ngwe:Event"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwe__Event * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwe__Event(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwe__Event(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwe__Event(struct soap *soap, std::vector<ngwe__Event * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwe__Event * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwe__Event(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwe__Event(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwe__Event, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwe__Event * >;
		if (size)
			*size = sizeof(std::vector<ngwe__Event * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwe__Event * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwe__Event * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwe__Event * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwe__Event(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwe__Event * > %p -> %p\n", q, p));
	*(std::vector<ngwe__Event * >*)p = *(std::vector<ngwe__Event * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstring(struct soap *soap, const std::vector<char * >*a)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_string(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstring(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfstring(struct soap *soap, const std::vector<char * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfstring);
	if (soap_out_std__vectorTemplateOfstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstring(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfstring(struct soap *soap, std::vector<char * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstring(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstring(soap, -1)))
		return NULL;
	char *n;
	char **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_byte, SOAP_TYPE_std__vectorTemplateOfstring, sizeof(char), 1))
				break;
			if (!(p = soap_in_string(soap, tag, NULL, "")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_string(soap, tag, &n, ""))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<char * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstring(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstring(struct soap *soap, std::vector<char * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<char * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char * >;
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char * >[n];
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfstring(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__ModifyItem(struct soap *soap, const std::vector<ngwt__ModifyItem * >*a)
{
	for (std::vector<ngwt__ModifyItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__ModifyItem(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__ModifyItem(struct soap *soap, std::vector<ngwt__ModifyItem * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__ModifyItem(struct soap *soap, const std::vector<ngwt__ModifyItem * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ModifyItem);
	if (soap_out_std__vectorTemplateOfPointerTongwt__ModifyItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__ModifyItem(struct soap *soap, const char *tag, int id, const std::vector<ngwt__ModifyItem * >*a, const char *type)
{
	for (std::vector<ngwt__ModifyItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__ModifyItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__ModifyItem * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__ModifyItem(struct soap *soap, std::vector<ngwt__ModifyItem * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__ModifyItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__ModifyItem * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__ModifyItem(struct soap *soap, const char *tag, std::vector<ngwt__ModifyItem * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__ModifyItem(soap, -1)))
		return NULL;
	ngwt__ModifyItem *n;
	ngwt__ModifyItem **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__ModifyItem, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ModifyItem, sizeof(ngwt__ModifyItem), 1))
				break;
			if (!(p = soap_in_PointerTongwt__ModifyItem(soap, tag, NULL, "ngwt:ModifyItem")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__ModifyItem(soap, tag, &n, "ngwt:ModifyItem"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__ModifyItem * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__ModifyItem(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__ModifyItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__ModifyItem(struct soap *soap, std::vector<ngwt__ModifyItem * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__ModifyItem * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__ModifyItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__ModifyItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ModifyItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__ModifyItem * >;
		if (size)
			*size = sizeof(std::vector<ngwt__ModifyItem * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__ModifyItem * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__ModifyItem * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__ModifyItem * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__ModifyItem(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__ModifyItem * > %p -> %p\n", q, p));
	*(std::vector<ngwt__ModifyItem * >*)p = *(std::vector<ngwt__ModifyItem * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__Host(struct soap *soap, const std::vector<ngwt__Host * >*a)
{
	for (std::vector<ngwt__Host * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__Host(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__Host(struct soap *soap, std::vector<ngwt__Host * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__Host(struct soap *soap, const std::vector<ngwt__Host * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Host);
	if (soap_out_std__vectorTemplateOfPointerTongwt__Host(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__Host(struct soap *soap, const char *tag, int id, const std::vector<ngwt__Host * >*a, const char *type)
{
	for (std::vector<ngwt__Host * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__Host(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__Host * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__Host(struct soap *soap, std::vector<ngwt__Host * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__Host(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__Host * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__Host(struct soap *soap, const char *tag, std::vector<ngwt__Host * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__Host(soap, -1)))
		return NULL;
	ngwt__Host *n;
	ngwt__Host **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__Host, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Host, sizeof(ngwt__Host), 1))
				break;
			if (!(p = soap_in_PointerTongwt__Host(soap, tag, NULL, "ngwt:Host")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__Host(soap, tag, &n, "ngwt:Host"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__Host * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__Host(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__Host(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__Host(struct soap *soap, std::vector<ngwt__Host * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__Host * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__Host(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__Host(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Host, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__Host * >;
		if (size)
			*size = sizeof(std::vector<ngwt__Host * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__Host * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__Host * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__Host * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__Host(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__Host * > %p -> %p\n", q, p));
	*(std::vector<ngwt__Host * >*)p = *(std::vector<ngwt__Host * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__UserInfo(struct soap *soap, const std::vector<ngwt__UserInfo * >*a)
{
	for (std::vector<ngwt__UserInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__UserInfo(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__UserInfo(struct soap *soap, std::vector<ngwt__UserInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__UserInfo(struct soap *soap, const std::vector<ngwt__UserInfo * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__UserInfo);
	if (soap_out_std__vectorTemplateOfPointerTongwt__UserInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__UserInfo(struct soap *soap, const char *tag, int id, const std::vector<ngwt__UserInfo * >*a, const char *type)
{
	for (std::vector<ngwt__UserInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__UserInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__UserInfo * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__UserInfo(struct soap *soap, std::vector<ngwt__UserInfo * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__UserInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__UserInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__UserInfo(struct soap *soap, const char *tag, std::vector<ngwt__UserInfo * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__UserInfo(soap, -1)))
		return NULL;
	ngwt__UserInfo *n;
	ngwt__UserInfo **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__UserInfo, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__UserInfo, sizeof(ngwt__UserInfo), 1))
				break;
			if (!(p = soap_in_PointerTongwt__UserInfo(soap, tag, NULL, "ngwt:UserInfo")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__UserInfo(soap, tag, &n, "ngwt:UserInfo"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__UserInfo * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__UserInfo(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__UserInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__UserInfo(struct soap *soap, std::vector<ngwt__UserInfo * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__UserInfo * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__UserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__UserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__UserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__UserInfo * >;
		if (size)
			*size = sizeof(std::vector<ngwt__UserInfo * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__UserInfo * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__UserInfo * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__UserInfo * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__UserInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__UserInfo * > %p -> %p\n", q, p));
	*(std::vector<ngwt__UserInfo * >*)p = *(std::vector<ngwt__UserInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__Timezone(struct soap *soap, const std::vector<ngwt__Timezone * >*a)
{
	for (std::vector<ngwt__Timezone * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__Timezone(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__Timezone(struct soap *soap, std::vector<ngwt__Timezone * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__Timezone(struct soap *soap, const std::vector<ngwt__Timezone * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Timezone);
	if (soap_out_std__vectorTemplateOfPointerTongwt__Timezone(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__Timezone(struct soap *soap, const char *tag, int id, const std::vector<ngwt__Timezone * >*a, const char *type)
{
	for (std::vector<ngwt__Timezone * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__Timezone(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__Timezone * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__Timezone(struct soap *soap, std::vector<ngwt__Timezone * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__Timezone(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__Timezone * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__Timezone(struct soap *soap, const char *tag, std::vector<ngwt__Timezone * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__Timezone(soap, -1)))
		return NULL;
	ngwt__Timezone *n;
	ngwt__Timezone **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__Timezone, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Timezone, sizeof(ngwt__Timezone), 1))
				break;
			if (!(p = soap_in_PointerTongwt__Timezone(soap, tag, NULL, "ngwt:Timezone")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__Timezone(soap, tag, &n, "ngwt:Timezone"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__Timezone * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__Timezone(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__Timezone(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__Timezone(struct soap *soap, std::vector<ngwt__Timezone * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__Timezone * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__Timezone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__Timezone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Timezone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__Timezone * >;
		if (size)
			*size = sizeof(std::vector<ngwt__Timezone * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__Timezone * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__Timezone * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__Timezone * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__Timezone(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__Timezone * > %p -> %p\n", q, p));
	*(std::vector<ngwt__Timezone * >*)p = *(std::vector<ngwt__Timezone * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__Signature(struct soap *soap, const std::vector<ngwt__Signature * >*a)
{
	for (std::vector<ngwt__Signature * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__Signature(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__Signature(struct soap *soap, std::vector<ngwt__Signature * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__Signature(struct soap *soap, const std::vector<ngwt__Signature * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Signature);
	if (soap_out_std__vectorTemplateOfPointerTongwt__Signature(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__Signature(struct soap *soap, const char *tag, int id, const std::vector<ngwt__Signature * >*a, const char *type)
{
	for (std::vector<ngwt__Signature * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__Signature(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__Signature * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__Signature(struct soap *soap, std::vector<ngwt__Signature * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__Signature(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__Signature * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__Signature(struct soap *soap, const char *tag, std::vector<ngwt__Signature * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__Signature(soap, -1)))
		return NULL;
	ngwt__Signature *n;
	ngwt__Signature **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__Signature, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Signature, sizeof(ngwt__Signature), 1))
				break;
			if (!(p = soap_in_PointerTongwt__Signature(soap, tag, NULL, "ngwt:Signature")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__Signature(soap, tag, &n, "ngwt:Signature"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__Signature * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__Signature(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__Signature(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__Signature(struct soap *soap, std::vector<ngwt__Signature * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__Signature * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__Signature(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__Signature(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Signature, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__Signature * >;
		if (size)
			*size = sizeof(std::vector<ngwt__Signature * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__Signature * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__Signature * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__Signature * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__Signature(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__Signature * > %p -> %p\n", q, p));
	*(std::vector<ngwt__Signature * >*)p = *(std::vector<ngwt__Signature * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__SettingsGroup(struct soap *soap, const std::vector<ngwt__SettingsGroup * >*a)
{
	for (std::vector<ngwt__SettingsGroup * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__SettingsGroup(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__SettingsGroup(struct soap *soap, std::vector<ngwt__SettingsGroup * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__SettingsGroup(struct soap *soap, const std::vector<ngwt__SettingsGroup * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__SettingsGroup);
	if (soap_out_std__vectorTemplateOfPointerTongwt__SettingsGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__SettingsGroup(struct soap *soap, const char *tag, int id, const std::vector<ngwt__SettingsGroup * >*a, const char *type)
{
	for (std::vector<ngwt__SettingsGroup * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__SettingsGroup(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__SettingsGroup * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__SettingsGroup(struct soap *soap, std::vector<ngwt__SettingsGroup * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__SettingsGroup(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__SettingsGroup * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__SettingsGroup(struct soap *soap, const char *tag, std::vector<ngwt__SettingsGroup * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__SettingsGroup(soap, -1)))
		return NULL;
	ngwt__SettingsGroup *n;
	ngwt__SettingsGroup **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__SettingsGroup, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__SettingsGroup, sizeof(ngwt__SettingsGroup), 1))
				break;
			if (!(p = soap_in_PointerTongwt__SettingsGroup(soap, tag, NULL, "ngwt:SettingsGroup")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__SettingsGroup(soap, tag, &n, "ngwt:SettingsGroup"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__SettingsGroup * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__SettingsGroup(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__SettingsGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__SettingsGroup(struct soap *soap, std::vector<ngwt__SettingsGroup * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__SettingsGroup * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__SettingsGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__SettingsGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__SettingsGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__SettingsGroup * >;
		if (size)
			*size = sizeof(std::vector<ngwt__SettingsGroup * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__SettingsGroup * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__SettingsGroup * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__SettingsGroup * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__SettingsGroup(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__SettingsGroup * > %p -> %p\n", q, p));
	*(std::vector<ngwt__SettingsGroup * >*)p = *(std::vector<ngwt__SettingsGroup * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__Rule(struct soap *soap, const std::vector<ngwt__Rule * >*a)
{
	for (std::vector<ngwt__Rule * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__Rule(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__Rule(struct soap *soap, std::vector<ngwt__Rule * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__Rule(struct soap *soap, const std::vector<ngwt__Rule * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Rule);
	if (soap_out_std__vectorTemplateOfPointerTongwt__Rule(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__Rule(struct soap *soap, const char *tag, int id, const std::vector<ngwt__Rule * >*a, const char *type)
{
	for (std::vector<ngwt__Rule * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__Rule(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__Rule * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__Rule(struct soap *soap, std::vector<ngwt__Rule * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__Rule(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__Rule * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__Rule(struct soap *soap, const char *tag, std::vector<ngwt__Rule * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__Rule(soap, -1)))
		return NULL;
	ngwt__Rule *n;
	ngwt__Rule **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__Rule, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Rule, sizeof(ngwt__Rule), 1))
				break;
			if (!(p = soap_in_PointerTongwt__Rule(soap, tag, NULL, "ngwt:Rule")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__Rule(soap, tag, &n, "ngwt:Rule"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__Rule * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__Rule(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__Rule(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__Rule(struct soap *soap, std::vector<ngwt__Rule * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__Rule * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__Rule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__Rule(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Rule, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__Rule * >;
		if (size)
			*size = sizeof(std::vector<ngwt__Rule * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__Rule * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__Rule * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__Rule * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__Rule(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__Rule * > %p -> %p\n", q, p));
	*(std::vector<ngwt__Rule * >*)p = *(std::vector<ngwt__Rule * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__RuleAction(struct soap *soap, const std::vector<ngwt__RuleAction * >*a)
{
	for (std::vector<ngwt__RuleAction * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__RuleAction(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__RuleAction(struct soap *soap, std::vector<ngwt__RuleAction * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__RuleAction(struct soap *soap, const std::vector<ngwt__RuleAction * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__RuleAction);
	if (soap_out_std__vectorTemplateOfPointerTongwt__RuleAction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__RuleAction(struct soap *soap, const char *tag, int id, const std::vector<ngwt__RuleAction * >*a, const char *type)
{
	for (std::vector<ngwt__RuleAction * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__RuleAction(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__RuleAction * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__RuleAction(struct soap *soap, std::vector<ngwt__RuleAction * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__RuleAction(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__RuleAction * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__RuleAction(struct soap *soap, const char *tag, std::vector<ngwt__RuleAction * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__RuleAction(soap, -1)))
		return NULL;
	ngwt__RuleAction *n;
	ngwt__RuleAction **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__RuleAction, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__RuleAction, sizeof(ngwt__RuleAction), 1))
				break;
			if (!(p = soap_in_PointerTongwt__RuleAction(soap, tag, NULL, "ngwt:RuleAction")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__RuleAction(soap, tag, &n, "ngwt:RuleAction"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__RuleAction * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__RuleAction(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__RuleAction(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__RuleAction(struct soap *soap, std::vector<ngwt__RuleAction * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__RuleAction * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__RuleAction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__RuleAction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__RuleAction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__RuleAction * >;
		if (size)
			*size = sizeof(std::vector<ngwt__RuleAction * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__RuleAction * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__RuleAction * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__RuleAction * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__RuleAction(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__RuleAction * > %p -> %p\n", q, p));
	*(std::vector<ngwt__RuleAction * >*)p = *(std::vector<ngwt__RuleAction * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__date(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__date(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__date(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfxsd__date(struct soap *soap, const std::vector<std::string >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfxsd__date);
	if (soap_out_std__vectorTemplateOfxsd__date(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__date(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__date(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_get_std__vectorTemplateOfxsd__date(struct soap *soap, std::vector<std::string >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfxsd__date(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__date(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfxsd__date(soap, -1)))
		return NULL;
	std::string n;
	std::string *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_xsd__date, SOAP_TYPE_std__vectorTemplateOfxsd__date, sizeof(std::string), 0))
				break;
			if (!(p = soap_in_xsd__date(soap, tag, NULL, "xsd:date")))
				break;
		}
		else
		{	soap_default_xsd__date(soap, &n);
			if (!soap_in_xsd__date(soap, tag, &n, "xsd:date"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfxsd__date(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfxsd__date(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfxsd__date(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfxsd__date(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__date(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__date, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfxsd__date(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__DelegateeStatus(struct soap *soap, const std::vector<ngwt__DelegateeStatus * >*a)
{
	for (std::vector<ngwt__DelegateeStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__DelegateeStatus(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__DelegateeStatus(struct soap *soap, std::vector<ngwt__DelegateeStatus * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__DelegateeStatus(struct soap *soap, const std::vector<ngwt__DelegateeStatus * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DelegateeStatus);
	if (soap_out_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__DelegateeStatus(struct soap *soap, const char *tag, int id, const std::vector<ngwt__DelegateeStatus * >*a, const char *type)
{
	for (std::vector<ngwt__DelegateeStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__DelegateeStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__DelegateeStatus * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__DelegateeStatus(struct soap *soap, std::vector<ngwt__DelegateeStatus * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__DelegateeStatus * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__DelegateeStatus(struct soap *soap, const char *tag, std::vector<ngwt__DelegateeStatus * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, -1)))
		return NULL;
	ngwt__DelegateeStatus *n;
	ngwt__DelegateeStatus **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__DelegateeStatus, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DelegateeStatus, sizeof(ngwt__DelegateeStatus), 1))
				break;
			if (!(p = soap_in_PointerTongwt__DelegateeStatus(soap, tag, NULL, "ngwt:DelegateeStatus")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__DelegateeStatus(soap, tag, &n, "ngwt:DelegateeStatus"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__DelegateeStatus * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__DelegateeStatus(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__DelegateeStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__DelegateeStatus(struct soap *soap, std::vector<ngwt__DelegateeStatus * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__DelegateeStatus * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__DelegateeStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__DelegateeStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DelegateeStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__DelegateeStatus * >;
		if (size)
			*size = sizeof(std::vector<ngwt__DelegateeStatus * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__DelegateeStatus * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__DelegateeStatus * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__DelegateeStatus * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__DelegateeStatus(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__DelegateeStatus * > %p -> %p\n", q, p));
	*(std::vector<ngwt__DelegateeStatus * >*)p = *(std::vector<ngwt__DelegateeStatus * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__Recipient(struct soap *soap, const std::vector<ngwt__Recipient * >*a)
{
	for (std::vector<ngwt__Recipient * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__Recipient(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__Recipient(struct soap *soap, std::vector<ngwt__Recipient * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__Recipient(struct soap *soap, const std::vector<ngwt__Recipient * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Recipient);
	if (soap_out_std__vectorTemplateOfPointerTongwt__Recipient(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__Recipient(struct soap *soap, const char *tag, int id, const std::vector<ngwt__Recipient * >*a, const char *type)
{
	for (std::vector<ngwt__Recipient * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__Recipient(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__Recipient * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__Recipient(struct soap *soap, std::vector<ngwt__Recipient * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__Recipient(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__Recipient * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__Recipient(struct soap *soap, const char *tag, std::vector<ngwt__Recipient * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__Recipient(soap, -1)))
		return NULL;
	ngwt__Recipient *n;
	ngwt__Recipient **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__Recipient, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Recipient, sizeof(ngwt__Recipient), 1))
				break;
			if (!(p = soap_in_PointerTongwt__Recipient(soap, tag, NULL, "ngwt:Recipient")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__Recipient(soap, tag, &n, "ngwt:Recipient"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__Recipient * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__Recipient(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__Recipient(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__Recipient(struct soap *soap, std::vector<ngwt__Recipient * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__Recipient * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__Recipient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__Recipient(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Recipient, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__Recipient * >;
		if (size)
			*size = sizeof(std::vector<ngwt__Recipient * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__Recipient * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__Recipient * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__Recipient * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__Recipient(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__Recipient * > %p -> %p\n", q, p));
	*(std::vector<ngwt__Recipient * >*)p = *(std::vector<ngwt__Recipient * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__ProxyUser(struct soap *soap, const std::vector<ngwt__ProxyUser * >*a)
{
	for (std::vector<ngwt__ProxyUser * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__ProxyUser(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__ProxyUser(struct soap *soap, std::vector<ngwt__ProxyUser * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__ProxyUser(struct soap *soap, const std::vector<ngwt__ProxyUser * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProxyUser);
	if (soap_out_std__vectorTemplateOfPointerTongwt__ProxyUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__ProxyUser(struct soap *soap, const char *tag, int id, const std::vector<ngwt__ProxyUser * >*a, const char *type)
{
	for (std::vector<ngwt__ProxyUser * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__ProxyUser(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__ProxyUser * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__ProxyUser(struct soap *soap, std::vector<ngwt__ProxyUser * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__ProxyUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__ProxyUser * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__ProxyUser(struct soap *soap, const char *tag, std::vector<ngwt__ProxyUser * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__ProxyUser(soap, -1)))
		return NULL;
	ngwt__ProxyUser *n;
	ngwt__ProxyUser **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__ProxyUser, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProxyUser, sizeof(ngwt__ProxyUser), 1))
				break;
			if (!(p = soap_in_PointerTongwt__ProxyUser(soap, tag, NULL, "ngwt:ProxyUser")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__ProxyUser(soap, tag, &n, "ngwt:ProxyUser"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__ProxyUser * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__ProxyUser(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__ProxyUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__ProxyUser(struct soap *soap, std::vector<ngwt__ProxyUser * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__ProxyUser * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__ProxyUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__ProxyUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProxyUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__ProxyUser * >;
		if (size)
			*size = sizeof(std::vector<ngwt__ProxyUser * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__ProxyUser * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__ProxyUser * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__ProxyUser * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__ProxyUser(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__ProxyUser * > %p -> %p\n", q, p));
	*(std::vector<ngwt__ProxyUser * >*)p = *(std::vector<ngwt__ProxyUser * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__ProblemEntry(struct soap *soap, const std::vector<ngwt__ProblemEntry * >*a)
{
	for (std::vector<ngwt__ProblemEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__ProblemEntry(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__ProblemEntry(struct soap *soap, std::vector<ngwt__ProblemEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__ProblemEntry(struct soap *soap, const std::vector<ngwt__ProblemEntry * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProblemEntry);
	if (soap_out_std__vectorTemplateOfPointerTongwt__ProblemEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__ProblemEntry(struct soap *soap, const char *tag, int id, const std::vector<ngwt__ProblemEntry * >*a, const char *type)
{
	for (std::vector<ngwt__ProblemEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__ProblemEntry(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__ProblemEntry * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__ProblemEntry(struct soap *soap, std::vector<ngwt__ProblemEntry * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__ProblemEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__ProblemEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__ProblemEntry(struct soap *soap, const char *tag, std::vector<ngwt__ProblemEntry * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__ProblemEntry(soap, -1)))
		return NULL;
	ngwt__ProblemEntry *n;
	ngwt__ProblemEntry **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__ProblemEntry, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProblemEntry, sizeof(ngwt__ProblemEntry), 1))
				break;
			if (!(p = soap_in_PointerTongwt__ProblemEntry(soap, tag, NULL, "ngwt:ProblemEntry")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__ProblemEntry(soap, tag, &n, "ngwt:ProblemEntry"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__ProblemEntry * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__ProblemEntry(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__ProblemEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__ProblemEntry(struct soap *soap, std::vector<ngwt__ProblemEntry * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__ProblemEntry * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__ProblemEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__ProblemEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ProblemEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__ProblemEntry * >;
		if (size)
			*size = sizeof(std::vector<ngwt__ProblemEntry * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__ProblemEntry * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__ProblemEntry * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__ProblemEntry * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__ProblemEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__ProblemEntry * > %p -> %p\n", q, p));
	*(std::vector<ngwt__ProblemEntry * >*)p = *(std::vector<ngwt__ProblemEntry * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__PostalAddress(struct soap *soap, const std::vector<ngwt__PostalAddress * >*a)
{
	for (std::vector<ngwt__PostalAddress * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__PostalAddress(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__PostalAddress(struct soap *soap, std::vector<ngwt__PostalAddress * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__PostalAddress(struct soap *soap, const std::vector<ngwt__PostalAddress * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PostalAddress);
	if (soap_out_std__vectorTemplateOfPointerTongwt__PostalAddress(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__PostalAddress(struct soap *soap, const char *tag, int id, const std::vector<ngwt__PostalAddress * >*a, const char *type)
{
	for (std::vector<ngwt__PostalAddress * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__PostalAddress(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__PostalAddress * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__PostalAddress(struct soap *soap, std::vector<ngwt__PostalAddress * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__PostalAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__PostalAddress * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__PostalAddress(struct soap *soap, const char *tag, std::vector<ngwt__PostalAddress * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__PostalAddress(soap, -1)))
		return NULL;
	ngwt__PostalAddress *n;
	ngwt__PostalAddress **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__PostalAddress, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PostalAddress, sizeof(ngwt__PostalAddress), 1))
				break;
			if (!(p = soap_in_PointerTongwt__PostalAddress(soap, tag, NULL, "ngwt:PostalAddress")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__PostalAddress(soap, tag, &n, "ngwt:PostalAddress"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__PostalAddress * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__PostalAddress(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__PostalAddress(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__PostalAddress(struct soap *soap, std::vector<ngwt__PostalAddress * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__PostalAddress * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__PostalAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__PostalAddress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PostalAddress, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__PostalAddress * >;
		if (size)
			*size = sizeof(std::vector<ngwt__PostalAddress * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__PostalAddress * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__PostalAddress * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__PostalAddress * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__PostalAddress(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__PostalAddress * > %p -> %p\n", q, p));
	*(std::vector<ngwt__PostalAddress * >*)p = *(std::vector<ngwt__PostalAddress * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__PhoneNumber(struct soap *soap, const std::vector<ngwt__PhoneNumber * >*a)
{
	for (std::vector<ngwt__PhoneNumber * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__PhoneNumber(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__PhoneNumber(struct soap *soap, std::vector<ngwt__PhoneNumber * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__PhoneNumber(struct soap *soap, const std::vector<ngwt__PhoneNumber * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PhoneNumber);
	if (soap_out_std__vectorTemplateOfPointerTongwt__PhoneNumber(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__PhoneNumber(struct soap *soap, const char *tag, int id, const std::vector<ngwt__PhoneNumber * >*a, const char *type)
{
	for (std::vector<ngwt__PhoneNumber * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__PhoneNumber(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__PhoneNumber * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__PhoneNumber(struct soap *soap, std::vector<ngwt__PhoneNumber * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__PhoneNumber(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__PhoneNumber * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__PhoneNumber(struct soap *soap, const char *tag, std::vector<ngwt__PhoneNumber * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__PhoneNumber(soap, -1)))
		return NULL;
	ngwt__PhoneNumber *n;
	ngwt__PhoneNumber **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__PhoneNumber, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PhoneNumber, sizeof(ngwt__PhoneNumber), 1))
				break;
			if (!(p = soap_in_PointerTongwt__PhoneNumber(soap, tag, NULL, "ngwt:PhoneNumber")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__PhoneNumber(soap, tag, &n, "ngwt:PhoneNumber"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__PhoneNumber * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__PhoneNumber(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__PhoneNumber(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__PhoneNumber(struct soap *soap, std::vector<ngwt__PhoneNumber * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__PhoneNumber * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__PhoneNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__PhoneNumber(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__PhoneNumber, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__PhoneNumber * >;
		if (size)
			*size = sizeof(std::vector<ngwt__PhoneNumber * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__PhoneNumber * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__PhoneNumber * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__PhoneNumber * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__PhoneNumber(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__PhoneNumber * > %p -> %p\n", q, p));
	*(std::vector<ngwt__PhoneNumber * >*)p = *(std::vector<ngwt__PhoneNumber * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfngwt__Month(struct soap *soap, const std::vector<unsigned char >*a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfngwt__Month(struct soap *soap, std::vector<unsigned char >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfngwt__Month(struct soap *soap, const std::vector<unsigned char >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfngwt__Month);
	if (soap_out_std__vectorTemplateOfngwt__Month(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfngwt__Month(struct soap *soap, const char *tag, int id, const std::vector<unsigned char >*a, const char *type)
{
	for (std::vector<unsigned char >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ngwt__Month(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<unsigned char >* SOAP_FMAC4 soap_get_std__vectorTemplateOfngwt__Month(struct soap *soap, std::vector<unsigned char >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfngwt__Month(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<unsigned char >* SOAP_FMAC4 soap_in_std__vectorTemplateOfngwt__Month(struct soap *soap, const char *tag, std::vector<unsigned char >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfngwt__Month(soap, -1)))
		return NULL;
	unsigned char n;
	unsigned char *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__Month, SOAP_TYPE_std__vectorTemplateOfngwt__Month, sizeof(unsigned char), 0))
				break;
			if (!(p = soap_in_ngwt__Month(soap, tag, NULL, "ngwt:Month")))
				break;
		}
		else
		{	soap_default_ngwt__Month(soap, &n);
			if (!soap_in_ngwt__Month(soap, tag, &n, "ngwt:Month"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<unsigned char > * SOAP_FMAC6 soap_new_std__vectorTemplateOfngwt__Month(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfngwt__Month(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfngwt__Month(struct soap *soap, std::vector<unsigned char >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<unsigned char > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfngwt__Month(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfngwt__Month(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfngwt__Month, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<unsigned char >;
		if (size)
			*size = sizeof(std::vector<unsigned char >);
	}
	else
	{	cp->ptr = (void*)new std::vector<unsigned char >[n];
		if (size)
			*size = n * sizeof(std::vector<unsigned char >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<unsigned char >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfngwt__Month(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<unsigned char > %p -> %p\n", q, p));
	*(std::vector<unsigned char >*)p = *(std::vector<unsigned char >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__MessagePart(struct soap *soap, const std::vector<ngwt__MessagePart * >*a)
{
	for (std::vector<ngwt__MessagePart * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__MessagePart(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__MessagePart(struct soap *soap, std::vector<ngwt__MessagePart * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__MessagePart(struct soap *soap, const std::vector<ngwt__MessagePart * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__MessagePart);
	if (soap_out_std__vectorTemplateOfPointerTongwt__MessagePart(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__MessagePart(struct soap *soap, const char *tag, int id, const std::vector<ngwt__MessagePart * >*a, const char *type)
{
	for (std::vector<ngwt__MessagePart * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__MessagePart(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__MessagePart * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__MessagePart(struct soap *soap, std::vector<ngwt__MessagePart * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__MessagePart(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__MessagePart * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__MessagePart(struct soap *soap, const char *tag, std::vector<ngwt__MessagePart * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__MessagePart(soap, -1)))
		return NULL;
	ngwt__MessagePart *n;
	ngwt__MessagePart **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__MessagePart, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__MessagePart, sizeof(ngwt__MessagePart), 1))
				break;
			if (!(p = soap_in_PointerTongwt__MessagePart(soap, tag, NULL, "ngwt:MessagePart")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__MessagePart(soap, tag, &n, "ngwt:MessagePart"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__MessagePart * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__MessagePart(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__MessagePart(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__MessagePart(struct soap *soap, std::vector<ngwt__MessagePart * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__MessagePart * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__MessagePart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__MessagePart(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__MessagePart, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__MessagePart * >;
		if (size)
			*size = sizeof(std::vector<ngwt__MessagePart * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__MessagePart * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__MessagePart * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__MessagePart * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__MessagePart(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__MessagePart * > %p -> %p\n", q, p));
	*(std::vector<ngwt__MessagePart * >*)p = *(std::vector<ngwt__MessagePart * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__Library(struct soap *soap, const std::vector<ngwt__Library * >*a)
{
	for (std::vector<ngwt__Library * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__Library(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__Library(struct soap *soap, std::vector<ngwt__Library * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__Library(struct soap *soap, const std::vector<ngwt__Library * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Library);
	if (soap_out_std__vectorTemplateOfPointerTongwt__Library(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__Library(struct soap *soap, const char *tag, int id, const std::vector<ngwt__Library * >*a, const char *type)
{
	for (std::vector<ngwt__Library * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__Library(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__Library * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__Library(struct soap *soap, std::vector<ngwt__Library * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__Library(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__Library * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__Library(struct soap *soap, const char *tag, std::vector<ngwt__Library * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__Library(soap, -1)))
		return NULL;
	ngwt__Library *n;
	ngwt__Library **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__Library, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Library, sizeof(ngwt__Library), 1))
				break;
			if (!(p = soap_in_PointerTongwt__Library(soap, tag, NULL, "ngwt:Library")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__Library(soap, tag, &n, "ngwt:Library"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__Library * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__Library(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__Library(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__Library(struct soap *soap, std::vector<ngwt__Library * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__Library * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__Library(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__Library(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Library, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__Library * >;
		if (size)
			*size = sizeof(std::vector<ngwt__Library * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__Library * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__Library * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__Library * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__Library(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__Library * > %p -> %p\n", q, p));
	*(std::vector<ngwt__Library * >*)p = *(std::vector<ngwt__Library * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__JunkEntry(struct soap *soap, const std::vector<ngwt__JunkEntry * >*a)
{
	for (std::vector<ngwt__JunkEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__JunkEntry(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__JunkEntry(struct soap *soap, std::vector<ngwt__JunkEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__JunkEntry(struct soap *soap, const std::vector<ngwt__JunkEntry * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__JunkEntry);
	if (soap_out_std__vectorTemplateOfPointerTongwt__JunkEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__JunkEntry(struct soap *soap, const char *tag, int id, const std::vector<ngwt__JunkEntry * >*a, const char *type)
{
	for (std::vector<ngwt__JunkEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__JunkEntry(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__JunkEntry * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__JunkEntry(struct soap *soap, std::vector<ngwt__JunkEntry * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__JunkEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__JunkEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__JunkEntry(struct soap *soap, const char *tag, std::vector<ngwt__JunkEntry * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__JunkEntry(soap, -1)))
		return NULL;
	ngwt__JunkEntry *n;
	ngwt__JunkEntry **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__JunkEntry, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__JunkEntry, sizeof(ngwt__JunkEntry), 1))
				break;
			if (!(p = soap_in_PointerTongwt__JunkEntry(soap, tag, NULL, "ngwt:JunkEntry")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__JunkEntry(soap, tag, &n, "ngwt:JunkEntry"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__JunkEntry * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__JunkEntry(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__JunkEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__JunkEntry(struct soap *soap, std::vector<ngwt__JunkEntry * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__JunkEntry * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__JunkEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__JunkEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__JunkEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__JunkEntry * >;
		if (size)
			*size = sizeof(std::vector<ngwt__JunkEntry * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__JunkEntry * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__JunkEntry * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__JunkEntry * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__JunkEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__JunkEntry * > %p -> %p\n", q, p));
	*(std::vector<ngwt__JunkEntry * >*)p = *(std::vector<ngwt__JunkEntry * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__Item(struct soap *soap, const std::vector<ngwt__Item * >*a)
{
	for (std::vector<ngwt__Item * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__Item(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__Item(struct soap *soap, std::vector<ngwt__Item * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__Item(struct soap *soap, const std::vector<ngwt__Item * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Item);
	if (soap_out_std__vectorTemplateOfPointerTongwt__Item(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__Item(struct soap *soap, const char *tag, int id, const std::vector<ngwt__Item * >*a, const char *type)
{
	for (std::vector<ngwt__Item * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__Item(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__Item * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__Item(struct soap *soap, std::vector<ngwt__Item * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__Item(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__Item * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__Item(struct soap *soap, const char *tag, std::vector<ngwt__Item * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__Item(soap, -1)))
		return NULL;
	ngwt__Item *n;
	ngwt__Item **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__Item, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Item, sizeof(ngwt__Item), 1))
				break;
			if (!(p = soap_in_PointerTongwt__Item(soap, tag, NULL, "ngwt:Item")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__Item(soap, tag, &n, "ngwt:Item"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__Item * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__Item(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__Item(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__Item(struct soap *soap, std::vector<ngwt__Item * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__Item * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__Item(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__Item(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Item, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__Item * >;
		if (size)
			*size = sizeof(std::vector<ngwt__Item * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__Item * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__Item * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__Item * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__Item(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__Item * > %p -> %p\n", q, p));
	*(std::vector<ngwt__Item * >*)p = *(std::vector<ngwt__Item * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__ImAddress(struct soap *soap, const std::vector<ngwt__ImAddress * >*a)
{
	for (std::vector<ngwt__ImAddress * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__ImAddress(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__ImAddress(struct soap *soap, std::vector<ngwt__ImAddress * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__ImAddress(struct soap *soap, const std::vector<ngwt__ImAddress * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ImAddress);
	if (soap_out_std__vectorTemplateOfPointerTongwt__ImAddress(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__ImAddress(struct soap *soap, const char *tag, int id, const std::vector<ngwt__ImAddress * >*a, const char *type)
{
	for (std::vector<ngwt__ImAddress * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__ImAddress(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__ImAddress * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__ImAddress(struct soap *soap, std::vector<ngwt__ImAddress * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__ImAddress(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__ImAddress * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__ImAddress(struct soap *soap, const char *tag, std::vector<ngwt__ImAddress * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__ImAddress(soap, -1)))
		return NULL;
	ngwt__ImAddress *n;
	ngwt__ImAddress **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__ImAddress, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ImAddress, sizeof(ngwt__ImAddress), 1))
				break;
			if (!(p = soap_in_PointerTongwt__ImAddress(soap, tag, NULL, "ngwt:ImAddress")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__ImAddress(soap, tag, &n, "ngwt:ImAddress"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__ImAddress * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__ImAddress(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__ImAddress(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__ImAddress(struct soap *soap, std::vector<ngwt__ImAddress * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__ImAddress * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__ImAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__ImAddress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__ImAddress, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__ImAddress * >;
		if (size)
			*size = sizeof(std::vector<ngwt__ImAddress * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__ImAddress * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__ImAddress * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__ImAddress * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__ImAddress(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__ImAddress * > %p -> %p\n", q, p));
	*(std::vector<ngwt__ImAddress * >*)p = *(std::vector<ngwt__ImAddress * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__GroupMember(struct soap *soap, const std::vector<ngwt__GroupMember * >*a)
{
	for (std::vector<ngwt__GroupMember * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__GroupMember(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__GroupMember(struct soap *soap, std::vector<ngwt__GroupMember * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__GroupMember(struct soap *soap, const std::vector<ngwt__GroupMember * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__GroupMember);
	if (soap_out_std__vectorTemplateOfPointerTongwt__GroupMember(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__GroupMember(struct soap *soap, const char *tag, int id, const std::vector<ngwt__GroupMember * >*a, const char *type)
{
	for (std::vector<ngwt__GroupMember * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__GroupMember(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__GroupMember * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__GroupMember(struct soap *soap, std::vector<ngwt__GroupMember * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__GroupMember(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__GroupMember * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__GroupMember(struct soap *soap, const char *tag, std::vector<ngwt__GroupMember * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__GroupMember(soap, -1)))
		return NULL;
	ngwt__GroupMember *n;
	ngwt__GroupMember **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__GroupMember, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__GroupMember, sizeof(ngwt__GroupMember), 1))
				break;
			if (!(p = soap_in_PointerTongwt__GroupMember(soap, tag, NULL, "ngwt:GroupMember")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__GroupMember(soap, tag, &n, "ngwt:GroupMember"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__GroupMember * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__GroupMember(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__GroupMember(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__GroupMember(struct soap *soap, std::vector<ngwt__GroupMember * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__GroupMember * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__GroupMember(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__GroupMember(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__GroupMember, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__GroupMember * >;
		if (size)
			*size = sizeof(std::vector<ngwt__GroupMember * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__GroupMember * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__GroupMember * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__GroupMember * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__GroupMember(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__GroupMember * > %p -> %p\n", q, p));
	*(std::vector<ngwt__GroupMember * >*)p = *(std::vector<ngwt__GroupMember * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(struct soap *soap, const std::vector<ngwt__FreeBusyInfo * >*a)
{
	for (std::vector<ngwt__FreeBusyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__FreeBusyInfo(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(struct soap *soap, std::vector<ngwt__FreeBusyInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(struct soap *soap, const std::vector<ngwt__FreeBusyInfo * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyInfo);
	if (soap_out_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(struct soap *soap, const char *tag, int id, const std::vector<ngwt__FreeBusyInfo * >*a, const char *type)
{
	for (std::vector<ngwt__FreeBusyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__FreeBusyInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__FreeBusyInfo * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(struct soap *soap, std::vector<ngwt__FreeBusyInfo * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__FreeBusyInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(struct soap *soap, const char *tag, std::vector<ngwt__FreeBusyInfo * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(soap, -1)))
		return NULL;
	ngwt__FreeBusyInfo *n;
	ngwt__FreeBusyInfo **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__FreeBusyInfo, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyInfo, sizeof(ngwt__FreeBusyInfo), 1))
				break;
			if (!(p = soap_in_PointerTongwt__FreeBusyInfo(soap, tag, NULL, "ngwt:FreeBusyInfo")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__FreeBusyInfo(soap, tag, &n, "ngwt:FreeBusyInfo"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__FreeBusyInfo * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(struct soap *soap, std::vector<ngwt__FreeBusyInfo * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__FreeBusyInfo * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__FreeBusyInfo * >;
		if (size)
			*size = sizeof(std::vector<ngwt__FreeBusyInfo * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__FreeBusyInfo * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__FreeBusyInfo * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__FreeBusyInfo * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__FreeBusyInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__FreeBusyInfo * > %p -> %p\n", q, p));
	*(std::vector<ngwt__FreeBusyInfo * >*)p = *(std::vector<ngwt__FreeBusyInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__NameAndEmail(struct soap *soap, const std::vector<ngwt__NameAndEmail * >*a)
{
	for (std::vector<ngwt__NameAndEmail * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__NameAndEmail(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__NameAndEmail(struct soap *soap, std::vector<ngwt__NameAndEmail * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__NameAndEmail(struct soap *soap, const std::vector<ngwt__NameAndEmail * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__NameAndEmail);
	if (soap_out_std__vectorTemplateOfPointerTongwt__NameAndEmail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__NameAndEmail(struct soap *soap, const char *tag, int id, const std::vector<ngwt__NameAndEmail * >*a, const char *type)
{
	for (std::vector<ngwt__NameAndEmail * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__NameAndEmail(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__NameAndEmail * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__NameAndEmail(struct soap *soap, std::vector<ngwt__NameAndEmail * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__NameAndEmail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__NameAndEmail * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__NameAndEmail(struct soap *soap, const char *tag, std::vector<ngwt__NameAndEmail * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__NameAndEmail(soap, -1)))
		return NULL;
	ngwt__NameAndEmail *n;
	ngwt__NameAndEmail **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__NameAndEmail, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__NameAndEmail, sizeof(ngwt__NameAndEmail), 1))
				break;
			if (!(p = soap_in_PointerTongwt__NameAndEmail(soap, tag, NULL, "ngwt:NameAndEmail")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__NameAndEmail(soap, tag, &n, "ngwt:NameAndEmail"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__NameAndEmail * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__NameAndEmail(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__NameAndEmail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__NameAndEmail(struct soap *soap, std::vector<ngwt__NameAndEmail * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__NameAndEmail * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__NameAndEmail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__NameAndEmail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__NameAndEmail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__NameAndEmail * >;
		if (size)
			*size = sizeof(std::vector<ngwt__NameAndEmail * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__NameAndEmail * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__NameAndEmail * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__NameAndEmail * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__NameAndEmail(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__NameAndEmail * > %p -> %p\n", q, p));
	*(std::vector<ngwt__NameAndEmail * >*)p = *(std::vector<ngwt__NameAndEmail * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(struct soap *soap, const std::vector<ngwt__FreeBusyBlock * >*a)
{
	for (std::vector<ngwt__FreeBusyBlock * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__FreeBusyBlock(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(struct soap *soap, std::vector<ngwt__FreeBusyBlock * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(struct soap *soap, const std::vector<ngwt__FreeBusyBlock * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyBlock);
	if (soap_out_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(struct soap *soap, const char *tag, int id, const std::vector<ngwt__FreeBusyBlock * >*a, const char *type)
{
	for (std::vector<ngwt__FreeBusyBlock * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__FreeBusyBlock(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__FreeBusyBlock * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(struct soap *soap, std::vector<ngwt__FreeBusyBlock * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__FreeBusyBlock * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(struct soap *soap, const char *tag, std::vector<ngwt__FreeBusyBlock * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(soap, -1)))
		return NULL;
	ngwt__FreeBusyBlock *n;
	ngwt__FreeBusyBlock **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__FreeBusyBlock, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyBlock, sizeof(ngwt__FreeBusyBlock), 1))
				break;
			if (!(p = soap_in_PointerTongwt__FreeBusyBlock(soap, tag, NULL, "ngwt:FreeBusyBlock")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__FreeBusyBlock(soap, tag, &n, "ngwt:FreeBusyBlock"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__FreeBusyBlock * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(struct soap *soap, std::vector<ngwt__FreeBusyBlock * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__FreeBusyBlock * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FreeBusyBlock, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__FreeBusyBlock * >;
		if (size)
			*size = sizeof(std::vector<ngwt__FreeBusyBlock * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__FreeBusyBlock * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__FreeBusyBlock * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__FreeBusyBlock * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__FreeBusyBlock(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__FreeBusyBlock * > %p -> %p\n", q, p));
	*(std::vector<ngwt__FreeBusyBlock * >*)p = *(std::vector<ngwt__FreeBusyBlock * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__Folder(struct soap *soap, const std::vector<ngwt__Folder * >*a)
{
	for (std::vector<ngwt__Folder * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__Folder(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__Folder(struct soap *soap, std::vector<ngwt__Folder * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__Folder(struct soap *soap, const std::vector<ngwt__Folder * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Folder);
	if (soap_out_std__vectorTemplateOfPointerTongwt__Folder(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__Folder(struct soap *soap, const char *tag, int id, const std::vector<ngwt__Folder * >*a, const char *type)
{
	for (std::vector<ngwt__Folder * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__Folder(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__Folder * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__Folder(struct soap *soap, std::vector<ngwt__Folder * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__Folder(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__Folder * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__Folder(struct soap *soap, const char *tag, std::vector<ngwt__Folder * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__Folder(soap, -1)))
		return NULL;
	ngwt__Folder *n;
	ngwt__Folder **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__Folder, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Folder, sizeof(ngwt__Folder), 1))
				break;
			if (!(p = soap_in_PointerTongwt__Folder(soap, tag, NULL, "ngwt:Folder")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__Folder(soap, tag, &n, "ngwt:Folder"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__Folder * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__Folder(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__Folder(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__Folder(struct soap *soap, std::vector<ngwt__Folder * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__Folder * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__Folder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__Folder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Folder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__Folder * >;
		if (size)
			*size = sizeof(std::vector<ngwt__Folder * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__Folder * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__Folder * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__Folder * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__Folder(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__Folder * > %p -> %p\n", q, p));
	*(std::vector<ngwt__Folder * >*)p = *(std::vector<ngwt__Folder * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__FolderACLEntry(struct soap *soap, const std::vector<ngwt__FolderACLEntry * >*a)
{
	for (std::vector<ngwt__FolderACLEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__FolderACLEntry(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__FolderACLEntry(struct soap *soap, std::vector<ngwt__FolderACLEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__FolderACLEntry(struct soap *soap, const std::vector<ngwt__FolderACLEntry * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FolderACLEntry);
	if (soap_out_std__vectorTemplateOfPointerTongwt__FolderACLEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__FolderACLEntry(struct soap *soap, const char *tag, int id, const std::vector<ngwt__FolderACLEntry * >*a, const char *type)
{
	for (std::vector<ngwt__FolderACLEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__FolderACLEntry(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__FolderACLEntry * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__FolderACLEntry(struct soap *soap, std::vector<ngwt__FolderACLEntry * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__FolderACLEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__FolderACLEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__FolderACLEntry(struct soap *soap, const char *tag, std::vector<ngwt__FolderACLEntry * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__FolderACLEntry(soap, -1)))
		return NULL;
	ngwt__FolderACLEntry *n;
	ngwt__FolderACLEntry **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__FolderACLEntry, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FolderACLEntry, sizeof(ngwt__FolderACLEntry), 1))
				break;
			if (!(p = soap_in_PointerTongwt__FolderACLEntry(soap, tag, NULL, "ngwt:FolderACLEntry")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__FolderACLEntry(soap, tag, &n, "ngwt:FolderACLEntry"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__FolderACLEntry * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__FolderACLEntry(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__FolderACLEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__FolderACLEntry(struct soap *soap, std::vector<ngwt__FolderACLEntry * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__FolderACLEntry * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__FolderACLEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__FolderACLEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__FolderACLEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__FolderACLEntry * >;
		if (size)
			*size = sizeof(std::vector<ngwt__FolderACLEntry * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__FolderACLEntry * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__FolderACLEntry * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__FolderACLEntry * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__FolderACLEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__FolderACLEntry * > %p -> %p\n", q, p));
	*(std::vector<ngwt__FolderACLEntry * >*)p = *(std::vector<ngwt__FolderACLEntry * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfstd__string);
	if (soap_out_std__vectorTemplateOfstd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_get_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfstd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	std::string *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!(p = soap_in_std__string(soap, tag, NULL, "")))
				break;
		}
		else
		{	soap_default_std__string(soap, &n);
			if (!soap_in_std__string(soap, tag, &n, ""))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__DocumentType(struct soap *soap, const std::vector<ngwt__DocumentType * >*a)
{
	for (std::vector<ngwt__DocumentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__DocumentType(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__DocumentType(struct soap *soap, std::vector<ngwt__DocumentType * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__DocumentType(struct soap *soap, const std::vector<ngwt__DocumentType * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DocumentType);
	if (soap_out_std__vectorTemplateOfPointerTongwt__DocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__DocumentType(struct soap *soap, const char *tag, int id, const std::vector<ngwt__DocumentType * >*a, const char *type)
{
	for (std::vector<ngwt__DocumentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__DocumentType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__DocumentType * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__DocumentType(struct soap *soap, std::vector<ngwt__DocumentType * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__DocumentType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__DocumentType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__DocumentType(struct soap *soap, const char *tag, std::vector<ngwt__DocumentType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__DocumentType(soap, -1)))
		return NULL;
	ngwt__DocumentType *n;
	ngwt__DocumentType **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__DocumentType, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DocumentType, sizeof(ngwt__DocumentType), 1))
				break;
			if (!(p = soap_in_PointerTongwt__DocumentType(soap, tag, NULL, "ngwt:DocumentType")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__DocumentType(soap, tag, &n, "ngwt:DocumentType"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__DocumentType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__DocumentType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__DocumentType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__DocumentType(struct soap *soap, std::vector<ngwt__DocumentType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__DocumentType * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__DocumentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__DocumentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DocumentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__DocumentType * >;
		if (size)
			*size = sizeof(std::vector<ngwt__DocumentType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__DocumentType * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__DocumentType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__DocumentType * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__DocumentType(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__DocumentType * > %p -> %p\n", q, p));
	*(std::vector<ngwt__DocumentType * >*)p = *(std::vector<ngwt__DocumentType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(struct soap *soap, const std::vector<ngwt__DayOfYearWeek * >*a)
{
	for (std::vector<ngwt__DayOfYearWeek * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__DayOfYearWeek(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(struct soap *soap, std::vector<ngwt__DayOfYearWeek * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(struct soap *soap, const std::vector<ngwt__DayOfYearWeek * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DayOfYearWeek);
	if (soap_out_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(struct soap *soap, const char *tag, int id, const std::vector<ngwt__DayOfYearWeek * >*a, const char *type)
{
	for (std::vector<ngwt__DayOfYearWeek * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__DayOfYearWeek(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__DayOfYearWeek * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(struct soap *soap, std::vector<ngwt__DayOfYearWeek * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__DayOfYearWeek * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(struct soap *soap, const char *tag, std::vector<ngwt__DayOfYearWeek * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(soap, -1)))
		return NULL;
	ngwt__DayOfYearWeek *n;
	ngwt__DayOfYearWeek **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__DayOfYearWeek, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DayOfYearWeek, sizeof(ngwt__DayOfYearWeek), 1))
				break;
			if (!(p = soap_in_PointerTongwt__DayOfYearWeek(soap, tag, NULL, "ngwt:DayOfYearWeek")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__DayOfYearWeek(soap, tag, &n, "ngwt:DayOfYearWeek"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__DayOfYearWeek * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(struct soap *soap, std::vector<ngwt__DayOfYearWeek * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__DayOfYearWeek * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__DayOfYearWeek, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__DayOfYearWeek * >;
		if (size)
			*size = sizeof(std::vector<ngwt__DayOfYearWeek * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__DayOfYearWeek * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__DayOfYearWeek * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__DayOfYearWeek * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__DayOfYearWeek(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__DayOfYearWeek * > %p -> %p\n", q, p));
	*(std::vector<ngwt__DayOfYearWeek * >*)p = *(std::vector<ngwt__DayOfYearWeek * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfngwt__DayOfYear(struct soap *soap, const std::vector<short >*a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfngwt__DayOfYear(struct soap *soap, std::vector<short >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfngwt__DayOfYear(struct soap *soap, const std::vector<short >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfngwt__DayOfYear);
	if (soap_out_std__vectorTemplateOfngwt__DayOfYear(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfngwt__DayOfYear(struct soap *soap, const char *tag, int id, const std::vector<short >*a, const char *type)
{
	for (std::vector<short >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ngwt__DayOfYear(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<short >* SOAP_FMAC4 soap_get_std__vectorTemplateOfngwt__DayOfYear(struct soap *soap, std::vector<short >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfngwt__DayOfYear(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<short >* SOAP_FMAC4 soap_in_std__vectorTemplateOfngwt__DayOfYear(struct soap *soap, const char *tag, std::vector<short >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfngwt__DayOfYear(soap, -1)))
		return NULL;
	short n;
	short *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__DayOfYear, SOAP_TYPE_std__vectorTemplateOfngwt__DayOfYear, sizeof(short), 0))
				break;
			if (!(p = soap_in_ngwt__DayOfYear(soap, tag, NULL, "ngwt:DayOfYear")))
				break;
		}
		else
		{	soap_default_ngwt__DayOfYear(soap, &n);
			if (!soap_in_ngwt__DayOfYear(soap, tag, &n, "ngwt:DayOfYear"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<short > * SOAP_FMAC6 soap_new_std__vectorTemplateOfngwt__DayOfYear(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfngwt__DayOfYear(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfngwt__DayOfYear(struct soap *soap, std::vector<short >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<short > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfngwt__DayOfYear(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfngwt__DayOfYear(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfngwt__DayOfYear, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<short >;
		if (size)
			*size = sizeof(std::vector<short >);
	}
	else
	{	cp->ptr = (void*)new std::vector<short >[n];
		if (size)
			*size = n * sizeof(std::vector<short >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<short >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfngwt__DayOfYear(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<short > %p -> %p\n", q, p));
	*(std::vector<short >*)p = *(std::vector<short >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfngwt__DayOfMonth(struct soap *soap, const std::vector<char >*a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfngwt__DayOfMonth(struct soap *soap, std::vector<char >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfngwt__DayOfMonth(struct soap *soap, const std::vector<char >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfngwt__DayOfMonth);
	if (soap_out_std__vectorTemplateOfngwt__DayOfMonth(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfngwt__DayOfMonth(struct soap *soap, const char *tag, int id, const std::vector<char >*a, const char *type)
{
	for (std::vector<char >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ngwt__DayOfMonth(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char >* SOAP_FMAC4 soap_get_std__vectorTemplateOfngwt__DayOfMonth(struct soap *soap, std::vector<char >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfngwt__DayOfMonth(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<char >* SOAP_FMAC4 soap_in_std__vectorTemplateOfngwt__DayOfMonth(struct soap *soap, const char *tag, std::vector<char >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfngwt__DayOfMonth(soap, -1)))
		return NULL;
	char n;
	char *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__DayOfMonth, SOAP_TYPE_std__vectorTemplateOfngwt__DayOfMonth, sizeof(char), 0))
				break;
			if (!(p = soap_in_ngwt__DayOfMonth(soap, tag, NULL, "ngwt:DayOfMonth")))
				break;
		}
		else
		{	soap_default_ngwt__DayOfMonth(soap, &n);
			if (!soap_in_ngwt__DayOfMonth(soap, tag, &n, "ngwt:DayOfMonth"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<char > * SOAP_FMAC6 soap_new_std__vectorTemplateOfngwt__DayOfMonth(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfngwt__DayOfMonth(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfngwt__DayOfMonth(struct soap *soap, std::vector<char >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<char > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfngwt__DayOfMonth(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfngwt__DayOfMonth(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfngwt__DayOfMonth, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char >;
		if (size)
			*size = sizeof(std::vector<char >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char >[n];
		if (size)
			*size = n * sizeof(std::vector<char >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfngwt__DayOfMonth(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char > %p -> %p\n", q, p));
	*(std::vector<char >*)p = *(std::vector<char >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__Custom(struct soap *soap, const std::vector<ngwt__Custom * >*a)
{
	for (std::vector<ngwt__Custom * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__Custom(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__Custom(struct soap *soap, std::vector<ngwt__Custom * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__Custom(struct soap *soap, const std::vector<ngwt__Custom * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Custom);
	if (soap_out_std__vectorTemplateOfPointerTongwt__Custom(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__Custom(struct soap *soap, const char *tag, int id, const std::vector<ngwt__Custom * >*a, const char *type)
{
	for (std::vector<ngwt__Custom * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__Custom(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__Custom * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__Custom(struct soap *soap, std::vector<ngwt__Custom * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__Custom(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__Custom * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__Custom(struct soap *soap, const char *tag, std::vector<ngwt__Custom * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__Custom(soap, -1)))
		return NULL;
	ngwt__Custom *n;
	ngwt__Custom **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__Custom, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Custom, sizeof(ngwt__Custom), 1))
				break;
			if (!(p = soap_in_PointerTongwt__Custom(soap, tag, NULL, "ngwt:Custom")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__Custom(soap, tag, &n, "ngwt:Custom"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__Custom * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__Custom(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__Custom(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__Custom(struct soap *soap, std::vector<ngwt__Custom * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__Custom * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__Custom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__Custom(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Custom, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__Custom * >;
		if (size)
			*size = sizeof(std::vector<ngwt__Custom * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__Custom * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__Custom * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__Custom * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__Custom(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__Custom * > %p -> %p\n", q, p));
	*(std::vector<ngwt__Custom * >*)p = *(std::vector<ngwt__Custom * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfngwt__uid(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_ngwt__uid(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfngwt__uid(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfngwt__uid(struct soap *soap, const std::vector<std::string >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfngwt__uid);
	if (soap_out_std__vectorTemplateOfngwt__uid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfngwt__uid(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ngwt__uid(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_get_std__vectorTemplateOfngwt__uid(struct soap *soap, std::vector<std::string >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfngwt__uid(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfngwt__uid(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfngwt__uid(soap, -1)))
		return NULL;
	std::string n;
	std::string *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__uid, SOAP_TYPE_std__vectorTemplateOfngwt__uid, sizeof(std::string), 0))
				break;
			if (!(p = soap_in_ngwt__uid(soap, tag, NULL, "ngwt:uid")))
				break;
		}
		else
		{	soap_default_ngwt__uid(soap, &n);
			if (!soap_in_ngwt__uid(soap, tag, &n, "ngwt:uid"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfngwt__uid(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfngwt__uid(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfngwt__uid(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfngwt__uid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfngwt__uid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfngwt__uid, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfngwt__uid(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__Category(struct soap *soap, const std::vector<ngwt__Category * >*a)
{
	for (std::vector<ngwt__Category * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__Category(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__Category(struct soap *soap, std::vector<ngwt__Category * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__Category(struct soap *soap, const std::vector<ngwt__Category * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Category);
	if (soap_out_std__vectorTemplateOfPointerTongwt__Category(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__Category(struct soap *soap, const char *tag, int id, const std::vector<ngwt__Category * >*a, const char *type)
{
	for (std::vector<ngwt__Category * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__Category(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__Category * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__Category(struct soap *soap, std::vector<ngwt__Category * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__Category(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__Category * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__Category(struct soap *soap, const char *tag, std::vector<ngwt__Category * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__Category(soap, -1)))
		return NULL;
	ngwt__Category *n;
	ngwt__Category **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__Category, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Category, sizeof(ngwt__Category), 1))
				break;
			if (!(p = soap_in_PointerTongwt__Category(soap, tag, NULL, "ngwt:Category")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__Category(soap, tag, &n, "ngwt:Category"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__Category * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__Category(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__Category(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__Category(struct soap *soap, std::vector<ngwt__Category * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__Category * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__Category(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__Category(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__Category, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__Category * >;
		if (size)
			*size = sizeof(std::vector<ngwt__Category * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__Category * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__Category * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__Category * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__Category(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__Category * > %p -> %p\n", q, p));
	*(std::vector<ngwt__Category * >*)p = *(std::vector<ngwt__Category * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfngwt__CalendarFolderFlags(struct soap *soap, const std::vector<enum ngwt__CalendarFolderFlags >*a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfngwt__CalendarFolderFlags(struct soap *soap, std::vector<enum ngwt__CalendarFolderFlags >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfngwt__CalendarFolderFlags(struct soap *soap, const std::vector<enum ngwt__CalendarFolderFlags >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfngwt__CalendarFolderFlags);
	if (soap_out_std__vectorTemplateOfngwt__CalendarFolderFlags(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfngwt__CalendarFolderFlags(struct soap *soap, const char *tag, int id, const std::vector<enum ngwt__CalendarFolderFlags >*a, const char *type)
{
	for (std::vector<enum ngwt__CalendarFolderFlags >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ngwt__CalendarFolderFlags(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ngwt__CalendarFolderFlags >* SOAP_FMAC4 soap_get_std__vectorTemplateOfngwt__CalendarFolderFlags(struct soap *soap, std::vector<enum ngwt__CalendarFolderFlags >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfngwt__CalendarFolderFlags(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<enum ngwt__CalendarFolderFlags >* SOAP_FMAC4 soap_in_std__vectorTemplateOfngwt__CalendarFolderFlags(struct soap *soap, const char *tag, std::vector<enum ngwt__CalendarFolderFlags >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfngwt__CalendarFolderFlags(soap, -1)))
		return NULL;
	enum ngwt__CalendarFolderFlags n;
	enum ngwt__CalendarFolderFlags *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__CalendarFolderFlags, SOAP_TYPE_std__vectorTemplateOfngwt__CalendarFolderFlags, sizeof(enum ngwt__CalendarFolderFlags), 0))
				break;
			if (!(p = soap_in_ngwt__CalendarFolderFlags(soap, tag, NULL, "")))
				break;
		}
		else
		{	soap_default_ngwt__CalendarFolderFlags(soap, &n);
			if (!soap_in_ngwt__CalendarFolderFlags(soap, tag, &n, ""))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<enum ngwt__CalendarFolderFlags > * SOAP_FMAC6 soap_new_std__vectorTemplateOfngwt__CalendarFolderFlags(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfngwt__CalendarFolderFlags(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfngwt__CalendarFolderFlags(struct soap *soap, std::vector<enum ngwt__CalendarFolderFlags >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<enum ngwt__CalendarFolderFlags > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfngwt__CalendarFolderFlags(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfngwt__CalendarFolderFlags(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfngwt__CalendarFolderFlags, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<enum ngwt__CalendarFolderFlags >;
		if (size)
			*size = sizeof(std::vector<enum ngwt__CalendarFolderFlags >);
	}
	else
	{	cp->ptr = (void*)new std::vector<enum ngwt__CalendarFolderFlags >[n];
		if (size)
			*size = n * sizeof(std::vector<enum ngwt__CalendarFolderFlags >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ngwt__CalendarFolderFlags >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfngwt__CalendarFolderFlags(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ngwt__CalendarFolderFlags > %p -> %p\n", q, p));
	*(std::vector<enum ngwt__CalendarFolderFlags >*)p = *(std::vector<enum ngwt__CalendarFolderFlags >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(struct soap *soap, const std::vector<ngwt__AttachmentItemInfo * >*a)
{
	for (std::vector<ngwt__AttachmentItemInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__AttachmentItemInfo(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(struct soap *soap, std::vector<ngwt__AttachmentItemInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(struct soap *soap, const std::vector<ngwt__AttachmentItemInfo * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo);
	if (soap_out_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(struct soap *soap, const char *tag, int id, const std::vector<ngwt__AttachmentItemInfo * >*a, const char *type)
{
	for (std::vector<ngwt__AttachmentItemInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__AttachmentItemInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__AttachmentItemInfo * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(struct soap *soap, std::vector<ngwt__AttachmentItemInfo * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__AttachmentItemInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(struct soap *soap, const char *tag, std::vector<ngwt__AttachmentItemInfo * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(soap, -1)))
		return NULL;
	ngwt__AttachmentItemInfo *n;
	ngwt__AttachmentItemInfo **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__AttachmentItemInfo, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo, sizeof(ngwt__AttachmentItemInfo), 1))
				break;
			if (!(p = soap_in_PointerTongwt__AttachmentItemInfo(soap, tag, NULL, "ngwt:AttachmentItemInfo")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__AttachmentItemInfo(soap, tag, &n, "ngwt:AttachmentItemInfo"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__AttachmentItemInfo * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(struct soap *soap, std::vector<ngwt__AttachmentItemInfo * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__AttachmentItemInfo * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__AttachmentItemInfo * >;
		if (size)
			*size = sizeof(std::vector<ngwt__AttachmentItemInfo * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__AttachmentItemInfo * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__AttachmentItemInfo * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__AttachmentItemInfo * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__AttachmentItemInfo(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__AttachmentItemInfo * > %p -> %p\n", q, p));
	*(std::vector<ngwt__AttachmentItemInfo * >*)p = *(std::vector<ngwt__AttachmentItemInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__AddressBook(struct soap *soap, const std::vector<ngwt__AddressBook * >*a)
{
	for (std::vector<ngwt__AddressBook * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__AddressBook(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__AddressBook(struct soap *soap, std::vector<ngwt__AddressBook * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__AddressBook(struct soap *soap, const std::vector<ngwt__AddressBook * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AddressBook);
	if (soap_out_std__vectorTemplateOfPointerTongwt__AddressBook(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__AddressBook(struct soap *soap, const char *tag, int id, const std::vector<ngwt__AddressBook * >*a, const char *type)
{
	for (std::vector<ngwt__AddressBook * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__AddressBook(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__AddressBook * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__AddressBook(struct soap *soap, std::vector<ngwt__AddressBook * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__AddressBook(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__AddressBook * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__AddressBook(struct soap *soap, const char *tag, std::vector<ngwt__AddressBook * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__AddressBook(soap, -1)))
		return NULL;
	ngwt__AddressBook *n;
	ngwt__AddressBook **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__AddressBook, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AddressBook, sizeof(ngwt__AddressBook), 1))
				break;
			if (!(p = soap_in_PointerTongwt__AddressBook(soap, tag, NULL, "ngwt:AddressBook")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__AddressBook(soap, tag, &n, "ngwt:AddressBook"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__AddressBook * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__AddressBook(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__AddressBook(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__AddressBook(struct soap *soap, std::vector<ngwt__AddressBook * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__AddressBook * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__AddressBook(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__AddressBook(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AddressBook, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__AddressBook * >;
		if (size)
			*size = sizeof(std::vector<ngwt__AddressBook * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__AddressBook * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__AddressBook * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__AddressBook * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__AddressBook(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__AddressBook * > %p -> %p\n", q, p));
	*(std::vector<ngwt__AddressBook * >*)p = *(std::vector<ngwt__AddressBook * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__AccessRightEntry(struct soap *soap, const std::vector<ngwt__AccessRightEntry * >*a)
{
	for (std::vector<ngwt__AccessRightEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__AccessRightEntry(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__AccessRightEntry(struct soap *soap, std::vector<ngwt__AccessRightEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__AccessRightEntry(struct soap *soap, const std::vector<ngwt__AccessRightEntry * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessRightEntry);
	if (soap_out_std__vectorTemplateOfPointerTongwt__AccessRightEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__AccessRightEntry(struct soap *soap, const char *tag, int id, const std::vector<ngwt__AccessRightEntry * >*a, const char *type)
{
	for (std::vector<ngwt__AccessRightEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__AccessRightEntry(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__AccessRightEntry * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__AccessRightEntry(struct soap *soap, std::vector<ngwt__AccessRightEntry * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__AccessRightEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__AccessRightEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__AccessRightEntry(struct soap *soap, const char *tag, std::vector<ngwt__AccessRightEntry * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__AccessRightEntry(soap, -1)))
		return NULL;
	ngwt__AccessRightEntry *n;
	ngwt__AccessRightEntry **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__AccessRightEntry, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessRightEntry, sizeof(ngwt__AccessRightEntry), 1))
				break;
			if (!(p = soap_in_PointerTongwt__AccessRightEntry(soap, tag, NULL, "ngwt:AccessRightEntry")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__AccessRightEntry(soap, tag, &n, "ngwt:AccessRightEntry"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__AccessRightEntry * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__AccessRightEntry(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__AccessRightEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__AccessRightEntry(struct soap *soap, std::vector<ngwt__AccessRightEntry * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__AccessRightEntry * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__AccessRightEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__AccessRightEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessRightEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__AccessRightEntry * >;
		if (size)
			*size = sizeof(std::vector<ngwt__AccessRightEntry * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__AccessRightEntry * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__AccessRightEntry * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__AccessRightEntry * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__AccessRightEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__AccessRightEntry * > %p -> %p\n", q, p));
	*(std::vector<ngwt__AccessRightEntry * >*)p = *(std::vector<ngwt__AccessRightEntry * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(struct soap *soap, const std::vector<ngwt__AccessControlListEntry * >*a)
{
	for (std::vector<ngwt__AccessControlListEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTongwt__AccessControlListEntry(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(struct soap *soap, std::vector<ngwt__AccessControlListEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(struct soap *soap, const std::vector<ngwt__AccessControlListEntry * >*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessControlListEntry);
	if (soap_out_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(struct soap *soap, const char *tag, int id, const std::vector<ngwt__AccessControlListEntry * >*a, const char *type)
{
	for (std::vector<ngwt__AccessControlListEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTongwt__AccessControlListEntry(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ngwt__AccessControlListEntry * >* SOAP_FMAC4 soap_get_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(struct soap *soap, std::vector<ngwt__AccessControlListEntry * >*p, const char *tag, const char *type)
{
	if ((p = soap_in_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::vector<ngwt__AccessControlListEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(struct soap *soap, const char *tag, std::vector<ngwt__AccessControlListEntry * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(soap, -1)))
		return NULL;
	ngwt__AccessControlListEntry *n;
	ngwt__AccessControlListEntry **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, SOAP_TYPE_ngwt__AccessControlListEntry, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessControlListEntry, sizeof(ngwt__AccessControlListEntry), 1))
				break;
			if (!(p = soap_in_PointerTongwt__AccessControlListEntry(soap, tag, NULL, "ngwt:AccessControlListEntry")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTongwt__AccessControlListEntry(soap, tag, &n, "ngwt:AccessControlListEntry"))
				break;
			a->insert(a->end(), n);
		}
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ngwt__AccessControlListEntry * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(struct soap *soap, std::vector<ngwt__AccessControlListEntry * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 std::vector<ngwt__AccessControlListEntry * > * SOAP_FMAC6 soap_instantiate_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTongwt__AccessControlListEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ngwt__AccessControlListEntry * >;
		if (size)
			*size = sizeof(std::vector<ngwt__AccessControlListEntry * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ngwt__AccessControlListEntry * >[n];
		if (size)
			*size = n * sizeof(std::vector<ngwt__AccessControlListEntry * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ngwt__AccessControlListEntry * >*)cp->ptr;
}

SOAP_FMAC5 void SOAP_FMAC6 soap_copy_std__vectorTemplateOfPointerTongwt__AccessControlListEntry(struct soap *soap, int st, int tt, void *p, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ngwt__AccessControlListEntry * > %p -> %p\n", q, p));
	*(std::vector<ngwt__AccessControlListEntry * >*)p = *(std::vector<ngwt__AccessControlListEntry * >*)q;
}

/* End of soapC.cpp */
